{
  "title": "Agent SDK reference - Python",
  "source_url": "https://docs.claude.com/en/docs/agent-sdk/python",
  "content": "Complete API reference for the Python Agent SDK, including all functions, types, and classes.\n\n## Installation\n\n```bash  theme={null}\npip install claude-agent-sdk\n```\n\n## Choosing Between `query()` and `ClaudeSDKClient`\n\nThe Python SDK provides two ways to interact with Claude Code:\n\n### Quick Comparison\n\n| Feature             | `query()`                     | `ClaudeSDKClient`                  |\n| :------------------ | :---------------------------- | :--------------------------------- |\n| **Session**         | Creates new session each time | Reuses same session                |\n| **Conversation**    | Single exchange               | Multiple exchanges in same context |\n| **Connection**      | Managed automatically         | Manual control                     |\n| **Streaming Input** | ✅ Supported                   | ✅ Supported                        |\n| **Interrupts**      | ❌ Not supported               | ✅ Supported                        |\n| **Hooks**           | ❌ Not supported               | ✅ Supported                        |\n| **Custom Tools**    | ❌ Not supported               | ✅ Supported                        |\n| **Continue Chat**   | ❌ New session each time       | ✅ Maintains conversation           |\n| **Use Case**        | One-off tasks                 | Continuous conversations           |\n\n### When to Use `query()` (New Session Each Time)\n\n**Best for:**\n\n* One-off questions where you don't need conversation history\n* Independent tasks that don't require context from previous exchanges\n* Simple automation scripts\n* When you want a fresh start each time\n\n### When to Use `ClaudeSDKClient` (Continuous Conversation)\n\n**Best for:**\n\n* **Continuing conversations** - When you need Claude to remember context\n* **Follow-up questions** - Building on previous responses\n* **Interactive applications** - Chat interfaces, REPLs\n* **Response-driven logic** - When next action depends on Claude's response\n* **Session control** - Managing conversation lifecycle explicitly\n\n## Functions\n\n### `query()`\n\nCreates a new session for each interaction with Claude Code. Returns an async iterator that yields messages as they arrive. Each call to `query()` starts fresh with no memory of previous interactions.\n\n```python  theme={null}\nasync def query(\n    *,\n    prompt: str | AsyncIterable[dict[str, Any]],\n    options: ClaudeAgentOptions | None = None\n) -> AsyncIterator[Message]\n```\n\n#### Parameters\n\n| Parameter | Type                         | Description                                                                |\n| :-------- | :--------------------------- | :------------------------------------------------------------------------- |\n| `prompt`  | `str \\| AsyncIterable[dict]` | The input prompt as a string or async iterable for streaming mode          |\n| `options` | `ClaudeAgentOptions \\| None` | Optional configuration object (defaults to `ClaudeAgentOptions()` if None) |\n\n#### Returns\n\nReturns an `AsyncIterator[Message]` that yields messages from the conversation.\n\n#### Example - With options\n\n```python  theme={null}\n\nimport asyncio\nfrom claude_agent_sdk import query, ClaudeAgentOptions\n\nasync def main():\n    options = ClaudeAgentOptions(\n        system_prompt=\"You are an expert Python developer\",\n        permission_mode='acceptEdits',\n        cwd=\"/home/user/project\"\n    )\n\n    async for message in query(\n        prompt=\"Create a Python web server\",\n        options=options\n    ):\n        print(message)\n\n\nasyncio.run(main())\n```\n\n### `tool()`\n\nDecorator for defining MCP tools with type safety.\n\n```python  theme={null}\ndef tool(\n    name: str,\n    description: str,\n    input_schema: type | dict[str, Any]\n) -> Callable[[Callable[[Any], Awaitable[dict[str, Any]]]], SdkMcpTool[Any]]\n```\n\n#### Parameters\n\n| Parameter      | Type                     | Description                                             |\n| :------------- | :----------------------- | :------------------------------------------------------ |\n| `name`         | `str`                    | Unique identifier for the tool                          |\n| `description`  | `str`                    | Human-readable description of what the tool does        |\n| `input_schema` | `type \\| dict[str, Any]` | Schema defining the tool's input parameters (see below) |\n\n#### Input Schema Options\n\n1. **Simple type mapping** (recommended):\n\n   ```python  theme={null}\n   {\"text\": str, \"count\": int, \"enabled\": bool}\n   ```\n\n2. **JSON Schema format** (for complex validation):\n   ```python  theme={null}\n   {\n       \"type\": \"object\",\n       \"properties\": {\n           \"text\": {\"type\": \"string\"},\n           \"count\": {\"type\": \"integer\", \"minimum\": 0}\n       },\n       \"required\": [\"text\"]\n   }\n   ```\n\n#### Returns\n\nA decorator function that wraps the tool implementation and returns an `SdkMcpTool` instance.\n\n#### Example\n\n```python  theme={null}\nfrom claude_agent_sdk import tool\nfrom typing import Any\n\n@tool(\"greet\", \"Greet a user\", {\"name\": str})\nasync def greet(args: dict[str, Any]) -> dict[str, Any]:\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Hello, {args['name']}!\"\n        }]\n    }\n```\n\n### `create_sdk_mcp_server()`\n\nCreate an in-process MCP server that runs within your Python application.\n\n```python  theme={null}\ndef create_sdk_mcp_server(\n    name: str,\n    version: str = \"1.0.0\",\n    tools: list[SdkMcpTool[Any]] | None = None\n) -> McpSdkServerConfig\n```\n\n#### Parameters\n\n| Parameter | Type                            | Default   | Description                                           |\n| :-------- | :------------------------------ | :-------- | :---------------------------------------------------- |\n| `name`    | `str`                           | -         | Unique identifier for the server                      |\n| `version` | `str`                           | `\"1.0.0\"` | Server version string                                 |\n| `tools`   | `list[SdkMcpTool[Any]] \\| None` | `None`    | List of tool functions created with `@tool` decorator |\n\n#### Returns\n\nReturns an `McpSdkServerConfig` object that can be passed to `ClaudeAgentOptions.mcp_servers`.\n\n#### Example\n\n```python  theme={null}\nfrom claude_agent_sdk import tool, create_sdk_mcp_server\n\n@tool(\"add\", \"Add two numbers\", {\"a\": float, \"b\": float})\nasync def add(args):\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Sum: {args['a'] + args['b']}\"\n        }]\n    }\n\n@tool(\"multiply\", \"Multiply two numbers\", {\"a\": float, \"b\": float})\nasync def multiply(args):\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Product: {args['a'] * args['b']}\"\n        }]\n    }\n\ncalculator = create_sdk_mcp_server(\n    name=\"calculator\",\n    version=\"2.0.0\",\n    tools=[add, multiply]  # Pass decorated functions\n)\n\n# Use with Claude\noptions = ClaudeAgentOptions(\n    mcp_servers={\"calc\": calculator},\n    allowed_tools=[\"mcp__calc__add\", \"mcp__calc__multiply\"]\n)\n```\n\n## Classes\n\n### `ClaudeSDKClient`\n\n**Maintains a conversation session across multiple exchanges.** This is the Python equivalent of how the TypeScript SDK's `query()` function works internally - it creates a client object that can continue conversations.\n\n#### Key Features\n\n* **Session Continuity**: Maintains conversation context across multiple `query()` calls\n* **Same Conversation**: Claude remembers previous messages in the session\n* **Interrupt Support**: Can stop Claude mid-execution\n* **Explicit Lifecycle**: You control when the session starts and ends\n* **Response-driven Flow**: Can react to responses and send follow-ups\n* **Custom Tools & Hooks**: Supports custom tools (created with `@tool` decorator) and hooks\n\n```python  theme={null}\nclass ClaudeSDKClient:\n    def __init__(self, options: ClaudeAgentOptions | None = None)\n    async def connect(self, prompt: str | AsyncIterable[dict] | None = None) -> None\n    async def query(self, prompt: str | AsyncIterable[dict], session_id: str = \"default\") -> None\n    async def receive_messages(self) -> AsyncIterator[Message]\n    async def receive_response(self) -> AsyncIterator[Message]\n    async def interrupt(self) -> None\n    async def disconnect(self) -> None\n```\n\n#### Methods\n\n| Method                      | Description                                                         |\n| :-------------------------- | :------------------------------------------------------------------ |\n| `__init__(options)`         | Initialize the client with optional configuration                   |\n| `connect(prompt)`           | Connect to Claude with an optional initial prompt or message stream |\n| `query(prompt, session_id)` | Send a new request in streaming mode                                |\n| `receive_messages()`        | Receive all messages from Claude as an async iterator               |\n| `receive_response()`        | Receive messages until and including a ResultMessage                |\n| `interrupt()`               | Send interrupt signal (only works in streaming mode)                |\n| `disconnect()`              | Disconnect from Claude                                              |\n\n#### Context Manager Support\n\nThe client can be used as an async context manager for automatic connection management:\n\n```python  theme={null}\nasync with ClaudeSDKClient() as client:\n    await client.query(\"Hello Claude\")\n    async for message in client.receive_response():\n        print(message)\n```\n\n> **Important:** When iterating over messages, avoid using `break` to exit early as this can cause asyncio cleanup issues. Instead, let the iteration complete naturally or use flags to track when you've found what you need.\n\n#### Example - Continuing a conversation\n\n```python  theme={null}\nimport asyncio\nfrom claude_agent_sdk import ClaudeSDKClient, AssistantMessage, TextBlock, ResultMessage\n\nasync def main():\n    async with ClaudeSDKClient() as client:\n        # First question\n        await client.query(\"What's the capital of France?\")\n\n        # Process response\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Claude: {block.text}\")\n\n        # Follow-up question - Claude remembers the previous context\n        await client.query(\"What's the population of that city?\")\n\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Claude: {block.text}\")\n\n        # Another follow-up - still in the same conversation\n        await client.query(\"What are some famous landmarks there?\")\n\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Claude: {block.text}\")\n\nasyncio.run(main())\n```\n\n#### Example - Streaming input with ClaudeSDKClient\n\n```python  theme={null}\nimport asyncio\nfrom claude_agent_sdk import ClaudeSDKClient\n\nasync def message_stream():\n    \"\"\"Generate messages dynamically.\"\"\"\n    yield {\"type\": \"text\", \"text\": \"Analyze the following data:\"}\n    await asyncio.sleep(0.5)\n    yield {\"type\": \"text\", \"text\": \"Temperature: 25°C\"}\n    await asyncio.sleep(0.5)\n    yield {\"type\": \"text\", \"text\": \"Humidity: 60%\"}\n    await asyncio.sleep(0.5)\n    yield {\"type\": \"text\", \"text\": \"What patterns do you see?\"}\n\nasync def main():\n    async with ClaudeSDKClient() as client:\n        # Stream input to Claude\n        await client.query(message_stream())\n\n        # Process response\n        async for message in client.receive_response():\n            print(message)\n\n        # Follow-up in same session\n        await client.query(\"Should we be concerned about these readings?\")\n\n        async for message in client.receive_response():\n            print(message)\n\nasyncio.run(main())\n```\n\n#### Example - Using interrupts\n\n```python  theme={null}\nimport asyncio\nfrom claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions\n\nasync def interruptible_task():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Bash\"],\n        permission_mode=\"acceptEdits\"\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        # Start a long-running task\n        await client.query(\"Count from 1 to 100 slowly\")\n\n        # Let it run for a bit\n        await asyncio.sleep(2)\n\n        # Interrupt the task\n        await client.interrupt()\n        print(\"Task interrupted!\")\n\n        # Send a new command\n        await client.query(\"Just say hello instead\")\n\n        async for message in client.receive_response():\n            # Process the new response\n            pass\n\nasyncio.run(interruptible_task())\n```\n\n#### Example - Advanced permission control\n\n```python  theme={null}\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions\n)\n\nasync def custom_permission_handler(\n    tool_name: str,\n    input_data: dict,\n    context: dict\n):\n    \"\"\"Custom logic for tool permissions.\"\"\"\n\n    # Block writes to system directories\n    if tool_name == \"Write\" and input_data.get(\"file_path\", \"\").startswith(\"/system/\"):\n        return {\n            \"behavior\": \"deny\",\n            \"message\": \"System directory write not allowed\",\n            \"interrupt\": True\n        }\n\n    # Redirect sensitive file operations\n    if tool_name in [\"Write\", \"Edit\"] and \"config\" in input_data.get(\"file_path\", \"\"):\n        safe_path = f\"./sandbox/{input_data['file_path']}\"\n        return {\n            \"behavior\": \"allow\",\n            \"updatedInput\": {**input_data, \"file_path\": safe_path}\n        }\n\n    # Allow everything else\n    return {\n        \"behavior\": \"allow\",\n        \"updatedInput\": input_data\n    }\n\nasync def main():\n    options = ClaudeAgentOptions(\n        can_use_tool=custom_permission_handler,\n        allowed_tools=[\"Read\", \"Write\", \"Edit\"]\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\"Update the system config file\")\n\n        async for message in client.receive_response():\n            # Will use sandbox path instead\n            print(message)\n\nasyncio.run(main())\n```\n\n## Types\n\n### `SdkMcpTool`\n\nDefinition for an SDK MCP tool created with the `@tool` decorator.\n\n```python  theme={null}\n@dataclass\nclass SdkMcpTool(Generic[T]):\n    name: str\n    description: str\n    input_schema: type[T] | dict[str, Any]\n    handler: Callable[[T], Awaitable[dict[str, Any]]]\n```\n\n| Property       | Type                                       | Description                                |\n| :------------- | :----------------------------------------- | :----------------------------------------- |\n| `name`         | `str`                                      | Unique identifier for the tool             |\n| `description`  | `str`                                      | Human-readable description                 |\n| `input_schema` | `type[T] \\| dict[str, Any]`                | Schema for input validation                |\n| `handler`      | `Callable[[T], Awaitable[dict[str, Any]]]` | Async function that handles tool execution |\n\n### `ClaudeAgentOptions`\n\nConfiguration dataclass for Claude Code queries.\n\n```python  theme={null}\n@dataclass\nclass ClaudeAgentOptions:\n    allowed_tools: list[str] = field(default_factory=list)\n    system_prompt: str | SystemPromptPreset | None = None\n    mcp_servers: dict[str, McpServerConfig] | str | Path = field(default_factory=dict)\n    permission_mode: PermissionMode | None = None\n    continue_conversation: bool = False\n    resume: str | None = None\n    max_turns: int | None = None\n    disallowed_tools: list[str] = field(default_factory=list)\n    model: str | None = None\n    output_format: OutputFormat | None = None\n    permission_prompt_tool_name: str | None = None\n    cwd: str | Path | None = None\n    settings: str | None = None\n    add_dirs: list[str | Path] = field(default_factory=list)\n    env: dict[str, str] = field(default_factory=dict)\n    extra_args: dict[str, str | None] = field(default_factory=dict)\n    max_buffer_size: int | None = None\n    debug_stderr: Any = sys.stderr  # Deprecated\n    stderr: Callable[[str], None] | None = None\n    can_use_tool: CanUseTool | None = None\n    hooks: dict[HookEvent, list[HookMatcher]] | None = None\n    user: str | None = None\n    include_partial_messages: bool = False\n    fork_session: bool = False\n    agents: dict[str, AgentDefinition] | None = None\n    setting_sources: list[SettingSource] | None = None\n```\n\n| Property                      | Type                                         | Default              | Description                                                                                                                                                                             |\n| :---------------------------- | :------------------------------------------- | :------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `allowed_tools`               | `list[str]`                                  | `[]`                 | List of allowed tool names                                                                                                                                                              |\n| `system_prompt`               | `str \\| SystemPromptPreset \\| None`          | `None`               | System prompt configuration. Pass a string for custom prompt, or use `{\"type\": \"preset\", \"preset\": \"claude_code\"}` for Claude Code's system prompt. Add `\"append\"` to extend the preset |\n| `mcp_servers`                 | `dict[str, McpServerConfig] \\| str \\| Path`  | `{}`                 | MCP server configurations or path to config file                                                                                                                                        |\n| `permission_mode`             | `PermissionMode \\| None`                     | `None`               | Permission mode for tool usage                                                                                                                                                          |\n| `continue_conversation`       | `bool`                                       | `False`              | Continue the most recent conversation                                                                                                                                                   |\n| `resume`                      | `str \\| None`                                | `None`               | Session ID to resume                                                                                                                                                                    |\n| `max_turns`                   | `int \\| None`                                | `None`               | Maximum conversation turns                                                                                                                                                              |\n| `disallowed_tools`            | `list[str]`                                  | `[]`                 | List of disallowed tool names                                                                                                                                                           |\n| `model`                       | `str \\| None`                                | `None`               | Claude model to use                                                                                                                                                                     |\n| `output_format`               | [`OutputFormat`](#outputformat) ` \\| None`   | `None`               | Define output format for agent results. See [Structured outputs](/en/docs/agent-sdk/structured-outputs) for details                                                                     |\n| `permission_prompt_tool_name` | `str \\| None`                                | `None`               | MCP tool name for permission prompts                                                                                                                                                    |\n| `cwd`                         | `str \\| Path \\| None`                        | `None`               | Current working directory                                                                                                                                                               |\n| `settings`                    | `str \\| None`                                | `None`               | Path to settings file                                                                                                                                                                   |\n| `add_dirs`                    | `list[str \\| Path]`                          | `[]`                 | Additional directories Claude can access                                                                                                                                                |\n| `env`                         | `dict[str, str]`                             | `{}`                 | Environment variables                                                                                                                                                                   |\n| `extra_args`                  | `dict[str, str \\| None]`                     | `{}`                 | Additional CLI arguments to pass directly to the CLI                                                                                                                                    |\n| `max_buffer_size`             | `int \\| None`                                | `None`               | Maximum bytes when buffering CLI stdout                                                                                                                                                 |\n| `debug_stderr`                | `Any`                                        | `sys.stderr`         | *Deprecated* - File-like object for debug output. Use `stderr` callback instead                                                                                                         |\n| `stderr`                      | `Callable[[str], None] \\| None`              | `None`               | Callback function for stderr output from CLI                                                                                                                                            |\n| `can_use_tool`                | `CanUseTool \\| None`                         | `None`               | Tool permission callback function                                                                                                                                                       |\n| `hooks`                       | `dict[HookEvent, list[HookMatcher]] \\| None` | `None`               | Hook configurations for intercepting events                                                                                                                                             |\n| `user`                        | `str \\| None`                                | `None`               | User identifier                                                                                                                                                                         |\n| `include_partial_messages`    | `bool`                                       | `False`              | Include partial message streaming events                                                                                                                                                |\n| `fork_session`                | `bool`                                       | `False`              | When resuming with `resume`, fork to a new session ID instead of continuing the original session                                                                                        |\n| `agents`                      | `dict[str, AgentDefinition] \\| None`         | `None`               | Programmatically defined subagents                                                                                                                                                      |\n| `plugins`                     | `list[SdkPluginConfig]`                      | `[]`                 | Load custom plugins from local paths. See [Plugins](/en/docs/agent-sdk/plugins) for details                                                                                             |\n| `setting_sources`             | `list[SettingSource] \\| None`                | `None` (no settings) | Control which filesystem settings to load. When omitted, no settings are loaded. **Note:** Must include `\"project\"` to load CLAUDE.md files                                             |\n\n### `OutputFormat`\n\nConfiguration for structured output validation.\n\n```python  theme={null}\nclass OutputFormat(TypedDict):\n    type: Literal[\"json_schema\"]\n    schema: dict[str, Any]\n```\n\n| Field    | Required | Description                                        |\n| :------- | :------- | :------------------------------------------------- |\n| `type`   | Yes      | Must be `\"json_schema\"` for JSON Schema validation |\n| `schema` | Yes      | JSON Schema definition for output validation       |\n\n### `SystemPromptPreset`\n\nConfiguration for using Claude Code's preset system prompt with optional additions.\n\n```python  theme={null}\nclass SystemPromptPreset(TypedDict):\n    type: Literal[\"preset\"]\n    preset: Literal[\"claude_code\"]\n    append: NotRequired[str]\n```\n\n| Field    | Required | Description                                                   |\n| :------- | :------- | :------------------------------------------------------------ |\n| `type`   | Yes      | Must be `\"preset\"` to use a preset system prompt              |\n| `preset` | Yes      | Must be `\"claude_code\"` to use Claude Code's system prompt    |\n| `append` | No       | Additional instructions to append to the preset system prompt |\n\n### `SettingSource`\n\nControls which filesystem-based configuration sources the SDK loads settings from.\n\n```python  theme={null}\nSettingSource = Literal[\"user\", \"project\", \"local\"]\n```\n\n| Value       | Description                                  | Location                      |\n| :---------- | :------------------------------------------- | :---------------------------- |\n| `\"user\"`    | Global user settings                         | `~/.claude/settings.json`     |\n| `\"project\"` | Shared project settings (version controlled) | `.claude/settings.json`       |\n| `\"local\"`   | Local project settings (gitignored)          | `.claude/settings.local.json` |\n\n#### Default behavior\n\nWhen `setting_sources` is **omitted** or **`None`**, the SDK does **not** load any filesystem settings. This provides isolation for SDK applications.\n\n#### Why use setting\\_sources?\n\n**Load all filesystem settings (legacy behavior):**\n\n```python  theme={null}\n# Load all settings like SDK v0.0.x did\nfrom claude_agent_sdk import query, ClaudeAgentOptions\n\nasync for message in query(\n    prompt=\"Analyze this code\",\n    options=ClaudeAgentOptions(\n        setting_sources=[\"user\", \"project\", \"local\"]  # Load all settings\n    )\n):\n    print(message)\n```\n\n**Load only specific setting sources:**\n\n```python  theme={null}\n# Load only project settings, ignore user and local\nasync for message in query(\n    prompt=\"Run CI checks\",\n    options=ClaudeAgentOptions(\n        setting_sources=[\"project\"]  # Only .claude/settings.json\n    )\n):\n    print(message)\n```\n\n**Testing and CI environments:**\n\n```python  theme={null}\n# Ensure consistent behavior in CI by excluding local settings\nasync for message in query(\n    prompt=\"Run tests\",\n    options=ClaudeAgentOptions(\n        setting_sources=[\"project\"],  # Only team-shared settings\n        permission_mode=\"bypassPermissions\"\n    )\n):\n    print(message)\n```\n\n**SDK-only applications:**\n\n```python  theme={null}\n# Define everything programmatically (default behavior)\n# No filesystem dependencies - setting_sources defaults to None\nasync for message in query(\n    prompt=\"Review this PR\",\n    options=ClaudeAgentOptions(\n        # setting_sources=None is the default, no need to specify\n        agents={ /* ... */ },\n        mcp_servers={ /* ... */ },\n        allowed_tools=[\"Read\", \"Grep\", \"Glob\"]\n    )\n):\n    print(message)\n```\n\n**Loading CLAUDE.md project instructions:**\n\n```python  theme={null}\n# Load project settings to include CLAUDE.md files\nasync for message in query(\n    prompt=\"Add a new feature following project conventions\",\n    options=ClaudeAgentOptions(\n        system_prompt={\n            \"type\": \"preset\",\n            \"preset\": \"claude_code\"  # Use Claude Code's system prompt\n        },\n        setting_sources=[\"project\"],  # Required to load CLAUDE.md from project\n        allowed_tools=[\"Read\", \"Write\", \"Edit\"]\n    )\n):\n    print(message)\n```\n\n#### Settings precedence\n\nWhen multiple sources are loaded, settings are merged with this precedence (highest to lowest):\n\n1. Local settings (`.claude/settings.local.json`)\n2. Project settings (`.claude/settings.json`)\n3. User settings (`~/.claude/settings.json`)\n\nProgrammatic options (like `agents`, `allowed_tools`) always override filesystem settings.\n\n### `AgentDefinition`\n\nConfiguration for a subagent defined programmatically.\n\n```python  theme={null}\n@dataclass\nclass AgentDefinition:\n    description: str\n    prompt: str\n    tools: list[str] | None = None\n    model: Literal[\"sonnet\", \"opus\", \"haiku\", \"inherit\"] | None = None\n```\n\n| Field         | Required | Description                                                    |\n| :------------ | :------- | :------------------------------------------------------------- |\n| `description` | Yes      | Natural language description of when to use this agent         |\n| `tools`       | No       | Array of allowed tool names. If omitted, inherits all tools    |\n| `prompt`      | Yes      | The agent's system prompt                                      |\n| `model`       | No       | Model override for this agent. If omitted, uses the main model |\n\n### `PermissionMode`\n\nPermission modes for controlling tool execution.\n\n```python  theme={null}\nPermissionMode = Literal[\n    \"default\",           # Standard permission behavior\n    \"acceptEdits\",       # Auto-accept file edits\n    \"plan\",              # Planning mode - no execution\n    \"bypassPermissions\"  # Bypass all permission checks (use with caution)\n]\n```\n\n### `McpSdkServerConfig`\n\nConfiguration for SDK MCP servers created with `create_sdk_mcp_server()`.\n\n```python  theme={null}\nclass McpSdkServerConfig(TypedDict):\n    type: Literal[\"sdk\"]\n    name: str\n    instance: Any  # MCP Server instance\n```\n\n### `McpServerConfig`\n\nUnion type for MCP server configurations.\n\n```python  theme={null}\nMcpServerConfig = McpStdioServerConfig | McpSSEServerConfig | McpHttpServerConfig | McpSdkServerConfig\n```\n\n#### `McpStdioServerConfig`\n\n```python  theme={null}\nclass McpStdioServerConfig(TypedDict):\n    type: NotRequired[Literal[\"stdio\"]]  # Optional for backwards compatibility\n    command: str\n    args: NotRequired[list[str]]\n    env: NotRequired[dict[str, str]]\n```\n\n#### `McpSSEServerConfig`\n\n```python  theme={null}\nclass McpSSEServerConfig(TypedDict):\n    type: Literal[\"sse\"]\n    url: str\n    headers: NotRequired[dict[str, str]]\n```\n\n#### `McpHttpServerConfig`\n\n```python  theme={null}\nclass McpHttpServerConfig(TypedDict):\n    type: Literal[\"http\"]\n    url: str\n    headers: NotRequired[dict[str, str]]\n```\n\n### `SdkPluginConfig`\n\nConfiguration for loading plugins in the SDK.\n\n```python  theme={null}\nclass SdkPluginConfig(TypedDict):\n    type: Literal[\"local\"]\n    path: str\n```\n\n| Field  | Type               | Description                                                |\n| :----- | :----------------- | :--------------------------------------------------------- |\n| `type` | `Literal[\"local\"]` | Must be `\"local\"` (only local plugins currently supported) |\n| `path` | `str`              | Absolute or relative path to the plugin directory          |\n\n**Example:**\n\n```python  theme={null}\nplugins=[\n    {\"type\": \"local\", \"path\": \"./my-plugin\"},\n    {\"type\": \"local\", \"path\": \"/absolute/path/to/plugin\"}\n]\n```\n\nFor complete information on creating and using plugins, see [Plugins](/en/docs/agent-sdk/plugins).\n\n## Message Types\n\n### `Message`\n\nUnion type of all possible messages.\n\n```python  theme={null}\nMessage = UserMessage | AssistantMessage | SystemMessage | ResultMessage\n```\n\n### `UserMessage`\n\nUser input message.\n\n```python  theme={null}\n@dataclass\nclass UserMessage:\n    content: str | list[ContentBlock]\n```\n\n### `AssistantMessage`\n\nAssistant response message with content blocks.\n\n```python  theme={null}\n@dataclass\nclass AssistantMessage:\n    content: list[ContentBlock]\n    model: str\n```\n\n### `SystemMessage`\n\nSystem message with metadata.\n\n```python  theme={null}\n@dataclass\nclass SystemMessage:\n    subtype: str\n    data: dict[str, Any]\n```\n\n### `ResultMessage`\n\nFinal result message with cost and usage information.\n\n```python  theme={null}\n@dataclass\nclass ResultMessage:\n    subtype: str\n    duration_ms: int\n    duration_api_ms: int\n    is_error: bool\n    num_turns: int\n    session_id: str\n    total_cost_usd: float | None = None\n    usage: dict[str, Any] | None = None\n    result: str | None = None\n```\n\n## Content Block Types\n\n### `ContentBlock`\n\nUnion type of all content blocks.\n\n```python  theme={null}\nContentBlock = TextBlock | ThinkingBlock | ToolUseBlock | ToolResultBlock\n```\n\n### `TextBlock`\n\nText content block.\n\n```python  theme={null}\n@dataclass\nclass TextBlock:\n    text: str\n```\n\n### `ThinkingBlock`\n\nThinking content block (for models with thinking capability).\n\n```python  theme={null}\n@dataclass\nclass ThinkingBlock:\n    thinking: str\n    signature: str\n```\n\n### `ToolUseBlock`\n\nTool use request block.\n\n```python  theme={null}\n@dataclass\nclass ToolUseBlock:\n    id: str\n    name: str\n    input: dict[str, Any]\n```\n\n### `ToolResultBlock`\n\nTool execution result block.\n\n```python  theme={null}\n@dataclass\nclass ToolResultBlock:\n    tool_use_id: str\n    content: str | list[dict[str, Any]] | None = None\n    is_error: bool | None = None\n```\n\n## Error Types\n\n### `ClaudeSDKError`\n\nBase exception class for all SDK errors.\n\n```python  theme={null}\nclass ClaudeSDKError(Exception):\n    \"\"\"Base error for Claude SDK.\"\"\"\n```\n\n### `CLINotFoundError`\n\nRaised when Claude Code CLI is not installed or not found.\n\n```python  theme={null}\nclass CLINotFoundError(CLIConnectionError):\n    def __init__(self, message: str = \"Claude Code not found\", cli_path: str | None = None):\n        \"\"\"\n        Args:\n            message: Error message (default: \"Claude Code not found\")\n            cli_path: Optional path to the CLI that was not found\n        \"\"\"\n```\n\n### `CLIConnectionError`\n\nRaised when connection to Claude Code fails.\n\n```python  theme={null}\nclass CLIConnectionError(ClaudeSDKError):\n    \"\"\"Failed to connect to Claude Code.\"\"\"\n```\n\n### `ProcessError`\n\nRaised when the Claude Code process fails.\n\n```python  theme={null}\nclass ProcessError(ClaudeSDKError):\n    def __init__(self, message: str, exit_code: int | None = None, stderr: str | None = None):\n        self.exit_code = exit_code\n        self.stderr = stderr\n```\n\n### `CLIJSONDecodeError`\n\nRaised when JSON parsing fails.\n\n```python  theme={null}\nclass CLIJSONDecodeError(ClaudeSDKError):\n    def __init__(self, line: str, original_error: Exception):\n        \"\"\"\n        Args:\n            line: The line that failed to parse\n            original_error: The original JSON decode exception\n        \"\"\"\n        self.line = line\n        self.original_error = original_error\n```\n\n## Hook Types\n\n### `HookEvent`\n\nSupported hook event types. Note that due to setup limitations, the Python SDK does not support SessionStart, SessionEnd, and Notification hooks.\n\n```python  theme={null}\nHookEvent = Literal[\n    \"PreToolUse\",      # Called before tool execution\n    \"PostToolUse\",     # Called after tool execution\n    \"UserPromptSubmit\", # Called when user submits a prompt\n    \"Stop\",            # Called when stopping execution\n    \"SubagentStop\",    # Called when a subagent stops\n    \"PreCompact\"       # Called before message compaction\n]\n```\n\n### `HookCallback`\n\nType definition for hook callback functions.\n\n```python  theme={null}\nHookCallback = Callable[\n    [dict[str, Any], str | None, HookContext],\n    Awaitable[dict[str, Any]]\n]\n```\n\nParameters:\n\n* `input_data`: Hook-specific input data (see [hook documentation](https://docs.claude.comhttps://code.claude.com/docs/en/hooks#hook-input))\n* `tool_use_id`: Optional tool use identifier (for tool-related hooks)\n* `context`: Hook context with additional information\n\nReturns a dictionary that may contain:\n\n* `decision`: `\"block\"` to block the action\n* `systemMessage`: System message to add to the transcript\n* `hookSpecificOutput`: Hook-specific output data\n\n### `HookContext`\n\nContext information passed to hook callbacks.\n\n```python  theme={null}\n@dataclass\nclass HookContext:\n    signal: Any | None = None  # Future: abort signal support\n```\n\n### `HookMatcher`\n\nConfiguration for matching hooks to specific events or tools.\n\n```python  theme={null}\n@dataclass\nclass HookMatcher:\n    matcher: str | None = None        # Tool name or pattern to match (e.g., \"Bash\", \"Write|Edit\")\n    hooks: list[HookCallback] = field(default_factory=list)  # List of callbacks to execute\n```\n\n### Hook Usage Example\n\n```python  theme={null}\nfrom claude_agent_sdk import query, ClaudeAgentOptions, HookMatcher, HookContext\nfrom typing import Any\n\nasync def validate_bash_command(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Validate and potentially block dangerous bash commands.\"\"\"\n    if input_data['tool_name'] == 'Bash':\n        command = input_data['tool_input'].get('command', '')\n        if 'rm -rf /' in command:\n            return {\n                'hookSpecificOutput': {\n                    'hookEventName': 'PreToolUse',\n                    'permissionDecision': 'deny',\n                    'permissionDecisionReason': 'Dangerous command blocked'\n                }\n            }\n    return {}\n\nasync def log_tool_use(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Log all tool usage for auditing.\"\"\"\n    print(f\"Tool used: {input_data.get('tool_name')}\")\n    return {}\n\noptions = ClaudeAgentOptions(\n    hooks={\n        'PreToolUse': [\n            HookMatcher(matcher='Bash', hooks=[validate_bash_command]),\n            HookMatcher(hooks=[log_tool_use])  # Applies to all tools\n        ],\n        'PostToolUse': [\n            HookMatcher(hooks=[log_tool_use])\n        ]\n    }\n)\n\nasync for message in query(\n    prompt=\"Analyze this codebase\",\n    options=options\n):\n    print(message)\n```\n\n## Tool Input/Output Types\n\nDocumentation of input/output schemas for all built-in Claude Code tools. While the Python SDK doesn't export these as types, they represent the structure of tool inputs and outputs in messages.\n\n### Task\n\n**Tool name:** `Task`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"description\": str,      # A short (3-5 word) description of the task\n    \"prompt\": str,           # The task for the agent to perform\n    \"subagent_type\": str     # The type of specialized agent to use\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"result\": str,                    # Final result from the subagent\n    \"usage\": dict | None,             # Token usage statistics\n    \"total_cost_usd\": float | None,  # Total cost in USD\n    \"duration_ms\": int | None         # Execution duration in milliseconds\n}\n```\n\n### Bash\n\n**Tool name:** `Bash`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"command\": str,                  # The command to execute\n    \"timeout\": int | None,           # Optional timeout in milliseconds (max 600000)\n    \"description\": str | None,       # Clear, concise description (5-10 words)\n    \"run_in_background\": bool | None # Set to true to run in background\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"output\": str,              # Combined stdout and stderr output\n    \"exitCode\": int,            # Exit code of the command\n    \"killed\": bool | None,      # Whether command was killed due to timeout\n    \"shellId\": str | None       # Shell ID for background processes\n}\n```\n\n### Edit\n\n**Tool name:** `Edit`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"file_path\": str,           # The absolute path to the file to modify\n    \"old_string\": str,          # The text to replace\n    \"new_string\": str,          # The text to replace it with\n    \"replace_all\": bool | None  # Replace all occurrences (default False)\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"message\": str,      # Confirmation message\n    \"replacements\": int, # Number of replacements made\n    \"file_path\": str     # File path that was edited\n}\n```\n\n### Read\n\n**Tool name:** `Read`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"file_path\": str,       # The absolute path to the file to read\n    \"offset\": int | None,   # The line number to start reading from\n    \"limit\": int | None     # The number of lines to read\n}\n```\n\n**Output (Text files):**\n\n```python  theme={null}\n{\n    \"content\": str,         # File contents with line numbers\n    \"total_lines\": int,     # Total number of lines in file\n    \"lines_returned\": int   # Lines actually returned\n}\n```\n\n**Output (Images):**\n\n```python  theme={null}\n{\n    \"image\": str,       # Base64 encoded image data\n    \"mime_type\": str,   # Image MIME type\n    \"file_size\": int    # File size in bytes\n}\n```\n\n### Write\n\n**Tool name:** `Write`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"file_path\": str,  # The absolute path to the file to write\n    \"content\": str     # The content to write to the file\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"message\": str,        # Success message\n    \"bytes_written\": int,  # Number of bytes written\n    \"file_path\": str       # File path that was written\n}\n```\n\n### Glob\n\n**Tool name:** `Glob`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"pattern\": str,       # The glob pattern to match files against\n    \"path\": str | None    # The directory to search in (defaults to cwd)\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"matches\": list[str],  # Array of matching file paths\n    \"count\": int,          # Number of matches found\n    \"search_path\": str     # Search directory used\n}\n```\n\n### Grep\n\n**Tool name:** `Grep`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"pattern\": str,                    # The regular expression pattern\n    \"path\": str | None,                # File or directory to search in\n    \"glob\": str | None,                # Glob pattern to filter files\n    \"type\": str | None,                # File type to search\n    \"output_mode\": str | None,         # \"content\", \"files_with_matches\", or \"count\"\n    \"-i\": bool | None,                 # Case insensitive search\n    \"-n\": bool | None,                 # Show line numbers\n    \"-B\": int | None,                  # Lines to show before each match\n    \"-A\": int | None,                  # Lines to show after each match\n    \"-C\": int | None,                  # Lines to show before and after\n    \"head_limit\": int | None,          # Limit output to first N lines/entries\n    \"multiline\": bool | None           # Enable multiline mode\n}\n```\n\n**Output (content mode):**\n\n```python  theme={null}\n{\n    \"matches\": [\n        {\n            \"file\": str,\n            \"line_number\": int | None,\n            \"line\": str,\n            \"before_context\": list[str] | None,\n            \"after_context\": list[str] | None\n        }\n    ],\n    \"total_matches\": int\n}\n```\n\n**Output (files\\_with\\_matches mode):**\n\n```python  theme={null}\n{\n    \"files\": list[str],  # Files containing matches\n    \"count\": int         # Number of files with matches\n}\n```\n\n### NotebookEdit\n\n**Tool name:** `NotebookEdit`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"notebook_path\": str,                     # Absolute path to the Jupyter notebook\n    \"cell_id\": str | None,                    # The ID of the cell to edit\n    \"new_source\": str,                        # The new source for the cell\n    \"cell_type\": \"code\" | \"markdown\" | None,  # The type of the cell\n    \"edit_mode\": \"replace\" | \"insert\" | \"delete\" | None  # Edit operation type\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"message\": str,                              # Success message\n    \"edit_type\": \"replaced\" | \"inserted\" | \"deleted\",  # Type of edit performed\n    \"cell_id\": str | None,                       # Cell ID that was affected\n    \"total_cells\": int                           # Total cells in notebook after edit\n}\n```\n\n### WebFetch\n\n**Tool name:** `WebFetch`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"url\": str,     # The URL to fetch content from\n    \"prompt\": str   # The prompt to run on the fetched content\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"response\": str,           # AI model's response to the prompt\n    \"url\": str,                # URL that was fetched\n    \"final_url\": str | None,   # Final URL after redirects\n    \"status_code\": int | None  # HTTP status code\n}\n```\n\n### WebSearch\n\n**Tool name:** `WebSearch`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"query\": str,                        # The search query to use\n    \"allowed_domains\": list[str] | None, # Only include results from these domains\n    \"blocked_domains\": list[str] | None  # Never include results from these domains\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"results\": [\n        {\n            \"title\": str,\n            \"url\": str,\n            \"snippet\": str,\n            \"metadata\": dict | None\n        }\n    ],\n    \"total_results\": int,\n    \"query\": str\n}\n```\n\n### TodoWrite\n\n**Tool name:** `TodoWrite`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"todos\": [\n        {\n            \"content\": str,                              # The task description\n            \"status\": \"pending\" | \"in_progress\" | \"completed\",  # Task status\n            \"activeForm\": str                            # Active form of the description\n        }\n    ]\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"message\": str,  # Success message\n    \"stats\": {\n        \"total\": int,\n        \"pending\": int,\n        \"in_progress\": int,\n        \"completed\": int\n    }\n}\n```\n\n### BashOutput\n\n**Tool name:** `BashOutput`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"bash_id\": str,       # The ID of the background shell\n    \"filter\": str | None  # Optional regex to filter output lines\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"output\": str,                                      # New output since last check\n    \"status\": \"running\" | \"completed\" | \"failed\",       # Current shell status\n    \"exitCode\": int | None                              # Exit code when completed\n}\n```\n\n### KillBash\n\n**Tool name:** `KillBash`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"shell_id\": str  # The ID of the background shell to kill\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"message\": str,  # Success message\n    \"shell_id\": str  # ID of the killed shell\n}\n```\n\n### ExitPlanMode\n\n**Tool name:** `ExitPlanMode`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"plan\": str  # The plan to run by the user for approval\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"message\": str,          # Confirmation message\n    \"approved\": bool | None  # Whether user approved the plan\n}\n```\n\n### ListMcpResources\n\n**Tool name:** `ListMcpResources`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"server\": str | None  # Optional server name to filter resources by\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"resources\": [\n        {\n            \"uri\": str,\n            \"name\": str,\n            \"description\": str | None,\n            \"mimeType\": str | None,\n            \"server\": str\n        }\n    ],\n    \"total\": int\n}\n```\n\n### ReadMcpResource\n\n**Tool name:** `ReadMcpResource`\n\n**Input:**\n\n```python  theme={null}\n{\n    \"server\": str,  # The MCP server name\n    \"uri\": str      # The resource URI to read\n}\n```\n\n**Output:**\n\n```python  theme={null}\n{\n    \"contents\": [\n        {\n            \"uri\": str,\n            \"mimeType\": str | None,\n            \"text\": str | None,\n            \"blob\": str | None\n        }\n    ],\n    \"server\": str\n}\n```\n\n## Advanced Features with ClaudeSDKClient\n\n### Building a Continuous Conversation Interface\n\n```python  theme={null}\nfrom claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions, AssistantMessage, TextBlock\nimport asyncio\n\nclass ConversationSession:\n    \"\"\"Maintains a single conversation session with Claude.\"\"\"\n\n    def __init__(self, options: ClaudeAgentOptions = None):\n        self.client = ClaudeSDKClient(options)\n        self.turn_count = 0\n\n    async def start(self):\n        await self.client.connect()\n        print(\"Starting conversation session. Claude will remember context.\")\n        print(\"Commands: 'exit' to quit, 'interrupt' to stop current task, 'new' for new session\")\n\n        while True:\n            user_input = input(f\"\\n[Turn {self.turn_count + 1}] You: \")\n\n            if user_input.lower() == 'exit':\n                break\n            elif user_input.lower() == 'interrupt':\n                await self.client.interrupt()\n                print(\"Task interrupted!\")\n                continue\n            elif user_input.lower() == 'new':\n                # Disconnect and reconnect for a fresh session\n                await self.client.disconnect()\n                await self.client.connect()\n                self.turn_count = 0\n                print(\"Started new conversation session (previous context cleared)\")\n                continue\n\n            # Send message - Claude remembers all previous messages in this session\n            await self.client.query(user_input)\n            self.turn_count += 1\n\n            # Process response\n            print(f\"[Turn {self.turn_count}] Claude: \", end=\"\")\n            async for message in self.client.receive_response():\n                if isinstance(message, AssistantMessage):\n                    for block in message.content:\n                        if isinstance(block, TextBlock):\n                            print(block.text, end=\"\")\n            print()  # New line after response\n\n        await self.client.disconnect()\n        print(f\"Conversation ended after {self.turn_count} turns.\")\n\nasync def main():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Read\", \"Write\", \"Bash\"],\n        permission_mode=\"acceptEdits\"\n    )\n    session = ConversationSession(options)\n    await session.start()\n\n# Example conversation:\n# Turn 1 - You: \"Create a file called hello.py\"\n# Turn 1 - Claude: \"I'll create a hello.py file for you...\"\n# Turn 2 - You: \"What's in that file?\"\n# Turn 2 - Claude: \"The hello.py file I just created contains...\" (remembers!)\n# Turn 3 - You: \"Add a main function to it\"\n# Turn 3 - Claude: \"I'll add a main function to hello.py...\" (knows which file!)\n\nasyncio.run(main())\n```\n\n### Using Hooks for Behavior Modification\n\n```python  theme={null}\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions,\n    HookMatcher,\n    HookContext\n)\nimport asyncio\nfrom typing import Any\n\nasync def pre_tool_logger(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Log all tool usage before execution.\"\"\"\n    tool_name = input_data.get('tool_name', 'unknown')\n    print(f\"[PRE-TOOL] About to use: {tool_name}\")\n\n    # You can modify or block the tool execution here\n    if tool_name == \"Bash\" and \"rm -rf\" in str(input_data.get('tool_input', {})):\n        return {\n            'hookSpecificOutput': {\n                'hookEventName': 'PreToolUse',\n                'permissionDecision': 'deny',\n                'permissionDecisionReason': 'Dangerous command blocked'\n            }\n        }\n    return {}\n\nasync def post_tool_logger(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Log results after tool execution.\"\"\"\n    tool_name = input_data.get('tool_name', 'unknown')\n    print(f\"[POST-TOOL] Completed: {tool_name}\")\n    return {}\n\nasync def user_prompt_modifier(\n    input_data: dict[str, Any],\n    tool_use_id: str | None,\n    context: HookContext\n) -> dict[str, Any]:\n    \"\"\"Add context to user prompts.\"\"\"\n    original_prompt = input_data.get('prompt', '')\n\n    # Add timestamp to all prompts\n    from datetime import datetime\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    return {\n        'hookSpecificOutput': {\n            'hookEventName': 'UserPromptSubmit',\n            'updatedPrompt': f\"[{timestamp}] {original_prompt}\"\n        }\n    }\n\nasync def main():\n    options = ClaudeAgentOptions(\n        hooks={\n            'PreToolUse': [\n                HookMatcher(hooks=[pre_tool_logger]),\n                HookMatcher(matcher='Bash', hooks=[pre_tool_logger])\n            ],\n            'PostToolUse': [\n                HookMatcher(hooks=[post_tool_logger])\n            ],\n            'UserPromptSubmit': [\n                HookMatcher(hooks=[user_prompt_modifier])\n            ]\n        },\n        allowed_tools=[\"Read\", \"Write\", \"Bash\"]\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\"List files in current directory\")\n\n        async for message in client.receive_response():\n            # Hooks will automatically log tool usage\n            pass\n\nasyncio.run(main())\n```\n\n### Real-time Progress Monitoring\n\n```python  theme={null}\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions,\n    AssistantMessage,\n    ToolUseBlock,\n    ToolResultBlock,\n    TextBlock\n)\nimport asyncio\n\nasync def monitor_progress():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Write\", \"Bash\"],\n        permission_mode=\"acceptEdits\"\n    )\n\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\n            \"Create 5 Python files with different sorting algorithms\"\n        )\n\n        # Monitor progress in real-time\n        files_created = []\n        async for message in client.receive_messages():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, ToolUseBlock):\n                        if block.name == \"Write\":\n                            file_path = block.input.get(\"file_path\", \"\")\n                            print(f\"🔨 Creating: {file_path}\")\n                    elif isinstance(block, ToolResultBlock):\n                        print(f\"✅ Completed tool execution\")\n                    elif isinstance(block, TextBlock):\n                        print(f\"💭 Claude says: {block.text[:100]}...\")\n\n            # Check if we've received the final result\n            if hasattr(message, 'subtype') and message.subtype in ['success', 'error']:\n                print(f\"\\n🎯 Task completed!\")\n                break\n\nasyncio.run(monitor_progress())\n```\n\n## Example Usage\n\n### Basic file operations (using query)\n\n```python  theme={null}\nfrom claude_agent_sdk import query, ClaudeAgentOptions, AssistantMessage, ToolUseBlock\nimport asyncio\n\nasync def create_project():\n    options = ClaudeAgentOptions(\n        allowed_tools=[\"Read\", \"Write\", \"Bash\"],\n        permission_mode='acceptEdits',\n        cwd=\"/home/user/project\"\n    )\n\n    async for message in query(\n        prompt=\"Create a Python project structure with setup.py\",\n        options=options\n    ):\n        if isinstance(message, AssistantMessage):\n            for block in message.content:\n                if isinstance(block, ToolUseBlock):\n                    print(f\"Using tool: {block.name}\")\n\nasyncio.run(create_project())\n```\n\n### Error handling\n\n```python  theme={null}\nfrom claude_agent_sdk import (\n    query,\n    CLINotFoundError,\n    ProcessError,\n    CLIJSONDecodeError\n)\n\ntry:\n    async for message in query(prompt=\"Hello\"):\n        print(message)\nexcept CLINotFoundError:\n    print(\"Please install Claude Code: npm install -g @anthropic-ai/claude-code\")\nexcept ProcessError as e:\n    print(f\"Process failed with exit code: {e.exit_code}\")\nexcept CLIJSONDecodeError as e:\n    print(f\"Failed to parse response: {e}\")\n```\n\n### Streaming mode with client\n\n```python  theme={null}\nfrom claude_agent_sdk import ClaudeSDKClient\nimport asyncio\n\nasync def interactive_session():\n    async with ClaudeSDKClient() as client:\n        # Send initial message\n        await client.query(\"What's the weather like?\")\n\n        # Process responses\n        async for msg in client.receive_response():\n            print(msg)\n\n        # Send follow-up\n        await client.query(\"Tell me more about that\")\n\n        # Process follow-up response\n        async for msg in client.receive_response():\n            print(msg)\n\nasyncio.run(interactive_session())\n```\n\n### Using custom tools with ClaudeSDKClient\n\n```python  theme={null}\nfrom claude_agent_sdk import (\n    ClaudeSDKClient,\n    ClaudeAgentOptions,\n    tool,\n    create_sdk_mcp_server,\n    AssistantMessage,\n    TextBlock\n)\nimport asyncio\nfrom typing import Any\n\n# Define custom tools with @tool decorator\n@tool(\"calculate\", \"Perform mathematical calculations\", {\"expression\": str})\nasync def calculate(args: dict[str, Any]) -> dict[str, Any]:\n    try:\n        result = eval(args[\"expression\"], {\"__builtins__\": {}})\n        return {\n            \"content\": [{\n                \"type\": \"text\",\n                \"text\": f\"Result: {result}\"\n            }]\n        }\n    except Exception as e:\n        return {\n            \"content\": [{\n                \"type\": \"text\",\n                \"text\": f\"Error: {str(e)}\"\n            }],\n            \"is_error\": True\n        }\n\n@tool(\"get_time\", \"Get current time\", {})\nasync def get_time(args: dict[str, Any]) -> dict[str, Any]:\n    from datetime import datetime\n    current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Current time: {current_time}\"\n        }]\n    }\n\nasync def main():\n    # Create SDK MCP server with custom tools\n    my_server = create_sdk_mcp_server(\n        name=\"utilities\",\n        version=\"1.0.0\",\n        tools=[calculate, get_time]\n    )\n\n    # Configure options with the server\n    options = ClaudeAgentOptions(\n        mcp_servers={\"utils\": my_server},\n        allowed_tools=[\n            \"mcp__utils__calculate\",\n            \"mcp__utils__get_time\"\n        ]\n    )\n\n    # Use ClaudeSDKClient for interactive tool usage\n    async with ClaudeSDKClient(options=options) as client:\n        await client.query(\"What's 123 * 456?\")\n\n        # Process calculation response\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Calculation: {block.text}\")\n\n        # Follow up with time query\n        await client.query(\"What time is it now?\")\n\n        async for message in client.receive_response():\n            if isinstance(message, AssistantMessage):\n                for block in message.content:\n                    if isinstance(block, TextBlock):\n                        print(f\"Time: {block.text}\")\n\nasyncio.run(main())\n```\n\n## See also\n\n* [Python SDK guide](/en/docs/agent-sdk/python) - Tutorial and examples\n* [SDK overview](/en/docs/agent-sdk/overview) - General SDK concepts\n* [TypeScript SDK reference](/en/docs/agent-sdk/typescript) - TypeScript SDK documentation\n* [CLI reference](https://code.claude.com/docs/en/cli-reference) - Command-line interface\n* [Common workflows](https://code.claude.com/docs/en/common-workflows) - Step-by-step guides",
  "content_length": 60092
}