{
  "title": "Handling Permissions",
  "source_url": "https://docs.claude.com/en/docs/agent-sdk/permissions",
  "content": "Control tool usage and permissions in the Claude Agent SDK\n\n<style>\n  {`\n    .edgeLabel {\n      padding: 8px 12px !important;\n    }\n    .edgeLabel rect {\n      rx: 4;\n      ry: 4;\n      stroke: #D9D8D5 !important;\n      stroke-width: 1px !important;\n    }\n    /* Add rounded corners to flowchart nodes */\n    .node rect {\n      rx: 8 !important;\n      ry: 8 !important;\n    }\n    `}\n</style>\n\n# SDK Permissions\n\nThe Claude Agent SDK provides powerful permission controls that allow you to manage how Claude uses tools in your application.\n\nThis guide covers how to implement permission systems using the `canUseTool` callback, hooks, and settings.json permission rules. For complete API documentation, see the [TypeScript SDK reference](/en/docs/agent-sdk/typescript).\n\n## Overview\n\nThe Claude Agent SDK provides four complementary ways to control tool usage:\n\n1. **[Permission Modes](#permission-modes)** - Global permission behavior settings that affect all tools\n2. **[canUseTool callback](/en/docs/agent-sdk/typescript#canusetool)** - Runtime permission handler for cases not covered by other rules\n3. **[Hooks](/en/docs/agent-sdk/typescript#hook-types)** - Fine-grained control over every tool execution with custom logic\n4. **[Permission rules (settings.json)](https://code.claude.com/docs/en/settings#permission-settings)** - Declarative allow/deny rules with integrated bash command parsing\n\nUse cases for each approach:\n\n* Permission modes - Set overall permission behavior (planning, auto-accepting edits, bypassing checks)\n* `canUseTool` - Dynamic approval for uncovered cases, prompts user for permission\n* Hooks - Programmatic control over all tool executions\n* Permission rules - Static policies with intelligent bash command parsing\n\n## Permission Flow Diagram\n\n```mermaid  theme={null}\n%%{init: {\"theme\": \"base\", \"themeVariables\": {\"edgeLabelBackground\": \"#F0F0EB\", \"lineColor\": \"#91918D\"}, \"flowchart\": {\"edgeLabelMarginX\": 12, \"edgeLabelMarginY\": 8}}}%%\nflowchart TD\n    Start([Tool request]) --> PreHook(PreToolUse Hook)\n\n    PreHook -->|&nbsp;&nbsp;Allow&nbsp;&nbsp;| Execute(Execute Tool)\n    PreHook -->|&nbsp;&nbsp;Deny&nbsp;&nbsp;| Denied(Denied)\n    PreHook -->|&nbsp;&nbsp;Ask&nbsp;&nbsp;| Callback(canUseTool Callback)\n    PreHook -->|&nbsp;&nbsp;Continue&nbsp;&nbsp;| Deny(Check Deny Rules)\n\n    Deny -->|&nbsp;&nbsp;Match&nbsp;&nbsp;| Denied\n    Deny -->|&nbsp;&nbsp;No Match&nbsp;&nbsp;| Allow(Check Allow Rules)\n\n    Allow -->|&nbsp;&nbsp;Match&nbsp;&nbsp;| Execute\n    Allow -->|&nbsp;&nbsp;No Match&nbsp;&nbsp;| Ask(Check Ask Rules)\n\n    Ask -->|&nbsp;&nbsp;Match&nbsp;&nbsp;| Callback\n    Ask -->|&nbsp;&nbsp;No Match&nbsp;&nbsp;| Mode{Permission Mode?}\n\n    Mode -->|&nbsp;&nbsp;bypassPermissions&nbsp;&nbsp;| Execute\n    Mode -->|&nbsp;&nbsp;Other modes&nbsp;&nbsp;| Callback\n\n    Callback -->|&nbsp;&nbsp;Allow&nbsp;&nbsp;| Execute\n    Callback -->|&nbsp;&nbsp;Deny&nbsp;&nbsp;| Denied\n\n    Denied --> DeniedResponse([Feedback to agent])\n\n    Execute --> PostHook(PostToolUse Hook)\n    PostHook --> Done([Tool Response])\n\n    style Start fill:#F0F0EB,stroke:#D9D8D5,color:#191919\n\n    style Denied fill:#BF4D43,color:#fff\n    style DeniedResponse fill:#BF4D43,color:#fff\n    style Execute fill:#DAAF91,color:#191919\n    style Done fill:#DAAF91,color:#191919\n\n    classDef hookClass fill:#CC785C,color:#fff\n    class PreHook,PostHook hookClass\n\n    classDef ruleClass fill:#EBDBBC,color:#191919\n    class Deny,Allow,Ask ruleClass\n\n    classDef modeClass fill:#A8DAEF,color:#191919\n    class Mode modeClass\n\n    classDef callbackClass fill:#D4A27F,color:#191919\n    class Callback callbackClass\n```\n\n**Processing Order:** PreToolUse Hook ‚Üí Deny Rules ‚Üí Allow Rules ‚Üí Ask Rules ‚Üí Permission Mode Check ‚Üí canUseTool Callback ‚Üí PostToolUse Hook\n\n## Permission Modes\n\nPermission modes provide global control over how Claude uses tools. You can set the permission mode when calling `query()` or change it dynamically during streaming sessions.\n\n### Available Modes\n\nThe SDK supports four permission modes, each with different behavior:\n\n| Mode                | Description                  | Tool Behavior                                                                                              |\n| :------------------ | :--------------------------- | :--------------------------------------------------------------------------------------------------------- |\n| `default`           | Standard permission behavior | Normal permission checks apply                                                                             |\n| `plan`              | Planning mode - no execution | Claude can only use read-only tools; presents a plan before execution **(Not currently supported in SDK)** |\n| `acceptEdits`       | Auto-accept file edits       | File edits and filesystem operations are automatically approved                                            |\n| `bypassPermissions` | Bypass all permission checks | All tools run without permission prompts (use with caution)                                                |\n\n### Setting Permission Mode\n\nYou can set the permission mode in two ways:\n\n#### 1. Initial Configuration\n\nSet the mode when creating a query:\n\n<CodeGroup>\n  ```typescript TypeScript theme={null}\n  import { query } from \"@anthropic-ai/claude-agent-sdk\";\n\n  const result = await query({\n    prompt: \"Help me refactor this code\",\n    options: {\n      permissionMode: 'default'  // Standard permission mode\n    }\n  });\n  ```\n\n  ```python Python theme={null}\n  from claude_agent_sdk import query\n\n  result = await query(\n      prompt=\"Help me refactor this code\",\n      options={\n          \"permission_mode\": \"default\"  # Standard permission mode\n      }\n  )\n  ```\n</CodeGroup>\n\n#### 2. Dynamic Mode Changes (Streaming Only)\n\nChange the mode during a streaming session:\n\n<CodeGroup>\n  ```typescript TypeScript theme={null}\n  import { query } from \"@anthropic-ai/claude-agent-sdk\";\n\n  // Create an async generator for streaming input\n  async function* streamInput() {\n    yield { \n      type: 'user',\n      message: { \n        role: 'user', \n        content: \"Let's start with default permissions\" \n      }\n    };\n    \n    // Later in the conversation...\n    yield {\n      type: 'user',\n      message: {\n        role: 'user',\n        content: \"Now let's speed up development\"\n      }\n    };\n  }\n\n  const q = query({\n    prompt: streamInput(),\n    options: {\n      permissionMode: 'default'  // Start in default mode\n    }\n  });\n\n  // Change mode dynamically\n  await q.setPermissionMode('acceptEdits');\n\n  // Process messages\n  for await (const message of q) {\n    console.log(message);\n  }\n  ```\n\n  ```python Python theme={null}\n  from claude_agent_sdk import query\n\n  async def stream_input():\n      \"\"\"Async generator for streaming input\"\"\"\n      yield {\n          \"type\": \"user\",\n          \"message\": {\n              \"role\": \"user\",\n              \"content\": \"Let's start with default permissions\"\n          }\n      }\n      \n      # Later in the conversation...\n      yield {\n          \"type\": \"user\",\n          \"message\": {\n              \"role\": \"user\",\n              \"content\": \"Now let's speed up development\"\n          }\n      }\n\n  q = query(\n      prompt=stream_input(),\n      options={\n          \"permission_mode\": \"default\"  # Start in default mode\n      }\n  )\n\n  # Change mode dynamically\n  await q.set_permission_mode(\"acceptEdits\")\n\n  # Process messages\n  async for message in q:\n      print(message)\n  ```\n</CodeGroup>\n\n### Mode-Specific Behaviors\n\n#### Accept Edits Mode (`acceptEdits`)\n\nIn accept edits mode:\n\n* All file edits are automatically approved\n* Filesystem operations (mkdir, touch, rm, etc.) are auto-approved\n* Other tools still require normal permissions\n* Speeds up development when you trust Claude's edits\n* Useful for rapid prototyping and iterations\n\nAuto-approved operations:\n\n* File edits (Edit, Write tools)\n* Bash filesystem commands (mkdir, touch, rm, mv, cp)\n* File creation and deletion\n\n#### Bypass Permissions Mode (`bypassPermissions`)\n\nIn bypass permissions mode:\n\n* **ALL tool uses are automatically approved**\n* No permission prompts appear\n* Hooks still execute (can still block operations)\n* **Use with extreme caution** - Claude has full system access\n* Recommended only for controlled environments\n\n### Mode Priority in Permission Flow\n\nPermission modes are evaluated at a specific point in the permission flow:\n\n1. **Hooks execute first** - Can allow, deny, ask, or continue\n2. **Deny rules** are checked - Block tools regardless of mode\n3. **Allow rules** are checked - Permit tools if matched\n4. **Ask rules** are checked - Prompt for permission if matched\n5. **Permission mode** is evaluated:\n   * **`bypassPermissions` mode** - If active, allows all remaining tools\n   * **Other modes** - Defer to `canUseTool` callback\n6. **`canUseTool` callback** - Handles remaining cases\n\nThis means:\n\n* Hooks can always control tool use, even in `bypassPermissions` mode\n* Explicit deny rules override all permission modes\n* Ask rules are evaluated before permission modes\n* `bypassPermissions` mode overrides the `canUseTool` callback for unmatched tools\n\n### Best Practices\n\n1. **Use default mode** for controlled execution with normal permission checks\n2. **Use acceptEdits mode** when working on isolated files or directories\n3. **Avoid bypassPermissions** in production or on systems with sensitive data\n4. **Combine modes with hooks** for fine-grained control\n5. **Switch modes dynamically** based on task progress and confidence\n\nExample of mode progression:\n\n```typescript  theme={null}\n// Start in default mode for controlled execution\npermissionMode: 'default'\n\n// Switch to acceptEdits for rapid iteration\nawait q.setPermissionMode('acceptEdits')\n```\n\n## canUseTool\n\nThe `canUseTool` callback is passed as an option when calling the `query` function. It receives the tool name and input parameters, and must return a decision- either allow or deny.\n\ncanUseTool fires whenever Claude Code would show a permission prompt to a user, e.g. hooks and permission rules do not cover it and it is not in acceptEdits mode.\n\nHere's a complete example showing how to implement interactive tool approval:\n\n<CodeGroup>\n  ```typescript TypeScript theme={null}\n  import { query } from \"@anthropic-ai/claude-agent-sdk\";\n\n  async function promptForToolApproval(toolName: string, input: any) {\n    console.log(\"\\nüîß Tool Request:\");\n    console.log(`   Tool: ${toolName}`);\n    \n    // Display tool parameters\n    if (input && Object.keys(input).length > 0) {\n      console.log(\"   Parameters:\");\n      for (const [key, value] of Object.entries(input)) {\n        let displayValue = value;\n        if (typeof value === 'string' && value.length > 100) {\n          displayValue = value.substring(0, 100) + \"...\";\n        } else if (typeof value === 'object') {\n          displayValue = JSON.stringify(value, null, 2);\n        }\n        console.log(`     ${key}: ${displayValue}`);\n      }\n    }\n    \n    // Get user approval (replace with your UI logic)\n    const approved = await getUserApproval();\n    \n    if (approved) {\n      console.log(\"   ‚úÖ Approved\\n\");\n      return {\n        behavior: \"allow\",\n        updatedInput: input\n      };\n    } else {\n      console.log(\"   ‚ùå Denied\\n\");\n      return {\n        behavior: \"deny\",\n        message: \"User denied permission for this tool\"\n      };\n    }\n  }\n\n  // Use the permission callback\n  const result = await query({\n    prompt: \"Help me analyze this codebase\",\n    options: {\n      canUseTool: async (toolName, input) => {\n        return promptForToolApproval(toolName, input);\n      }\n    }\n  });\n  ```\n\n  ```python Python theme={null}\n  from claude_agent_sdk import query\n\n  async def prompt_for_tool_approval(tool_name: str, input_params: dict):\n      print(f\"\\nüîß Tool Request:\")\n      print(f\"   Tool: {tool_name}\")\n\n      # Display parameters\n      if input_params:\n          print(\"   Parameters:\")\n          for key, value in input_params.items():\n              display_value = value\n              if isinstance(value, str) and len(value) > 100:\n                  display_value = value[:100] + \"...\"\n              elif isinstance(value, (dict, list)):\n                  display_value = json.dumps(value, indent=2)\n              print(f\"     {key}: {display_value}\")\n\n      # Get user approval\n      answer = input(\"\\n   Approve this tool use? (y/n): \")\n\n      if answer.lower() in ['y', 'yes']:\n          print(\"   ‚úÖ Approved\\n\")\n          return {\n              \"behavior\": \"allow\",\n              \"updatedInput\": input_params\n          }\n      else:\n          print(\"   ‚ùå Denied\\n\")\n          return {\n              \"behavior\": \"deny\",\n              \"message\": \"User denied permission for this tool\"\n          }\n\n  # Use the permission callback\n  result = await query(\n      prompt=\"Help me analyze this codebase\",\n      options={\n          \"can_use_tool\": prompt_for_tool_approval\n      }\n  )\n  ```\n</CodeGroup>\n\n## Related Resources\n\n* [Hooks Guide](https://code.claude.com/docs/en/hooks-guide) - Learn how to implement hooks for fine-grained control over tool execution\n* [Settings: Permission Rules](https://code.claude.com/docs/en/settings#permission-settings) - Configure declarative allow/deny rules with bash command parsing",
  "content_length": 13273
}