{
  "title": "How to implement tool use",
  "source_url": "https://docs.claude.com/en/docs/agents-and-tools/tool-use/implement-tool-use",
  "content": "## Choosing a model\n\nWe recommend using the latest Claude Sonnet (4.5) or Claude Opus (4.1) model for complex tools and ambiguous queries; they handle multiple tools better and seek clarification when needed.\n\nUse Claude Haiku models for straightforward tools, but note they may infer missing parameters.\n\n<Tip>\n  If using Claude with tool use and extended thinking, refer to our guide [here](/en/docs/build-with-claude/extended-thinking) for more information.\n</Tip>\n\n## Specifying client tools\n\nClient tools (both Anthropic-defined and user-defined) are specified in the `tools` top-level parameter of the API request. Each tool definition includes:\n\n| Parameter      | Description                                                                                         |\n| :------------- | :-------------------------------------------------------------------------------------------------- |\n| `name`         | The name of the tool. Must match the regex `^[a-zA-Z0-9_-]{1,64}$`.                                 |\n| `description`  | A detailed plaintext description of what the tool does, when it should be used, and how it behaves. |\n| `input_schema` | A [JSON Schema](https://json-schema.org/) object defining the expected parameters for the tool.     |\n\n<Accordion title=\"Example simple tool definition\">\n  ```JSON JSON theme={null}\n  {\n    \"name\": \"get_weather\",\n    \"description\": \"Get the current weather in a given location\",\n    \"input_schema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"location\": {\n          \"type\": \"string\",\n          \"description\": \"The city and state, e.g. San Francisco, CA\"\n        },\n        \"unit\": {\n          \"type\": \"string\",\n          \"enum\": [\"celsius\", \"fahrenheit\"],\n          \"description\": \"The unit of temperature, either 'celsius' or 'fahrenheit'\"\n        }\n      },\n      \"required\": [\"location\"]\n    }\n  }\n  ```\n\n  This tool, named `get_weather`, expects an input object with a required `location` string and an optional `unit` string that must be either \"celsius\" or \"fahrenheit\".\n</Accordion>\n\n### Tool use system prompt\n\nWhen you call the Claude API with the `tools` parameter, we construct a special system prompt from the tool definitions, tool configuration, and any user-specified system prompt. The constructed prompt is designed to instruct the model to use the specified tool(s) and provide the necessary context for the tool to operate properly:\n\n```\nIn this environment you have access to a set of tools you can use to answer the user's question.\n{{ FORMATTING INSTRUCTIONS }}\nString and scalar parameters should be specified as is, while lists and objects should use JSON format. Note that spaces for string values are not stripped. The output is not expected to be valid XML and is parsed with regular expressions.\nHere are the functions available in JSONSchema format:\n{{ TOOL DEFINITIONS IN JSON SCHEMA }}\n{{ USER SYSTEM PROMPT }}\n{{ TOOL CONFIGURATION }}\n```\n\n### Best practices for tool definitions\n\nTo get the best performance out of Claude when using tools, follow these guidelines:\n\n* **Provide extremely detailed descriptions.** This is by far the most important factor in tool performance. Your descriptions should explain every detail about the tool, including:\n  * What the tool does\n  * When it should be used (and when it shouldn't)\n  * What each parameter means and how it affects the tool's behavior\n  * Any important caveats or limitations, such as what information the tool does not return if the tool name is unclear. The more context you can give Claude about your tools, the better it will be at deciding when and how to use them. Aim for at least 3-4 sentences per tool description, more if the tool is complex.\n* **Prioritize descriptions over examples.** While you can include examples of how to use a tool in its description or in the accompanying prompt, this is less important than having a clear and comprehensive explanation of the tool's purpose and parameters. Only add examples after you've fully fleshed out the description.\n\n<AccordionGroup>\n  <Accordion title=\"Example of a good tool description\">\n    ```JSON JSON theme={null}\n    {\n      \"name\": \"get_stock_price\",\n      \"description\": \"Retrieves the current stock price for a given ticker symbol. The ticker symbol must be a valid symbol for a publicly traded company on a major US stock exchange like NYSE or NASDAQ. The tool will return the latest trade price in USD. It should be used when the user asks about the current or most recent price of a specific stock. It will not provide any other information about the stock or company.\",\n      \"input_schema\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"ticker\": {\n            \"type\": \"string\",\n            \"description\": \"The stock ticker symbol, e.g. AAPL for Apple Inc.\"\n          }\n        },\n        \"required\": [\"ticker\"]\n      }\n    }\n    ```\n  </Accordion>\n\n  <Accordion title=\"Example poor tool description\">\n    ```JSON JSON theme={null}\n    {\n      \"name\": \"get_stock_price\",\n      \"description\": \"Gets the stock price for a ticker.\",\n      \"input_schema\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"ticker\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\"ticker\"]\n      }\n    }\n    ```\n  </Accordion>\n</AccordionGroup>\n\nThe good description clearly explains what the tool does, when to use it, what data it returns, and what the `ticker` parameter means. The poor description is too brief and leaves Claude with many open questions about the tool's behavior and usage.\n\n## Tool runner (beta)\n\nThe tool runner provides an out-of-the-box solution for executing tools with Claude. Instead of manually handling tool calls, tool results, and conversation management, the tool runner automatically:\n\n* Executes tools when Claude calls them\n* Handles the request/response cycle\n* Manages conversation state\n* Provides type safety and validation\n\nWe recommend that you use the tool runner for most tool use implementations.\n\n<Note>\n  The tool runner is currently in beta and only available in the [Python](https://github.com/anthropics/anthropic-sdk-python/blob/main/tools.md) and [TypeScript](https://github.com/anthropics/anthropic-sdk-typescript/blob/main/helpers.md#tool-helpers) SDKs.\n</Note>\n\n<Tabs>\n  <Tab title=\"Python\">\n    ### Basic usage\n\n    Use the `@beta_tool` decorator to define tools and `client.beta.messages.tool_runner()` to execute them.\n\n    <Note>\n      If you're using the async client, replace `@beta_tool` with `@beta_async_tool` and define the function with `async def`.\n    </Note>\n\n    ```python  theme={null}\n    import anthropic\n    import json\n    from anthropic import beta_tool\n\n    # Initialize client\n    client = anthropic.Anthropic()\n\n    # Define tools using the decorator\n    @beta_tool\n    def get_weather(location: str, unit: str = \"fahrenheit\") -> str:\n        \"\"\"Get the current weather in a given location.\n\n        Args:\n            location: The city and state, e.g. San Francisco, CA\n            unit: Temperature unit, either 'celsius' or 'fahrenheit'\n        \"\"\"\n        # In a full implementation, you'd call a weather API here\n        return json.dumps({\"temperature\": \"20°C\", \"condition\": \"Sunny\"})\n\n    @beta_tool\n    def calculate_sum(a: int, b: int) -> str:\n        \"\"\"Add two numbers together.\n\n        Args:\n            a: First number\n            b: Second number\n        \"\"\"\n        return str(a + b)\n\n    # Use the tool runner\n    runner = client.beta.messages.tool_runner(\n        model=\"claude-sonnet-4-5\",\n        max_tokens=1024,\n        tools=[get_weather, calculate_sum],\n        messages=[\n            {\"role\": \"user\", \"content\": \"What's the weather like in Paris? Also, what's 15 + 27?\"}\n        ]\n    )\n    for message in runner:\n        print(message.content[0].text)\n    ```\n\n    The decorated function must return a content block or content block array, including text, images, or document blocks. This allows tools to return rich, multimodal responses. Returned strings will be converted to a text content block.\n    If you want to return a structured JSON object to Claude, encode it to a JSON string before returning it. Numbers, booleans or other non-string primitives also must be converted to strings.\n\n    The `@beta_tool` decorator will inspect the function arguments and the docstring to extract a json schema representation of the given function, in the example above `calculate_sum` will be turned into:\n\n    ```json  theme={null}\n    {\n      \"name\": \"calculate_sum\",\n      \"description\": \"Adds two integers together.\",\n      \"input_schema\": {\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"left\": {\n            \"description\": \"The first integer to add.\",\n            \"title\": \"Left\",\n            \"type\": \"integer\"\n          },\n          \"right\": {\n            \"description\": \"The second integer to add.\",\n            \"title\": \"Right\",\n            \"type\": \"integer\"\n          }\n        },\n        \"required\": [\"left\", \"right\"],\n        \"type\": \"object\"\n      }\n    }\n    ```\n\n    ### Iterating over the tool runner\n\n    The tool runner returned by `tool_runner()` is an iterable, which you can iterate over with a `for` loop. This is often referred to as a \"tool call loop\".\n    Each loop iteration yields a message that was returned by Claude.\n\n    After your code has a chance to process the current message inside the loop, the tool runner will check the message to see if Claude requested a tool use. If so, it will call the tool and send the tool result back to Claude automatically, then yield the next message from Claude to start the next iteration of your loop.\n\n    You may end the loop at any iteration with a simple `break` statement. The tool runner will loop until Claude returns a message without a tool use.\n\n    If you don't care about intermediate messages, instead of using a loop, you can call the `until_done()` method, which will return the final message from Claude:\n\n    ```python  theme={null}\n    runner = client.beta.messages.tool_runner(\n        model=\"claude-sonnet-4-5\",\n        max_tokens=1024,\n        tools=[get_weather, calculate_sum],\n        messages=[\n            {\"role\": \"user\", \"content\": \"What's the weather like in Paris? Also, what's 15 + 27?\"}\n        ]\n    )\n    final_message = runner.until_done()\n    print(final_message.content[0].text)\n    ```\n\n    ### Advanced usage\n\n    Within the loop, you have the ability to fully customize the tool runner's next request to the Messages API.\n    The method `runner.generate_tool_call_response()` will call the tool (if Claude triggered a tool use) and give you access to the tool result that will be sent back to the Messages API.\n    The methods `runner.set_messages_params()` and `runner.append_messages()` allow you to modify the parameters for the next Messages API request.\n\n    ```python  theme={null}\n    runner = client.beta.messages.tool_runner(\n        model=\"claude-sonnet-4-5\",\n        max_tokens=1024,\n        tools=[get_weather],\n        messages=[{\"role\": \"user\", \"content\": \"What's the weather in San Francisco?\"}]\n    )\n    for message in runner:\n        # Get the tool response that will be sent\n        tool_response = runner.generate_tool_call_response()\n\n        # Customize the next request\n        runner.set_messages_params(lambda params: {\n            **params,\n            \"max_tokens\": 2048  # Increase tokens for next request\n        })\n\n        # Or add additional messages\n        runner.append_messages(\n            {\"role\": \"user\", \"content\": \"Please be concise in your response.\"}\n        )\n    ```\n\n    ### Streaming\n\n    When enabling streaming with `stream=True`, each value emitted by the tool runner is a `BetaMessageStream` as returned from `anthropic.messages.stream()`. The `BetaMessageStream` is itself an iterable that yields streaming events from the Messages API.\n\n    You can use `message_stream.get_final_message()` to let the SDK do the accumulation of streaming events into the final message for you.\n\n    ```python  theme={null}\n    runner = client.beta.messages.tool_runner(\n        model=\"claude-sonnet-4-5\",\n        max_tokens=1024,\n        tools=[calculate_sum],\n        messages=[{\"role\": \"user\", \"content\": \"What is 15 + 27?\"}],\n        stream=True\n    )\n\n    # When streaming, the runner returns BetaMessageStream\n    for message_stream in runner:\n        for event in message_stream:\n            print('event:', event)\n        print('message:', message_stream.get_final_message())\n\n    print(runner.until_done())\n    ```\n  </Tab>\n\n  <Tab title=\"TypeScript (Zod)\">\n    ### Basic usage\n\n    Use `betaZodTool()` for type-safe tool definitions with Zod validation (requires Zod 3.25.0 or higher).\n\n    ```typescript  theme={null}\n    import { Anthropic } from '@anthropic-ai/sdk';\n    import { betaZodTool, betaTool } from '@anthropic-ai/sdk/helpers/beta/zod';\n    import { z } from 'zod';\n\n    const anthropic = new Anthropic();\n\n    // Using betaZodTool (requires Zod 3.25.0+)\n    const getWeatherTool = betaZodTool({\n      name: 'get_weather',\n      description: 'Get the current weather in a given location',\n      inputSchema: z.object({\n        location: z.string().describe('The city and state, e.g. San Francisco, CA'),\n        unit: z.enum(['celsius', 'fahrenheit']).default('fahrenheit')\n          .describe('Temperature unit')\n      }),\n      run: async (input) => {\n        // In a full implementation, you'd call a weather API here\n        return JSON.stringify({temperature: '20°C', condition: 'Sunny'});\n      }\n    });\n\n    // Use the tool runner\n    const runner = anthropic.beta.messages.toolRunner({\n      model: 'claude-sonnet-4-5',\n      max_tokens: 1024,\n      tools: [getWeatherTool],\n      messages: [\n        {\n          role: 'user',\n          content: \"What's the weather like in Paris?\"\n        }\n      ]\n    });\n\n    // Process messages as they come in\n    for await (const message of runner) {\n      console.log(message.content[0].text);\n    }\n    ```\n\n    The `run` function must return a content block or content block array, including text, images, or document blocks. This allows tools to return rich, multimodal responses. Returned strings will be converted to a text content block.\n    If you want to return a structured JSON object to Claude, stringify it to a JSON string before returning it. Numbers, booleans or other non-string primitives also must be converted to strings.\n\n    ### Iterating over the tool runner\n\n    The tool runner returned by `toolRunner()` is an async iterable, which you can iterate over with a `for await ... of` loop. This is often referred to as a \"tool call loop\".\n    Each loop iteration yields a messages that was returned by Claude.\n\n    After your code had a chance to process the current message inside the loop, the tool runner will check the message to see if Claude requested a tool use. If so, it will call the tool and send the tool result back to Claude automatically, then yield the next message from Claude to start the next iteration of your loop.\n\n    You may end the loop at any iteration with a simple `break` statement. The tool runner will loop until Claude returns a message without a tool use.\n\n    If you don't care about intermediate messages, instead of using a loop, you may simply `await` the tool runner, which will return the final message from Claude.\n\n    ### Advanced usage\n\n    Within the loop, you have the ability to fully customize the tool runner's next request to the Messages API.\n    The method `runner.generateToolResponse()` will call the tool (if Claude triggered a tool use) and give you access to the tool result that will be sent back to the Messages API.\n    The methods `runner.setMessagesParams()` and `runner.pushMessages()` allow you to modify the parameters for the next Messages API request. The current parameters are available under `runner.params`.\n\n    ```typescript  theme={null}\n    const runner = anthropic.beta.messages.toolRunner({\n      model: 'claude-sonnet-4-5',\n      max_tokens: 1024,\n      tools: [getWeatherTool],\n      messages: [\n        { role: 'user', content: \"What's the weather in San Francisco?\" }\n      ]\n    });\n\n    for await (const message of runner) {\n      // Get the tool response that will be sent\n      const toolResponse = await runner.generateToolResponse();\n\n      // Customize the next request\n      runner.setMessagesParams(params => ({\n        ...params,\n        max_tokens: 2048  // Increase tokens for next request\n      }));\n\n      // Or add additional messages\n      runner.pushMessages(\n        { role: 'user', content: 'Please be concise in your response.' }\n      );\n    }\n    ```\n\n    ### Streaming\n\n    When enabling streaming with `stream: true`, each value emitted by the tool runner is a `MessageStream` as returned from `anthropic.messages.stream()`. The `MessageStream` is itself an async iterable that yields streaming events from the Messages API.\n\n    You can use `messageStream.finalMessage()` to let the SDK do the accumulation of streaming events into the final message for you.\n\n    ```typescript  theme={null}\n    const runner = anthropic.beta.messages.toolRunner({\n      model: 'claude-sonnet-4-5-20250929',\n      max_tokens: 1000,\n      messages: [{ role: 'user', content: 'What is the weather in San Francisco?' }],\n      tools: [calculatorTool],\n      stream: true,\n    });\n\n    // When streaming, the runner returns BetaMessageStream\n    for await (const messageStream of runner) {\n      for await (const event of messageStream) {\n        console.log('event:', event);\n      }\n      console.log('message:', await messageStream.finalMessage());\n    }\n\n    console.log(await runner);\n    ```\n  </Tab>\n\n  <Tab title=\"TypeScript (JSON Schema)\">\n    ### Basic usage\n\n    Use `betaTool()` for type-safe tool definitions based on JSON schemas. TypeScript and your editor will be aware of the type of the `input` parameter for autocompletion.\n\n    <Note>\n      The input generated by Claude will not be validated at runtime. Perform validation inside the `run` function if needed.\n    </Note>\n\n    ```typescript  theme={null}\n    import { Anthropic } from '@anthropic-ai/sdk';\n    import { betaZodTool, betaTool } from '@anthropic-ai/sdk/helpers/beta/json-schema';\n    import { z } from 'zod';\n\n    const anthropic = new Anthropic();\n\n    // Using betaTool with JSON schema (no Zod required)\n    const calculateSumTool = betaTool({\n      name: 'calculate_sum',\n      description: 'Add two numbers together',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          a: { type: 'number', description: 'First number' },\n          b: { type: 'number', description: 'Second number' }\n        },\n        required: ['a', 'b']\n      },\n      run: async (input) => {\n        return String(input.a + input.b);\n      }\n    });\n\n    // Use the tool runner\n    const runner = anthropic.beta.messages.toolRunner({\n      model: 'claude-sonnet-4-5',\n      max_tokens: 1024,\n      tools: [getWeatherTool, calculateSumTool],\n      messages: [\n        {\n          role: 'user',\n          content: \"What's 15 + 27?\"\n        }\n      ]\n    });\n\n    // Process messages as they come in\n    for await (const message of runner) {\n      console.log(message.content[0].text);\n    }\n    ```\n\n    The `run` function must return any content block or content block array, including text, image, or document blocks. This allows tools to return rich, multimodal responses. Returned strings will be converted to a text content block.\n    If you want to return a structured JSON object to Claude, encode it to a JSON string before returning it. Numbers, booleans or other non-string primitives also must be converted to strings.\n\n    ### Iterating over the tool runner\n\n    The tool runner returned by `toolRunner()` is an async iterable, which you can iterate over with a `for await ... of` loop. This is often referred to as a \"tool call loop\".\n    Each loop iteration yields a messages that was returned by Claude.\n\n    After your code had a chance to process the current message inside the loop, the tool runner will check the message to see if Claude requested a tool use. If so, it will call the tool and send the tool result back to Claude automatically, then yield the next message from Claude to start the next iteration of your loop.\n\n    You may end the loop at any iteration with a simple `break` statement. The tool runner will loop until Claude returns a message without a tool use.\n\n    If you don't care about intermediate messages, instead of using a loop, you may simply `await` the tool runner, which will return the final message from Claude.\n\n    ### Advanced usage\n\n    Within the loop, you have the ability to fully customize the tool runner's next request to the Messages API.\n    The method `runner.generateToolResponse()` will call the tool (if Claude triggered a tool use) and give you access to the tool result that will be sent back to the Messages API.\n    The methods `runner.setMessagesParams()` and `runner.pushMessages()` allow you to modify the parameters for the next Messages API request. The current parameters are available under `runner.params`.\n\n    ```typescript  theme={null}\n    const runner = anthropic.beta.messages.toolRunner({\n      model: 'claude-sonnet-4-5',\n      max_tokens: 1024,\n      tools: [getWeatherTool],\n      messages: [\n        { role: 'user', content: \"What's the weather in San Francisco?\" }\n      ]\n    });\n\n    for await (const message of runner) {\n      // Get the tool response that will be sent\n      const toolResponse = await runner.generateToolResponse();\n\n      // Customize the next request\n      runner.setMessagesParams(params => ({\n        ...params,\n        max_tokens: 2048  // Increase tokens for next request\n      }));\n\n      // Or add additional messages\n      runner.pushMessages(\n        { role: 'user', content: 'Please be concise in your response.' }\n      );\n    }\n    ```\n\n    ### Streaming\n\n    When enabling streaming with `stream: true`, each value emitted by the tool runner is a `MessageStream` as returned from `anthropic.messages.stream()`. The `MessageStream` is itself an async iterable that yields streaming events from the Messages API.\n\n    You can use `messageStream.finalMessage()` to let the SDK do the accumulation of streaming events into the final message for you.\n\n    ```typescript  theme={null}\n    const runner = anthropic.beta.messages.toolRunner({\n      model: 'claude-sonnet-4-5-20250929',\n      max_tokens: 1000,\n      messages: [{ role: 'user', content: 'What is the weather in San Francisco?' }],\n      tools: [calculatorTool],\n      stream: true,\n    });\n\n    // When streaming, the runner returns BetaMessageStream\n    for await (const messageStream of runner) {\n      for await (const event of messageStream) {\n        console.log('event:', event);\n      }\n      console.log('message:', await messageStream.finalMessage());\n    }\n\n    console.log(await runner);\n    ```\n  </Tab>\n</Tabs>\n\n<Note>\n  The SDK tool runner is in beta. The rest of this document covers manual tool implementation.\n</Note>\n\n## Controlling Claude's output\n\n### Forcing tool use\n\nIn some cases, you may want Claude to use a specific tool to answer the user's question, even if Claude thinks it can provide an answer without using a tool. You can do this by specifying the tool in the `tool_choice` field like so:\n\n```\ntool_choice = {\"type\": \"tool\", \"name\": \"get_weather\"}\n```\n\nWhen working with the tool\\_choice parameter, we have four possible options:\n\n* `auto` allows Claude to decide whether to call any provided tools or not. This is the default value when `tools` are provided.\n* `any` tells Claude that it must use one of the provided tools, but doesn't force a particular tool.\n* `tool` allows us to force Claude to always use a particular tool.\n* `none` prevents Claude from using any tools. This is the default value when no `tools` are provided.\n\n<Note>\n  When using [prompt caching](/en/docs/build-with-claude/prompt-caching#what-invalidates-the-cache), changes to the `tool_choice` parameter will invalidate cached message blocks. Tool definitions and system prompts remain cached, but message content must be reprocessed.\n</Note>\n\nThis diagram illustrates how each option works:\n\n<Frame>\n  <img src=\"https://mintcdn.com/anthropic-claude-docs/LF5WV0SNF6oudpT5/images/tool_choice.png?fit=max&auto=format&n=LF5WV0SNF6oudpT5&q=85&s=fb88b9fa0da23fc231e4fece253f4406\" data-og-width=\"1920\" width=\"1920\" data-og-height=\"1080\" height=\"1080\" data-path=\"images/tool_choice.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/anthropic-claude-docs/LF5WV0SNF6oudpT5/images/tool_choice.png?w=280&fit=max&auto=format&n=LF5WV0SNF6oudpT5&q=85&s=11a4cfd7ab7815ea14c21e0948d060d4 280w, https://mintcdn.com/anthropic-claude-docs/LF5WV0SNF6oudpT5/images/tool_choice.png?w=560&fit=max&auto=format&n=LF5WV0SNF6oudpT5&q=85&s=c889c279adce34f1fa479bc722b3fe6f 560w, https://mintcdn.com/anthropic-claude-docs/LF5WV0SNF6oudpT5/images/tool_choice.png?w=840&fit=max&auto=format&n=LF5WV0SNF6oudpT5&q=85&s=e16651305d256ded74250f1c0dadb622 840w, https://mintcdn.com/anthropic-claude-docs/LF5WV0SNF6oudpT5/images/tool_choice.png?w=1100&fit=max&auto=format&n=LF5WV0SNF6oudpT5&q=85&s=a99b0dd3b603051efdf9536ba9307a34 1100w, https://mintcdn.com/anthropic-claude-docs/LF5WV0SNF6oudpT5/images/tool_choice.png?w=1650&fit=max&auto=format&n=LF5WV0SNF6oudpT5&q=85&s=5045888f298f7261d3ae2e1466e54027 1650w, https://mintcdn.com/anthropic-claude-docs/LF5WV0SNF6oudpT5/images/tool_choice.png?w=2500&fit=max&auto=format&n=LF5WV0SNF6oudpT5&q=85&s=8a9c615a15610a949a2dad3aaa8113b8 2500w\" />\n</Frame>\n\nNote that when you have `tool_choice` as `any` or `tool`, we will prefill the assistant message to force a tool to be used. This means that the models will not emit a natural language response or explanation before `tool_use` content blocks, even if explicitly asked to do so.\n\n<Note>\n  When using [extended thinking](/en/docs/build-with-claude/extended-thinking) with tool use, `tool_choice: {\"type\": \"any\"}` and `tool_choice: {\"type\": \"tool\", \"name\": \"...\"}` are not supported and will result in an error. Only `tool_choice: {\"type\": \"auto\"}` (the default) and `tool_choice: {\"type\": \"none\"}` are compatible with extended thinking.\n</Note>\n\nOur testing has shown that this should not reduce performance. If you would like the model to provide natural language context or explanations while still requesting that the model use a specific tool, you can use `{\"type\": \"auto\"}` for `tool_choice` (the default) and add explicit instructions in a `user` message. For example: `What's the weather like in London? Use the get_weather tool in your response.`\n\n<Tip>\n  **Guaranteed tool calls with strict tools**\n\n  Combine `tool_choice: {\"type\": \"any\"}` with [strict tool use](/en/docs/build-with-claude/structured-outputs) to guarantee both that one of your tools will be called AND that the tool inputs strictly follow your schema. Set `strict: true` on your tool definitions to enable schema validation.\n</Tip>\n\n### JSON output\n\nTools do not necessarily need to be client functions — you can use tools anytime you want the model to return JSON output that follows a provided schema. For example, you might use a `record_summary` tool with a particular schema. See [Tool use with Claude](/en/docs/agents-and-tools/tool-use/overview) for a full working example.\n\n### Model responses with tools\n\nWhen using tools, Claude will often comment on what it's doing or respond naturally to the user before invoking tools.\n\nFor example, given the prompt \"What's the weather like in San Francisco right now, and what time is it there?\", Claude might respond with:\n\n```JSON JSON theme={null}\n{\n  \"role\": \"assistant\",\n  \"content\": [\n    {\n      \"type\": \"text\",\n      \"text\": \"I'll help you check the current weather and time in San Francisco.\"\n    },\n    {\n      \"type\": \"tool_use\",\n      \"id\": \"toolu_01A09q90qw90lq917835lq9\",\n      \"name\": \"get_weather\",\n      \"input\": {\"location\": \"San Francisco, CA\"}\n    }\n  ]\n}\n```\n\nThis natural response style helps users understand what Claude is doing and creates a more conversational interaction. You can guide the style and content of these responses through your system prompts and by providing `<examples>` in your prompts.\n\nIt's important to note that Claude may use various phrasings and approaches when explaining its actions. Your code should treat these responses like any other assistant-generated text, and not rely on specific formatting conventions.\n\n### Parallel tool use\n\nBy default, Claude may use multiple tools to answer a user query. You can disable this behavior by:\n\n* Setting `disable_parallel_tool_use=true` when tool\\_choice type is `auto`, which ensures that Claude uses **at most one** tool\n* Setting `disable_parallel_tool_use=true` when tool\\_choice type is `any` or `tool`, which ensures that Claude uses **exactly one** tool\n\n<AccordionGroup>\n  <Accordion title=\"Complete parallel tool use example\">\n    <Note>\n      **Simpler with Tool runner**: The example below shows manual parallel tool handling. For most use cases, [tool runner](#tool-runner-beta) automatically handle parallel tool execution with much less code.\n    </Note>\n\n    Here's a complete example showing how to properly format parallel tool calls in the message history:\n\n    <CodeGroup>\n      ```python Python theme={null}\n      import anthropic\n\n      client = anthropic.Anthropic()\n\n      # Define tools\n      tools = [\n          {\n              \"name\": \"get_weather\",\n              \"description\": \"Get the current weather in a given location\",\n              \"input_schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                      \"location\": {\n                          \"type\": \"string\",\n                          \"description\": \"The city and state, e.g. San Francisco, CA\"\n                      }\n                  },\n                  \"required\": [\"location\"]\n              }\n          },\n          {\n              \"name\": \"get_time\",\n              \"description\": \"Get the current time in a given timezone\",\n              \"input_schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                      \"timezone\": {\n                          \"type\": \"string\",\n                          \"description\": \"The timezone, e.g. America/New_York\"\n                      }\n                  },\n                  \"required\": [\"timezone\"]\n              }\n          }\n      ]\n\n      # Initial request\n      response = client.messages.create(\n          model=\"claude-sonnet-4-5\",\n          max_tokens=1024,\n          tools=tools,\n          messages=[\n              {\n                  \"role\": \"user\",\n                  \"content\": \"What's the weather in SF and NYC, and what time is it there?\"\n              }\n          ]\n      )\n\n      # Claude's response with parallel tool calls\n      print(\"Claude wants to use tools:\", response.stop_reason == \"tool_use\")\n      print(\"Number of tool calls:\", len([c for c in response.content if c.type == \"tool_use\"]))\n\n      # Build the conversation with tool results\n      messages = [\n          {\n              \"role\": \"user\",\n              \"content\": \"What's the weather in SF and NYC, and what time is it there?\"\n          },\n          {\n              \"role\": \"assistant\",\n              \"content\": response.content  # Contains multiple tool_use blocks\n          },\n          {\n              \"role\": \"user\",\n              \"content\": [\n                  {\n                      \"type\": \"tool_result\",\n                      \"tool_use_id\": \"toolu_01\",  # Must match the ID from tool_use\n                      \"content\": \"San Francisco: 68°F, partly cloudy\"\n                  },\n                  {\n                      \"type\": \"tool_result\",\n                      \"tool_use_id\": \"toolu_02\",\n                      \"content\": \"New York: 45°F, clear skies\"\n                  },\n                  {\n                      \"type\": \"tool_result\",\n                      \"tool_use_id\": \"toolu_03\",\n                      \"content\": \"San Francisco time: 2:30 PM PST\"\n                  },\n                  {\n                      \"type\": \"tool_result\",\n                      \"tool_use_id\": \"toolu_04\",\n                      \"content\": \"New York time: 5:30 PM EST\"\n                  }\n              ]\n          }\n      ]\n\n      # Get final response\n      final_response = client.messages.create(\n          model=\"claude-sonnet-4-5\",\n          max_tokens=1024,\n          tools=tools,\n          messages=messages\n      )\n\n      print(final_response.content[0].text)\n      ```\n\n      ```typescript TypeScript theme={null}\n      import { Anthropic } from '@anthropic-ai/sdk';\n\n      const anthropic = new Anthropic();\n\n      // Define tools\n      const tools = [\n        {\n          name: \"get_weather\",\n          description: \"Get the current weather in a given location\",\n          input_schema: {\n            type: \"object\",\n            properties: {\n              location: {\n                type: \"string\",\n                description: \"The city and state, e.g. San Francisco, CA\"\n              }\n            },\n            required: [\"location\"]\n          }\n        },\n        {\n          name: \"get_time\",\n          description: \"Get the current time in a given timezone\",\n          input_schema: {\n            type: \"object\",\n            properties: {\n              timezone: {\n                type: \"string\",\n                description: \"The timezone, e.g. America/New_York\"\n              }\n            },\n            required: [\"timezone\"]\n          }\n        }\n      ];\n\n      // Initial request\n      const response = await anthropic.messages.create({\n        model: \"claude-sonnet-4-5\",\n        max_tokens: 1024,\n        tools: tools,\n        messages: [\n          {\n            role: \"user\",\n            content: \"What's the weather in SF and NYC, and what time is it there?\"\n          }\n        ]\n      });\n\n      // Build conversation with tool results\n      const messages = [\n        {\n          role: \"user\",\n          content: \"What's the weather in SF and NYC, and what time is it there?\"\n        },\n        {\n          role: \"assistant\",\n          content: response.content  // Contains multiple tool_use blocks\n        },\n        {\n          role: \"user\",\n          content: [\n            {\n              type: \"tool_result\",\n              tool_use_id: \"toolu_01\",  // Must match the ID from tool_use\n              content: \"San Francisco: 68°F, partly cloudy\"\n            },\n            {\n              type: \"tool_result\",\n              tool_use_id: \"toolu_02\",\n              content: \"New York: 45°F, clear skies\"\n            },\n            {\n              type: \"tool_result\",\n              tool_use_id: \"toolu_03\",\n              content: \"San Francisco time: 2:30 PM PST\"\n            },\n            {\n              type: \"tool_result\",\n              tool_use_id: \"toolu_04\",\n              content: \"New York time: 5:30 PM EST\"\n            }\n          ]\n        }\n      ];\n\n      // Get final response\n      const finalResponse = await anthropic.messages.create({\n        model: \"claude-sonnet-4-5\",\n        max_tokens: 1024,\n        tools: tools,\n        messages: messages\n      });\n\n      console.log(finalResponse.content[0].text);\n      ```\n    </CodeGroup>\n\n    The assistant message with parallel tool calls would look like this:\n\n    ```json  theme={null}\n    {\n      \"role\": \"assistant\",\n      \"content\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"I'll check the weather and time for both San Francisco and New York City.\"\n        },\n        {\n          \"type\": \"tool_use\",\n          \"id\": \"toolu_01\",\n          \"name\": \"get_weather\",\n          \"input\": {\"location\": \"San Francisco, CA\"}\n        },\n        {\n          \"type\": \"tool_use\",\n          \"id\": \"toolu_02\",\n          \"name\": \"get_weather\",\n          \"input\": {\"location\": \"New York, NY\"}\n        },\n        {\n          \"type\": \"tool_use\",\n          \"id\": \"toolu_03\",\n          \"name\": \"get_time\",\n          \"input\": {\"timezone\": \"America/Los_Angeles\"}\n        },\n        {\n          \"type\": \"tool_use\",\n          \"id\": \"toolu_04\",\n          \"name\": \"get_time\",\n          \"input\": {\"timezone\": \"America/New_York\"}\n        }\n      ]\n    }\n    ```\n  </Accordion>\n\n  <Accordion title=\"Complete test script for parallel tools\">\n    Here's a complete, runnable script to test and verify parallel tool calls are working correctly:\n\n    <CodeGroup>\n      ```python Python theme={null}\n      #!/usr/bin/env python3\n      \"\"\"Test script to verify parallel tool calls with the Claude API\"\"\"\n\n      import os\n      from anthropic import Anthropic\n\n      # Initialize client\n      client = Anthropic(api_key=os.environ.get(\"ANTHROPIC_API_KEY\"))\n\n      # Define tools\n      tools = [\n          {\n              \"name\": \"get_weather\",\n              \"description\": \"Get the current weather in a given location\",\n              \"input_schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                      \"location\": {\n                          \"type\": \"string\",\n                          \"description\": \"The city and state, e.g. San Francisco, CA\"\n                      }\n                  },\n                  \"required\": [\"location\"]\n              }\n          },\n          {\n              \"name\": \"get_time\",\n              \"description\": \"Get the current time in a given timezone\",\n              \"input_schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                      \"timezone\": {\n                          \"type\": \"string\",\n                          \"description\": \"The timezone, e.g. America/New_York\"\n                      }\n                  },\n                  \"required\": [\"timezone\"]\n              }\n          }\n      ]\n\n      # Test conversation with parallel tool calls\n      messages = [\n          {\n              \"role\": \"user\",\n              \"content\": \"What's the weather in SF and NYC, and what time is it there?\"\n          }\n      ]\n\n      # Make initial request\n      print(\"Requesting parallel tool calls...\")\n      response = client.messages.create(\n          model=\"claude-sonnet-4-5\",\n          max_tokens=1024,\n          messages=messages,\n          tools=tools\n      )\n\n      # Check for parallel tool calls\n      tool_uses = [block for block in response.content if block.type == \"tool_use\"]\n      print(f\"\\n✓ Claude made {len(tool_uses)} tool calls\")\n\n      if len(tool_uses) > 1:\n          print(\"✓ Parallel tool calls detected!\")\n          for tool in tool_uses:\n              print(f\"  - {tool.name}: {tool.input}\")\n      else:\n          print(\"✗ No parallel tool calls detected\")\n\n      # Simulate tool execution and format results correctly\n      tool_results = []\n      for tool_use in tool_uses:\n          if tool_use.name == \"get_weather\":\n              if \"San Francisco\" in str(tool_use.input):\n                  result = \"San Francisco: 68°F, partly cloudy\"\n              else:\n                  result = \"New York: 45°F, clear skies\"\n          else:  # get_time\n              if \"Los_Angeles\" in str(tool_use.input):\n                  result = \"2:30 PM PST\"\n              else:\n                  result = \"5:30 PM EST\"\n\n          tool_results.append({\n              \"type\": \"tool_result\",\n              \"tool_use_id\": tool_use.id,\n              \"content\": result\n          })\n\n      # Continue conversation with tool results\n      messages.extend([\n          {\"role\": \"assistant\", \"content\": response.content},\n          {\"role\": \"user\", \"content\": tool_results}  # All results in one message!\n      ])\n\n      # Get final response\n      print(\"\\nGetting final response...\")\n      final_response = client.messages.create(\n          model=\"claude-sonnet-4-5\",\n          max_tokens=1024,\n          messages=messages,\n          tools=tools\n      )\n\n      print(f\"\\nClaude's response:\\n{final_response.content[0].text}\")\n\n      # Verify formatting\n      print(\"\\n--- Verification ---\")\n      print(f\"✓ Tool results sent in single user message: {len(tool_results)} results\")\n      print(\"✓ No text before tool results in content array\")\n      print(\"✓ Conversation formatted correctly for future parallel tool use\")\n      ```\n\n      ```typescript TypeScript theme={null}\n      #!/usr/bin/env node\n      // Test script to verify parallel tool calls with the Claude API\n\n      import { Anthropic } from '@anthropic-ai/sdk';\n\n      const anthropic = new Anthropic({\n        apiKey: process.env.ANTHROPIC_API_KEY\n      });\n\n      // Define tools\n      const tools = [\n        {\n          name: \"get_weather\",\n          description: \"Get the current weather in a given location\",\n          input_schema: {\n            type: \"object\",\n            properties: {\n              location: {\n                type: \"string\",\n                description: \"The city and state, e.g. San Francisco, CA\"\n              }\n            },\n            required: [\"location\"]\n          }\n        },\n        {\n          name: \"get_time\",\n          description: \"Get the current time in a given timezone\",\n          input_schema: {\n            type: \"object\",\n            properties: {\n              timezone: {\n                type: \"string\",\n                description: \"The timezone, e.g. America/New_York\"\n              }\n            },\n            required: [\"timezone\"]\n          }\n        }\n      ];\n\n      async function testParallelTools() {\n        // Make initial request\n        console.log(\"Requesting parallel tool calls...\");\n        const response = await anthropic.messages.create({\n          model: \"claude-sonnet-4-5\",\n          max_tokens: 1024,\n          messages: [{\n            role: \"user\",\n            content: \"What's the weather in SF and NYC, and what time is it there?\"\n          }],\n          tools: tools\n        });\n\n        // Check for parallel tool calls\n        const toolUses = response.content.filter(block => block.type === \"tool_use\");\n        console.log(`\\n✓ Claude made ${toolUses.length} tool calls`);\n\n        if (toolUses.length > 1) {\n          console.log(\"✓ Parallel tool calls detected!\");\n          toolUses.forEach(tool => {\n            console.log(`  - ${tool.name}: ${JSON.stringify(tool.input)}`);\n          });\n        } else {\n          console.log(\"✗ No parallel tool calls detected\");\n        }\n\n        // Simulate tool execution and format results correctly\n        const toolResults = toolUses.map(toolUse => {\n          let result;\n          if (toolUse.name === \"get_weather\") {\n            result = toolUse.input.location.includes(\"San Francisco\")\n              ? \"San Francisco: 68°F, partly cloudy\"\n              : \"New York: 45°F, clear skies\";\n          } else {\n            result = toolUse.input.timezone.includes(\"Los_Angeles\")\n              ? \"2:30 PM PST\"\n              : \"5:30 PM EST\";\n          }\n\n          return {\n            type: \"tool_result\",\n            tool_use_id: toolUse.id,\n            content: result\n          };\n        });\n\n        // Get final response with correct formatting\n        console.log(\"\\nGetting final response...\");\n        const finalResponse = await anthropic.messages.create({\n          model: \"claude-sonnet-4-5\",\n          max_tokens: 1024,\n          messages: [\n            { role: \"user\", content: \"What's the weather in SF and NYC, and what time is it there?\" },\n            { role: \"assistant\", content: response.content },\n            { role: \"user\", content: toolResults }  // All results in one message!\n          ],\n          tools: tools\n        });\n\n        console.log(`\\nClaude's response:\\n${finalResponse.content[0].text}`);\n\n        // Verify formatting\n        console.log(\"\\n--- Verification ---\");\n        console.log(`✓ Tool results sent in single user message: ${toolResults.length} results`);\n        console.log(\"✓ No text before tool results in content array\");\n        console.log(\"✓ Conversation formatted correctly for future parallel tool use\");\n      }\n\n      testParallelTools().catch(console.error);\n      ```\n    </CodeGroup>\n\n    This script demonstrates:\n\n    * How to properly format parallel tool calls and results\n    * How to verify that parallel calls are being made\n    * The correct message structure that encourages future parallel tool use\n    * Common mistakes to avoid (like text before tool results)\n\n    Run this script to test your implementation and ensure Claude is making parallel tool calls effectively.\n  </Accordion>\n</AccordionGroup>\n\n#### Maximizing parallel tool use\n\nWhile Claude 4 models have excellent parallel tool use capabilities by default, you can increase the likelihood of parallel tool execution across all models with targeted prompting:\n\n<AccordionGroup>\n  <Accordion title=\"System prompts for parallel tool use\">\n    For Claude 4 models (Opus 4.1, Opus 4, and Sonnet 4), add this to your system prompt:\n\n    ```text  theme={null}\n    For maximum efficiency, whenever you need to perform multiple independent operations, invoke all relevant tools simultaneously rather than sequentially.\n    ```\n\n    For even stronger parallel tool use (recommended if the default isn't sufficient), use:\n\n    ```text  theme={null}\n    <use_parallel_tool_calls>\n    For maximum efficiency, whenever you perform multiple independent operations, invoke all relevant tools simultaneously rather than sequentially. Prioritize calling tools in parallel whenever possible. For example, when reading 3 files, run 3 tool calls in parallel to read all 3 files into context at the same time. When running multiple read-only commands like `ls` or `list_dir`, always run all of the commands in parallel. Err on the side of maximizing parallel tool calls rather than running too many tools sequentially.\n    </use_parallel_tool_calls>\n    ```\n  </Accordion>\n\n  <Accordion title=\"User message prompting\">\n    You can also encourage parallel tool use within specific user messages:\n\n    ```python  theme={null}\n    # Instead of:\n    \"What's the weather in Paris? Also check London.\"\n\n    # Use:\n    \"Check the weather in Paris and London simultaneously.\"\n\n    # Or be explicit:\n    \"Please use parallel tool calls to get the weather for Paris, London, and Tokyo at the same time.\"\n    ```\n  </Accordion>\n</AccordionGroup>\n\n<Warning>\n  **Parallel tool use with Claude Sonnet 3.7**\n\n  Claude Sonnet 3.7 may be less likely to make make parallel tool calls in a response, even when you have not set `disable_parallel_tool_use`. To work around this, we recommend enabling [token-efficient tool use](/en/docs/agents-and-tools/tool-use/token-efficient-tool-use), which helps encourage Claude to use parallel tools. This beta feature also reduces latency and saves an average of 14% in output tokens.\n\n  If you prefer not to opt into the token-efficient tool use beta, you can also introduce a \"batch tool\" that can act as a meta-tool to wrap invocations to other tools simultaneously. We find that if this tool is present, the model will use it to simultaneously call multiple tools in parallel for you.\n\n  See [this example](https://github.com/anthropics/anthropic-cookbook/blob/main/tool_use/parallel_tools_claude_3_7_sonnet.ipynb) in our cookbook for how to use this workaround.\n</Warning>\n\n## Handling tool use and tool result content blocks\n\n<Note>\n  **Simpler with Tool runner**: The manual tool handling described in this section is automatically managed by [tool runner](#tool-runner-beta). Use this section when you need custom control over tool execution.\n</Note>\n\nClaude's response differs based on whether it uses a client or server tool.\n\n### Handling results from client tools\n\nThe response will have a `stop_reason` of `tool_use` and one or more `tool_use` content blocks that include:\n\n* `id`: A unique identifier for this particular tool use block. This will be used to match up the tool results later.\n* `name`: The name of the tool being used.\n* `input`: An object containing the input being passed to the tool, conforming to the tool's `input_schema`.\n\n<Accordion title=\"Example API response with a `tool_use` content block\">\n  ```JSON JSON theme={null}\n  {\n    \"id\": \"msg_01Aq9w938a90dw8q\",\n    \"model\": \"claude-sonnet-4-5\",\n    \"stop_reason\": \"tool_use\",\n    \"role\": \"assistant\",\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"I'll check the current weather in San Francisco for you.\"\n      },\n      {\n        \"type\": \"tool_use\",\n        \"id\": \"toolu_01A09q90qw90lq917835lq9\",\n        \"name\": \"get_weather\",\n        \"input\": {\"location\": \"San Francisco, CA\", \"unit\": \"celsius\"}\n      }\n    ]\n  }\n  ```\n</Accordion>\n\nWhen you receive a tool use response for a client tool, you should:\n\n1. Extract the `name`, `id`, and `input` from the `tool_use` block.\n2. Run the actual tool in your codebase corresponding to that tool name, passing in the tool `input`.\n3. Continue the conversation by sending a new message with the `role` of `user`, and a `content` block containing the `tool_result` type and the following information:\n   * `tool_use_id`: The `id` of the tool use request this is a result for.\n   * `content`: The result of the tool, as a string (e.g. `\"content\": \"15 degrees\"`), a list of nested content blocks (e.g. `\"content\": [{\"type\": \"text\", \"text\": \"15 degrees\"}]`), or a list of document blocks (e.g. `\"content\": [\"type\": \"document\", \"source\": {\"type\": \"text\", \"media_type\": \"text/plain\", \"data\": \"15 degrees\"}]`). These content blocks can use the `text`, `image`, or `document` types.\n   * `is_error` (optional): Set to `true` if the tool execution resulted in an error.\n\n<Note>\n  **Important formatting requirements**:\n\n  * Tool result blocks must immediately follow their corresponding tool use blocks in the message history. You cannot include any messages between the assistant's tool use message and the user's tool result message.\n  * In the user message containing tool results, the tool\\_result blocks must come FIRST in the content array. Any text must come AFTER all tool results.\n\n  For example, this will cause a 400 error:\n\n  ```json  theme={null}\n  {\"role\": \"user\", \"content\": [\n    {\"type\": \"text\", \"text\": \"Here are the results:\"},  // ❌ Text before tool_result\n    {\"type\": \"tool_result\", \"tool_use_id\": \"toolu_01\", ...}\n  ]}\n  ```\n\n  This is correct:\n\n  ```json  theme={null}\n  {\"role\": \"user\", \"content\": [\n    {\"type\": \"tool_result\", \"tool_use_id\": \"toolu_01\", ...},\n    {\"type\": \"text\", \"text\": \"What should I do next?\"}  // ✅ Text after tool_result\n  ]}\n  ```\n\n  If you receive an error like \"tool\\_use ids were found without tool\\_result blocks immediately after\", check that your tool results are formatted correctly.\n</Note>\n\n<AccordionGroup>\n  <Accordion title=\"Example of successful tool result\">\n    ```JSON JSON theme={null}\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"tool_result\",\n          \"tool_use_id\": \"toolu_01A09q90qw90lq917835lq9\",\n          \"content\": \"15 degrees\"\n        }\n      ]\n    }\n    ```\n  </Accordion>\n\n  <Accordion title=\"Example of tool result with images\">\n    ```JSON JSON theme={null}\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"tool_result\",\n          \"tool_use_id\": \"toolu_01A09q90qw90lq917835lq9\",\n          \"content\": [\n            {\"type\": \"text\", \"text\": \"15 degrees\"},\n            {\n              \"type\": \"image\",\n              \"source\": {\n                \"type\": \"base64\",\n                \"media_type\": \"image/jpeg\",\n                \"data\": \"/9j/4AAQSkZJRg...\",\n              }\n            }\n          ]\n        }\n      ]\n    }\n    ```\n  </Accordion>\n\n  <Accordion title=\"Example of empty tool result\">\n    ```JSON JSON theme={null}\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"tool_result\",\n          \"tool_use_id\": \"toolu_01A09q90qw90lq917835lq9\",\n        }\n      ]\n    }\n    ```\n  </Accordion>\n\n  <Accordion title=\"Example of tool result with documents\">\n    ```JSON JSON theme={null}\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"tool_result\",\n          \"tool_use_id\": \"toolu_01A09q90qw90lq917835lq9\",\n          \"content\": [\n            {\"type\": \"text\", \"text\": \"The weather is\"},\n            {\n              \"type\": \"document\",\n              \"source\": {\n                \"type\": \"text\",\n                \"media_type\": \"text/plain\",\n                \"data\": \"15 degrees\"\n              }\n            }\n          ]\n        }\n      ]\n    }\n    ```\n  </Accordion>\n</AccordionGroup>\n\nAfter receiving the tool result, Claude will use that information to continue generating a response to the original user prompt.\n\n### Handling results from server tools\n\nClaude executes the tool internally and incorporates the results directly into its response without requiring additional user interaction.\n\n<Tip>\n  **Differences from other APIs**\n\n  Unlike APIs that separate tool use or use special roles like `tool` or `function`, the Claude API integrates tools directly into the `user` and `assistant` message structure.\n\n  Messages contain arrays of `text`, `image`, `tool_use`, and `tool_result` blocks. `user` messages include client content and `tool_result`, while `assistant` messages contain AI-generated content and `tool_use`.\n</Tip>\n\n### Handling the `max_tokens` stop reason\n\nIf Claude's [response is cut off due to hitting the `max_tokens` limit](/en/docs/build-with-claude/handling-stop-reasons#max-tokens), and the truncated response contains an incomplete tool use block, you'll need to retry the request with a higher `max_tokens` value to get the full tool use.\n\n<CodeGroup>\n  ```python Python theme={null}\n  # Check if response was truncated during tool use\n  if response.stop_reason == \"max_tokens\":\n      # Check if the last content block is an incomplete tool_use\n      last_block = response.content[-1]\n      if last_block.type == \"tool_use\":\n          # Send the request with higher max_tokens\n          response = client.messages.create(\n              model=\"claude-sonnet-4-5\",\n              max_tokens=4096,  # Increased limit\n              messages=messages,\n              tools=tools\n          )\n  ```\n\n  ```typescript TypeScript theme={null}\n  // Check if response was truncated during tool use\n  if (response.stop_reason === \"max_tokens\") {\n    // Check if the last content block is an incomplete tool_use\n    const lastBlock = response.content[response.content.length - 1];\n    if (lastBlock.type === \"tool_use\") {\n      // Send the request with higher max_tokens\n      response = await anthropic.messages.create({\n        model: \"claude-sonnet-4-5\",\n        max_tokens: 4096, // Increased limit\n        messages: messages,\n        tools: tools\n      });\n    }\n  }\n  ```\n</CodeGroup>\n\n#### Handling the `pause_turn` stop reason\n\nWhen using server tools like web search, the API may return a `pause_turn` stop reason, indicating that the API has paused a long-running turn.\n\nHere's how to handle the `pause_turn` stop reason:\n\n<CodeGroup>\n  ```python Python theme={null}\n  import anthropic\n\n  client = anthropic.Anthropic()\n\n  # Initial request with web search\n  response = client.messages.create(\n      model=\"claude-3-7-sonnet-latest\",\n      max_tokens=1024,\n      messages=[\n          {\n              \"role\": \"user\",\n              \"content\": \"Search for comprehensive information about quantum computing breakthroughs in 2025\"\n          }\n      ],\n      tools=[{\n          \"type\": \"web_search_20250305\",\n          \"name\": \"web_search\",\n          \"max_uses\": 10\n      }]\n  )\n\n  # Check if the response has pause_turn stop reason\n  if response.stop_reason == \"pause_turn\":\n      # Continue the conversation with the paused content\n      messages = [\n          {\"role\": \"user\", \"content\": \"Search for comprehensive information about quantum computing breakthroughs in 2025\"},\n          {\"role\": \"assistant\", \"content\": response.content}\n      ]\n\n      # Send the continuation request\n      continuation = client.messages.create(\n          model=\"claude-3-7-sonnet-latest\",\n          max_tokens=1024,\n          messages=messages,\n          tools=[{\n              \"type\": \"web_search_20250305\",\n              \"name\": \"web_search\",\n              \"max_uses\": 10\n          }]\n      )\n\n      print(continuation)\n  else:\n      print(response)\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { Anthropic } from '@anthropic-ai/sdk';\n\n  const anthropic = new Anthropic();\n\n  // Initial request with web search\n  const response = await anthropic.messages.create({\n    model: \"claude-3-7-sonnet-latest\",\n    max_tokens: 1024,\n    messages: [\n      {\n        role: \"user\",\n        content: \"Search for comprehensive information about quantum computing breakthroughs in 2025\"\n      }\n    ],\n    tools: [{\n      type: \"web_search_20250305\",\n      name: \"web_search\",\n      max_uses: 10\n    }]\n  });\n\n  // Check if the response has pause_turn stop reason\n  if (response.stop_reason === \"pause_turn\") {\n    // Continue the conversation with the paused content\n    const messages = [\n      { role: \"user\", content: \"Search for comprehensive information about quantum computing breakthroughs in 2025\" },\n      { role: \"assistant\", content: response.content }\n    ];\n\n    // Send the continuation request\n    const continuation = await anthropic.messages.create({\n      model: \"claude-3-7-sonnet-latest\",\n      max_tokens: 1024,\n      messages: messages,\n      tools: [{\n        type: \"web_search_20250305\",\n        name: \"web_search\",\n        max_uses: 10\n      }]\n    });\n\n    console.log(continuation);\n  } else {\n    console.log(response);\n  }\n  ```\n</CodeGroup>\n\nWhen handling `pause_turn`:\n\n* **Continue the conversation**: Pass the paused response back as-is in a subsequent request to let Claude continue its turn\n* **Modify if needed**: You can optionally modify the content before continuing if you want to interrupt or redirect the conversation\n* **Preserve tool state**: Include the same tools in the continuation request to maintain functionality\n\n## Troubleshooting errors\n\n<Note>\n  **Built-in Error Handling**: [Tool runner](#tool-runner-beta) provide automatic error handling for most common scenarios. This section covers manual error handling for advanced use cases.\n</Note>\n\nThere are a few different types of errors that can occur when using tools with Claude:\n\n<AccordionGroup>\n  <Accordion title=\"Tool execution error\">\n    If the tool itself throws an error during execution (e.g. a network error when fetching weather data), you can return the error message in the `content` along with `\"is_error\": true`:\n\n    ```JSON JSON theme={null}\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"tool_result\",\n          \"tool_use_id\": \"toolu_01A09q90qw90lq917835lq9\",\n          \"content\": \"ConnectionError: the weather service API is not available (HTTP 500)\",\n          \"is_error\": true\n        }\n      ]\n    }\n    ```\n\n    Claude will then incorporate this error into its response to the user, e.g. \"I'm sorry, I was unable to retrieve the current weather because the weather service API is not available. Please try again later.\"\n  </Accordion>\n\n  <Accordion title=\"Invalid tool name\">\n    If Claude's attempted use of a tool is invalid (e.g. missing required parameters), it usually means that the there wasn't enough information for Claude to use the tool correctly. Your best bet during development is to try the request again with more-detailed `description` values in your tool definitions.\n\n    However, you can also continue the conversation forward with a `tool_result` that indicates the error, and Claude will try to use the tool again with the missing information filled in:\n\n    ```JSON JSON theme={null}\n    {\n      \"role\": \"user\",\n      \"content\": [\n        {\n          \"type\": \"tool_result\",\n          \"tool_use_id\": \"toolu_01A09q90qw90lq917835lq9\",\n          \"content\": \"Error: Missing required 'location' parameter\",\n          \"is_error\": true\n        }\n      ]\n    }\n    ```\n\n    If a tool request is invalid or missing parameters, Claude will retry 2-3 times with corrections before apologizing to the user.\n\n    <Tip>\n      To eliminate invalid tool calls entirely, use [strict tool use](/en/docs/build-with-claude/structured-outputs) with `strict: true` on your tool definitions. This guarantees that tool inputs will always match your schema exactly, preventing missing parameters and type mismatches.\n    </Tip>\n  </Accordion>\n\n  <Accordion title=\"<search_quality_reflection> tags\">\n    To prevent Claude from reflecting on search quality with \\<search\\_quality\\_reflection> tags, add \"Do not reflect on the quality of the returned search results in your response\" to your prompt.\n  </Accordion>\n\n  <Accordion title=\"Server tool errors\">\n    When server tools encounter errors (e.g., network issues with Web Search), Claude will transparently handle these errors and attempt to provide an alternative response or explanation to the user. Unlike client tools, you do not need to handle `is_error` results for server tools.\n\n    For web search specifically, possible error codes include:\n\n    * `too_many_requests`: Rate limit exceeded\n    * `invalid_input`: Invalid search query parameter\n    * `max_uses_exceeded`: Maximum web search tool uses exceeded\n    * `query_too_long`: Query exceeds maximum length\n    * `unavailable`: An internal error occurred\n  </Accordion>\n\n  <Accordion title=\"Parallel tool calls not working\">\n    If Claude isn't making parallel tool calls when expected, check these common issues:\n\n    **1. Incorrect tool result formatting**\n\n    The most common issue is formatting tool results incorrectly in the conversation history. This \"teaches\" Claude to avoid parallel calls.\n\n    Specifically for parallel tool use:\n\n    * ❌ **Wrong**: Sending separate user messages for each tool result\n    * ✅ **Correct**: All tool results must be in a single user message\n\n    ```json  theme={null}\n    // ❌ This reduces parallel tool use\n    [\n      {\"role\": \"assistant\", \"content\": [tool_use_1, tool_use_2]},\n      {\"role\": \"user\", \"content\": [tool_result_1]},\n      {\"role\": \"user\", \"content\": [tool_result_2]}  // Separate message\n    ]\n\n    // ✅ This maintains parallel tool use\n    [\n      {\"role\": \"assistant\", \"content\": [tool_use_1, tool_use_2]},\n      {\"role\": \"user\", \"content\": [tool_result_1, tool_result_2]}  // Single message\n    ]\n    ```\n\n    See the [general formatting requirements above](#handling-tool-use-and-tool-result-content-blocks) for other formatting rules.\n\n    **2. Weak prompting**\n\n    Default prompting may not be sufficient. Use stronger language:\n\n    ```text  theme={null}\n    <use_parallel_tool_calls>\n    For maximum efficiency, whenever you perform multiple independent operations,\n    invoke all relevant tools simultaneously rather than sequentially.\n    Prioritize calling tools in parallel whenever possible.\n    </use_parallel_tool_calls>\n    ```\n\n    **3. Measuring parallel tool usage**\n\n    To verify parallel tool calls are working:\n\n    ```python  theme={null}\n    # Calculate average tools per tool-calling message\n    tool_call_messages = [msg for msg in messages if any(\n        block.type == \"tool_use\" for block in msg.content\n    )]\n    total_tool_calls = sum(\n        len([b for b in msg.content if b.type == \"tool_use\"])\n        for msg in tool_call_messages\n    )\n    avg_tools_per_message = total_tool_calls / len(tool_call_messages)\n    print(f\"Average tools per message: {avg_tools_per_message}\")\n    # Should be > 1.0 if parallel calls are working\n    ```\n\n    **4. Model-specific behavior**\n\n    * Claude Opus 4.1, Opus 4, and Sonnet 4: Excel at parallel tool use with minimal prompting\n    * Claude Sonnet 3.7: May need stronger prompting or [token-efficient tool use](/en/docs/agents-and-tools/tool-use/token-efficient-tool-use)\n    * Claude Haiku: Less likely to use parallel tools without explicit prompting\n  </Accordion>\n</AccordionGroup>",
  "content_length": 63934
}