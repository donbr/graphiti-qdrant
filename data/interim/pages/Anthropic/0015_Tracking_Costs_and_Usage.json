{
  "title": "Tracking Costs and Usage",
  "source_url": "https://docs.claude.com/en/docs/agent-sdk/cost-tracking",
  "content": "Understand and track token usage for billing in the Claude Agent SDK\n\n# SDK Cost Tracking\n\nThe Claude Agent SDK provides detailed token usage information for each interaction with Claude. This guide explains how to properly track costs and understand usage reporting, especially when dealing with parallel tool uses and multi-step conversations.\n\nFor complete API documentation, see the [TypeScript SDK reference](/en/docs/agent-sdk/typescript).\n\n## Understanding Token Usage\n\nWhen Claude processes requests, it reports token usage at the message level. This usage data is essential for tracking costs and billing users appropriately.\n\n### Key Concepts\n\n1. **Steps**: A step is a single request/response pair between your application and Claude\n2. **Messages**: Individual messages within a step (text, tool uses, tool results)\n3. **Usage**: Token consumption data attached to assistant messages\n\n## Usage Reporting Structure\n\n### Single vs Parallel Tool Use\n\nWhen Claude executes tools, the usage reporting differs based on whether tools are executed sequentially or in parallel:\n\n<CodeGroup>\n  ```typescript TypeScript theme={null}\n  import { query } from \"@anthropic-ai/claude-agent-sdk\";\n\n  // Example: Tracking usage in a conversation\n  const result = await query({\n    prompt: \"Analyze this codebase and run tests\",\n    options: {\n      onMessage: (message) => {\n        if (message.type === 'assistant' && message.usage) {\n          console.log(`Message ID: ${message.id}`);\n          console.log(`Usage:`, message.usage);\n        }\n      }\n    }\n  });\n  ```\n\n  ```python Python theme={null}\n  from claude_agent_sdk import query, ClaudeAgentOptions, AssistantMessage\n  import asyncio\n\n  # Example: Tracking usage in a conversation\n  async def track_usage():\n      # Process messages as they arrive\n      async for message in query(\n          prompt=\"Analyze this codebase and run tests\"\n      ):\n          if isinstance(message, AssistantMessage) and hasattr(message, 'usage'):\n              print(f\"Message ID: {message.id}\")\n              print(f\"Usage: {message.usage}\")\n\n  asyncio.run(track_usage())\n  ```\n</CodeGroup>\n\n### Message Flow Example\n\nHere's how messages and usage are reported in a typical multi-step conversation:\n\n```\n<!-- Step 1: Initial request with parallel tool uses -->\nassistant (text)      { id: \"msg_1\", usage: { output_tokens: 100, ... } }\nassistant (tool_use)  { id: \"msg_1\", usage: { output_tokens: 100, ... } }\nassistant (tool_use)  { id: \"msg_1\", usage: { output_tokens: 100, ... } }\nassistant (tool_use)  { id: \"msg_1\", usage: { output_tokens: 100, ... } }\nuser (tool_result)\nuser (tool_result)\nuser (tool_result)\n\n<!-- Step 2: Follow-up response -->\nassistant (text)      { id: \"msg_2\", usage: { output_tokens: 98, ... } }\n```\n\n## Important Usage Rules\n\n### 1. Same ID = Same Usage\n\n**All messages with the same `id` field report identical usage**. When Claude sends multiple messages in the same turn (e.g., text + tool uses), they share the same message ID and usage data.\n\n```typescript  theme={null}\n// All these messages have the same ID and usage\nconst messages = [\n  { type: 'assistant', id: 'msg_123', usage: { output_tokens: 100 } },\n  { type: 'assistant', id: 'msg_123', usage: { output_tokens: 100 } },\n  { type: 'assistant', id: 'msg_123', usage: { output_tokens: 100 } }\n];\n\n// Charge only once per unique message ID\nconst uniqueUsage = messages[0].usage; // Same for all messages with this ID\n```\n\n### 2. Charge Once Per Step\n\n**You should only charge users once per step**, not for each individual message. When you see multiple assistant messages with the same ID, use the usage from any one of them.\n\n### 3. Result Message Contains Cumulative Usage\n\nThe final `result` message contains the total cumulative usage from all steps in the conversation:\n\n```typescript  theme={null}\n// Final result includes total usage\nconst result = await query({\n  prompt: \"Multi-step task\",\n  options: { /* ... */ }\n});\n\nconsole.log(\"Total usage:\", result.usage);\nconsole.log(\"Total cost:\", result.usage.total_cost_usd);\n```\n\n## Implementation: Cost Tracking System\n\nHere's a complete example of implementing a cost tracking system:\n\n<CodeGroup>\n  ```typescript TypeScript theme={null}\n  import { query } from \"@anthropic-ai/claude-agent-sdk\";\n\n  class CostTracker {\n    private processedMessageIds = new Set<string>();\n    private stepUsages: Array<any> = [];\n    \n    async trackConversation(prompt: string) {\n      const result = await query({\n        prompt,\n        options: {\n          onMessage: (message) => {\n            this.processMessage(message);\n          }\n        }\n      });\n      \n      return {\n        result,\n        stepUsages: this.stepUsages,\n        totalCost: result.usage?.total_cost_usd || 0\n      };\n    }\n    \n    private processMessage(message: any) {\n      // Only process assistant messages with usage\n      if (message.type !== 'assistant' || !message.usage) {\n        return;\n      }\n      \n      // Skip if we've already processed this message ID\n      if (this.processedMessageIds.has(message.id)) {\n        return;\n      }\n      \n      // Mark as processed and record usage\n      this.processedMessageIds.add(message.id);\n      this.stepUsages.push({\n        messageId: message.id,\n        timestamp: new Date().toISOString(),\n        usage: message.usage,\n        costUSD: this.calculateCost(message.usage)\n      });\n    }\n    \n    private calculateCost(usage: any): number {\n      // Implement your pricing calculation here\n      // This is a simplified example\n      const inputCost = usage.input_tokens * 0.00003;\n      const outputCost = usage.output_tokens * 0.00015;\n      const cacheReadCost = (usage.cache_read_input_tokens || 0) * 0.0000075;\n      \n      return inputCost + outputCost + cacheReadCost;\n    }\n  }\n\n  // Usage\n  const tracker = new CostTracker();\n  const { result, stepUsages, totalCost } = await tracker.trackConversation(\n    \"Analyze and refactor this code\"\n  );\n\n  console.log(`Steps processed: ${stepUsages.length}`);\n  console.log(`Total cost: $${totalCost.toFixed(4)}`);\n  ```\n\n  ```python Python theme={null}\n  from claude_agent_sdk import query, AssistantMessage, ResultMessage\n  from datetime import datetime\n  import asyncio\n\n  class CostTracker:\n      def __init__(self):\n          self.processed_message_ids = set()\n          self.step_usages = []\n\n      async def track_conversation(self, prompt):\n          result = None\n\n          # Process messages as they arrive\n          async for message in query(prompt=prompt):\n              self.process_message(message)\n\n              # Capture the final result message\n              if isinstance(message, ResultMessage):\n                  result = message\n\n          return {\n              \"result\": result,\n              \"step_usages\": self.step_usages,\n              \"total_cost\": result.total_cost_usd if result else 0\n          }\n\n      def process_message(self, message):\n          # Only process assistant messages with usage\n          if not isinstance(message, AssistantMessage) or not hasattr(message, 'usage'):\n              return\n\n          # Skip if already processed this message ID\n          message_id = getattr(message, 'id', None)\n          if not message_id or message_id in self.processed_message_ids:\n              return\n\n          # Mark as processed and record usage\n          self.processed_message_ids.add(message_id)\n          self.step_usages.append({\n              \"message_id\": message_id,\n              \"timestamp\": datetime.now().isoformat(),\n              \"usage\": message.usage,\n              \"cost_usd\": self.calculate_cost(message.usage)\n          })\n\n      def calculate_cost(self, usage):\n          # Implement your pricing calculation\n          input_cost = usage.get(\"input_tokens\", 0) * 0.00003\n          output_cost = usage.get(\"output_tokens\", 0) * 0.00015\n          cache_read_cost = usage.get(\"cache_read_input_tokens\", 0) * 0.0000075\n\n          return input_cost + output_cost + cache_read_cost\n\n  # Usage\n  async def main():\n      tracker = CostTracker()\n      result = await tracker.track_conversation(\"Analyze and refactor this code\")\n\n      print(f\"Steps processed: {len(result['step_usages'])}\")\n      print(f\"Total cost: ${result['total_cost']:.4f}\")\n\n  asyncio.run(main())\n  ```\n</CodeGroup>\n\n## Handling Edge Cases\n\n### Output Token Discrepancies\n\nIn rare cases, you might observe different `output_tokens` values for messages with the same ID. When this occurs:\n\n1. **Use the highest value** - The final message in a group typically contains the accurate total\n2. **Verify against total cost** - The `total_cost_usd` in the result message is authoritative\n3. **Report inconsistencies** - File issues at the [Claude Code GitHub repository](https://github.com/anthropics/claude-code/issues)\n\n### Cache Token Tracking\n\nWhen using prompt caching, track these token types separately:\n\n```typescript  theme={null}\ninterface CacheUsage {\n  cache_creation_input_tokens: number;\n  cache_read_input_tokens: number;\n  cache_creation: {\n    ephemeral_5m_input_tokens: number;\n    ephemeral_1h_input_tokens: number;\n  };\n}\n```\n\n## Best Practices\n\n1. **Use Message IDs for Deduplication**: Always track processed message IDs to avoid double-charging\n2. **Monitor the Result Message**: The final result contains authoritative cumulative usage\n3. **Implement Logging**: Log all usage data for auditing and debugging\n4. **Handle Failures Gracefully**: Track partial usage even if a conversation fails\n5. **Consider Streaming**: For streaming responses, accumulate usage as messages arrive\n\n## Usage Fields Reference\n\nEach usage object contains:\n\n* `input_tokens`: Base input tokens processed\n* `output_tokens`: Tokens generated in the response\n* `cache_creation_input_tokens`: Tokens used to create cache entries\n* `cache_read_input_tokens`: Tokens read from cache\n* `service_tier`: The service tier used (e.g., \"standard\")\n* `total_cost_usd`: Total cost in USD (only in result message)\n\n## Example: Building a Billing Dashboard\n\nHere's how to aggregate usage data for a billing dashboard:\n\n```typescript  theme={null}\nclass BillingAggregator {\n  private userUsage = new Map<string, {\n    totalTokens: number;\n    totalCost: number;\n    conversations: number;\n  }>();\n  \n  async processUserRequest(userId: string, prompt: string) {\n    const tracker = new CostTracker();\n    const { result, stepUsages, totalCost } = await tracker.trackConversation(prompt);\n    \n    // Update user totals\n    const current = this.userUsage.get(userId) || {\n      totalTokens: 0,\n      totalCost: 0,\n      conversations: 0\n    };\n    \n    const totalTokens = stepUsages.reduce((sum, step) => \n      sum + step.usage.input_tokens + step.usage.output_tokens, 0\n    );\n    \n    this.userUsage.set(userId, {\n      totalTokens: current.totalTokens + totalTokens,\n      totalCost: current.totalCost + totalCost,\n      conversations: current.conversations + 1\n    });\n    \n    return result;\n  }\n  \n  getUserBilling(userId: string) {\n    return this.userUsage.get(userId) || {\n      totalTokens: 0,\n      totalCost: 0,\n      conversations: 0\n    };\n  }\n}\n```\n\n## Related Documentation\n\n* [TypeScript SDK Reference](/en/docs/agent-sdk/typescript) - Complete API documentation\n* [SDK Overview](/en/docs/agent-sdk/overview) - Getting started with the SDK\n* [SDK Permissions](/en/docs/agent-sdk/permissions) - Managing tool permissions",
  "content_length": 11406
}