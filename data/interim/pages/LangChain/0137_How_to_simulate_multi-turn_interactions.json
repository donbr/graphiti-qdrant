{
  "title": "How to simulate multi-turn interactions",
  "source_url": "https://docs.langchain.com/langsmith/multi-turn-simulation",
  "content": "<Info>\n  * [Multi-turn interactions](/langsmith/evaluation-concepts#multi-turn-interactions)\n  * [Evaluators](/langsmith/evaluation-concepts#evaluators)\n  * [LLM-as-judge](/langsmith/evaluation-concepts#llm-as-judge)\n  * [OpenEvals](https://github.com/langchain-ai/openevals)\n</Info>\n\nAI applications with conversational interfaces, like chatbots, operate over multiple interactions with a user, also called conversation *turns*. When evaluating the performance of such applications, core concepts such as [building a dataset](/langsmith/evaluation-concepts#datasets) and defining [evaluators](/langsmith/evaluation-concepts#evaluators) and metrics to judge your app outputs remain useful. However, you may also find it useful to run a *simulation* between your app and a user, then evaluate this dynamically created trajectory.\n\nSome advantages of doing this are:\n\n* Ease of getting started vs. an evaluation over a full dataset of pre-existing trajectories\n* End-to-end coverage from an initial query until a successful or unsuccessful resolution\n* The ability to detect repetitive behavior or context loss over several iterations of your app\n\nThe downside is that because you are broadening your evaluation surface area to contain multiple turns, there is less consistency than evaluating a single output from your app given a static input from a dataset.\n\n<img src=\"https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=c903f388600ab575e70edb92209c6b2e\" alt=\"\" data-og-width=\"2952\" width=\"2952\" data-og-height=\"1790\" height=\"1790\" data-path=\"langsmith/images/multi-turn-trace.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=280&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=a5113736dc83834150a2b414619626b2 280w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=560&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=f0bfc1f1764c80efcdebfcc07149ef8a 560w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=840&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=53e53c0f05f5638b5e17576c0f37d195 840w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=1100&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=dc05ed0dcfe9d6da5b8872df189f6ed9 1100w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=1650&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=7fbd598ec4a113bb143d0a0a1ca68a91 1650w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=2500&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=a9dcabf49b84ba2ad8aac4159b5b0657 2500w\" />\n\nThis guide will show you how to simulate multi-turn interactions and evaluate them using the open-source [`openevals`](https://github.com/langchain-ai/openevals) package, which contains prebuilt evaluators and other convenient resources for evaluating your AI apps. It will also use OpenAI models, though you can use other providers as well.\n\n## Setup\n\nFirst, ensure you have the required dependencies installed:\n\n<CodeGroup>\n  ```bash Python theme={null}\n  pip install -U langsmith openevals\n  ```\n\n  ```bash TypeScript theme={null}\n  npm install langsmith openevals\n  ```\n</CodeGroup>\n\n<Info>\n  If you are using `yarn` as your package manager, you will also need to manually install `@langchain/core` as a peer dependency of `openevals`. This is not required for LangSmith evals in general.\n</Info>\n\nAnd set up your environment variables:\n\n```bash  theme={null}\nexport LANGSMITH_TRACING=\"true\"\nexport LANGSMITH_API_KEY=\"<Your LangSmith API key>\"\nexport OPENAI_API_KEY=\"<Your OpenAI API key>\"\n```\n\n## Running a simulation\n\nThere are two primary components you'll need to get started:\n\n* `app`: Your application, or a function wrapping it. Must accept a single chat message (dict with \"role\" and \"content\" keys) as an input arg and a `thread_id` as a kwarg. Should accept other kwargs as more may be added in future releases. Returns a chat message as output with at least role and content keys.\n* `user`: The simulated user. In this guide, we will use an imported prebuilt function named `create_llm_simulated_user` which uses an LLM to generate user responses, though you can [create your own too](https://github.com/langchain-ai/openevals?tab=readme-ov-file#custom-simulated-users).\n\nThe simulator in `openevals` passes a single chat message to your `app` from the `user` for each turn. Therefore you should statefully track the current history internally based on `thread_id` if needed.\n\nHere's an example that simulates a multi-turn customer support interaction. This guide uses a simple chat app that wraps a single call to the OpenAI chat completions API, however this is where you would call your application or agent. In this example, our simulated user is playing the role of a particularly aggressive customer:\n\n<CodeGroup>\n  ```python Python theme={null}\n  from openevals.simulators import run_multiturn_simulation, create_llm_simulated_user\n  from openevals.types import ChatCompletionMessage\n  from langsmith.wrappers import wrap_openai\n  from openai import OpenAI\n\n  # Wrap OpenAI client for tracing\n  client = wrap_openai(OpenAI())\n  history = {}\n\n  # Your application logic\n  def app(inputs: ChatCompletionMessage, *, thread_id: str, **kwargs):\n      if thread_id not in history:\n          history[thread_id] = []\n      history[thread_id].append(inputs)\n      # inputs is a message object with role and content\n      res = client.chat.completions.create(\n          model=\"gpt-4.1-mini\",\n          messages=[\n              {\n                  \"role\": \"system\",\n                  \"content\": \"You are a patient and understanding customer service agent.\",\n              },\n          ] + history[thread_id],\n      )\n      response_message = res.choices[0].message\n      history[thread_id].append(response_message)\n      return response_message\n\n  user = create_llm_simulated_user(\n      system=\"You are an aggressive and hostile customer who wants a refund for their car.\",\n      model=\"openai:gpt-4.1-mini\",\n  )\n\n  # Run the simulation directly with the new function\n  simulator_result = run_multiturn_simulation(\n      app=app,\n      user=user,\n      max_turns=5,\n  )\n  print(simulator_result)\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { OpenAI } from \"openai\";\n  import { wrapOpenAI } from \"langsmith/wrappers/openai\";\n  import {\n    createLLMSimulatedUser,\n    runMultiturnSimulation,\n    type ChatCompletionMessage,\n  } from \"openevals\";\n\n  // Wrap OpenAI client for tracing\n  const client = wrapOpenAI(new OpenAI());\n  const history = {};\n\n  // Your application logic\n  const app = async ({ inputs, threadId }: { inputs: ChatCompletionMessage, threadId: string }) => {\n    if (history[threadId] === undefined) {\n      history[threadId] = [];\n    }\n    history[threadId].push(inputs);\n    const res = await client.chat.completions.create({\n      model: \"gpt-4.1-mini\",\n      messages: [\n        {\n          role: \"system\",\n          content:\n            \"You are a patient and understanding customer service agent.\",\n        },\n        inputs,\n      ],\n    });\n    const responseMessage = res.choices[0].message;\n    history[threadId].push(responseMessage);\n    return res.choices[0].message;\n  };\n\n  const user = createLLMSimulatedUser({\n    system: \"You are an aggressive and hostile customer who wants a refund for their car.\",\n    model: \"openai:gpt-4.1-mini\",\n  });\n\n  const result = await runMultiturnSimulation({\n    app,\n    user,\n    maxTurns: 5,\n  });\n  console.log(result);\n  ```\n</CodeGroup>\n\nThe response looks like this:\n\n```json  theme={null}\n{\n  \"trajectory\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"This piece of junk car is a complete disaster! I demand a full refund immediately. How dare you sell me such a worthless vehicle!\",\n      \"id\": \"chatcmpl-BUpXa07LaM7wXbyaNnng1Gtn5Dsbh\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"I'm really sorry to hear about your experience and understand how frustrating this must be. I'd like to help resolve this issue as smoothly as possible. Could you please provide some details about the problem with the vehicle? Once I have more information, I'll do my best to assist you with a solution, whether it's a refund or other options. Thank you for your patience.\",\n      \"refusal\": null,\n      \"annotations\": [],\n      \"id\": \"d7520f6a-7cf8-46f8-abe4-7df04f134482\"\n    },\n    \"...\",\n    {\n      \"role\": \"assistant\",\n      \"content\": \"I truly understand your frustration and sincerely apologize for the inconvenience you've experienced.\\n\\nPlease allow me a moment to review your case, and I will do everything I can to expedite your refund. Your patience is greatly appreciated, and I am committed to resolving this matter to your satisfaction.\",\n      \"refusal\": null,\n      \"annotations\": [],\n      \"id\": \"a0536d4f-9353-4cfa-84df-51c8d29e076d\"\n    }\n  ]\n}\n```\n\nThe simulation first generates an initial query from the simulated `user`, then passes response chat messages back and forth until it reaches `max_turns` (you can alternatively pass a `stopping_condition` that takes the current trajectory and returns `True` or `False` - [see the OpenEvals README for more information](https://github.com/langchain-ai/openevals?tab=readme-ov-file#multiturn-simulation)). The return value is the final list of chat messages that make up the converation's **trajectory**.\n\n<Info>\n  There are several ways to configure the simulated user, such as having it return fixed responses for the first turns of your simulation, as well as the simulation as a whole. For full details, check out [the OpenEvals README](https://github.com/langchain-ai/openevals?tab=readme-ov-file#multiturn-simulation).\n</Info>\n\nThe final trace will look something [like this](https://smith.langchain.com/public/648ca37d-1c4d-4f7b-9b6a-89e35dc5d4f0/r) with responses from your `app` and `user` interleaved:\n\n<img src=\"https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=c903f388600ab575e70edb92209c6b2e\" alt=\"\" data-og-width=\"2952\" width=\"2952\" data-og-height=\"1790\" height=\"1790\" data-path=\"langsmith/images/multi-turn-trace.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=280&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=a5113736dc83834150a2b414619626b2 280w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=560&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=f0bfc1f1764c80efcdebfcc07149ef8a 560w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=840&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=53e53c0f05f5638b5e17576c0f37d195 840w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=1100&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=dc05ed0dcfe9d6da5b8872df189f6ed9 1100w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=1650&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=7fbd598ec4a113bb143d0a0a1ca68a91 1650w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-trace.png?w=2500&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=a9dcabf49b84ba2ad8aac4159b5b0657 2500w\" />\n\nCongrats! You just ran your first multi-turn simulation. Next, we'll cover how to run it in a LangSmith experiment.\n\n## Running in LangSmith experiments\n\nYou can use the results of multi-turn simulations as part of a LangSmith experiment to track performance and progress over time. For these sections, it helps to be familiar with at least one of LangSmith's [`pytest`](/langsmith/pytest) (Python-only), [`Vitest`/`Jest`](/langsmith/vitest-jest) (JS only), or [`evaluate`](/langsmith/evaluate-llm-application) runners.\n\n### Using `pytest` or `Vitest/Jest`\n\n<Check>\n  See the following guides to learn how to set up evals using LangSmith's integrations with test frameworks:\n\n  * [`pytest`](https://docs.smith.langchain.com/langsmith/pytest)\n  * [`Vitest` or `Jest`](https://docs.smith.langchain.com/langsmith/vitest-jest)\n</Check>\n\nIf you are using one of the [LangSmith test framework integrations](/langsmith/pytest), you can pass in an array of OpenEvals evaluators as a `trajectory_evaluators` param when running the simulation. These evaluators will run at the end of the simulation, taking the final list of chat messages as an `outputs` kwarg. Your passed `trajectory_evaluator` must therefore accept this kwarg.\n\n<img src=\"https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-vitest.png?fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=04c56e67e7bb9f01cb905d8a184d62d5\" alt=\"\" data-og-width=\"3448\" width=\"3448\" data-og-height=\"1128\" height=\"1128\" data-path=\"langsmith/images/multi-turn-vitest.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-vitest.png?w=280&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=41ac969c6ceb99ac0976ab3027b00e89 280w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-vitest.png?w=560&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=c10eece031225173dc0ded446e3e2e3c 560w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-vitest.png?w=840&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=90bda951b2cfa02bde0c8ad204a7dac7 840w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-vitest.png?w=1100&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=2ca95c911f68412eb09e2f8a0a6b42e4 1100w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-vitest.png?w=1650&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=12be96d7f216cd8ce664c01f61f45288 1650w, https://mintcdn.com/langchain-5e9cc07a/4kN8yiLrZX_amfFn/langsmith/images/multi-turn-vitest.png?w=2500&fit=max&auto=format&n=4kN8yiLrZX_amfFn&q=85&s=1faa3a34b3daf67705e2afeca748e353 2500w\" />\n\nHere's an example:\n\n<CodeGroup>\n  ```python Python theme={null}\n  from openevals.simulators import run_multiturn_simulation, create_llm_simulated_user\n  from openevals.llm import create_llm_as_judge\n  from openevals.types import ChatCompletionMessage\n  from langsmith import testing as t\n  from langsmith.wrappers import wrap_openai\n  from openai import OpenAI\n  import pytest\n\n  @pytest.mark.langsmith\n  def test_multiturn_message_with_openai():\n      inputs = {\"role\": \"user\", \"content\": \"I want a refund for my car!\"}\n      t.log_inputs(inputs)\n      # Wrap OpenAI client for tracing\n      client = wrap_openai(OpenAI())\n      history = {}\n\n      def app(inputs: ChatCompletionMessage, *, thread_id: str):\n          if thread_id not in history:\n              history[thread_id] = []\n          history[thread_id] = history[thread_id] + [inputs]\n          res = client.chat.completions.create(\n              model=\"gpt-4.1-nano\",\n              messages=[\n                  {\n                      \"role\": \"system\",\n                      \"content\": \"You are a patient and understanding customer service agent.\",\n                  }\n              ]\n              + history[thread_id],\n          )\n          response = res.choices[0].message\n          history[thread_id].append(response)\n          return response\n\n      user = create_llm_simulated_user(\n          system=\"You are a nice customer who wants a refund for their car.\",\n          model=\"openai:gpt-4.1-nano\",\n          fixed_responses=[\n              inputs,\n          ],\n      )\n      trajectory_evaluator = create_llm_as_judge(\n          model=\"openai:o3-mini\",\n          prompt=\"Based on the below conversation, was the user satisfied?\\n{outputs}\",\n          feedback_key=\"satisfaction\",\n      )\n      res = run_multiturn_simulation(\n          app=app,\n          user=user,\n          trajectory_evaluators=[trajectory_evaluator],\n          max_turns=5,\n      )\n      t.log_outputs(res)\n      # Optionally, assert that the evaluator scored the interaction as satisfactory.\n      # This will cause the overall test case to fail if \"score\" is False.\n      assert res[\"evaluator_results\"][0][\"score\"]\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { OpenAI } from \"openai\";\n  import { wrapOpenAI } from \"langsmith/wrappers/openai\";\n  import * as ls from \"langsmith/vitest\";\n  import { expect } from \"vitest\";\n  // import * as ls from \"langsmith/jest\";\n  // import { expect } from \"@jest/globals\";\n  import {\n    createLLMSimulatedUser,\n    runMultiturnSimulation,\n    createLLMAsJudge,\n    type ChatCompletionMessage,\n  } from \"openevals\";\n\n  const client = wrapOpenAI(new OpenAI());\n\n  ls.describe(\"Multiturn demo\", () => {\n    ls.test(\n      \"Should have a satisfactory interaction with a nice user\",\n      {\n        inputs: {\n          messages: [{ role: \"user\" as const, content: \"I want a refund for my car!\" }],\n        },\n      },\n      async ({ inputs }) => {\n        const history = {};\n        // Create a custom app function\n        const app = async (\n          { inputs, threadId }: { inputs: ChatCompletionMessage, threadId: string }\n        ) => {\n          if (history[threadId] === undefined) {\n            history[threadId] = [];\n          }\n          history[threadId].push(inputs);\n          const res = await client.chat.completions.create({\n            model: \"gpt-4.1-nano\",\n            messages: [\n              {\n                role: \"system\",\n                content:\n                  \"You are a patient and understanding customer service agent\",\n              },\n              inputs,\n            ],\n          });\n          const responseMessage = res.choices[0].message;\n          history[threadId].push(responseMessage);\n          return responseMessage;\n        };\n\n        const user = createLLMSimulatedUser({\n          system:\n            \"You are a nice customer who wants a refund for their car.\",\n          model: \"openai:gpt-4.1-nano\",\n          fixedResponses: inputs.messages,\n        });\n\n        const trajectoryEvaluator = createLLMAsJudge({\n          model: \"openai:o3-mini\",\n          prompt:\n            \"Based on the below conversation, was the user satisfied?\\n{outputs}\",\n          feedbackKey: \"satisfaction\",\n        });\n\n        const result = await runMultiturnSimulation({\n          app,\n          user,\n          trajectoryEvaluators: [trajectoryEvaluator],\n          maxTurns: 5,\n        });\n\n        ls.logOutputs(result);\n        // Optionally, assert that the evaluator scored the interaction as satisfactory.\n        // This will cause the overall test case to fail if \"score\" is false.\n        expect(result.evaluatorResults[0].score).toBe(true);\n      }\n    );\n  });\n  ```\n</CodeGroup>\n\nLangSmith will automatically detect and log the feedback returned from the passed `trajectory_evaluators`, adding it to the experiment. Note also that the test case uses the `fixed_responses` param on the simulated user to start the conversation with a specific input, which you can log and make part of your stored dataset.\n\nYou may also find it convenient to have the simulated user's system prompt to be part of your logged dataset as well.\n\n### Using `evaluate`\n\nYou can also use the [`evaluate`](/langsmith/evaluate-llm-application) runner to evaluate simulated multi-turn interactions. This will be a little bit different from the `pytest`/`Vitest`/`Jest` example in the following ways:\n\n* The simulation should be part of your `target` function, and your target function should return the final trajectory.\n  * This will make the trajectory the `outputs` that LangSmith will pass to your evaluators.\n* Instead of using the `trajectory_evaluators` param, you should pass your evaluators as a param into the `evaluate()` method.\n* You will need an existing dataset of inputs and (optionally) reference trajectories.\n\nHere's an example:\n\n<CodeGroup>\n  ```python Python theme={null}\n  from openevals.simulators import run_multiturn_simulation, create_llm_simulated_user\n  from openevals.llm import create_llm_as_judge\n  from openevals.types import ChatCompletionMessage\n  from langsmith.wrappers import wrap_openai\n  from langsmith import Client\n  from openai import OpenAI\n\n  ls_client = Client()\n  examples = [\n      {\n          \"inputs\": {\n              \"messages\": [{ \"role\": \"user\", \"content\": \"I want a refund for my car!\" }]\n          },\n      },\n  ]\n  dataset = ls_client.create_dataset(dataset_name=\"multiturn-starter\")\n  ls_client.create_examples(\n      dataset_id=dataset.id,\n      examples=examples,\n  )\n  trajectory_evaluator = create_llm_as_judge(\n      model=\"openai:o3-mini\",\n      prompt=\"Based on the below conversation, was the user satisfied?\\n{outputs}\",\n      feedback_key=\"satisfaction\",\n  )\n\n  def target(inputs: dict):\n      # Wrap OpenAI client for tracing\n      client = wrap_openai(OpenAI())\n      history = {}\n\n      def app(next_message: ChatCompletionMessage, *, thread_id: str):\n          if thread_id not in history:\n              history[thread_id] = []\n          history[thread_id] = history[thread_id] + [next_message]\n          res = client.chat.completions.create(\n              model=\"gpt-4.1-nano\",\n              messages=[\n                  {\n                      \"role\": \"system\",\n                      \"content\": \"You are a patient and understanding customer service agent.\",\n                  }\n              ]\n              + history[thread_id],\n          )\n          response = res.choices[0].message\n          history[thread_id].append(response)\n          return response\n\n      user = create_llm_simulated_user(\n          system=\"You are a nice customer who wants a refund for their car.\",\n          model=\"openai:gpt-4.1-nano\",\n          fixed_responses=inputs[\"messages\"],\n      )\n      res = run_multiturn_simulation(\n          app=app,\n          user=user,\n          max_turns=5,\n      )\n      return res[\"trajectory\"]\n\n  results = ls_client.evaluate(\n      target,\n      data=dataset.name,\n      evaluators=[trajectory_evaluator],\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { OpenAI } from \"openai\";\n  import { Client } from \"langsmith\";\n  import { wrapOpenAI } from \"langsmith/wrappers/openai\";\n  import { evaluate } from \"langsmith/evaluation\";\n  import {\n    createLLMSimulatedUser,\n    runMultiturnSimulation,\n    createLLMAsJudge,\n    type ChatCompletionMessage,\n  } from \"openevals\";\n\n  const lsClient = new Client();\n  const inputs = {\n    messages: [\n      {\n        role: \"user\",\n        content: \"I want a refund for my car!\",\n      },\n    ],\n  };\n  const datasetName = \"Multiturn\";\n  const dataset = await lsClient.createDataset(datasetName);\n  await lsClient.createExamples([{ inputs, dataset_id: dataset.id }]);\n\n  const trajectoryEvaluator = createLLMAsJudge({\n    model: \"openai:o3-mini\",\n    prompt:\n      \"Based on the below conversation, was the user satisfied?\\n{outputs}\",\n    feedbackKey: \"satisfaction\",\n  });\n\n  const client = wrapOpenAI(new OpenAI());\n\n  const target = async (inputs: { messages: ChatCompletionMessage[]}) => {\n    const history = {};\n    // Create a custom app function\n    const app = async (\n      { inputs: nextMessage, threadId }: { inputs: ChatCompletionMessage, threadId: string }\n    ) => {\n      if (history[threadId] === undefined) {\n        history[threadId] = [];\n      }\n      history[threadId].push(nextMessage);\n      const res = await client.chat.completions.create({\n        model: \"gpt-4.1-nano\",\n        messages: [\n          {\n            role: \"system\",\n            content:\n              \"You are a patient and understanding customer service agent\",\n          },\n          nextMessage,\n        ],\n      });\n      const responseMessage = res.choices[0].message;\n      history[threadId].push(responseMessage);\n      return responseMessage;\n    };\n\n    const user = createLLMSimulatedUser({\n      system:\n        \"You are a nice customer who wants a refund for their car.\",\n      model: \"openai:gpt-4.1-nano\",\n      fixedResponses: inputs.messages,\n    });\n\n    const result = await runMultiturnSimulation({\n      app,\n      user,\n      maxTurns: 5,\n    });\n    return result.trajectory;\n  };\n\n  await evaluate(target, {\n    data: datasetName,\n    evaluators: [trajectoryEvaluator],\n  });\n  ```\n</CodeGroup>\n\n## Modifying the simulated user persona\n\nThe above examples run using the same simulated user persona for all input examples, defined by the `system` parameter passed into `create_llm_simulated_user`. If you would like to use a different persona for specific items in your dataset, you can update your dataset examples to also contain an extra field with the desired `system` prompt, then pass that field in when creating your simulated user like this:\n\n<CodeGroup>\n  ```python Python theme={null}\n  from openevals.simulators import run_multiturn_simulation, create_llm_simulated_user\n  from openevals.llm import create_llm_as_judge\n  from openevals.types import ChatCompletionMessage\n  from langsmith.wrappers import wrap_openai\n  from langsmith import Client\n  from openai import OpenAI\n\n  ls_client = Client()\n  examples = [\n      {\n          \"inputs\": {\n              \"messages\": [{ \"role\": \"user\", \"content\": \"I want a refund for my car!\" }],\n              \"simulated_user_prompt\": \"You are an angry and belligerent customer who wants a refund for their car.\"\n          },\n      },\n      {\n          \"inputs\": {\n              \"messages\": [{ \"role\": \"user\", \"content\": \"Please give me a refund for my car.\" }],\n              \"simulated_user_prompt\": \"You are a nice customer who wants a refund for their car.\",\n          },\n      }\n  ]\n  dataset = ls_client.create_dataset(dataset_name=\"multiturn-with-personas\")\n  ls_client.create_examples(\n      dataset_id=dataset.id,\n      examples=examples,\n  )\n  trajectory_evaluator = create_llm_as_judge(\n      model=\"openai:o3-mini\",\n      prompt=\"Based on the below conversation, was the user satisfied?\\n{outputs}\",\n      feedback_key=\"satisfaction\",\n  )\n\n  def target(inputs: dict):\n      # Wrap OpenAI client for tracing\n      client = wrap_openai(OpenAI())\n      history = {}\n\n      def app(next_message: ChatCompletionMessage, *, thread_id: str):\n          if thread_id not in history:\n              history[thread_id] = []\n          history[thread_id] = history[thread_id] + [next_message]\n          res = client.chat.completions.create(\n              model=\"gpt-4.1-nano\",\n              messages=[\n                  {\n                      \"role\": \"system\",\n                      \"content\": \"You are a patient and understanding customer service agent.\",\n                  }\n              ]\n              + history[thread_id],\n          )\n          response = res.choices[0].message\n          history[thread_id].append(response)\n          return response\n\n      user = create_llm_simulated_user(\n          system=inputs[\"simulated_user_prompt\"],\n          model=\"openai:gpt-4.1-nano\",\n          fixed_responses=inputs[\"messages\"],\n      )\n      res = run_multiturn_simulation(\n          app=app,\n          user=user,\n          max_turns=5,\n      )\n      return res[\"trajectory\"]\n\n  results = ls_client.evaluate(\n      target,\n      data=dataset.name,\n      evaluators=[trajectory_evaluator],\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { OpenAI } from \"openai\";\n  import { Client } from \"langsmith\";\n  import { wrapOpenAI } from \"langsmith/wrappers/openai\";\n  import { evaluate } from \"langsmith/evaluation\";\n  import {\n    createLLMSimulatedUser,\n    runMultiturnSimulation,\n    createLLMAsJudge,\n    type ChatCompletionMessage,\n  } from \"openevals\";\n\n  const lsClient = new Client();\n  const datasetName = \"Multiturn with personas\";\n  const dataset = await lsClient.createDataset(datasetName);\n  const examples = [{\n    inputs: {\n      messages: [\n        {\n          role: \"user\",\n          content: \"I want a refund for my car!\",\n        },\n      ],\n      simulated_user_prompt: \"You are an angry and belligerent customer who wants a refund for their car.\",\n    },\n    dataset_id: dataset.id,\n  }, {\n    inputs: {\n      messages: [\n        {\n          role: \"user\",\n          content: \"Please give me a refund for my car.\"\n        }\n      ],\n      simulated_user_prompt: \"You are a nice customer who wants a refund for their car.\",\n    },\n    dataset_id: dataset.id,\n  }];\n  await lsClient.createExamples(examples);\n\n  const trajectoryEvaluator = createLLMAsJudge({\n    model: \"openai:o3-mini\",\n    prompt:\n      \"Based on the below conversation, was the user satisfied?\\n{outputs}\",\n    feedbackKey: \"satisfaction\",\n  });\n\n  const client = wrapOpenAI(new OpenAI());\n\n  const target = async (inputs: {\n    messages: ChatCompletionMessage[],\n    simulated_user_prompt: string,\n  }) => {\n    const history = {};\n    // Create a custom app function\n    const app = async (\n      { inputs: nextMessage, threadId }: { inputs: ChatCompletionMessage, threadId: string }\n    ) => {\n      if (history[threadId] === undefined) {\n        history[threadId] = [];\n      }\n      history[threadId].push(nextMessage);\n      const res = await client.chat.completions.create({\n        model: \"gpt-4.1-nano\",\n        messages: [\n          {\n            role: \"system\",\n            content:\n              \"You are a patient and understanding customer service agent\",\n          },\n          nextMessage,\n        ],\n      });\n      const responseMessage = res.choices[0].message;\n      history[threadId].push(responseMessage);\n      return responseMessage;\n    };\n\n    const user = createLLMSimulatedUser({\n      system: inputs.simulated_user_prompt,\n      model: \"openai:gpt-4.1-nano\",\n      fixedResponses: inputs.messages,\n    });\n\n    const result = await runMultiturnSimulation({\n      app,\n      user,\n      maxTurns: 5,\n    });\n    return result.trajectory;\n  };\n\n  await evaluate(target, {\n    data: datasetName,\n    evaluators: [trajectoryEvaluator],\n  });\n  ```\n</CodeGroup>\n\n## Next steps\n\nYou've just seen some techniques for simulating multi-turn interactions and running them in LangSmith evals.\n\nHere are some topics you might want to explore next:\n\n* [Trace multiturn conversations across different traces](/langsmith/threads)\n* [Use multiple messages in the playground UI](/langsmith/multiple-messages)\n* [Return multiple metrics in one evaluator](/langsmith/multiple-scores)\n\nYou can also explore the [OpenEvals readme](https://github.com/langchain-ai/openevals) for more on prebuilt evaluators.\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/multi-turn-simulation.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 31080
}