{
  "title": "Structured output",
  "source_url": "https://docs.langchain.com/oss/python/langchain/structured-output",
  "content": "Structured output allows agents to return data in a specific, predictable format. Instead of parsing natural language responses, you get structured data in the form of JSON objects, Pydantic models, or dataclasses that your application can directly use.\n\nLangChain's [`create_agent`](https://reference.langchain.com/python/langchain/agents/#langchain.agents.create_agent) handles structured output automatically. The user sets their desired structured output schema, and when the model generates the structured data, it's captured, validated, and returned in the `'structured_response'` key of the agent's state.\n\n```python  theme={null}\ndef create_agent(\n    ...\n    response_format: Union[\n        ToolStrategy[StructuredResponseT],\n        ProviderStrategy[StructuredResponseT],\n        type[StructuredResponseT],\n    ]\n```\n\n## Response Format\n\nControls how the agent returns structured data:\n\n* **`ToolStrategy[StructuredResponseT]`**: Uses tool calling for structured output\n* **`ProviderStrategy[StructuredResponseT]`**: Uses provider-native structured output\n* **`type[StructuredResponseT]`**: Schema type - automatically selects best strategy based on model capabilities\n* **`None`**: No structured output\n\nWhen a schema type is provided directly, LangChain automatically chooses:\n\n* `ProviderStrategy` for models supporting native structured output (e.g. [OpenAI](/oss/python/integrations/providers/openai), [Anthropic](/oss/python/integrations/providers/anthropic), or [Grok](/oss/python/integrations/providers/xai)).\n* `ToolStrategy` for all other models.\n\n<Tip>\n  Support for native structured output features is read dynamically from the model's [profile data](/oss/python/langchain/models#model-profiles) if using `langchain>=1.1`. If data are not available, use another condition or specify manually:\n\n  ```python  theme={null}\n  custom_profile = {\n      \"structured_output\": True,\n      # ...\n  }\n  model = init_chat_model(\"...\", profile=custom_profile)\n  ```\n\n  If tools are specified, the model must support simultaneous use of tools and structured output.\n</Tip>\n\nThe structured response is returned in the `structured_response` key of the agent's final state.\n\n## Provider strategy\n\nSome model providers support structured output natively through their APIs (e.g. OpenAI, Grok, Gemini). This is the most reliable method when available.\n\nTo use this strategy, configure a `ProviderStrategy`:\n\n```python  theme={null}\nclass ProviderStrategy(Generic[SchemaT]):\n    schema: type[SchemaT]\n```\n\n<ParamField path=\"schema\" required>\n  The schema defining the structured output format. Supports:\n\n  * **Pydantic models**: `BaseModel` subclasses with field validation\n  * **Dataclasses**: Python dataclasses with type annotations\n  * **TypedDict**: Typed dictionary classes\n  * **JSON Schema**: Dictionary with JSON schema specification\n</ParamField>\n\nLangChain automatically uses `ProviderStrategy` when you pass a schema type directly to [`create_agent.response_format`](https://reference.langchain.com/python/langchain/agents/#langchain.agents.create_agent\\(response_format\\)) and the model supports native structured output:\n\n<CodeGroup>\n  ```python Pydantic Model theme={null}\n  from pydantic import BaseModel, Field\n  from langchain.agents import create_agent\n\n\n  class ContactInfo(BaseModel):\n      \"\"\"Contact information for a person.\"\"\"\n      name: str = Field(description=\"The name of the person\")\n      email: str = Field(description=\"The email address of the person\")\n      phone: str = Field(description=\"The phone number of the person\")\n\n  agent = create_agent(\n      model=\"gpt-5\",\n      response_format=ContactInfo  # Auto-selects ProviderStrategy\n  )\n\n  result = agent.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"Extract contact info from: John Doe, john@example.com, (555) 123-4567\"}]\n  })\n\n  print(result[\"structured_response\"])\n  # ContactInfo(name='John Doe', email='john@example.com', phone='(555) 123-4567')\n  ```\n\n  ```python Dataclass theme={null}\n  from dataclasses import dataclass\n  from langchain.agents import create_agent\n\n\n  @dataclass\n  class ContactInfo:\n      \"\"\"Contact information for a person.\"\"\"\n      name: str # The name of the person\n      email: str # The email address of the person\n      phone: str # The phone number of the person\n\n  agent = create_agent(\n      model=\"gpt-5\",\n      tools=tools,\n      response_format=ContactInfo  # Auto-selects ProviderStrategy\n  )\n\n  result = agent.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"Extract contact info from: John Doe, john@example.com, (555) 123-4567\"}]\n  })\n\n  result[\"structured_response\"]\n  # ContactInfo(name='John Doe', email='john@example.com', phone='(555) 123-4567')\n  ```\n\n  ```python TypedDict theme={null}\n  from typing_extensions import TypedDict\n  from langchain.agents import create_agent\n\n\n  class ContactInfo(TypedDict):\n      \"\"\"Contact information for a person.\"\"\"\n      name: str # The name of the person\n      email: str # The email address of the person\n      phone: str # The phone number of the person\n\n  agent = create_agent(\n      model=\"gpt-5\",\n      tools=tools,\n      response_format=ContactInfo  # Auto-selects ProviderStrategy\n  )\n\n  result = agent.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"Extract contact info from: John Doe, john@example.com, (555) 123-4567\"}]\n  })\n\n  result[\"structured_response\"]\n  # {'name': 'John Doe', 'email': 'john@example.com', 'phone': '(555) 123-4567'}\n  ```\n\n  ```python JSON Schema theme={null}\n  from langchain.agents import create_agent\n\n\n  contact_info_schema = {\n      \"type\": \"object\",\n      \"description\": \"Contact information for a person.\",\n      \"properties\": {\n          \"name\": {\"type\": \"string\", \"description\": \"The name of the person\"},\n          \"email\": {\"type\": \"string\", \"description\": \"The email address of the person\"},\n          \"phone\": {\"type\": \"string\", \"description\": \"The phone number of the person\"}\n      },\n      \"required\": [\"name\", \"email\", \"phone\"]\n  }\n\n  agent = create_agent(\n      model=\"gpt-5\",\n      tools=tools,\n      response_format=ProviderStrategy(contact_info_schema)\n  )\n\n  result = agent.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"Extract contact info from: John Doe, john@example.com, (555) 123-4567\"}]\n  })\n\n  result[\"structured_response\"]\n  # {'name': 'John Doe', 'email': 'john@example.com', 'phone': '(555) 123-4567'}\n  ```\n</CodeGroup>\n\nProvider-native structured output provides high reliability and strict validation because the model provider enforces the schema. Use it when available.\n\n<Note>\n  If the provider natively supports structured output for your model choice, it is functionally equivalent to write `response_format=ProductReview` instead of `response_format=ProviderStrategy(ProductReview)`. In either case, if structured output is not supported, the agent will fall back to a tool calling strategy.\n</Note>\n\n## Tool calling strategy\n\nFor models that don't support native structured output, LangChain uses tool calling to achieve the same result. This works with all models that support tool calling, which is most modern models.\n\nTo use this strategy, configure a `ToolStrategy`:\n\n```python  theme={null}\nclass ToolStrategy(Generic[SchemaT]):\n    schema: type[SchemaT]\n    tool_message_content: str | None\n    handle_errors: Union[\n        bool,\n        str,\n        type[Exception],\n        tuple[type[Exception], ...],\n        Callable[[Exception], str],\n    ]\n```\n\n<ParamField path=\"schema\" required>\n  The schema defining the structured output format. Supports:\n\n  * **Pydantic models**: `BaseModel` subclasses with field validation\n  * **Dataclasses**: Python dataclasses with type annotations\n  * **TypedDict**: Typed dictionary classes\n  * **JSON Schema**: Dictionary with JSON schema specification\n  * **Union types**: Multiple schema options. The model will choose the most appropriate schema based on the context.\n</ParamField>\n\n<ParamField path=\"tool_message_content\">\n  Custom content for the tool message returned when structured output is generated.\n  If not provided, defaults to a message showing the structured response data.\n</ParamField>\n\n<ParamField path=\"handle_errors\">\n  Error handling strategy for structured output validation failures. Defaults to `True`.\n\n  * **`True`**: Catch all errors with default error template\n  * **`str`**: Catch all errors with this custom message\n  * **`type[Exception]`**: Only catch this exception type with default message\n  * **`tuple[type[Exception], ...]`**: Only catch these exception types with default message\n  * **`Callable[[Exception], str]`**: Custom function that returns error message\n  * **`False`**: No retry, let exceptions propagate\n</ParamField>\n\n<CodeGroup>\n  ```python Pydantic Model theme={null}\n  from pydantic import BaseModel, Field\n  from typing import Literal\n  from langchain.agents import create_agent\n  from langchain.agents.structured_output import ToolStrategy\n\n\n  class ProductReview(BaseModel):\n      \"\"\"Analysis of a product review.\"\"\"\n      rating: int | None = Field(description=\"The rating of the product\", ge=1, le=5)\n      sentiment: Literal[\"positive\", \"negative\"] = Field(description=\"The sentiment of the review\")\n      key_points: list[str] = Field(description=\"The key points of the review. Lowercase, 1-3 words each.\")\n\n  agent = create_agent(\n      model=\"gpt-5\",\n      tools=tools,\n      response_format=ToolStrategy(ProductReview)\n  )\n\n  result = agent.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"Analyze this review: 'Great product: 5 out of 5 stars. Fast shipping, but expensive'\"}]\n  })\n  result[\"structured_response\"]\n  # ProductReview(rating=5, sentiment='positive', key_points=['fast shipping', 'expensive'])\n  ```\n\n  ```python Dataclass theme={null}\n  from dataclasses import dataclass\n  from typing import Literal\n  from langchain.agents import create_agent\n  from langchain.agents.structured_output import ToolStrategy\n\n\n  @dataclass\n  class ProductReview:\n      \"\"\"Analysis of a product review.\"\"\"\n      rating: int | None  # The rating of the product (1-5)\n      sentiment: Literal[\"positive\", \"negative\"]  # The sentiment of the review\n      key_points: list[str]  # The key points of the review\n\n  agent = create_agent(\n      model=\"gpt-5\",\n      tools=tools,\n      response_format=ToolStrategy(ProductReview)\n  )\n\n  result = agent.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"Analyze this review: 'Great product: 5 out of 5 stars. Fast shipping, but expensive'\"}]\n  })\n  result[\"structured_response\"]\n  # ProductReview(rating=5, sentiment='positive', key_points=['fast shipping', 'expensive'])\n  ```\n\n  ```python TypedDict theme={null}\n  from typing import Literal\n  from typing_extensions import TypedDict\n  from langchain.agents import create_agent\n  from langchain.agents.structured_output import ToolStrategy\n\n\n  class ProductReview(TypedDict):\n      \"\"\"Analysis of a product review.\"\"\"\n      rating: int | None  # The rating of the product (1-5)\n      sentiment: Literal[\"positive\", \"negative\"]  # The sentiment of the review\n      key_points: list[str]  # The key points of the review\n\n  agent = create_agent(\n      model=\"gpt-5\",\n      tools=tools,\n      response_format=ToolStrategy(ProductReview)\n  )\n\n  result = agent.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"Analyze this review: 'Great product: 5 out of 5 stars. Fast shipping, but expensive'\"}]\n  })\n  result[\"structured_response\"]\n  # {'rating': 5, 'sentiment': 'positive', 'key_points': ['fast shipping', 'expensive']}\n  ```\n\n  ```python JSON Schema theme={null}\n  from langchain.agents import create_agent\n  from langchain.agents.structured_output import ToolStrategy\n\n\n  product_review_schema = {\n      \"type\": \"object\",\n      \"description\": \"Analysis of a product review.\",\n      \"properties\": {\n          \"rating\": {\n              \"type\": [\"integer\", \"null\"],\n              \"description\": \"The rating of the product (1-5)\",\n              \"minimum\": 1,\n              \"maximum\": 5\n          },\n          \"sentiment\": {\n              \"type\": \"string\",\n              \"enum\": [\"positive\", \"negative\"],\n              \"description\": \"The sentiment of the review\"\n          },\n          \"key_points\": {\n              \"type\": \"array\",\n              \"items\": {\"type\": \"string\"},\n              \"description\": \"The key points of the review\"\n          }\n      },\n      \"required\": [\"sentiment\", \"key_points\"]\n  }\n\n  agent = create_agent(\n      model=\"gpt-5\",\n      tools=tools,\n      response_format=ToolStrategy(product_review_schema)\n  )\n\n  result = agent.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"Analyze this review: 'Great product: 5 out of 5 stars. Fast shipping, but expensive'\"}]\n  })\n  result[\"structured_response\"]\n  # {'rating': 5, 'sentiment': 'positive', 'key_points': ['fast shipping', 'expensive']}\n  ```\n\n  ```python Union Types theme={null}\n  from pydantic import BaseModel, Field\n  from typing import Literal, Union\n  from langchain.agents import create_agent\n  from langchain.agents.structured_output import ToolStrategy\n\n\n  class ProductReview(BaseModel):\n      \"\"\"Analysis of a product review.\"\"\"\n      rating: int | None = Field(description=\"The rating of the product\", ge=1, le=5)\n      sentiment: Literal[\"positive\", \"negative\"] = Field(description=\"The sentiment of the review\")\n      key_points: list[str] = Field(description=\"The key points of the review. Lowercase, 1-3 words each.\")\n\n  class CustomerComplaint(BaseModel):\n      \"\"\"A customer complaint about a product or service.\"\"\"\n      issue_type: Literal[\"product\", \"service\", \"shipping\", \"billing\"] = Field(description=\"The type of issue\")\n      severity: Literal[\"low\", \"medium\", \"high\"] = Field(description=\"The severity of the complaint\")\n      description: str = Field(description=\"Brief description of the complaint\")\n\n  agent = create_agent(\n      model=\"gpt-5\",\n      tools=tools,\n      response_format=ToolStrategy(Union[ProductReview, CustomerComplaint])\n  )\n\n  result = agent.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"Analyze this review: 'Great product: 5 out of 5 stars. Fast shipping, but expensive'\"}]\n  })\n  result[\"structured_response\"]\n  # ProductReview(rating=5, sentiment='positive', key_points=['fast shipping', 'expensive'])\n  ```\n</CodeGroup>\n\n### Custom tool message content\n\nThe `tool_message_content` parameter allows you to customize the message that appears in the conversation history when structured output is generated:\n\n```python  theme={null}\nfrom pydantic import BaseModel, Field\nfrom typing import Literal\nfrom langchain.agents import create_agent\nfrom langchain.agents.structured_output import ToolStrategy\n\n\nclass MeetingAction(BaseModel):\n    \"\"\"Action items extracted from a meeting transcript.\"\"\"\n    task: str = Field(description=\"The specific task to be completed\")\n    assignee: str = Field(description=\"Person responsible for the task\")\n    priority: Literal[\"low\", \"medium\", \"high\"] = Field(description=\"Priority level\")\n\nagent = create_agent(\n    model=\"gpt-5\",\n    tools=[],\n    response_format=ToolStrategy(\n        schema=MeetingAction,\n        tool_message_content=\"Action item captured and added to meeting notes!\"\n    )\n)\n\nagent.invoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"From our meeting: Sarah needs to update the project timeline as soon as possible\"}]\n})\n```\n\n```\n================================ Human Message =================================\n\nFrom our meeting: Sarah needs to update the project timeline as soon as possible\n================================== Ai Message ==================================\nTool Calls:\n  MeetingAction (call_1)\n Call ID: call_1\n  Args:\n    task: Update the project timeline\n    assignee: Sarah\n    priority: high\n================================= Tool Message =================================\nName: MeetingAction\n\nAction item captured and added to meeting notes!\n```\n\nWithout `tool_message_content`, our final [`ToolMessage`](https://reference.langchain.com/python/langchain/messages/#langchain.messages.ToolMessage) would be:\n\n```\n================================= Tool Message =================================\nName: MeetingAction\n\nReturning structured response: {'task': 'update the project timeline', 'assignee': 'Sarah', 'priority': 'high'}\n```\n\n### Error handling\n\nModels can make mistakes when generating structured output via tool calling. LangChain provides intelligent retry mechanisms to handle these errors automatically.\n\n#### Multiple structured outputs error\n\nWhen a model incorrectly calls multiple structured output tools, the agent provides error feedback in a [`ToolMessage`](https://reference.langchain.com/python/langchain/messages/#langchain.messages.ToolMessage) and prompts the model to retry:\n\n```python  theme={null}\nfrom pydantic import BaseModel, Field\nfrom typing import Union\nfrom langchain.agents import create_agent\nfrom langchain.agents.structured_output import ToolStrategy\n\n\nclass ContactInfo(BaseModel):\n    name: str = Field(description=\"Person's name\")\n    email: str = Field(description=\"Email address\")\n\nclass EventDetails(BaseModel):\n    event_name: str = Field(description=\"Name of the event\")\n    date: str = Field(description=\"Event date\")\n\nagent = create_agent(\n    model=\"gpt-5\",\n    tools=[],\n    response_format=ToolStrategy(Union[ContactInfo, EventDetails])  # Default: handle_errors=True\n)\n\nagent.invoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"Extract info: John Doe (john@email.com) is organizing Tech Conference on March 15th\"}]\n})\n```\n\n```\n================================ Human Message =================================\n\nExtract info: John Doe (john@email.com) is organizing Tech Conference on March 15th\nNone\n================================== Ai Message ==================================\nTool Calls:\n  ContactInfo (call_1)\n Call ID: call_1\n  Args:\n    name: John Doe\n    email: john@email.com\n  EventDetails (call_2)\n Call ID: call_2\n  Args:\n    event_name: Tech Conference\n    date: March 15th\n================================= Tool Message =================================\nName: ContactInfo\n\nError: Model incorrectly returned multiple structured responses (ContactInfo, EventDetails) when only one is expected.\n Please fix your mistakes.\n================================= Tool Message =================================\nName: EventDetails\n\nError: Model incorrectly returned multiple structured responses (ContactInfo, EventDetails) when only one is expected.\n Please fix your mistakes.\n================================== Ai Message ==================================\nTool Calls:\n  ContactInfo (call_3)\n Call ID: call_3\n  Args:\n    name: John Doe\n    email: john@email.com\n================================= Tool Message =================================\nName: ContactInfo\n\nReturning structured response: {'name': 'John Doe', 'email': 'john@email.com'}\n```\n\n#### Schema validation error\n\nWhen structured output doesn't match the expected schema, the agent provides specific error feedback:\n\n```python  theme={null}\nfrom pydantic import BaseModel, Field\nfrom langchain.agents import create_agent\nfrom langchain.agents.structured_output import ToolStrategy\n\n\nclass ProductRating(BaseModel):\n    rating: int | None = Field(description=\"Rating from 1-5\", ge=1, le=5)\n    comment: str = Field(description=\"Review comment\")\n\nagent = create_agent(\n    model=\"gpt-5\",\n    tools=[],\n    response_format=ToolStrategy(ProductRating),  # Default: handle_errors=True\n    system_prompt=\"You are a helpful assistant that parses product reviews. Do not make any field or value up.\"\n)\n\nagent.invoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"Parse this: Amazing product, 10/10!\"}]\n})\n```\n\n```\n================================ Human Message =================================\n\nParse this: Amazing product, 10/10!\n================================== Ai Message ==================================\nTool Calls:\n  ProductRating (call_1)\n Call ID: call_1\n  Args:\n    rating: 10\n    comment: Amazing product\n================================= Tool Message =================================\nName: ProductRating\n\nError: Failed to parse structured output for tool 'ProductRating': 1 validation error for ProductRating.rating\n  Input should be less than or equal to 5 [type=less_than_equal, input_value=10, input_type=int].\n Please fix your mistakes.\n================================== Ai Message ==================================\nTool Calls:\n  ProductRating (call_2)\n Call ID: call_2\n  Args:\n    rating: 5\n    comment: Amazing product\n================================= Tool Message =================================\nName: ProductRating\n\nReturning structured response: {'rating': 5, 'comment': 'Amazing product'}\n```\n\n#### Error handling strategies\n\nYou can customize how errors are handled using the `handle_errors` parameter:\n\n**Custom error message:**\n\n```python  theme={null}\nToolStrategy(\n    schema=ProductRating,\n    handle_errors=\"Please provide a valid rating between 1-5 and include a comment.\"\n)\n```\n\nIf `handle_errors` is a string, the agent will *always* prompt the model to re-try with a fixed tool message:\n\n```\n================================= Tool Message =================================\nName: ProductRating\n\nPlease provide a valid rating between 1-5 and include a comment.\n```\n\n**Handle specific exceptions only:**\n\n```python  theme={null}\nToolStrategy(\n    schema=ProductRating,\n    handle_errors=ValueError  # Only retry on ValueError, raise others\n)\n```\n\nIf `handle_errors` is an exception type, the agent will only retry (using the default error message) if the exception raised is the specified type. In all other cases, the exception will be raised.\n\n**Handle multiple exception types:**\n\n```python  theme={null}\nToolStrategy(\n    schema=ProductRating,\n    handle_errors=(ValueError, TypeError)  # Retry on ValueError and TypeError\n)\n```\n\nIf `handle_errors` is a tuple of exceptions, the agent will only retry (using the default error message) if the exception raised is one of the specified types. In all other cases, the exception will be raised.\n\n**Custom error handler function:**\n\n```python  theme={null}\n\nfrom langchain.agents.structured_output import StructuredOutputValidationError\nfrom langchain.agents.structured_output import MultipleStructuredOutputsError\n\ndef custom_error_handler(error: Exception) -> str:\n    if isinstance(error, StructuredOutputValidationError):\n        return \"There was an issue with the format. Try again.\n    elif isinstance(error, MultipleStructuredOutputsError):\n        return \"Multiple structured outputs were returned. Pick the most relevant one.\"\n    else:\n        return f\"Error: {str(error)}\"\n\n\nagent = create_agent(\n    model=\"gpt-5\",\n    tools=[],\n    response_format=ToolStrategy(\n                        schema=Union[ContactInfo, EventDetails],\n                        handle_errors=custom_error_handler\n                    )  # Default: handle_errors=True\n)\n\nresult = agent.invoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"Extract info: John Doe (john@email.com) is organizing Tech Conference on March 15th\"}]\n})\n\nfor msg in result['messages']:\n    # If message is actually a ToolMessage object (not a dict), check its class name\n    if type(msg).__name__ == \"ToolMessage\":\n        print(msg.content)\n    # If message is a dictionary or you want a fallback\n    elif isinstance(msg, dict) and msg.get('tool_call_id'):\n        print(msg['content'])\n\n```\n\nOn `StructuredOutputValidationError`:\n\n```\n================================= Tool Message =================================\nName: ToolStrategy\n\nThere was an issue with the format. Try again.\n```\n\nOn `MultipleStructuredOutputsError`:\n\n```\n================================= Tool Message =================================\nName: ToolStrategy\n\nMultiple structured outputs were returned. Pick the most relevant one.\n```\n\nOn other errors:\n\n```\n================================= Tool Message =================================\nName: ToolStrategy\n\nError: <error message>\n```\n\n**No error handling:**\n\n```python  theme={null}\nresponse_format = ToolStrategy(\n    schema=ProductRating,\n    handle_errors=False  # All errors raised\n)\n```\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/structured-output.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 24477
}