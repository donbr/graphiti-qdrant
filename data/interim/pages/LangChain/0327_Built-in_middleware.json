{
  "title": "Built-in middleware",
  "source_url": "https://docs.langchain.com/oss/javascript/langchain/middleware/built-in",
  "content": "Prebuilt middleware for common agent use cases\n\nLangChain provides prebuilt middleware for common use cases. Each middleware is production-ready and configurable for your specific needs.\n\n## Provider-agnostic middleware\n\nThe following middleware work with any LLM provider:\n\n| Middleware                              | Description                                                                 |\n| --------------------------------------- | --------------------------------------------------------------------------- |\n| [Summarization](#summarization)         | Automatically summarize conversation history when approaching token limits. |\n| [Human-in-the-loop](#human-in-the-loop) | Pause execution for human approval of tool calls.                           |\n| [Model call limit](#model-call-limit)   | Limit the number of model calls to prevent excessive costs.                 |\n| [Tool call limit](#tool-call-limit)     | Control tool execution by limiting call counts.                             |\n| [Model fallback](#model-fallback)       | Automatically fallback to alternative models when primary fails.            |\n| [PII detection](#pii-detection)         | Detect and handle Personally Identifiable Information (PII).                |\n| [To-do list](#to-do-list)               | Equip agents with task planning and tracking capabilities.                  |\n| [LLM tool selector](#llm-tool-selector) | Use an LLM to select relevant tools before calling main model.              |\n| [Tool retry](#tool-retry)               | Automatically retry failed tool calls with exponential backoff.             |\n| [Model retry](#model-retry)             | Automatically retry failed model calls with exponential backoff.            |\n| [LLM tool emulator](#llm-tool-emulator) | Emulate tool execution using an LLM for testing purposes.                   |\n| [Context editing](#context-editing)     | Manage conversation context by trimming or clearing tool uses.              |\n\n### Summarization\n\nAutomatically summarize conversation history when approaching token limits, preserving recent messages while compressing older context. Summarization is useful for the following:\n\n* Long-running conversations that exceed context windows.\n* Multi-turn dialogues with extensive history.\n* Applications where preserving full conversation context matters.\n\n```typescript  theme={null}\nimport { createAgent, summarizationMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [weatherTool, calculatorTool],\n  middleware: [\n    summarizationMiddleware({\n      model: \"gpt-4o-mini\",\n      trigger: { tokens: 4000 },\n      keep: { messages: 20 },\n    }),\n  ],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  <Tip>\n    The `fraction` conditions for `trigger` and `keep` (shown below) rely on a chat model's [profile data](/oss/javascript/langchain/models#model-profiles) if using `langchain@1.1.0`. If data are not available, use another condition or specify manually:\n\n    ```typescript  theme={null}\n    const customProfile: ModelProfile = {\n        maxInputTokens: 100_000,\n        // ...\n    }\n    model = await initChatModel(\"...\", {\n        profile: customProfile,\n    });\n    ```\n  </Tip>\n\n  <ParamField body=\"model\" type=\"string | BaseChatModel\" required>\n    Model for generating summaries. Can be a model identifier string (e.g., `'openai:gpt-4o-mini'`) or a `BaseChatModel` instance.\n  </ParamField>\n\n  <ParamField body=\"trigger\" type=\"object | object[]\">\n    Conditions for triggering summarization. Can be:\n\n    * A single condition object (all properties must be met - AND logic)\n    * An array of condition objects (any condition must be met - OR logic)\n\n    Each condition can include:\n\n    * `fraction` (number): Fraction of model's context size (0-1)\n    * `tokens` (number): Absolute token count\n    * `messages` (number): Message count\n\n    At least one property must be specified per condition. If not provided, summarization will not trigger automatically.\n  </ParamField>\n\n  <ParamField body=\"keep\" type=\"object\" default=\"{messages: 20}\">\n    How much context to preserve after summarization. Specify exactly one of:\n\n    * `fraction` (number): Fraction of model's context size to keep (0-1)\n    * `tokens` (number): Absolute token count to keep\n    * `messages` (number): Number of recent messages to keep\n  </ParamField>\n\n  <ParamField body=\"tokenCounter\" type=\"function\">\n    Custom token counting function. Defaults to character-based counting.\n  </ParamField>\n\n  <ParamField body=\"summaryPrompt\" type=\"string\">\n    Custom prompt template for summarization. Uses built-in template if not specified. The template should include `{messages}` placeholder where conversation history will be inserted.\n  </ParamField>\n\n  <ParamField body=\"trimTokensToSummarize\" type=\"number\" default=\"4000\">\n    Maximum number of tokens to include when generating the summary. Messages will be trimmed to fit this limit before summarization.\n  </ParamField>\n\n  <ParamField body=\"summaryPrefix\" type=\"string\">\n    Prefix to add to the summary message. If not provided, a default prefix is used.\n  </ParamField>\n\n  <ParamField body=\"maxTokensBeforeSummary\" type=\"number\" deprecated>\n    **Deprecated:** Use `trigger: { tokens: value }` instead. Token threshold for triggering summarization.\n  </ParamField>\n\n  <ParamField body=\"messagesToKeep\" type=\"number\" deprecated>\n    **Deprecated:** Use `keep: { messages: value }` instead. Recent messages to preserve.\n  </ParamField>\n</Accordion>\n\n<Accordion title=\"Full example\">\n  The summarization middleware monitors message token counts and automatically summarizes older messages when thresholds are reached.\n\n  **Trigger conditions** control when summarization runs:\n\n  * Single condition object (all properties must be met - AND logic)\n  * Array of conditions (any condition must be met - OR logic)\n  * Each condition can use `fraction` (of model's context size), `tokens` (absolute count), or `messages` (message count)\n\n  **Keep conditions** control how much context to preserve (specify exactly one):\n\n  * `fraction` - Fraction of model's context size to keep\n  * `tokens` - Absolute token count to keep\n  * `messages` - Number of recent messages to keep\n\n  ```typescript  theme={null}\n  import { createAgent, summarizationMiddleware } from \"langchain\";\n\n  // Single condition\n  const agent = createAgent({\n    model: \"gpt-4o\",\n    tools: [weatherTool, calculatorTool],\n    middleware: [\n      summarizationMiddleware({\n        model: \"gpt-4o-mini\",\n        trigger: { tokens: 4000, messages: 10 },\n        keep: { messages: 20 },\n      }),\n    ],\n  });\n\n  // Multiple conditions\n  const agent2 = createAgent({\n    model: \"gpt-4o\",\n    tools: [weatherTool, calculatorTool],\n    middleware: [\n      summarizationMiddleware({\n        model: \"gpt-4o-mini\",\n        trigger: [\n          { tokens: 5000, messages: 3 },\n          { tokens: 3000, messages: 6 },\n        ],\n        keep: { messages: 20 },\n      }),\n    ],\n  });\n\n  // Using fractional limits\n  const agent3 = createAgent({\n    model: \"gpt-4o\",\n    tools: [weatherTool, calculatorTool],\n    middleware: [\n      summarizationMiddleware({\n        model: \"gpt-4o-mini\",\n        trigger: { fraction: 0.8 },\n        keep: { fraction: 0.3 },\n      }),\n    ],\n  });\n  ```\n</Accordion>\n\n### Human-in-the-loop\n\nPause agent execution for human approval, editing, or rejection of tool calls before they execute. [Human-in-the-loop](/oss/javascript/langchain/human-in-the-loop) is useful for the following:\n\n* High-stakes operations requiring human approval (e.g. database writes, financial transactions).\n* Compliance workflows where human oversight is mandatory.\n* Long-running conversations where human feedback guides the agent.\n\n<Warning>\n  Human-in-the-loop middleware requires a [checkpointer](/oss/javascript/langgraph/persistence#checkpoints) to maintain state across interruptions.\n</Warning>\n\n```typescript  theme={null}\nimport { createAgent, humanInTheLoopMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [readEmailTool, sendEmailTool],\n  middleware: [\n    humanInTheLoopMiddleware({\n      interruptOn: {\n        send_email: {\n          allowAccept: true,\n          allowEdit: true,\n          allowRespond: true,\n        },\n        read_email: false,\n      }\n    })\n  ]\n});\n```\n\n<Tip>\n  For complete examples, configuration options, and integration patterns, see the [Human-in-the-loop documentation](/oss/javascript/langchain/human-in-the-loop).\n</Tip>\n\n### Model call limit\n\nLimit the number of model calls to prevent infinite loops or excessive costs. Model call limit is useful for the following:\n\n* Preventing runaway agents from making too many API calls.\n* Enforcing cost controls on production deployments.\n* Testing agent behavior within specific call budgets.\n\n```typescript  theme={null}\nimport { createAgent, modelCallLimitMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [...],\n  middleware: [\n    modelCallLimitMiddleware({\n      threadLimit: 10,\n      runLimit: 5,\n      exitBehavior: \"end\",\n    }),\n  ],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  <ParamField body=\"threadLimit\" type=\"number\">\n    Maximum model calls across all runs in a thread. Defaults to no limit.\n  </ParamField>\n\n  <ParamField body=\"runLimit\" type=\"number\">\n    Maximum model calls per single invocation. Defaults to no limit.\n  </ParamField>\n\n  <ParamField body=\"exitBehavior\" type=\"string\" default=\"end\">\n    Behavior when limit is reached. Options: `'end'` (graceful termination) or `'error'` (throw exception)\n  </ParamField>\n</Accordion>\n\n### Tool call limit\n\nControl agent execution by limiting the number of tool calls, either globally across all tools or for specific tools. Tool call limits are useful for the following:\n\n* Preventing excessive calls to expensive external APIs.\n* Limiting web searches or database queries.\n* Enforcing rate limits on specific tool usage.\n* Protecting against runaway agent loops.\n\n```typescript  theme={null}\nimport { createAgent, toolCallLimitMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [searchTool, databaseTool],\n  middleware: [\n    toolCallLimitMiddleware({ threadLimit: 20, runLimit: 10 }),\n    toolCallLimitMiddleware({\n      toolName: \"search\",\n      threadLimit: 5,\n      runLimit: 3,\n    }),\n  ],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  <ParamField body=\"toolName\" type=\"string\">\n    Name of specific tool to limit. If not provided, limits apply to **all tools globally**.\n  </ParamField>\n\n  <ParamField body=\"threadLimit\" type=\"number\">\n    Maximum tool calls across all runs in a thread (conversation). Persists across multiple invocations with the same thread ID. Requires a checkpointer to maintain state. `undefined` means no thread limit.\n  </ParamField>\n\n  <ParamField body=\"runLimit\" type=\"number\">\n    Maximum tool calls per single invocation (one user message → response cycle). Resets with each new user message. `undefined` means no run limit.\n\n    **Note:** At least one of `threadLimit` or `runLimit` must be specified.\n  </ParamField>\n\n  <ParamField body=\"exitBehavior\" type=\"string\" default=\"continue\">\n    Behavior when limit is reached:\n\n    * `'continue'` (default) - Block exceeded tool calls with error messages, let other tools and the model continue. The model decides when to end based on the error messages.\n    * `'error'` - Throw a `ToolCallLimitExceededError` exception, stopping execution immediately\n    * `'end'` - Stop execution immediately with a ToolMessage and AI message for the exceeded tool call. Only works when limiting a single tool; throws error if other tools have pending calls.\n  </ParamField>\n</Accordion>\n\n<Accordion title=\"Full example\">\n  Specify limits with:\n\n  * **Thread limit** - Max calls across all runs in a conversation (requires checkpointer)\n  * **Run limit** - Max calls per single invocation (resets each turn)\n\n  Exit behaviors:\n\n  * `'continue'` (default) - Block exceeded calls with error messages, agent continues\n  * `'error'` - Raise exception immediately\n  * `'end'` - Stop with ToolMessage + AI message (single-tool scenarios only)\n\n  ```typescript  theme={null}\n  import { createAgent, toolCallLimitMiddleware } from \"langchain\";\n\n  const globalLimiter = toolCallLimitMiddleware({ threadLimit: 20, runLimit: 10 });\n  const searchLimiter = toolCallLimitMiddleware({ toolName: \"search\", threadLimit: 5, runLimit: 3 });\n  const databaseLimiter = toolCallLimitMiddleware({ toolName: \"query_database\", threadLimit: 10 });\n  const strictLimiter = toolCallLimitMiddleware({ toolName: \"scrape_webpage\", runLimit: 2, exitBehavior: \"error\" });\n\n  const agent = createAgent({\n    model: \"gpt-4o\",\n    tools: [searchTool, databaseTool, scraperTool],\n    middleware: [globalLimiter, searchLimiter, databaseLimiter, strictLimiter],\n  });\n  ```\n</Accordion>\n\n### Model fallback\n\nAutomatically fallback to alternative models when the primary model fails. Model fallback is useful for the following:\n\n* Building resilient agents that handle model outages.\n* Cost optimization by falling back to cheaper models.\n* Provider redundancy across OpenAI, Anthropic, etc.\n\n```typescript  theme={null}\nimport { createAgent, modelFallbackMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [...],\n  middleware: [\n    modelFallbackMiddleware(\n      \"gpt-4o-mini\",\n      \"claude-3-5-sonnet-20241022\"\n    ),\n  ],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  The middleware accepts a variable number of string arguments representing fallback models in order:\n\n  <ParamField body=\"...models\" type=\"string[]\" required>\n    One or more fallback model strings to try in order when the primary model fails\n\n    ```typescript  theme={null}\n    modelFallbackMiddleware(\n      \"first-fallback-model\",\n      \"second-fallback-model\",\n      // ... more models\n    )\n    ```\n  </ParamField>\n</Accordion>\n\n### PII detection\n\nDetect and handle Personally Identifiable Information (PII) in conversations using configurable strategies. PII detection is useful for the following:\n\n* Healthcare and financial applications with compliance requirements.\n* Customer service agents that need to sanitize logs.\n* Any application handling sensitive user data.\n\n```typescript  theme={null}\nimport { createAgent, piiMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [...],\n  middleware: [\n    piiMiddleware(\"email\", { strategy: \"redact\", applyToInput: true }),\n    piiMiddleware(\"credit_card\", { strategy: \"mask\", applyToInput: true }),\n  ],\n});\n```\n\n#### Custom PII types\n\nYou can create custom PII types by providing a `detector` parameter. This allows you to detect patterns specific to your use case beyond the built-in types.\n\n**Three ways to create custom detectors:**\n\n1. **Regex pattern string** - Simple pattern matching\n\n2. **RegExp object** - More control over regex flags\n\n3. **Custom function** - Complex detection logic with validation\n\n```typescript  theme={null}\nimport { createAgent, piiMiddleware, type PIIMatch } from \"langchain\";\n\n// Method 1: Regex pattern string\nconst agent1 = createAgent({\n  model: \"gpt-4o\",\n  tools: [...],\n  middleware: [\n    piiMiddleware(\"api_key\", {\n      detector: \"sk-[a-zA-Z0-9]{32}\",\n      strategy: \"block\",\n    }),\n  ],\n});\n\n// Method 2: RegExp object\nconst agent2 = createAgent({\n  model: \"gpt-4o\",\n  tools: [...],\n  middleware: [\n    piiMiddleware(\"phone_number\", {\n      detector: /\\+?\\d{1,3}[\\s.-]?\\d{3,4}[\\s.-]?\\d{4}/,\n      strategy: \"mask\",\n    }),\n  ],\n});\n\n// Method 3: Custom detector function\nfunction detectSSN(content: string): PIIMatch[] {\n  const matches: PIIMatch[] = [];\n  const pattern = /\\d{3}-\\d{2}-\\d{4}/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = pattern.exec(content)) !== null) {\n    const ssn = match[0];\n    // Validate: first 3 digits shouldn't be 000, 666, or 900-999\n    const firstThree = parseInt(ssn.substring(0, 3), 10);\n    if (firstThree !== 0 && firstThree !== 666 && !(firstThree >= 900 && firstThree <= 999)) {\n      matches.push({\n        text: ssn,\n        start: match.index ?? 0,\n        end: (match.index ?? 0) + ssn.length,\n      });\n    }\n  }\n  return matches;\n}\n\nconst agent3 = createAgent({\n  model: \"gpt-4o\",\n  tools: [...],\n  middleware: [\n    piiMiddleware(\"ssn\", {\n      detector: detectSSN,\n      strategy: \"hash\",\n    }),\n  ],\n});\n```\n\n**Custom detector function signature:**\n\nThe detector function must accept a string (content) and return matches:\n\nReturns an array of `PIIMatch` objects:\n\n```typescript  theme={null}\ninterface PIIMatch {\n  text: string;    // The matched text\n  start: number;   // Start index in content\n  end: number;      // End index in content\n}\n\nfunction detector(content: string): PIIMatch[] {\n  return [\n    { text: \"matched_text\", start: 0, end: 12 },\n    // ... more matches\n  ];\n}\n```\n\n<Tip>\n  For custom detectors:\n\n  * Use regex strings for simple patterns\n  * Use RegExp objects when you need flags (e.g., case-insensitive matching)\n  * Use custom functions when you need validation logic beyond pattern matching\n  * Custom functions give you full control over detection logic and can implement complex validation rules\n</Tip>\n\n<Accordion title=\"Configuration options\">\n  <ParamField body=\"piiType\" type=\"string\" required>\n    Type of PII to detect. Can be a built-in type (`email`, `credit_card`, `ip`, `mac_address`, `url`) or a custom type name.\n  </ParamField>\n\n  <ParamField body=\"strategy\" type=\"string\" default=\"redact\">\n    How to handle detected PII. Options:\n\n    * `'block'` - Throw error when detected\n    * `'redact'` - Replace with `[REDACTED_TYPE]`\n    * `'mask'` - Partially mask (e.g., `****-****-****-1234`)\n    * `'hash'` - Replace with deterministic hash (e.g., `<email_hash:a1b2c3d4>`)\n  </ParamField>\n\n  <ParamField body=\"detector\" type=\"RegExp | string | function\">\n    Custom detector. Can be:\n\n    * `RegExp` - Regex pattern for matching\n    * `string` - Regex pattern string (e.g., `\"sk-[a-zA-Z0-9]{32}\"`)\n    * `function` - Custom detector function `(content: string) => PIIMatch[]`\n\n    If not provided, uses built-in detector for the PII type.\n  </ParamField>\n\n  <ParamField body=\"applyToInput\" type=\"boolean\" default=\"true\">\n    Check user messages before model call\n  </ParamField>\n\n  <ParamField body=\"applyToOutput\" type=\"boolean\" default=\"false\">\n    Check AI messages after model call\n  </ParamField>\n\n  <ParamField body=\"applyToToolResults\" type=\"boolean\" default=\"false\">\n    Check tool result messages after execution\n  </ParamField>\n</Accordion>\n\n### To-do list\n\nEquip agents with task planning and tracking capabilities for complex multi-step tasks. To-do lists are useful for the following:\n\n* Complex multi-step tasks requiring coordination across multiple tools.\n* Long-running operations where progress visibility is important.\n\n<Note>\n  This middleware automatically provides agents with a `write_todos` tool and system prompts to guide effective task planning.\n</Note>\n\n```typescript  theme={null}\nimport { createAgent, todoListMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [readFile, writeFile, runTests],\n  middleware: [todoListMiddleware()],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  No configuration options available (uses defaults).\n</Accordion>\n\n### LLM tool selector\n\nUse an LLM to intelligently select relevant tools before calling the main model. LLM tool selectors are useful for the following:\n\n* Agents with many tools (10+) where most aren't relevant per query.\n* Reducing token usage by filtering irrelevant tools.\n* Improving model focus and accuracy.\n\nThis middleware uses structured output to ask an LLM which tools are most relevant for the current query. The structured output schema defines the available tool names and descriptions. Model providers often add this structured output information to the system prompt behind the scenes.\n\n```typescript  theme={null}\nimport { createAgent, llmToolSelectorMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [tool1, tool2, tool3, tool4, tool5, ...],\n  middleware: [\n    llmToolSelectorMiddleware({\n      model: \"gpt-4o-mini\",\n      maxTools: 3,\n      alwaysInclude: [\"search\"],\n    }),\n  ],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  <ParamField body=\"model\" type=\"string | BaseChatModel\">\n    Model for tool selection. Can be a model identifier string (e.g., `'openai:gpt-4o-mini'`) or a `BaseChatModel` instance. Defaults to the agent's main model.\n  </ParamField>\n\n  <ParamField body=\"systemPrompt\" type=\"string\">\n    Instructions for the selection model. Uses built-in prompt if not specified.\n  </ParamField>\n\n  <ParamField body=\"maxTools\" type=\"number\">\n    Maximum number of tools to select. If the model selects more, only the first maxTools will be used. No limit if not specified.\n  </ParamField>\n\n  <ParamField body=\"alwaysInclude\" type=\"string[]\">\n    Tool names to always include regardless of selection. These do not count against the maxTools limit.\n  </ParamField>\n</Accordion>\n\n### Tool retry\n\nAutomatically retry failed tool calls with configurable exponential backoff. Tool retry is useful for the following:\n\n* Handling transient failures in external API calls.\n* Improving reliability of network-dependent tools.\n* Building resilient agents that gracefully handle temporary errors.\n\n**API reference:** [`toolRetryMiddleware`](https://reference.langchain.com/javascript/functions/langchain.index.toolRetryMiddleware.html)\n\n```typescript  theme={null}\nimport { createAgent, toolRetryMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [searchTool, databaseTool],\n  middleware: [\n    toolRetryMiddleware({\n      maxRetries: 3,\n      backoffFactor: 2.0,\n      initialDelayMs: 1000,\n    }),\n  ],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  <ParamField body=\"maxRetries\" type=\"number\" default=\"2\">\n    Maximum number of retry attempts after the initial call (3 total attempts with default). Must be >= 0.\n  </ParamField>\n\n  <ParamField body=\"tools\" type=\"(ClientTool | ServerTool | string)[]\">\n    Optional array of tools or tool names to apply retry logic to. Can be a list of `BaseTool` instances or tool name strings. If `undefined`, applies to all tools.\n  </ParamField>\n\n  <ParamField body=\"retryOn\" type=\"((error: Error) => boolean) | (new (...args: any[]) => Error)[]\" default=\"() => true\">\n    Either an array of error constructors to retry on, or a function that takes an error and returns `true` if it should be retried. Default is to retry on all errors.\n  </ParamField>\n\n  <ParamField body=\"onFailure\" type=\"'error' | 'continue' | ((error: Error) => string)\" default=\"continue\">\n    Behavior when all retries are exhausted. Options:\n\n    * `'continue'` (default) - Return a `ToolMessage` with error details, allowing the LLM to handle the failure and potentially recover\n    * `'error'` - Re-raise the exception, stopping agent execution\n    * Custom function - Function that takes the exception and returns a string for the `ToolMessage` content, allowing custom error formatting\n\n    **Deprecated values:** `'raise'` (use `'error'` instead) and `'return_message'` (use `'continue'` instead). These deprecated values still work but will show a warning.\n  </ParamField>\n\n  <ParamField body=\"backoffFactor\" type=\"number\" default=\"2.0\">\n    Multiplier for exponential backoff. Each retry waits `initialDelayMs * (backoffFactor ** retryNumber)` milliseconds. Set to `0.0` for constant delay. Must be >= 0.\n  </ParamField>\n\n  <ParamField body=\"initialDelayMs\" type=\"number\" default=\"1000\">\n    Initial delay in milliseconds before first retry. Must be >= 0.\n  </ParamField>\n\n  <ParamField body=\"maxDelayMs\" type=\"number\" default=\"60000\">\n    Maximum delay in milliseconds between retries (caps exponential backoff growth). Must be >= 0.\n  </ParamField>\n\n  <ParamField body=\"jitter\" type=\"boolean\" default=\"true\">\n    Whether to add random jitter (`±25%`) to delay to avoid thundering herd\n  </ParamField>\n</Accordion>\n\n<Accordion title=\"Full example\">\n  The middleware automatically retries failed tool calls with exponential backoff.\n\n  **Key configuration:**\n\n  * `maxRetries` - Number of retry attempts (default: 2)\n  * `backoffFactor` - Multiplier for exponential backoff (default: 2.0)\n  * `initialDelayMs` - Starting delay in milliseconds (default: 1000ms)\n  * `maxDelayMs` - Cap on delay growth (default: 60000ms)\n  * `jitter` - Add random variation (default: true)\n\n  **Failure handling:**\n\n  * `onFailure: \"continue\"` (default) - Return error message\n  * `onFailure: \"error\"` - Re-raise exception\n  * Custom function - Function returning error message\n\n  ```typescript  theme={null}\n  import { createAgent, toolRetryMiddleware } from \"langchain\";\n  import { tool } from \"@langchain/core/tools\";\n  import { z } from \"zod\";\n\n  // Basic usage with default settings (2 retries, exponential backoff)\n  const agent = createAgent({\n    model: \"gpt-4o\",\n    tools: [searchTool, databaseTool],\n    middleware: [toolRetryMiddleware()],\n  });\n\n  // Retry specific exceptions only\n  const retry = toolRetryMiddleware({\n    maxRetries: 4,\n    retryOn: [TimeoutError, NetworkError],\n    backoffFactor: 1.5,\n  });\n\n  // Custom exception filtering\n  function shouldRetry(error: Error): boolean {\n    // Only retry on 5xx errors\n    if (error.name === \"HTTPError\" && \"statusCode\" in error) {\n      const statusCode = (error as any).statusCode;\n      return 500 <= statusCode && statusCode < 600;\n    }\n    return false;\n  }\n\n  const retryWithFilter = toolRetryMiddleware({\n    maxRetries: 3,\n    retryOn: shouldRetry,\n  });\n\n  // Apply to specific tools with custom error handling\n  const formatError = (error: Error) =>\n    \"Database temporarily unavailable. Please try again later.\";\n\n  const retrySpecificTools = toolRetryMiddleware({\n    maxRetries: 4,\n    tools: [\"search_database\"],\n    onFailure: formatError,\n  });\n\n  // Apply to specific tools using BaseTool instances\n  const searchDatabase = tool(\n    async ({ query }) => {\n      // Search implementation\n      return results;\n    },\n    {\n      name: \"search_database\",\n      description: \"Search the database\",\n      schema: z.object({ query: z.string() }),\n    }\n  );\n\n  const retryWithToolInstance = toolRetryMiddleware({\n    maxRetries: 4,\n    tools: [searchDatabase], // Pass BaseTool instance\n  });\n\n  // Constant backoff (no exponential growth)\n  const constantBackoff = toolRetryMiddleware({\n    maxRetries: 5,\n    backoffFactor: 0.0, // No exponential growth\n    initialDelayMs: 2000, // Always wait 2 seconds\n  });\n\n  // Raise exception on failure\n  const strictRetry = toolRetryMiddleware({\n    maxRetries: 2,\n    onFailure: \"error\", // Re-raise exception instead of returning message\n  });\n  ```\n</Accordion>\n\n### Model retry\n\nAutomatically retry failed model calls with configurable exponential backoff. Model retry is useful for the following:\n\n* Handling transient failures in model API calls.\n* Improving reliability of network-dependent model requests.\n* Building resilient agents that gracefully handle temporary model errors.\n\n**API reference:** [`modelRetryMiddleware`](https://reference.langchain.com/javascript/functions/langchain.index.modelRetryMiddleware.html)\n\n```typescript  theme={null}\nimport { createAgent, modelRetryMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [searchTool, databaseTool],\n  middleware: [\n    modelRetryMiddleware({\n      maxRetries: 3,\n      backoffFactor: 2.0,\n      initialDelayMs: 1000,\n    }),\n  ],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  <ParamField body=\"maxRetries\" type=\"number\" default=\"2\">\n    Maximum number of retry attempts after the initial call (3 total attempts with default). Must be >= 0.\n  </ParamField>\n\n  <ParamField body=\"retryOn\" type=\"((error: Error) => boolean) | (new (...args: any[]) => Error)[]\" default=\"() => true\">\n    Either an array of error constructors to retry on, or a function that takes an error and returns `true` if it should be retried. Default is to retry on all errors.\n  </ParamField>\n\n  <ParamField body=\"onFailure\" type=\"'error' | 'continue' | ((error: Error) => string)\" default=\"continue\">\n    Behavior when all retries are exhausted. Options:\n\n    * `'continue'` (default) - Return an `AIMessage` with error details, allowing the agent to potentially handle the failure gracefully\n    * `'error'` - Re-raise the exception, stopping agent execution\n    * Custom function - Function that takes the exception and returns a string for the `AIMessage` content, allowing custom error formatting\n  </ParamField>\n\n  <ParamField body=\"backoffFactor\" type=\"number\" default=\"2.0\">\n    Multiplier for exponential backoff. Each retry waits `initialDelayMs * (backoffFactor ** retryNumber)` milliseconds. Set to `0.0` for constant delay. Must be >= 0.\n  </ParamField>\n\n  <ParamField body=\"initialDelayMs\" type=\"number\" default=\"1000\">\n    Initial delay in milliseconds before first retry. Must be >= 0.\n  </ParamField>\n\n  <ParamField body=\"maxDelayMs\" type=\"number\" default=\"60000\">\n    Maximum delay in milliseconds between retries (caps exponential backoff growth). Must be >= 0.\n  </ParamField>\n\n  <ParamField body=\"jitter\" type=\"boolean\" default=\"true\">\n    Whether to add random jitter (`±25%`) to delay to avoid thundering herd\n  </ParamField>\n</Accordion>\n\n<Accordion title=\"Full example\">\n  The middleware automatically retries failed model calls with exponential backoff.\n\n  ```typescript  theme={null}\n  import { createAgent, modelRetryMiddleware } from \"langchain\";\n\n  // Basic usage with default settings (2 retries, exponential backoff)\n  const agent = createAgent({\n    model: \"gpt-4o\",\n    tools: [searchTool],\n    middleware: [modelRetryMiddleware()],\n  });\n\n  class TimeoutError extends Error {\n      // ...\n  }\n  class NetworkError extends Error {\n      // ...\n  }\n\n  // Retry specific exceptions only\n  const retry = modelRetryMiddleware({\n    maxRetries: 4,\n    retryOn: [TimeoutError, NetworkError],\n    backoffFactor: 1.5,\n  });\n\n  // Custom exception filtering\n  function shouldRetry(error: Error): boolean {\n    // Only retry on rate limit errors\n    if (error.name === \"RateLimitError\") {\n      return true;\n    }\n    // Or check for specific HTTP status codes\n    if (error.name === \"HTTPError\" && \"statusCode\" in error) {\n      const statusCode = (error as any).statusCode;\n      return statusCode === 429 || statusCode === 503;\n    }\n    return false;\n  }\n\n  const retryWithFilter = modelRetryMiddleware({\n    maxRetries: 3,\n    retryOn: shouldRetry,\n  });\n\n  // Return error message instead of raising\n  const retryContinue = modelRetryMiddleware({\n    maxRetries: 4,\n    onFailure: \"continue\", // Return AIMessage with error instead of throwing\n  });\n\n  // Custom error message formatting\n  const formatError = (error: Error) =>\n    `Model call failed: ${error.message}. Please try again later.`;\n\n  const retryWithFormatter = modelRetryMiddleware({\n    maxRetries: 4,\n    onFailure: formatError,\n  });\n\n  // Constant backoff (no exponential growth)\n  const constantBackoff = modelRetryMiddleware({\n    maxRetries: 5,\n    backoffFactor: 0.0, // No exponential growth\n    initialDelayMs: 2000, // Always wait 2 seconds\n  });\n\n  // Raise exception on failure\n  const strictRetry = modelRetryMiddleware({\n    maxRetries: 2,\n    onFailure: \"error\", // Re-raise exception instead of returning message\n  });\n  ```\n</Accordion>\n\n### LLM tool emulator\n\nEmulate tool execution using an LLM for testing purposes, replacing actual tool calls with AI-generated responses. LLM tool emulators are useful for the following:\n\n* Testing agent behavior without executing real tools.\n* Developing agents when external tools are unavailable or expensive.\n* Prototyping agent workflows before implementing actual tools.\n\n```typescript  theme={null}\nimport { createAgent, toolEmulatorMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [getWeather, searchDatabase, sendEmail],\n  middleware: [\n    toolEmulatorMiddleware(), // Emulate all tools\n  ],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  <ParamField body=\"tools\" type=\"(string | ClientTool | ServerTool)[]\">\n    List of tool names (string) or tool instances to emulate. If `undefined` (default), ALL tools will be emulated. If empty array `[]`, no tools will be emulated. If array with tool names/instances, only those tools will be emulated.\n  </ParamField>\n\n  <ParamField body=\"model\" type=\"string | BaseChatModel\">\n    Model to use for generating emulated tool responses. Can be a model identifier string (e.g., `'anthropic:claude-sonnet-4-5-20250929'`) or a `BaseChatModel` instance. Defaults to the agent's model if not specified.\n  </ParamField>\n</Accordion>\n\n<Accordion title=\"Full example\">\n  The middleware uses an LLM to generate plausible responses for tool calls instead of executing the actual tools.\n\n  ```typescript  theme={null}\n  import { createAgent, toolEmulatorMiddleware, tool } from \"langchain\";\n  import * as z from \"zod\";\n\n  const getWeather = tool(\n    async ({ location }) => `Weather in ${location}`,\n    {\n      name: \"get_weather\",\n      description: \"Get the current weather for a location\",\n      schema: z.object({ location: z.string() }),\n    }\n  );\n\n  const sendEmail = tool(\n    async ({ to, subject, body }) => \"Email sent\",\n    {\n      name: \"send_email\",\n      description: \"Send an email\",\n      schema: z.object({\n        to: z.string(),\n        subject: z.string(),\n        body: z.string(),\n      }),\n    }\n  );\n\n  // Emulate all tools (default behavior)\n  const agent = createAgent({\n    model: \"gpt-4o\",\n    tools: [getWeather, sendEmail],\n    middleware: [toolEmulatorMiddleware()],\n  });\n\n  // Emulate specific tools by name\n  const agent2 = createAgent({\n    model: \"gpt-4o\",\n    tools: [getWeather, sendEmail],\n    middleware: [\n      toolEmulatorMiddleware({\n        tools: [\"get_weather\"],\n      }),\n    ],\n  });\n\n  // Emulate specific tools by passing tool instances\n  const agent3 = createAgent({\n    model: \"gpt-4o\",\n    tools: [getWeather, sendEmail],\n    middleware: [\n      toolEmulatorMiddleware({\n        tools: [getWeather],\n      }),\n    ],\n  });\n\n  // Use custom model for emulation\n  const agent5 = createAgent({\n    model: \"gpt-4o\",\n    tools: [getWeather, sendEmail],\n    middleware: [\n      toolEmulatorMiddleware({\n        model: \"anthropic:claude-sonnet-4-5-20250929\",\n      }),\n    ],\n  });\n  ```\n</Accordion>\n\n### Context editing\n\nManage conversation context by clearing older tool call outputs when token limits are reached, while preserving recent results. This helps keep context windows manageable in long conversations with many tool calls. Context editing is useful for the following:\n\n* Long conversations with many tool calls that exceed token limits\n* Reducing token costs by removing older tool outputs that are no longer relevant\n* Maintaining only the most recent N tool results in context\n\n```typescript  theme={null}\nimport { createAgent, contextEditingMiddleware, ClearToolUsesEdit } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [...],\n  middleware: [\n    contextEditingMiddleware({\n      edits: [\n        new ClearToolUsesEdit({\n          triggerTokens: 100000,\n          keep: 3,\n        }),\n      ],\n    }),\n  ],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  <ParamField body=\"edits\" type=\"ContextEdit[]\" default=\"[new ClearToolUsesEdit()]\">\n    Array of [`ContextEdit`](https://reference.langchain.com/javascript/interfaces/langchain.index.ContextEdit.html) strategies to apply\n  </ParamField>\n\n  **[`ClearToolUsesEdit`](https://reference.langchain.com/javascript/classes/langchain.index.ClearToolUsesEdit.html) options:**\n\n  <ParamField body=\"triggerTokens\" type=\"number\" default=\"100000\">\n    Token count that triggers the edit. When the conversation exceeds this token count, older tool outputs will be cleared.\n  </ParamField>\n\n  <ParamField body=\"clearAtLeast\" type=\"number\" default=\"0\">\n    Minimum number of tokens to reclaim when the edit runs. If set to 0, clears as much as needed.\n  </ParamField>\n\n  <ParamField body=\"keep\" type=\"number\" default=\"3\">\n    Number of most recent tool results that must be preserved. These will never be cleared.\n  </ParamField>\n\n  <ParamField body=\"clearToolInputs\" type=\"boolean\" default=\"false\">\n    Whether to clear the originating tool call parameters on the AI message. When `true`, tool call arguments are replaced with empty objects.\n  </ParamField>\n\n  <ParamField body=\"excludeTools\" type=\"string[]\" default=\"[]\">\n    List of tool names to exclude from clearing. These tools will never have their outputs cleared.\n  </ParamField>\n\n  <ParamField body=\"placeholder\" type=\"string\" default=\"[cleared]\">\n    Placeholder text inserted for cleared tool outputs. This replaces the original tool message content.\n  </ParamField>\n</Accordion>\n\n<Accordion title=\"Full example\">\n  The middleware applies context editing strategies when token limits are reached. The most common strategy is `ClearToolUsesEdit`, which clears older tool results while preserving recent ones.\n\n  **How it works:**\n\n  1. Monitor token count in conversation\n  2. When threshold is reached, clear older tool outputs\n  3. Keep most recent N tool results\n  4. Optionally preserve tool call arguments for context\n\n  ```typescript  theme={null}\n  import { createAgent, contextEditingMiddleware, ClearToolUsesEdit } from \"langchain\";\n\n  const agent = createAgent({\n    model: \"gpt-4o\",\n    tools: [searchTool, calculatorTool, databaseTool],\n    middleware: [\n      contextEditingMiddleware({\n        edits: [\n          new ClearToolUsesEdit({\n            triggerTokens: 2000,\n            keep: 3,\n            clearToolInputs: false,\n            excludeTools: [],\n            placeholder: \"[cleared]\",\n          }),\n        ],\n      }),\n    ],\n  });\n  ```\n</Accordion>\n\n## Provider-specific middleware\n\nThese middleware are optimized for specific LLM providers.\n\n### Anthropic\n\nMiddleware specifically designed for Anthropic's Claude models.\n\n| Middleware                        | Description                                        |\n| --------------------------------- | -------------------------------------------------- |\n| [Prompt caching](#prompt-caching) | Reduce costs by caching repetitive prompt prefixes |\n\n#### Prompt caching\n\nReduce costs and latency by caching static or repetitive prompt content (like system prompts, tool definitions, and conversation history) on Anthropic's servers. This middleware implements a **conversational caching strategy** that places cache breakpoints after the most recent message, allowing the entire conversation history (including the latest user message) to be cached and reused in subsequent API calls. Prompt caching is useful for the following:\n\n* Applications with long, static system prompts that don't change between requests\n* Agents with many tool definitions that remain constant across invocations\n* Conversations where early message history is reused across multiple turns\n* High-volume deployments where reducing API costs and latency is critical\n\n<Info>\n  Learn more about [Anthropic prompt caching](https://platform.claude.com/docs/en/build-with-claude/prompt-caching#cache-limitations) strategies and limitations.\n</Info>\n\n```typescript  theme={null}\nimport { createAgent, anthropicPromptCachingMiddleware } from \"langchain\";\n\nconst agent = createAgent({\n  model: \"claude-sonnet-4-5-20250929\",\n  prompt: \"<Your long system prompt here>\",\n  middleware: [anthropicPromptCachingMiddleware({ ttl: \"5m\" })],\n});\n```\n\n<Accordion title=\"Configuration options\">\n  <ParamField body=\"ttl\" type=\"string\" default=\"5m\">\n    Time to live for cached content. Valid values: `'5m'` or `'1h'`\n  </ParamField>\n</Accordion>\n\n<Accordion title=\"Full example\">\n  The middleware caches content up to and including the latest message in each request. On subsequent requests within the TTL window (5 minutes or 1 hour), previously seen content is retrieved from cache rather than reprocessed, significantly reducing costs and latency.\n\n  **How it works:**\n\n  1. First request: System prompt, tools, and the user message \"Hi, my name is Bob\" are sent to the API and cached\n  2. Second request: The cached content (system prompt, tools, and first message) is retrieved from cache. Only the new message \"What's my name?\" needs to be processed, plus the model's response from the first request\n  3. This pattern continues for each turn, with each request reusing the cached conversation history\n\n  ```typescript  theme={null}\n  import { createAgent, HumanMessage, anthropicPromptCachingMiddleware } from \"langchain\";\n\n  const LONG_PROMPT = `\n  Please be a helpful assistant.\n\n  <Lots more context ...>\n  `;\n\n  const agent = createAgent({\n    model: \"claude-sonnet-4-5-20250929\",\n    prompt: LONG_PROMPT,\n    middleware: [anthropicPromptCachingMiddleware({ ttl: \"5m\" })],\n  });\n\n  // First invocation: Creates cache with system prompt, tools, and \"Hi, my name is Bob\"\n  await agent.invoke({\n    messages: [new HumanMessage(\"Hi, my name is Bob\")]\n  });\n\n  // Second invocation: Reuses cached system prompt, tools, and previous messages\n  // Only processes the new message \"What's my name?\" and the previous AI response\n  const result = await agent.invoke({\n    messages: [new HumanMessage(\"What's my name?\")]\n  });\n  ```\n</Accordion>\n\n### OpenAI\n\nMiddleware specifically designed for OpenAI models.\n\n| Middleware                                | Description                                               |\n| ----------------------------------------- | --------------------------------------------------------- |\n| [Content moderation](#content-moderation) | Moderate agent traffic using OpenAI's moderation endpoint |\n\n#### Content moderation\n\nModerate agent traffic (user input, model output, and tool results) using OpenAI's moderation endpoint to detect and handle unsafe content. Content moderation is useful for the following:\n\n* Applications requiring content safety and compliance\n* Filtering harmful, hateful, or inappropriate content\n* Customer-facing agents that need safety guardrails\n* Meeting platform moderation requirements\n\n<Info>\n  Learn more about [OpenAI's moderation models](https://platform.openai.com/docs/guides/moderation) and categories.\n</Info>\n\n<Accordion title=\"Configuration options\" />\n\n<Accordion title=\"Full example\">\n  The middleware integrates OpenAI's moderation endpoint to check content at different stages:\n\n  **Moderation stages:**\n\n  * `check_input` - User messages before model call\n  * `check_output` - AI messages after model call\n  * `check_tool_results` - Tool outputs before model call\n\n  **Exit behaviors:**\n\n  * `'end'` (default) - Stop execution with violation message\n  * `'error'` - Raise exception for application handling\n  * `'replace'` - Replace flagged content and continue\n</Accordion>\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/middleware/built-in.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 43436
}