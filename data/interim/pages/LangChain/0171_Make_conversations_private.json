{
  "title": "Make conversations private",
  "source_url": "https://docs.langchain.com/langsmith/resource-auth",
  "content": "In this tutorial, you will extend [the chatbot created in the last tutorial](/langsmith/set-up-custom-auth) to give each user their own private conversations. You'll add [resource-level access control](/langsmith/auth#single-owner-resources) so users can only see their own threads.\n\n<img src=\"https://mintcdn.com/langchain-5e9cc07a/IMK8wJkjSpMCGODD/langsmith/images/authorization.png?fit=max&auto=format&n=IMK8wJkjSpMCGODD&q=85&s=8daa07dd8efb13d7f9d7aa35117b2138\" alt=\"Authorization flow: after authentication, an authorization handler tags each resource with owner=user id and returns a filter so users only see their own threads.\" data-og-width=\"2617\" width=\"2617\" data-og-height=\"1673\" height=\"1673\" data-path=\"langsmith/images/authorization.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/IMK8wJkjSpMCGODD/langsmith/images/authorization.png?w=280&fit=max&auto=format&n=IMK8wJkjSpMCGODD&q=85&s=a617e2e62772c307a7b69a78e627ac40 280w, https://mintcdn.com/langchain-5e9cc07a/IMK8wJkjSpMCGODD/langsmith/images/authorization.png?w=560&fit=max&auto=format&n=IMK8wJkjSpMCGODD&q=85&s=c978257553e23b1cb19348959ed72ffc 560w, https://mintcdn.com/langchain-5e9cc07a/IMK8wJkjSpMCGODD/langsmith/images/authorization.png?w=840&fit=max&auto=format&n=IMK8wJkjSpMCGODD&q=85&s=62370abd0f9ca0093d252fd9c1f7cda8 840w, https://mintcdn.com/langchain-5e9cc07a/IMK8wJkjSpMCGODD/langsmith/images/authorization.png?w=1100&fit=max&auto=format&n=IMK8wJkjSpMCGODD&q=85&s=6388bdfb9d7a61105c32683b8b750db1 1100w, https://mintcdn.com/langchain-5e9cc07a/IMK8wJkjSpMCGODD/langsmith/images/authorization.png?w=1650&fit=max&auto=format&n=IMK8wJkjSpMCGODD&q=85&s=95ff1d87241c5b94fd38483350159abb 1650w, https://mintcdn.com/langchain-5e9cc07a/IMK8wJkjSpMCGODD/langsmith/images/authorization.png?w=2500&fit=max&auto=format&n=IMK8wJkjSpMCGODD&q=85&s=bd94714727ddb6d79a49109d4ca7014f 2500w\" />\n\n## Prerequisites\n\nBefore you start this tutorial, ensure you have the [bot from the first tutorial](/langsmith/set-up-custom-auth) running without errors.\n\n## 1. Add resource authorization\n\nRecall that in the last tutorial, the [`Auth`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth) object lets you register an [authentication function](/langsmith/auth#authentication), which LangSmith uses to validate the bearer tokens in incoming requests. Now you'll use it to register an **authorization** handler.\n\nAuthorization handlers are functions that run **after** authentication succeeds. These handlers can add [metadata](/langsmith/auth#filter-operations) to resources (like who owns them) and filter what each user can see.\n\nUpdate your `src/security/auth.py` and add one authorization handler to run on every request:\n\n```python {highlight={29-39}} title=\"src/security/auth.py\" theme={null}\nfrom langgraph_sdk import Auth\n\n# Keep our test users from the previous tutorial\nVALID_TOKENS = {\n    \"user1-token\": {\"id\": \"user1\", \"name\": \"Alice\"},\n    \"user2-token\": {\"id\": \"user2\", \"name\": \"Bob\"},\n}\n\nauth = Auth()\n\n\n@auth.authenticate\nasync def get_current_user(authorization: str | None) -> Auth.types.MinimalUserDict:\n    \"\"\"Our authentication handler from the previous tutorial.\"\"\"\n    assert authorization\n    scheme, token = authorization.split()\n    assert scheme.lower() == \"bearer\"\n\n    if token not in VALID_TOKENS:\n        raise Auth.exceptions.HTTPException(status_code=401, detail=\"Invalid token\")\n\n    user_data = VALID_TOKENS[token]\n    return {\n        \"identity\": user_data[\"id\"],\n    }\n\n\n@auth.on\nasync def add_owner(\n    ctx: Auth.types.AuthContext,  # Contains info about the current user\n    value: dict,  # The resource being created/accessed\n):\n    \"\"\"Make resources private to their creator.\"\"\"\n    # Examples:\n    # ctx: AuthContext(\n    #     permissions=[],\n    #     user=ProxyUser(\n    #         identity='user1',\n    #         is_authenticated=True,\n    #         display_name='user1'\n    #     ),\n    #     resource='threads',\n    #     action='create_run'\n    # )\n    # value:\n    # {\n    #     'thread_id': UUID('1e1b2733-303f-4dcd-9620-02d370287d72'),\n    #     'assistant_id': UUID('fe096781-5601-53d2-b2f6-0d3403f7e9ca'),\n    #     'run_id': UUID('1efbe268-1627-66d4-aa8d-b956b0f02a41'),\n    #     'status': 'pending',\n    #     'metadata': {},\n    #     'prevent_insert_if_inflight': True,\n    #     'multitask_strategy': 'reject',\n    #     'if_not_exists': 'reject',\n    #     'after_seconds': 0,\n    #     'kwargs': {\n    #         'input': {'messages': [{'role': 'user', 'content': 'Hello!'}]},\n    #         'command': None,\n    #         'config': {\n    #             'configurable': {\n    #                 'langgraph_auth_user': ... Your user object...\n    #                 'langgraph_auth_user_id': 'user1'\n    #             }\n    #         },\n    #         'stream_mode': ['values'],\n    #         'interrupt_before': None,\n    #         'interrupt_after': None,\n    #         'webhook': None,\n    #         'feedback_keys': None,\n    #         'temporary': False,\n    #         'subgraphs': False\n    #     }\n    # }\n\n    # Does 2 things:\n    # 1. Add the user's ID to the resource's metadata. Each LangGraph resource has a `metadata` dict that persists with the resource.\n    # this metadata is useful for filtering in read and update operations\n    # 2. Return a filter that lets users only see their own resources\n    filters = {\"owner\": ctx.user.identity}\n    metadata = value.setdefault(\"metadata\", {})\n    metadata.update(filters)\n\n    # Only let users see their own resources\n    return filters\n```\n\nThe handler receives two parameters:\n\n1. `ctx` ([AuthContext](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.AuthContext)): contains info about the current `user`, the user's `permissions`, the `resource` (\"threads\", \"crons\", \"assistants\"), and the `action` being taken (\"create\", \"read\", \"update\", \"delete\", \"search\", \"create\\_run\")\n2. `value` (`dict`): data that is being created or accessed. The contents of this dict depend on the resource and action being accessed. See [adding scoped authorization handlers](#scoped-authorization) below for information on how to get more tightly scoped access control.\n\nNotice that the simple handler does two things:\n\n1. Adds the user's ID to the resource's metadata.\n2. Returns a metadata filter so users only see resources they own.\n\n## 2. Test private conversations\n\nTest your authorization. If you have set things up correctly, you will see all ✅ messages. Be sure to have your development server running (run `langgraph dev`):\n\n```python  theme={null}\nfrom langgraph_sdk import get_client\n\n# Create clients for both users\nalice = get_client(\n    url=\"http://localhost:2024\",\n    headers={\"Authorization\": \"Bearer user1-token\"}\n)\n\nbob = get_client(\n    url=\"http://localhost:2024\",\n    headers={\"Authorization\": \"Bearer user2-token\"}\n)\n\n# Alice creates an assistant\nalice_assistant = await alice.assistants.create()\nprint(f\"✅ Alice created assistant: {alice_assistant['assistant_id']}\")\n\n# Alice creates a thread and chats\nalice_thread = await alice.threads.create()\nprint(f\"✅ Alice created thread: {alice_thread['thread_id']}\")\n\nawait alice.runs.create(\n    thread_id=alice_thread[\"thread_id\"],\n    assistant_id=\"agent\",\n    input={\"messages\": [{\"role\": \"user\", \"content\": \"Hi, this is Alice's private chat\"}]}\n)\n\n# Bob tries to access Alice's thread\ntry:\n    await bob.threads.get(alice_thread[\"thread_id\"])\n    print(\"❌ Bob shouldn't see Alice's thread!\")\nexcept Exception as e:\n    print(\"✅ Bob correctly denied access:\", e)\n\n# Bob creates his own thread\nbob_thread = await bob.threads.create()\nawait bob.runs.create(\n    thread_id=bob_thread[\"thread_id\"],\n    assistant_id=\"agent\",\n    input={\"messages\": [{\"role\": \"user\", \"content\": \"Hi, this is Bob's private chat\"}]}\n)\nprint(f\"✅ Bob created his own thread: {bob_thread['thread_id']}\")\n\n# List threads - each user only sees their own\nalice_threads = await alice.threads.search()\nbob_threads = await bob.threads.search()\nprint(f\"✅ Alice sees {len(alice_threads)} thread\")\nprint(f\"✅ Bob sees {len(bob_threads)} thread\")\n```\n\nOutput:\n\n```bash  theme={null}\n✅ Alice created assistant: fc50fb08-78da-45a9-93cc-1d3928a3fc37\n✅ Alice created thread: 533179b7-05bc-4d48-b47a-a83cbdb5781d\n✅ Bob correctly denied access: Client error '404 Not Found' for url 'http://localhost:2024/threads/533179b7-05bc-4d48-b47a-a83cbdb5781d'\nFor more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404\n✅ Bob created his own thread: 437c36ed-dd45-4a1e-b484-28ba6eca8819\n✅ Alice sees 1 thread\n✅ Bob sees 1 thread\n```\n\nThis means:\n\n1. Each user can create and chat in their own threads\n2. Users can't see each other's threads\n3. Listing threads only shows your own\n\n<a id=\"scoped-authorization\" />\n\n## 3. Add scoped authorization handlers\n\nThe broad `@auth.on` handler matches on all [authorization events](/langsmith/auth#supported-resources). This is concise, but it means the contents of the `value` dict are not well-scoped, and the same user-level access control is applied to every resource. If you want to be more fine-grained, you can also control specific actions on resources.\n\nUpdate `src/security/auth.py` to add handlers for specific resource types:\n\n```python  theme={null}\n# Keep our previous handlers...\n\nfrom langgraph_sdk import Auth\n\n@auth.on.threads.create\nasync def on_thread_create(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.on.threads.create.value,\n):\n    \"\"\"Add owner when creating threads.\n\n    This handler runs when creating new threads and does two things:\n    1. Sets metadata on the thread being created to track ownership\n    2. Returns a filter that ensures only the creator can access it\n    \"\"\"\n    # Example value:\n    #  {'thread_id': UUID('99b045bc-b90b-41a8-b882-dabc541cf740'), 'metadata': {}, 'if_exists': 'raise'}\n\n    # Add owner metadata to the thread being created\n    # This metadata is stored with the thread and persists\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n\n\n    # Return filter to restrict access to just the creator\n    return {\"owner\": ctx.user.identity}\n\n@auth.on.threads.read\nasync def on_thread_read(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.on.threads.read.value,\n):\n    \"\"\"Only let users read their own threads.\n\n    This handler runs on read operations. We don't need to set\n    metadata since the thread already exists - we just need to\n    return a filter to ensure users can only see their own threads.\n    \"\"\"\n    return {\"owner\": ctx.user.identity}\n\n@auth.on.assistants\nasync def on_assistants(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.on.assistants.value,\n):\n    # For illustration purposes, we will deny all requests\n    # that touch the assistants resource\n    # Example value:\n    # {\n    #     'assistant_id': UUID('63ba56c3-b074-4212-96e2-cc333bbc4eb4'),\n    #     'graph_id': 'agent',\n    #     'config': {},\n    #     'metadata': {},\n    #     'name': 'Untitled'\n    # }\n    raise Auth.exceptions.HTTPException(\n        status_code=403,\n        detail=\"User lacks the required permissions.\",\n    )\n\n# Assumes you organize information in store like (user_id, resource_type, resource_id)\n@auth.on.store()\nasync def authorize_store(ctx: Auth.types.AuthContext, value: dict):\n    # The \"namespace\" field for each store item is a tuple you can think of as the directory of an item.\n    namespace: tuple = value[\"namespace\"]\n    assert namespace[0] == ctx.user.identity, \"Not authorized\"\n```\n\nNotice that instead of one global handler, you now have specific handlers for:\n\n1. Creating threads\n2. Reading threads\n3. Accessing assistants\n\nThe first three of these match specific **actions** on each resource (see [resource actions](/langsmith/auth#resource-specific-handlers)), while the last one (`@auth.on.assistants`) matches *any* action on the `assistants` resource. For each request, LangGraph will run the most specific handler that matches the resource and action being accessed. This means that the four handlers above will run rather than the broadly scoped \"`@auth.on`\" handler.\n\nTry adding the following test code to your test file:\n\n```python  theme={null}\n# ... Same as before\n# Try creating an assistant. This should fail\ntry:\n    await alice.assistants.create(\"agent\")\n    print(\"❌ Alice shouldn't be able to create assistants!\")\nexcept Exception as e:\n    print(\"✅ Alice correctly denied access:\", e)\n\n# Try searching for assistants. This also should fail\ntry:\n    await alice.assistants.search()\n    print(\"❌ Alice shouldn't be able to search assistants!\")\nexcept Exception as e:\n    print(\"✅ Alice correctly denied access to searching assistants:\", e)\n\n# Alice can still create threads\nalice_thread = await alice.threads.create()\nprint(f\"✅ Alice created thread: {alice_thread['thread_id']}\")\n```\n\nOutput:\n\n```bash  theme={null}\n✅ Alice created thread: dcea5cd8-eb70-4a01-a4b6-643b14e8f754\n✅ Bob correctly denied access: Client error '404 Not Found' for url 'http://localhost:2024/threads/dcea5cd8-eb70-4a01-a4b6-643b14e8f754'\nFor more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404\n✅ Bob created his own thread: 400f8d41-e946-429f-8f93-4fe395bc3eed\n✅ Alice sees 1 thread\n✅ Bob sees 1 thread\n✅ Alice correctly denied access:\nFor more information check: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500\n✅ Alice correctly denied access to searching assistants:\n```\n\nCongratulations! You've built a chatbot where each user has their own private conversations. While this system uses simple token-based authentication, these authorization patterns will work with implementing any real authentication system. In the next tutorial, you'll replace your test users with real user accounts using OAuth2.\n\n## Next steps\n\nNow that you can control access to resources, you might want to:\n\n1. Move on to [Connect an authentication provider](/langsmith/add-auth-server) to add real user accounts.\n2. Read more about [authorization patterns](/langsmith/auth#authorization).\n3. Check out the [API reference](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth) for details about the interfaces and methods used in this tutorial.\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/resource-auth.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 14659
}