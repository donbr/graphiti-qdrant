{
  "title": "Connect an authentication provider",
  "source_url": "https://docs.langchain.com/langsmith/add-auth-server",
  "content": "In [the last tutorial](/langsmith/resource-auth), you added resource authorization to give users private conversations. However, you are still using hard-coded tokens for authentication, which is not secure. Now you'll replace those tokens with real user accounts using [OAuth2](/langsmith/deployment-quickstart).\n\nYou'll keep the same [`Auth`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth) object and [resource-level access control](/langsmith/auth#single-owner-resources), but upgrade authentication to use Supabase as your identity provider. While Supabase is used in this tutorial, the concepts apply to any OAuth2 provider. You'll learn how to:\n\n1. Replace test tokens with real JWT tokens\n2. Integrate with OAuth2 providers for secure user authentication\n3. Handle user sessions and metadata while maintaining our existing authorization logic\n\n## Background\n\nOAuth2 involves three main roles:\n\n1. **Authorization server**: The identity provider (e.g., Supabase, Auth0, Google) that handles user authentication and issues tokens\n2. **Application backend**: Your LangGraph application. This validates tokens and serves protected resources (conversation data)\n3. **Client application**: The web or mobile app where users interact with your service\n\nA standard OAuth2 flow works something like this:\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant User\n    participant Client\n    participant AuthServer\n    participant LangGraph Backend\n\n    User->>Client: Initiate login\n    User->>AuthServer: Enter credentials\n    AuthServer->>Client: Send tokens\n    Client->>LangGraph Backend: Request with token\n    LangGraph Backend->>AuthServer: Validate token\n    AuthServer->>LangGraph Backend: Token valid\n    LangGraph Backend->>Client: Serve request (e.g., run agent or graph)\n```\n\n## Prerequisites\n\nBefore you start this tutorial, ensure you have:\n\n* The [bot from the second tutorial](/langsmith/resource-auth) running without errors.\n* A [Supabase project](https://supabase.com/dashboard) to use its authentication server.\n\n## 1. Install dependencies\n\nInstall the required dependencies. Start in your `custom-auth` directory and ensure you have the `langgraph-cli` installed:\n\n<CodeGroup>\n  ```bash pip theme={null}\n  cd custom-auth\n  pip install -U \"langgraph-cli[inmem]\"\n  ```\n\n  ```bash uv theme={null}\n  cd custom-auth\n  uv add langgraph-cli[inmem]\n  ```\n</CodeGroup>\n\n<a id=\"setup-auth-provider\" />\n\n## 2. Set up the authentication provider\n\nNext, fetch the URL of your auth server and the private key for authentication.\nSince you're using Supabase for this, you can do this in the Supabase dashboard:\n\n1. In the left sidebar, click on tÔ∏è‚öô Project Settings\" and then click \"API\"\n2. Copy your project URL and add it to your `.env` file\n\n```shell  theme={null}\necho \"SUPABASE_URL=your-project-url\" >> .env\n```\n\n3. Copy your service role secret key and add it to your `.env` file:\n\n```shell  theme={null}\necho \"SUPABASE_SERVICE_KEY=your-service-role-key\" >> .env\n```\n\n4. Copy your \"anon public\" key and note it down. This will be used later when you set up our client code.\n\n```bash  theme={null}\nSUPABASE_URL=your-project-url\nSUPABASE_SERVICE_KEY=your-service-role-key\n```\n\n## 3. Implement token validation\n\nIn the previous tutorials, you used the [`Auth`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth) object to [validate hard-coded tokens](/langsmith/set-up-custom-auth) and [add resource ownership](/langsmith/resource-auth).\n\nNow you'll upgrade your authentication to validate real JWT tokens from Supabase. The main changes will all be in the [`@auth.authenticate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth.authenticate) decorated function:\n\n* Instead of checking against a hard-coded list of tokens, you'll make an HTTP request to Supabase to validate the token.\n* You'll extract real user information (ID, email) from the validated token.\n* The existing resource authorization logic remains unchanged.\n\nUpdate `src/security/auth.py` to implement this:\n\n```python {highlight={8-9,20-30}} title=\"src/security/auth.py\" theme={null}\nimport os\nimport httpx\nfrom langgraph_sdk import Auth\n\nauth = Auth()\n\n# This is loaded from the `.env` file you created above\nSUPABASE_URL = os.environ[\"SUPABASE_URL\"]\nSUPABASE_SERVICE_KEY = os.environ[\"SUPABASE_SERVICE_KEY\"]\n\n\n@auth.authenticate\nasync def get_current_user(authorization: str | None):\n    \"\"\"Validate JWT tokens and extract user information.\"\"\"\n    assert authorization\n    scheme, token = authorization.split()\n    assert scheme.lower() == \"bearer\"\n\n    try:\n        # Verify token with auth provider\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{SUPABASE_URL}/auth/v1/user\",\n                headers={\n                    \"Authorization\": authorization,\n                    \"apiKey\": SUPABASE_SERVICE_KEY,\n                },\n            )\n            assert response.status_code == 200\n            user = response.json()\n            return {\n                \"identity\": user[\"id\"],  # Unique user identifier\n                \"email\": user[\"email\"],\n                \"is_authenticated\": True,\n            }\n    except Exception as e:\n        raise Auth.exceptions.HTTPException(status_code=401, detail=str(e))\n\n# ... the rest is the same as before\n\n# Keep our resource authorization from the previous tutorial\n@auth.on\nasync def add_owner(ctx, value):\n    \"\"\"Make resources private to their creator using resource metadata.\"\"\"\n    filters = {\"owner\": ctx.user.identity}\n    metadata = value.setdefault(\"metadata\", {})\n    metadata.update(filters)\n    return filters\n```\n\nThe most important change is that we're now validating tokens with a real authentication server. Our authentication handler has the private key for our Supabase project, which we can use to validate the user's token and extract their information.\n\n## 4. Test authentication flow\n\nLet's test out the new authentication flow. You can run the following code in a file or notebook. You will need to provide:\n\n* A valid email address\n* A Supabase project URL (from [above](#setup-auth-provider))\n* A Supabase anon **public key** (also from [above](#setup-auth-provider))\n\n```python  theme={null}\nimport os\nimport httpx\nfrom getpass import getpass\nfrom langgraph_sdk import get_client\n\n\n# Get email from command line\nemail = getpass(\"Enter your email: \")\nbase_email = email.split(\"@\")\npassword = \"secure-password\"  # CHANGEME\nemail1 = f\"{base_email[0]}+1@{base_email[1]}\"\nemail2 = f\"{base_email[0]}+2@{base_email[1]}\"\n\nSUPABASE_URL = os.environ.get(\"SUPABASE_URL\")\nif not SUPABASE_URL:\n    SUPABASE_URL = getpass(\"Enter your Supabase project URL: \")\n\n# This is your PUBLIC anon key (which is safe to use client-side)\n# Do NOT mistake this for the secret service role key\nSUPABASE_ANON_KEY = os.environ.get(\"SUPABASE_ANON_KEY\")\nif not SUPABASE_ANON_KEY:\n    SUPABASE_ANON_KEY = getpass(\"Enter your public Supabase anon  key: \")\n\n\nasync def sign_up(email: str, password: str):\n    \"\"\"Create a new user account.\"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.post(\n            f\"{SUPABASE_URL}/auth/v1/signup\",\n            json={\"email\": email, \"password\": password},\n            headers={\"apiKey\": SUPABASE_ANON_KEY},\n        )\n        assert response.status_code == 200\n        return response.json()\n\n# Create two test users\nprint(f\"Creating test users: {email1} and {email2}\")\nawait sign_up(email1, password)\nawait sign_up(email2, password)\n```\n\n‚ö†Ô∏è Before continuing: Check your email and click both confirmation links. Supabase will reject `/login` requests until after you have confirmed your users' email.\n\nNow test that users can only see their own data. Make sure the server is running (run `langgraph dev`) before proceeding. The following snippet requires the \"anon public\" key that you copied from the Supabase dashboard while [setting up the auth provider](#setup-auth-provider) previously.\n\n```python  theme={null}\nasync def login(email: str, password: str):\n    \"\"\"Get an access token for an existing user.\"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.post(\n            f\"{SUPABASE_URL}/auth/v1/token?grant_type=password\",\n            json={\n                \"email\": email,\n                \"password\": password\n            },\n            headers={\n                \"apikey\": SUPABASE_ANON_KEY,\n                \"Content-Type\": \"application/json\"\n            },\n        )\n        assert response.status_code == 200\n        return response.json()[\"access_token\"]\n\n\n# Log in as user 1\nuser1_token = await login(email1, password)\nuser1_client = get_client(\n    url=\"http://localhost:2024\", headers={\"Authorization\": f\"Bearer {user1_token}\"}\n)\n\n# Create a thread as user 1\nthread = await user1_client.threads.create()\nprint(f\"‚úÖ User 1 created thread: {thread['thread_id']}\")\n\n# Try to access without a token\nunauthenticated_client = get_client(url=\"http://localhost:2024\")\ntry:\n    await unauthenticated_client.threads.create()\n    print(\"‚ùå Unauthenticated access should fail!\")\nexcept Exception as e:\n    print(\"‚úÖ Unauthenticated access blocked:\", e)\n\n# Try to access user 1's thread as user 2\nuser2_token = await login(email2, password)\nuser2_client = get_client(\n    url=\"http://localhost:2024\", headers={\"Authorization\": f\"Bearer {user2_token}\"}\n)\n\ntry:\n    await user2_client.threads.get(thread[\"thread_id\"])\n    print(\"‚ùå User 2 shouldn't see User 1's thread!\")\nexcept Exception as e:\n    print(\"‚úÖ User 2 blocked from User 1's thread:\", e)\n```\n\nThe output should look like this:\n\n```shell  theme={null}\n‚úÖ User 1 created thread: d6af3754-95df-4176-aa10-dbd8dca40f1a\n‚úÖ Unauthenticated access blocked: Client error '403 Forbidden' for url 'http://localhost:2024/threads'\n‚úÖ User 2 blocked from User 1's thread: Client error '404 Not Found' for url 'http://localhost:2024/threads/d6af3754-95df-4176-aa10-dbd8dca40f1a'\n```\n\nYour authentication and authorization are working together:\n\n1. Users must log in to access the bot\n2. Each user can only see their own threads\n\nAll users are managed by the Supabase auth provider, so you don't need to implement any additional user management logic.\n\n## Next steps\n\nYou've successfully built a production-ready authentication system for your LangGraph application! Let's review what you've accomplished:\n\n1. Set up an authentication provider (Supabase in this case)\n2. Added real user accounts with email/password authentication\n3. Integrated JWT token validation into your Agent Server\n4. Implemented proper authorization to ensure users can only access their own data\n5. Created a foundation that's ready to handle your next authentication challenge üöÄ\n\nNow that you have production authentication, consider:\n\n1. Building a web UI with your preferred framework (see the [Custom Auth](https://github.com/langchain-ai/custom-auth) template for an example)\n2. Learn more about the other aspects of authentication and authorization in the [conceptual guide on authentication](/langsmith/auth).\n3. Customize your handlers and setup further after reading the [reference docs](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth).\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/add-auth-server.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 11665
}