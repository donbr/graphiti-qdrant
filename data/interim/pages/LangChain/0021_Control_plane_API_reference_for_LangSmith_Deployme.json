{
  "title": "Control plane API reference for LangSmith Deployment",
  "source_url": "https://docs.langchain.com/langsmith/api-ref-control-plane",
  "content": "The control plane API is part of [LangSmith Deployment](/langsmith/deployments). With the control plane API, you can programmatically create, manage, and automate your [Agent Server](/langsmith/agent-server) deploymentsâ€”for example, as part of a custom CI/CD workflow.\n\n<Card title=\"API Reference\" href=\"https://api.host.langchain.com/docs\" icon=\"book\">\n  View the full Control Plane API reference documentation\n</Card>\n\n## Host\n\nThe control plane hosts for Cloud data regions:\n\n| US                               | EU                                  |\n| -------------------------------- | ----------------------------------- |\n| `https://api.host.langchain.com` | `https://eu.api.host.langchain.com` |\n\n**Note**: Self-hosted deployments of LangSmith will have a custom host for the control plane. The control plane APIs can be accessed at the path `/api-host`. For example, `http(s)://<host>/api-host/v2/deployments`. See [here](../langsmith/self-host-usage#configuring-the-application-you-want-to-use-with-langsmith) for more details.\n\n## Authentication\n\nTo authenticate with the control plane API, set the `X-Api-Key` header to a valid LangSmith API key and set the `X-Tenant-Id` header to a valid workspace ID to target.\n\nExample `curl` command:\n\n```shell  theme={null}\ncurl --request GET \\\n  --url http://localhost:8124/v2/deployments \\\n  --header 'X-Api-Key: LANGSMITH_API_KEY'\n  --header 'X-Tenant-Id': WORKSPACE_ID'\n```\n\n## Versioning\n\nEach endpoint path is prefixed with a version (e.g. `v1`, `v2`).\n\n## Quick Start\n\n1. Call `POST /v2/deployments` to create a new Deployment. The response body contains the Deployment ID (`id`) and the ID of the latest (and first) revision (`latest_revision_id`).\n2. Call `GET /v2/deployments/{deployment_id}` to retrieve the Deployment. Set `deployment_id` in the URL to the value of Deployment ID (`id`).\n3. Poll for revision `status` until `status` is `DEPLOYED` by calling `GET /v2/deployments/{deployment_id}/revisions/{latest_revision_id}`.\n4. Call `PATCH /v2/deployments/{deployment_id}` to update the deployment.\n\n## Example Code\n\nBelow is example Python code that demonstrates how to orchestrate the control plane APIs to create a deployment, update the deployment, and delete the deployment.\n\n```python  theme={null}\nimport os\nimport time\n\nimport requests\nfrom dotenv import load_dotenv\n\n\nload_dotenv()\n\n# required environment variables\nCONTROL_PLANE_HOST = os.getenv(\"CONTROL_PLANE_HOST\")\nLANGSMITH_API_KEY = os.getenv(\"LANGSMITH_API_KEY\")\nWORKSPACE_ID = os.getenv(\"WORKSPACE_ID\")\nINTEGRATION_ID = os.getenv(\"INTEGRATION_ID\")\nMAX_WAIT_TIME = 1800  # 30 mins\n\n\ndef get_headers() -> dict:\n    \"\"\"Return common headers for requests to the control plane API.\"\"\"\n    return {\n        \"X-Api-Key\": LANGSMITH_API_KEY,\n        \"X-Tenant-Id\": WORKSPACE_ID,\n    }\n\n\ndef create_deployment() -> str:\n    \"\"\"Create deployment. Return deployment ID.\"\"\"\n    headers = get_headers()\n    headers[\"Content-Type\"] = \"application/json\"\n\n    deployment_name = \"my_deployment\"\n\n    request_body = {\n        \"name\": deployment_name,\n        \"source\": \"github\",\n        \"source_config\": {\n            \"integration_id\": INTEGRATION_ID,\n            \"repo_url\": \"https://github.com/langchain-ai/langgraph-example\",\n            \"deployment_type\": \"dev\",\n            \"build_on_push\": False,\n            \"custom_url\": None,\n            \"resource_spec\": None,\n        },\n        \"source_revision_config\": {\n            \"repo_ref\": \"main\",\n            \"langgraph_config_path\": \"langgraph.json\",\n            \"image_uri\": None,\n        },\n        \"secrets\": [\n            {\n                \"name\": \"OPENAI_API_KEY\",\n                \"value\": \"test_openai_api_key\",\n            },\n            {\n                \"name\": \"ANTHROPIC_API_KEY\",\n                \"value\": \"test_anthropic_api_key\",\n            },\n            {\n                \"name\": \"TAVILY_API_KEY\",\n                \"value\": \"test_tavily_api_key\",\n            },\n        ],\n    }\n\n    response = requests.post(\n        url=f\"{CONTROL_PLANE_HOST}/v2/deployments\",\n        headers=headers,\n        json=request_body,\n    )\n\n    if response.status_code != 201:\n        raise Exception(f\"Failed to create deployment: {response.text}\")\n\n    deployment_id = response.json()[\"id\"]\n    print(f\"Created deployment {deployment_name} ({deployment_id})\")\n    return deployment_id\n\n\ndef get_deployment(deployment_id: str) -> dict:\n    \"\"\"Get deployment.\"\"\"\n    response = requests.get(\n        url=f\"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}\",\n        headers=get_headers(),\n    )\n\n    if response.status_code != 200:\n        raise Exception(f\"Failed to get deployment ID {deployment_id}: {response.text}\")\n\n    return response.json()\n\n\ndef list_revisions(deployment_id: str) -> list[dict]:\n    \"\"\"List revisions.\n\n    Return list is sorted by created_at in descending order (latest first).\n    \"\"\"\n    response = requests.get(\n        url=f\"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}/revisions\",\n        headers=get_headers(),\n    )\n\n    if response.status_code != 200:\n        raise Exception(\n            f\"Failed to list revisions for deployment ID {deployment_id}: {response.text}\"\n        )\n\n    return response.json()\n\n\ndef get_revision(\n    deployment_id: str,\n    revision_id: str,\n) -> dict:\n    \"\"\"Get revision.\"\"\"\n    response = requests.get(\n        url=f\"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}/revisions/{revision_id}\",\n        headers=get_headers(),\n    )\n\n    if response.status_code != 200:\n        raise Exception(f\"Failed to get revision ID {revision_id}: {response.text}\")\n\n    return response.json()\n\n\ndef patch_deployment(deployment_id: str) -> None:\n    \"\"\"Patch deployment.\"\"\"\n    headers = get_headers()\n    headers[\"Content-Type\"] = \"application/json\"\n\n    # This creates a new revision because source_revision_config is included\n    response = requests.patch(\n        url=f\"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}\",\n        headers=headers,\n        json={\n            \"source_config\": {\n                \"build_on_push\": True,\n            },\n            \"source_revision_config\": {\n                \"repo_ref\": \"main\",\n                \"langgraph_config_path\": \"langgraph.json\",\n            },\n        },\n    )\n\n    if response.status_code != 200:\n        raise Exception(f\"Failed to patch deployment: {response.text}\")\n\n    print(f\"Patched deployment ID {deployment_id}\")\n\n\ndef wait_for_deployment(deployment_id: str, revision_id: str) -> None:\n    \"\"\"Wait for revision status to be DEPLOYED.\"\"\"\n    start_time = time.time()\n    revision, status = None, None\n    while time.time() - start_time < MAX_WAIT_TIME:\n        revision = get_revision(deployment_id, revision_id)\n        status = revision[\"status\"]\n        if status == \"DEPLOYED\":\n            break\n        elif \"FAILED\" in status:\n            raise Exception(f\"Revision ID {revision_id} failed: {revision}\")\n\n        print(f\"Waiting for revision ID {revision_id} to be DEPLOYED...\")\n        time.sleep(60)\n\n    if status != \"DEPLOYED\":\n        raise Exception(\n            f\"Timeout waiting for revision ID {revision_id} to be DEPLOYED: {revision}\"\n        )\n\n\ndef delete_deployment(deployment_id: str) -> None:\n    \"\"\"Delete deployment.\"\"\"\n    response = requests.delete(\n        url=f\"{CONTROL_PLANE_HOST}/v2/deployments/{deployment_id}\",\n        headers=get_headers(),\n    )\n\n    if response.status_code != 204:\n        raise Exception(\n            f\"Failed to delete deployment ID {deployment_id}: {response.text}\"\n        )\n\n    print(f\"Deployment ID {deployment_id} deleted\")\n\n\nif __name__ == \"__main__\":\n    # create deployment and get the latest revision\n    deployment_id = create_deployment()\n    revisions = list_revisions(deployment_id)\n    latest_revision = revisions[\"resources\"][0]\n    latest_revision_id = latest_revision[\"id\"]\n\n    # wait for latest revision to be DEPLOYED\n    wait_for_deployment(deployment_id, latest_revision_id)\n\n    # patch the deployment and get the latest revision\n    patch_deployment(deployment_id)\n    revisions = list_revisions(deployment_id)\n    latest_revision = revisions[\"resources\"][0]\n    latest_revision_id = latest_revision[\"id\"]\n\n    # wait for latest revision to be DEPLOYED\n    wait_for_deployment(deployment_id, latest_revision_id)\n\n    # delete the deployment\n    delete_deployment(deployment_id)\n```\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/api-ref-control-plane.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 8719
}