{
  "title": "Query traces (SDK)",
  "source_url": "https://docs.langchain.com/langsmith/export-traces",
  "content": "<Tip>\n  **Recommended Reading**\n\n  Before diving into this content, it might be helpful to read the following:\n\n  * [Run (span) data format](/langsmith/run-data-format)\n  * <RegionalUrl type=\"api\" suffix=\"/redoc\" text=\"LangSmith API Reference\" />\n  * [LangSmith trace query syntax](/langsmith/trace-query-syntax)\n</Tip>\n\n<Note>\n  **If you are looking to export a large volume of traces, we recommend that you use the [Bulk Data Export](./data-export) functionality, as it will better handle large data volumes and will support automatic retries and parallelization across partitions.**\n</Note>\n\nThe recommended way to query runs (the span data in LangSmith traces) is to use the `list_runs` method in the SDK or `/runs/query` endpoint in the API.\n\nLangSmith stores traces in a simple format that is specified in the [Run (span) data format](/langsmith/run-data-format).\n\n## Use filter arguments\n\nFor simple queries, you don't have to rely on our query syntax. You can use the filter arguments specified in the [filter arguments reference](/langsmith/trace-query-syntax#filter-arguments).\n\n<Warning>\n  **Prerequisites**\n\n  Initialize the client before running the below code snippets.\n</Warning>\n\n<CodeGroup>\n  ```python Python theme={null}\n  from langsmith import Client\n\n  client = Client()\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { Client, Run } from \"langsmith\";\n\n  const client = new Client();\n  ```\n</CodeGroup>\n\nBelow are some examples of ways to list runs using keyword arguments:\n\n### List all runs in a project\n\n<CodeGroup>\n  ```python Python theme={null}\n  project_runs = client.list_runs(project_name=\"<your_project>\")\n  ```\n\n  ```typescript TypeScript theme={null}\n  // Download runs in a project\n  const projectRuns: Run[] = [];\n  for await (const run of client.listRuns({\n    projectName: \"<your_project>\",\n  })) {\n    projectRuns.push(run);\n  };\n  ```\n</CodeGroup>\n\n### List LLM and Chat runs in the last 24 hours\n\n<CodeGroup>\n  ```python Python theme={null}\n  todays_llm_runs = client.list_runs(\n      project_name=\"<your_project>\",\n      start_time=datetime.now() - timedelta(days=1),\n      run_type=\"llm\",\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  const todaysLlmRuns: Run[] = [];\n  for await (const run of client.listRuns({\n    projectName: \"<your_project>\",\n    startTime: new Date(Date.now() - 1000 * 60 * 60 * 24),\n    runType: \"llm\",\n  })) {\n    todaysLlmRuns.push(run);\n  };\n  ```\n</CodeGroup>\n\n### List root runs in a project\n\nRoot runs are runs that have no parents. These are assigned a value of `True` for `is_root`. You can use this to filter for root runs.\n\n<CodeGroup>\n  ```python Python theme={null}\n  root_runs = client.list_runs(\n      project_name=\"<your_project>\",\n      is_root=True\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  const rootRuns: Run[] = [];\n  for await (const run of client.listRuns({\n    projectName: \"<your_project>\",\n    isRoot: 1,\n  })) {\n    rootRuns.push(run);\n  };\n  ```\n</CodeGroup>\n\n### List runs without errors\n\n<CodeGroup>\n  ```python Python theme={null}\n  correct_runs = client.list_runs(project_name=\"<your_project>\", error=False)\n  ```\n\n  ```typescript TypeScript theme={null}\n  const correctRuns: Run[] = [];\n  for await (const run of client.listRuns({\n    projectName: \"<your_project>\",\n    error: false,\n  })) {\n    correctRuns.push(run);\n  };\n  ```\n</CodeGroup>\n\n### List runs by run ID\n\n<Warning>\n  **Ignores Other Arguments**\n\n  If you provide a list of run IDs in the way described above, it will ignore all other filtering arguments like `project_name`, `run_type`, etc. and directly return the runs matching the given IDs.\n</Warning>\n\nIf you have a list of run IDs, you can list them directly:\n\n<CodeGroup>\n  ```python Python theme={null}\n  run_ids = ['a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836','9398e6be-964f-4aa4-8ae9-ad78cd4b7074']\n  selected_runs = client.list_runs(id=run_ids)\n  ```\n\n  ```typescript TypeScript theme={null}\n  const runIds = [\n    \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n    \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n  ];\n  const selectedRuns: Run[] = [];\n  for await (const run of client.listRuns({\n    id: runIds,\n  })) {\n    selectedRuns.push(run);\n  };\n  ```\n</CodeGroup>\n\n## Use filter query language\n\nFor more complex queries, you can use the query language described in the [filter query language reference](/langsmith/trace-query-syntax#filter-query-language).\n\n### List all root runs in a conversational thread\n\nThis is the way to fetch runs in a conversational thread. For more information on setting up threads, refer to our [how-to guide on setting up threads](./threads).\nThreads are grouped by setting a shared thread ID. The LangSmith UI lets you use any one of the following three metadata keys: `session_id`, `conversation_id`, or `thread_id`. The session ID is also known as the tracing project ID. The following query matches on any of them.\n\n<CodeGroup>\n  ```python Python theme={null}\n  group_key = \"<your_thread_id>\"\n  filter_string = f'and(in(metadata_key, [\"session_id\",\"conversation_id\",\"thread_id\"]), eq(metadata_value, \"{group_key}\"))'\n  thread_runs = client.list_runs(\n      project_name=\"<your_project>\",\n      filter=filter_string,\n      is_root=True\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  const groupKey = \"<your_thread_id>\";\n  const filterString = `and(in(metadata_key, [\"session_id\",\"conversation_id\",\"thread_id\"]), eq(metadata_value, \"${groupKey}\"))`;\n  const threadRuns: Run[] = [];\n  for await (const run of client.listRuns({\n    projectName: \"<your_project>\",\n    filter: filterString,\n    isRoot: true\n  })) {\n    threadRuns.push(run);\n  };\n  ```\n</CodeGroup>\n\n### List all runs called \"extractor\" whose root of the trace was assigned feedback \"user\\_score\" score of 1\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(\n      project_name=\"<your_project>\",\n      filter='eq(name, \"extractor\")',\n      trace_filter='and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))'\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({\n    projectName: \"<your_project>\",\n    filter: 'eq(name, \"extractor\")',\n    traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))'\n  })\n  ```\n</CodeGroup>\n\n### List runs with \"star\\_rating\" key whose score is greater than 4\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(\n      project_name=\"<your_project>\",\n      filter='and(eq(feedback_key, \"star_rating\"), gt(feedback_score, 4))'\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({\n    projectName: \"<your_project>\",\n    filter: 'and(eq(feedback_key, \"star_rating\"), gt(feedback_score, 4))'\n  })\n  ```\n</CodeGroup>\n\n### List runs that took longer than 5 seconds to complete\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(project_name=\"<your_project>\", filter='gt(latency, \"5s\")')\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({projectName: \"<your_project>\", filter: 'gt(latency, \"5s\")'})\n  ```\n</CodeGroup>\n\n### List all runs that have \"error\" not equal to null\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(project_name=\"<your_project>\", filter='neq(error, null)')\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({projectName: \"<your_project>\", filter: 'neq(error, null)'})\n  ```\n</CodeGroup>\n\n### List all runs where start\\_time is greater than a specific timestamp\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(project_name=\"<your_project>\", filter='gt(start_time, \"2023-07-15T12:34:56Z\")')\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({projectName: \"<your_project>\", filter: 'gt(start_time, \"2023-07-15T12:34:56Z\")'})\n  ```\n</CodeGroup>\n\n### List all runs that contain the string \"substring\"\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(project_name=\"<your_project>\", filter='search(\"substring\")')\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({projectName: \"<your_project>\", filter: 'search(\"substring\")'})\n  ```\n</CodeGroup>\n\n### List all runs that are tagged with the git hash \"2aa1cf4\"\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(project_name=\"<your_project>\", filter='has(tags, \"2aa1cf4\")')\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({projectName: \"<your_project>\", filter: 'has(tags, \"2aa1cf4\")'})\n  ```\n</CodeGroup>\n\n### List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(\n    project_name=\"<your_project>\",\n    filter='and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))'\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({\n    projectName: \"<your_project>\",\n    filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))'\n  })\n  ```\n</CodeGroup>\n\n### Complex query: List all runs where tags include \"experimental\" or \"beta\" and latency is greater than 2 seconds\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(\n    project_name=\"<your_project>\",\n    filter='and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))'\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({\n    projectName: \"<your_project>\",\n    filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))'\n  })\n  ```\n</CodeGroup>\n\n### Search trace trees by full text\n\nYou can use the `search()` function without any specific field to do a full text search across all string fields in a run. This allows you to quickly find traces that match a search term.\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(\n    project_name=\"<your_project>\",\n    filter='search(\"image classification\")'\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({\n    projectName: \"<your_project>\",\n    filter: 'search(\"image classification\")'\n  })\n  ```\n</CodeGroup>\n\n### Check for presence of metadata\n\nIf you want to check for the presence of metadata, you can use the `eq` operator, optionally with an `and` statement to match by value. This is useful if you want to log more structured information about your runs.\n\n<CodeGroup>\n  ```python Python theme={null}\n  to_search = {\n      \"user_id\": \"\"\n  }\n\n  # Check for any run with the \"user_id\" metadata key\n  client.list_runs(\n    project_name=\"default\",\n    filter=\"eq(metadata_key, 'user_id')\"\n  )\n  # Check for runs with user_id=4070f233-f61e-44eb-bff1-da3c163895a3\n  client.list_runs(\n    project_name=\"default\",\n    filter=\"and(eq(metadata_key, 'user_id'), eq(metadata_value, '4070f233-f61e-44eb-bff1-da3c163895a3'))\"\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  // Check for any run with the \"user_id\" metadata key\n  client.listRuns({\n    projectName: 'default',\n    filter: `eq(metadata_key, 'user_id')`\n  });\n  // Check for runs with user_id=4070f233-f61e-44eb-bff1-da3c163895a3\n  client.listRuns({\n    projectName: 'default',\n    filter: `and(eq(metadata_key, 'user_id'), eq(metadata_value, '4070f233-f61e-44eb-bff1-da3c163895a3'))`\n  });\n  ```\n</CodeGroup>\n\n### Check for environment details in metadata\n\nA common pattern is to add environment information to your traces via metadata. If you want to filter for runs containing environment metadata, you can use the same pattern as above:\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(\n    project_name=\"default\",\n    filter=\"and(eq(metadata_key, 'environment'), eq(metadata_value, 'production'))\"\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({\n    projectName: 'default',\n    filter: `and(eq(metadata_key, 'environment'), eq(metadata_value, 'production'))`\n  });\n  ```\n</CodeGroup>\n\n### Check for conversation ID in metadata\n\nAnother common way to associate traces in the same conversation is by using a shared conversation ID. If you want to filter runs based on a conversation ID in this way, you can search for that ID in the metadata.\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(\n    project_name=\"default\",\n    filter=\"and(eq(metadata_key, 'conversation_id'), eq(metadata_value, 'a1b2c3d4-e5f6-7890'))\"\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({\n    projectName: 'default',\n    filter: `and(eq(metadata_key, 'conversation_id'), eq(metadata_value, 'a1b2c3d4-e5f6-7890'))`\n  });\n  ```\n</CodeGroup>\n\n### Negative filtering on key-value pairs\n\nYou can use negative filtering on metadata, input, and output key-value pairs to exclude specific runs from your results. Here are some examples for metadata key-value pairs but the same logic applies to input and output key-value pairs.\n\n<CodeGroup>\n  ```python Python theme={null}\n  # Find all runs where the metadata does not contain a \"conversation_id\" key\n  client.list_runs(\n    project_name=\"default\",\n    filter=\"and(neq(metadata_key, 'conversation_id'))\"\n  )\n\n  # Find all runs where the conversation_id in metadata is not \"a1b2c3d4-e5f6-7890\"\n  client.list_runs(\n    project_name=\"default\",\n    filter=\"and(eq(metadata_key, 'conversation_id'), neq(metadata_value, 'a1b2c3d4-e5f6-7890'))\"\n  )\n\n  # Find all runs where there is no \"conversation_id\" metadata key and the \"a1b2c3d4-e5f6-7890\" value is not present\n  client.list_runs(\n    project_name=\"default\",\n    filter=\"and(neq(metadata_key, 'conversation_id'), neq(metadata_value, 'a1b2c3d4-e5f6-7890'))\"\n  )\n\n  # Find all runs where the conversation_id metadata key is not present but the \"a1b2c3d4-e5f6-7890\" value is present\n  client.list_runs(\n    project_name=\"default\",\n    filter=\"and(neq(metadata_key, 'conversation_id'), eq(metadata_value, 'a1b2c3d4-e5f6-7890'))\"\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  // Find all runs where the metadata does not contain a \"conversation_id\" key\n  client.listRuns({\n    projectName: 'default',\n    filter: `and(neq(metadata_key, 'conversation_id'))`\n  });\n\n  // Find all runs where the conversation_id in metadata is not \"a1b2c3d4-e5f6-7890\"\n  client.listRuns({\n    projectName: 'default',\n    filter: `and(eq(metadata_key, 'conversation_id'), neq(metadata_value, 'a1b2c3d4-e5f6-7890'))`\n  });\n\n  // Find all runs where there is no \"conversation_id\" metadata key and the \"a1b2c3d4-e5f6-7890\" value is not present\n  client.listRuns({\n    projectName: 'default',\n    filter: `and(neq(metadata_key, 'conversation_id'), neq(metadata_value, 'a1b2c3d4-e5f6-7890'))`\n  });\n\n  // Find all runs where the conversation_id metadata key is not present but the \"a1b2c3d4-e5f6-7890\" value is present\n  client.listRuns({\n    projectName: 'default',\n    filter: `and(neq(metadata_key, 'conversation_id'), eq(metadata_value, 'a1b2c3d4-e5f6-7890'))`\n  });\n  ```\n</CodeGroup>\n\n### Combine multiple filters\n\nIf you want to combine multiple conditions to refine your search, you can use the `and` operator along with other filtering functions. Here's how you can search for runs named \"ChatOpenAI\" that also have a specific `conversation_id` in their metadata:\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(\n    project_name=\"default\",\n    filter=\"and(eq(name, 'ChatOpenAI'), eq(metadata_key, 'conversation_id'), eq(metadata_value, '69b12c91-b1e2-46ce-91de-794c077e8151'))\"\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({\n    projectName: 'default',\n    filter: `and(eq(name, 'ChatOpenAI'), eq(metadata_key, 'conversation_id'), eq(metadata_value, '69b12c91-b1e2-46ce-91de-794c077e8151'))`\n  });\n  ```\n</CodeGroup>\n\n### Tree Filter\n\nList all runs named \"RetrieveDocs\" whose root run has a \"user\\_score\" feedback of 1 and any run in the full trace is named \"ExpandQuery\".\n\nThis type of query is useful if you want to extract a specific run conditional on various states or steps being reached within the trace.\n\n<CodeGroup>\n  ```python Python theme={null}\n  client.list_runs(\n      project_name=\"<your_project>\",\n      filter='eq(name, \"RetrieveDocs\")',\n      trace_filter='and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n      tree_filter='eq(name, \"ExpandQuery\")'\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  client.listRuns({\n    projectName: \"<your_project>\",\n    filter: 'eq(name, \"RetrieveDocs\")',\n    traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n    treeFilter: 'eq(name, \"ExpandQuery\")'\n  })\n  ```\n</CodeGroup>\n\n### Advanced: export flattened trace view with child tool usage\n\nThe following Python example demonstrates how to export a flattened view of traces, including information on the tools (from nested runs) used by the agent within each trace.\nThis can be used to analyze the behavior of your agents across multiple traces.\n\nThis example queries all tool runs within a specified number of days and groups them by their parent (root) run ID. It then fetches the relevant information for each root run, such as the run name, inputs, outputs, and combines that information with the child run information.\n\nTo optimize the query, the example:\n\n1. Selects only the necessary fields when querying tool runs to reduce query time.\n2. Fetches root runs in batches while processing tool runs concurrently.\n\n<CodeGroup>\n  ```python Python theme={null}\n  from collections import defaultdict\n  from concurrent.futures import Future, ThreadPoolExecutor\n  from datetime import datetime, timedelta\n\n  from langsmith import Client\n  from tqdm.auto import tqdm\n\n  client = Client()\n  project_name = \"my-project\"\n  num_days = 30\n\n  # List all tool runs\n  tool_runs = client.list_runs(\n      project_name=project_name,\n      start_time=datetime.now() - timedelta(days=num_days),\n      run_type=\"tool\",\n      # We don't need to fetch inputs, outputs, and other values that # may increase the query time\n      select=[\"trace_id\", \"name\", \"run_type\"],\n  )\n\n  data = []\n  futures: list[Future] = []\n  trace_cursor = 0\n  trace_batch_size = 50\n\n  tool_runs_by_parent = defaultdict(lambda: defaultdict(set))\n  # Do not exceed rate limit\n  with ThreadPoolExecutor(max_workers=2) as executor:\n      # Group tool runs by parent run ID\n      for run in tqdm(tool_runs):\n          # Collect all tools invoked within a given trace\n          tool_runs_by_parent[run.trace_id][\"tools_involved\"].add(run.name)\n          # maybe send a batch of parent run IDs to the server\n          # this lets us query for the root runs in batches\n          # while still processing the tool runs\n          if len(tool_runs_by_parent) % trace_batch_size == 0:\n              if this_batch := list(tool_runs_by_parent.keys())[\n                  trace_cursor : trace_cursor + trace_batch_size\n              ]:\n                  trace_cursor += trace_batch_size\n                  futures.append(\n                      executor.submit(\n                          client.list_runs,\n                          project_name=project_name,\n                          run_ids=this_batch,\n                          select=[\"name\", \"inputs\", \"outputs\", \"run_type\"],\n                      )\n                  )\n      if this_batch := list(tool_runs_by_parent.keys())[trace_cursor:]:\n          futures.append(\n              executor.submit(\n                  client.list_runs,\n                  project_name=project_name,\n                  run_ids=this_batch,\n                  select=[\"name\", \"inputs\", \"outputs\", \"run_type\"],\n              )\n          )\n\n  for future in tqdm(futures):\n      root_runs = future.result()\n      for root_run in root_runs:\n          root_data = tool_runs_by_parent[root_run.id]\n          data.append(\n              {\n                  \"run_id\": root_run.id,\n                  \"run_name\": root_run.name,\n                  \"run_type\": root_run.run_type,\n                  \"inputs\": root_run.inputs,\n                  \"outputs\": root_run.outputs,\n                  \"tools_involved\": list(root_data[\"tools_involved\"]),\n              }\n          )\n\n  # (Optional): Convert to a pandas DataFrame\n  import pandas as pd\n\n  df = pd.DataFrame(data)\n  df.head()\n  ```\n</CodeGroup>\n\n### Advanced: export retriever IO for traces with feedback\n\nThis query is useful if you want to fine-tune embeddings or diagnose end-to-end system performance issues based on retriever behavior.\nThe following Python example demonstrates how to export retriever inputs and outputs within traces that have a specific feedback score.\n\n<CodeGroup>\n  ```python Python theme={null}\n  from collections import defaultdict\n  from concurrent.futures import Future, ThreadPoolExecutor\n  from datetime import datetime, timedelta\n\n  import pandas as pd\n  from langsmith import Client\n  from tqdm.auto import tqdm\n\n  client = Client()\n  project_name = \"your-project-name\"\n  num_days = 1\n\n  # List all tool runs\n  retriever_runs = client.list_runs(\n      project_name=project_name,\n      start_time=datetime.now() - timedelta(days=num_days),\n      run_type=\"retriever\",\n      # This time we do want to fetch the inputs and outputs, since they\n      # may be adjusted by query expansion steps.\n      select=[\"trace_id\", \"name\", \"run_type\", \"inputs\", \"outputs\"],\n      trace_filter='eq(feedback_key, \"user_score\")',\n  )\n\n  data = []\n  futures: list[Future] = []\n  trace_cursor = 0\n  trace_batch_size = 50\n\n  retriever_runs_by_parent = defaultdict(lambda: defaultdict(list))\n  # Do not exceed rate limit\n  with ThreadPoolExecutor(max_workers=2) as executor:\n      # Group retriever runs by parent run ID\n      for run in tqdm(retriever_runs):\n          # Collect all retriever calls invoked within a given trace\n          for k, v in run.inputs.items():\n              retriever_runs_by_parent[run.trace_id][f\"retriever.inputs.{k}\"].append(v)\n          for k, v in (run.outputs or {}).items():\n              # Extend the docs\n              retriever_runs_by_parent[run.trace_id][f\"retriever.outputs.{k}\"].extend(v)\n          # maybe send a batch of parent run IDs to the server\n          # this lets us query for the root runs in batches\n          # while still processing the retriever runs\n          if len(retriever_runs_by_parent) % trace_batch_size == 0:\n              if this_batch := list(retriever_runs_by_parent.keys())[\n                  trace_cursor : trace_cursor + trace_batch_size\n              ]:\n                  trace_cursor += trace_batch_size\n                  futures.append(\n                      executor.submit(\n                          client.list_runs,\n                          project_name=project_name,\n                          run_ids=this_batch,\n                          select=[\n                              \"name\",\n                              \"inputs\",\n                              \"outputs\",\n                              \"run_type\",\n                              \"feedback_stats\",\n                          ],\n                      )\n                  )\n      if this_batch := list(retriever_runs_by_parent.keys())[trace_cursor:]:\n          futures.append(\n              executor.submit(\n                  client.list_runs,\n                  project_name=project_name,\n                  run_ids=this_batch,\n                  select=[\"name\", \"inputs\", \"outputs\", \"run_type\"],\n              )\n          )\n\n  for future in tqdm(futures):\n      root_runs = future.result()\n      for root_run in root_runs:\n          root_data = retriever_runs_by_parent[root_run.id]\n          feedback = {\n              f\"feedback.{k}\": v.get(\"avg\")\n              for k, v in (root_run.feedback_stats or {}).items()\n          }\n          inputs = {f\"inputs.{k}\": v for k, v in root_run.inputs.items()}\n          outputs = {f\"outputs.{k}\": v for k, v in (root_run.outputs or {}).items()}\n          data.append(\n              {\n                  \"run_id\": root_run.id,\n                  \"run_name\": root_run.name,\n                  **inputs,\n                  **outputs,\n                  **feedback,\n                  **root_data,\n              }\n          )\n\n  # (Optional): Convert to a pandas DataFrame\n  import pandas as pd\n  df = pd.DataFrame(data)\n  df.head()\n  ```\n</CodeGroup>\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/export-traces.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 24447
}