{
  "title": "How to sync prompts with GitHub",
  "source_url": "https://docs.langchain.com/langsmith/prompt-commit",
  "content": "LangSmith provides a collaborative interface to create, test, and iterate on prompts.\n\nWhile you can [dynamically fetch prompts](/langsmith/manage-prompts-programmatically#pull-a-prompt) from LangSmith into your application at runtime, you may prefer to sync prompts with your own database or version control system. To support this workflow, LangSmith allows you to receive notifications of prompt updates via webhooks.\n\n**Why sync prompts with GitHub?**\n\n* **Version Control:** Keep your prompts versioned alongside your application code in a familiar system.\n* **CI/CD Integration:** Trigger automated staging or production deployments when critical prompts change.\n\n<img src=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-excalidraw.png?fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=a7fd1ae2a70f91c14298803a48785f89\" alt=\"Prompt Webhook Diagram\" data-og-width=\"1336\" width=\"1336\" data-og-height=\"343\" height=\"343\" data-path=\"langsmith/images/prompt-excalidraw.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-excalidraw.png?w=280&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=02f868ec42337b43a533f23effa76417 280w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-excalidraw.png?w=560&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=68806f6d9d1e5b8dbaf49d98294190da 560w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-excalidraw.png?w=840&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=133aeb6d3a880b989c2246632b8c0d5d 840w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-excalidraw.png?w=1100&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=fc7091cce5fec3407e005f798db85544 1100w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-excalidraw.png?w=1650&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=d789978f57574ec4f0c75beac19fc10c 1650w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-excalidraw.png?w=2500&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=d6362e5787b7fd1a5db69b3d704912bb 2500w\" />\n\n## Prerequisites\n\nBefore we begin, ensure you have the following set up:\n\n1. **GitHub Account:** A standard GitHub account.\n\n2. **GitHub Repository:** Create a new (or choose an existing) repository where your LangSmith prompt manifests will be stored. This could be the same repository as your application code or a dedicated one for prompts.\n\n3. **GitHub Personal Access Token (PAT):**\n\n   * LangSmith webhooks don't directly interact with GitHub—they call an intermediary server that *you* create.\n   * This server requires a GitHub PAT to authenticate and make commits to your repository.\n   * Must include the `repo` scope (`public_repo` is sufficient for public repositories).\n   * Go to **GitHub > Settings > Developer settings > Personal access tokens > Tokens (classic)**.\n   * Click **Generate new token (classic)**.\n   * Name it (e.g., \"LangSmith Prompt Sync\"), set an expiration, and select the required scopes.\n   * Click **Generate token** and **copy it immediately** — it won't be shown again.\n   * Store the token securely and provide it as an environment variable to your server.\n\n## Understanding LangSmith \"Prompt Commits\" and webhooks\n\nIn LangSmith, when you save changes to a prompt, you're essentially creating a new version or a \"Prompt Commit.\" These commits are what can trigger webhooks.\n\nThe webhook will send a JSON payload containing the new **prompt manifest**.\n\n<Accordion title=\"Sample Webhook Payload\">\n  ```json  theme={null}\n  {\n    \"prompt_id\": \"f33dcb51-eb17-47a5-83ca-64ac8a027a29\",\n    \"prompt_name\": \"My Prompt\",\n    \"commit_hash\": \"commit_hash_1234567890\",\n    \"created_at\": \"2021-01-01T00:00:00Z\",\n    \"created_by\": \"Jane Doe\",\n    \"manifest\": {\n      \"lc\": 1,\n      \"type\": \"constructor\",\n      \"id\": [\"langchain\", \"schema\", \"runnable\", \"RunnableSequence\"],\n      \"kwargs\": {\n        \"first\": {\n          \"lc\": 1,\n          \"type\": \"constructor\",\n          \"id\": [\"langchain\", \"prompts\", \"chat\", \"ChatPromptTemplate\"],\n          \"kwargs\": {\n            \"messages\": [\n              {\n                \"lc\": 1,\n                \"type\": \"constructor\",\n                \"id\": [\n                  \"langchain_core\",\n                  \"prompts\",\n                  \"chat\",\n                  \"SystemMessagePromptTemplate\"\n                ],\n                \"kwargs\": {\n                  \"prompt\": {\n                    \"lc\": 1,\n                    \"type\": \"constructor\",\n                    \"id\": [\n                      \"langchain_core\",\n                      \"prompts\",\n                      \"prompt\",\n                      \"PromptTemplate\"\n                    ],\n                    \"kwargs\": {\n                      \"input_variables\": [],\n                      \"template_format\": \"mustache\",\n                      \"template\": \"You are a chatbot.\"\n                    }\n                  }\n                }\n              },\n              {\n                \"lc\": 1,\n                \"type\": \"constructor\",\n                \"id\": [\n                  \"langchain_core\",\n                  \"prompts\",\n                  \"chat\",\n                  \"HumanMessagePromptTemplate\"\n                ],\n                \"kwargs\": {\n                  \"prompt\": {\n                    \"lc\": 1,\n                    \"type\": \"constructor\",\n                    \"id\": [\n                      \"langchain_core\",\n                      \"prompts\",\n                      \"prompt\",\n                      \"PromptTemplate\"\n                    ],\n                    \"kwargs\": {\n                      \"input_variables\": [\"question\"],\n                      \"template_format\": \"mustache\",\n                      \"template\": \"{{question}}\"\n                    }\n                  }\n                }\n              }\n            ],\n            \"input_variables\": [\"question\"]\n          }\n        },\n        \"last\": {\n          \"lc\": 1,\n          \"type\": \"constructor\",\n          \"id\": [\"langchain\", \"schema\", \"runnable\", \"RunnableBinding\"],\n          \"kwargs\": {\n            \"bound\": {\n              \"lc\": 1,\n              \"type\": \"constructor\",\n              \"id\": [\"langchain\", \"chat_models\", \"openai\", \"ChatOpenAI\"],\n              \"kwargs\": {\n                \"temperature\": 1,\n                \"top_p\": 1,\n                \"presence_penalty\": 0,\n                \"frequency_penalty\": 0,\n                \"model\": \"gpt-4.1-mini\",\n                \"extra_headers\": {},\n                \"openai_api_key\": {\n                  \"id\": [\"OPENAI_API_KEY\"],\n                  \"lc\": 1,\n                  \"type\": \"secret\"\n                }\n              }\n            },\n            \"kwargs\": {}\n          }\n        }\n      }\n    }\n  }\n  ```\n</Accordion>\n\n<Note>\n  It's important to understand that LangSmith webhooks for prompt commits are generally triggered at the **workspace level**. This means if *any* prompt within your LangSmith workspace is modified and a \"prompt commit\" is saved, the webhook will fire and send the updated manifest of the prompt. The payloads are identifiable by prompt id. Your receiving server should be designed with this in mind.\n</Note>\n\n## Implementing a FastAPI server for webhook reception\n\nTo effectively process webhook notifications from LangSmith when prompts are updated, an intermediary server application is necessary. This server will act as the receiver for HTTP POST requests sent by LangSmith. For demonstration purposes in this guide, we will outline the creation of a simple FastAPI application to fulfill this role.\n\nThis publicly accessible server will be responsible for:\n\n1. **Receiving Webhook Requests:** Listening for incoming HTTP POST requests.\n2. **Parsing Payloads:** Extracting and interpreting the JSON-formatted prompt manifest from the request body.\n3. **Committing to GitHub:** Programmatically creating a new commit in your specified GitHub repository, containing the updated prompt manifest. This ensures your prompts remain version-controlled and synchronized with changes made in LangSmith.\n\nFor deployment, platforms like [Render.com](https://render.com/) (offering a suitable free tier), Vercel, Fly.io, or other cloud providers (AWS, GCP, Azure) can be utilized to host the FastAPI application and obtain a public URL.\n\nThe server's core functionality will include an endpoint for webhook reception, logic for parsing the manifest, and integration with the GitHub API (using a Personal Access Token for authentication) to manage commits.\n\n<Accordion title=\"Minimal FastAPI Server Code ()\">\n  `main.py`\n\n  This server will listen for incoming webhooks from LangSmith and commit the received prompt manifest to your GitHub repository.\n\n  ```python  theme={null}\n  import base64\n  import json\n  import uuid\n  from typing import Any, Dict\n  import httpx\n  from fastapi import FastAPI, HTTPException, Body\n  from pydantic import BaseModel, Field\n  from pydantic_settings import BaseSettings, SettingsConfigDict\n\n  # --- Configuration ---\n  class AppConfig(BaseSettings):\n      \"\"\"\n      Application configuration model.\n      Loads settings from environment variables.\n      \"\"\"\n      GITHUB_TOKEN: str\n      GITHUB_REPO_OWNER: str\n      GITHUB_REPO_NAME: str\n      GITHUB_FILE_PATH: str = \"prompt_manifest.json\"\n      GITHUB_BRANCH: str = \"main\"\n      model_config = SettingsConfigDict(\n          env_file=\".env\",\n          env_file_encoding='utf-8',\n          extra='ignore'\n      )\n\n  settings = AppConfig()\n\n  # --- Pydantic Models ---\n  class WebhookPayload(BaseModel):\n      \"\"\"\n      Defines the expected structure of the incoming webhook payload.\n      \"\"\"\n      prompt_id: UUID = Field(\n          ...,\n          description=\"The unique identifier for the prompt.\"\n      )\n      prompt_name: str = Field(\n          ...,\n          description=\"The name/title of the prompt.\"\n      )\n      commit_hash: str = Field(\n          ...,\n          description=\"An identifier for the commit event that triggered the webhook.\"\n      )\n      created_at: str = Field(\n          ...,\n          description=\"Timestamp indicating when the event was created (ISO format preferred).\"\n      )\n      created_by: str = Field(\n          ...,\n          description=\"The name of the user who created the event.\"\n      )\n      manifest: Dict[str, Any] = Field(\n          ...,\n          description=\"The main content or configuration data to be committed to GitHub.\"\n      )\n\n  # --- GitHub Helper Function ---\n  async def commit_manifest_to_github(payload: WebhookPayload) -> Dict[str, Any]:\n      \"\"\"\n      Helper function to commit the manifest directly to the configured branch.\n      \"\"\"\n      github_api_base_url = \"https://api.github.com\"\n      repo_file_url = (\n          f\"{github_api_base_url}/repos/{settings.GITHUB_REPO_OWNER}/\"\n          f\"{settings.GITHUB_REPO_NAME}/contents/{settings.GITHUB_FILE_PATH}\"\n      )\n      headers = {\n          \"Authorization\": f\"Bearer {settings.GITHUB_TOKEN}\",\n          \"Accept\": \"application/vnd.github.v3+json\",\n          \"X-GitHub-Api-Version\": \"2022-11-28\",\n      }\n      manifest_json_string = json.dumps(payload.manifest, indent=2)\n      content_base64 = base64.b64encode(manifest_json_string.encode('utf-8')).decode('utf-8')\n      commit_message = f\"feat: Update {settings.GITHUB_FILE_PATH} via webhook - commit {payload.commit_hash}\"\n      data_to_commit = {\n          \"message\": commit_message,\n          \"content\": content_base64,\n          \"branch\": settings.GITHUB_BRANCH,\n      }\n      async with httpx.AsyncClient() as client:\n          current_file_sha = None\n          try:\n              params_get = {\"ref\": settings.GITHUB_BRANCH}\n              response_get = await client.get(repo_file_url, headers=headers, params=params_get)\n              if response_get.status_code == 200:\n                  current_file_sha = response_get.json().get(\"sha\")\n              elif response_get.status_code != 404: # If not 404 (not found), it's an unexpected error\n                  response_get.raise_for_status()\n          except httpx.HTTPStatusError as e:\n              error_detail = f\"GitHub API error (GET file SHA): {e.response.status_code} - {e.response.text}\"\n              print(f\"[ERROR] {error_detail}\")\n              raise HTTPException(status_code=e.response.status_code, detail=error_detail)\n          except httpx.RequestError as e:\n              error_detail = f\"Network error connecting to GitHub (GET file SHA): {str(e)}\"\n              print(f\"[ERROR] {error_detail}\")\n              raise HTTPException(status_code=503, detail=error_detail)\n          if current_file_sha:\n              data_to_commit[\"sha\"] = current_file_sha\n          try:\n              response_put = await client.put(repo_file_url, headers=headers, json=data_to_commit)\n              response_put.raise_for_status()\n              return response_put.json()\n          except httpx.HTTPStatusError as e:\n              error_detail = f\"GitHub API error (PUT content): {e.response.status_code} - {e.response.text}\"\n              if e.response.status_code == 409: # Conflict\n                  error_detail = (\n                      f\"GitHub API conflict (PUT content): {e.response.text}. \"\n                      \"This might be due to an outdated SHA or branch protection rules.\"\n                  )\n              elif e.response.status_code == 422: # Unprocessable Entity\n                  error_detail = (\n                      f\"GitHub API Unprocessable Entity (PUT content): {e.response.text}. \"\n                      f\"Ensure the branch '{settings.GITHUB_BRANCH}' exists and the payload is correctly formatted.\"\n                  )\n              print(f\"[ERROR] {error_detail}\")\n              raise HTTPException(status_code=e.response.status_code, detail=error_detail)\n          except httpx.RequestError as e:\n              error_detail = f\"Network error connecting to GitHub (PUT content): {str(e)}\"\n              print(f\"[ERROR] {error_detail}\")\n              raise HTTPException(status_code=503, detail=error_detail)\n\n  # --- FastAPI Application ---\n  app = FastAPI(\n      title=\"Minimal Webhook to GitHub Commit Service\",\n      description=\"Receives a webhook and commits its 'manifest' part directly to a GitHub repository.\",\n      version=\"0.1.0\",\n  )\n\n  @app.post(\"/webhook/commit\", status_code=201, tags=[\"GitHub Webhooks\"])\n  async def handle_webhook_direct_commit(payload: WebhookPayload = Body(...)):\n      \"\"\"\n      Webhook endpoint to receive events and commit DIRECTLY to the configured branch.\n      \"\"\"\n      try:\n          github_response = await commit_manifest_to_github(payload)\n          return {\n              \"message\": \"Webhook received and manifest committed directly to GitHub successfully.\",\n              \"github_commit_details\": github_response.get(\"commit\", {}),\n              \"github_content_details\": github_response.get(\"content\", {})\n          }\n      except HTTPException:\n          raise # Re-raise if it's an HTTPException from the helper\n      except Exception as e:\n          error_message = f\"An unexpected error occurred: {str(e)}\"\n          print(f\"[ERROR] {error_message}\")\n          raise HTTPException(status_code=500, detail=\"An internal server error occurred.\")\n\n  @app.get(\"/health\", status_code=200, tags=[\"Health\"])\n  async def health_check():\n      \"\"\"\n      A simple health check endpoint.\n      \"\"\"\n      return {\"status\": \"ok\", \"message\": \"Service is running.\"}\n\n  # To run this server (save as main.py):\n  # 1. Install dependencies: pip install fastapi uvicorn pydantic pydantic-settings httpx python-dotenv\n  # 2. Create a .env file with your GitHub token and repo details.\n  # 3. Run with Uvicorn: uvicorn main:app --reload\n  # 4. Deploy to a public platform like Render.com.\n  ```\n\n  **Key aspects of this server:**\n\n  * **Configuration (`.env`):** It expects a `.env` file with your `GITHUB_TOKEN`, `GITHUB_REPO_OWNER`, and `GITHUB_REPO_NAME`. You can also customize `GITHUB_FILE_PATH` (default: `LangSmith_prompt_manifest.json`) and `GITHUB_BRANCH` (default: `main`).\n  * **GitHub Interaction:** The `commit_manifest_to_github` function handles the logic of fetching the current file's SHA (to update it) and then committing the new manifest content.\n  * **Webhook Endpoint (`/webhook/commit`):** This is the URL path your LangSmith webhook will target.\n  * **Error Handling:** Basic error handling for GitHub API interactions is included.\n\n  **Deploy this server to your chosen platform (e.g., Render) and note down its public URL (e.g., `https://prompt-commit-webhook.onrender.com`).**\n</Accordion>\n\n## Configuring the webhook in LangSmith\n\nOnce your FastAPI server is deployed and you have its public URL, you can configure the webhook in LangSmith:\n\n1. Navigate to your LangSmith workspace.\n\n2. Go to the **Prompts** section. Here you'll see a list of your prompts.\n\n   <img src=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-main.png?fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=7e61c83cdd67749970d8f0e401066d60\" alt=\"LangSmith Prompts section\" data-og-width=\"2996\" width=\"2996\" data-og-height=\"852\" height=\"852\" data-path=\"langsmith/images/prompt-commit-main.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-main.png?w=280&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=f492027577eacd4131954de447fa77f2 280w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-main.png?w=560&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=b5f7ea835f9cddd0724a209869c2512e 560w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-main.png?w=840&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=9aceebb242173d56a79e4974eb0fc7cd 840w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-main.png?w=1100&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=2ec5c08e0a4682b84a202ebb52bf981d 1100w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-main.png?w=1650&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=7dce8f5f164d40ab0f47dbf7e308382e 1650w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-main.png?w=2500&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=03f8d9d0d9368ec370a71f7605f019a2 2500w\" />\n\n3. On the top right of the Prompts page, click the **+ Webhook** button.\n\n4. You'll be presented with a form to configure your webhook:\n\n   <img src=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-webhook.png?fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=775cc6392de007e894c42400117d113e\" alt=\"LangSmith Webhook configuration modal\" data-og-width=\"3008\" width=\"3008\" data-og-height=\"1454\" height=\"1454\" data-path=\"langsmith/images/prompt-commit-webhook.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-webhook.png?w=280&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=a1d037dbc657bc0758b444d94d458c91 280w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-webhook.png?w=560&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=708b8a9d27bd584fdd3a4a8df17be36d 560w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-webhook.png?w=840&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=080f345e1d97aeac9b0d15a0d762fd42 840w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-webhook.png?w=1100&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=387781e1444e51ff64cc2b0f7f02cd26 1100w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-webhook.png?w=1650&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=c855c18d16698e49737ea6f581162970 1650w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-webhook.png?w=2500&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=38e417a519b578f880d59a6c23efb102 2500w\" />\n\n   * **Webhook URL:** Enter the full public URL of your deployed FastAPI server's endpoint. For our example server, this would be `https://prompt-commit-webhook.onrender.com/webhook/commit`.\n   * **Headers (Optional):**\n     * You can add custom headers that LangSmith will send with each webhook request.\n\n5. **Test the Webhook:** LangSmith provides a \"Send Test Notification\" button. Use this to send a sample payload to your server. Check your server logs (e.g., on Render) to ensure it receives the request and processes it successfully (or to debug any issues).\n\n6. **Save** the webhook configuration.\n\n## The workflow in action\n\n<img src=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-sequence-diagram.png?fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=823988be6300f39a6e9de784b34a2a77\" alt=\"Workflow Diagram showing: User saves prompt in LangSmith, LangSmith sends webhook to FastAPI Server, which interacts with GitHub to update files\" data-og-width=\"2922\" width=\"2922\" data-og-height=\"1014\" height=\"1014\" data-path=\"langsmith/images/prompt-sequence-diagram.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-sequence-diagram.png?w=280&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=13a26887fccdca822c175912ed7fbd3b 280w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-sequence-diagram.png?w=560&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=07e46cc25aa6d0ebe76b14ce9057936b 560w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-sequence-diagram.png?w=840&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=887758bfcf886c3062177706b7f22fb1 840w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-sequence-diagram.png?w=1100&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=a5aa30f606eac545f30a715eccfd80a1 1100w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-sequence-diagram.png?w=1650&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=32cae9f09ec30759550214f3c3e490ff 1650w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-sequence-diagram.png?w=2500&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=bced33a052aa88056de397389f9f7d64 2500w\" />\n\nNow, with everything set up, here's what happens:\n\n1. **Prompt Modification:** A user (developer or non-technical team member) modifies a prompt in the LangSmith UI and saves it, creating a new \"prompt commit.\"\n\n2. **Webhook Trigger:** LangSmith detects this new prompt commit and triggers the configured webhook.\n\n3. **HTTP Request:** LangSmith sends an HTTP POST request to the public URL of your FastAPI server (e.g., `https://prompt-commit-webhook.onrender.com/webhook/commit`). The body of this request contains the JSON prompt manifest for the entire workspace.\n\n4. **Server Receives Payload:** Your FastAPI server's endpoint receives the request.\n\n5. **GitHub Commit:** The server parses the JSON manifest from the request body. It then uses the configured GitHub Personal Access Token, repository owner, repository name, file path, and branch to:\n\n   * Check if the manifest file already exists in the repository on the specified branch to get its SHA (this is necessary for updating an existing file).\n   * Create a new commit with the latest prompt manifest, either creating the file or updating it if it already exists. The commit message will indicate that it's an update from LangSmith.\n\n6. **Confirmation:** You should see the new commit appear in your GitHub repository.\n\n   <img src=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-github.png?fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=213d6364ce20e4acf4e3eb7fe8c1b13d\" alt=\"Manifest commited to Github\" data-og-width=\"2982\" width=\"2982\" data-og-height=\"1270\" height=\"1270\" data-path=\"langsmith/images/prompt-commit-github.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-github.png?w=280&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=f03e1a469e28196f66bc1f92993e6045 280w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-github.png?w=560&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=645f3cf20850a03a89a2e56a53d95719 560w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-github.png?w=840&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=418f7716a8521e3d57a4381d4ebd4d08 840w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-github.png?w=1100&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=34af751c0c20b176c715f0c6f86654f1 1100w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-github.png?w=1650&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=13309faa18bde23df5e6df56521823fb 1650w, https://mintcdn.com/langchain-5e9cc07a/H9jA2WRyA-MV4-H0/langsmith/images/prompt-commit-github.png?w=2500&fit=max&auto=format&n=H9jA2WRyA-MV4-H0&q=85&s=f17d618b6d8e237aa8be023cccea4fd3 2500w\" />\n\nYou've now successfully synced your LangSmith prompts with GitHub!\n\n## Beyond a simple commit\n\nOur example FastAPI server performs a direct commit of the entire prompt manifest. However, this is just the starting point. You can extend the server's functionality to perform more sophisticated actions:\n\n* **Granular Commits:** Parse the manifest and commit changes to individual prompt files if you prefer a more granular structure in your repository.\n* **Trigger CI/CD:** Instead of (or in addition to) committing, have the server trigger a CI/CD pipeline (e.g., Jenkins, GitHub Actions, GitLab CI) to deploy a staging environment, run tests, or build new application versions.\n* **Update Databases/Caches:** If your application loads prompts from a database or cache, update these stores directly.\n* **Notifications:** Send notifications to Slack, email, or other communication channels about prompt changes.\n* **Selective Processing:** Based on metadata within the LangSmith payload (if available, e.g., which specific prompt changed or by whom), you could apply different logic.\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/prompt-commit.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 26643
}