{
  "title": "Backends",
  "source_url": "https://docs.langchain.com/oss/javascript/deepagents/backends",
  "content": "Choose and configure filesystem backends for deep agents. You can specify routes to different backends, implement virtual filesystems, and enforce policies.\n\nDeep agents expose a filesystem surface to the agent via tools like `ls`, `read_file`, `write_file`, `edit_file`, `glob`, and `grep`. These tools operate through a pluggable backend.\n\n```mermaid  theme={null}\ngraph TB\n    Tools[Filesystem Tools] --> Backend[Backend]\n\n    Backend --> State[State]\n    Backend --> Disk[Filesystem]\n    Backend --> Store[Store]\n    Backend --> Composite[Composite]\n    Backend --> Custom[Custom]\n\n    Composite --> Router{Routes}\n    Router --> State\n    Router --> Disk\n    Router --> Store\n```\n\nThis page explains how to [choose a backend](#specify-a-backend), [route different paths to different backends](#route-to-different-backends), [implement your own virtual filesystem](#use-a-virtual-filesystem) (e.g., S3 or Postgres), [add policy hooks](#add-policy-hooks), and [comply with the backend protocol](#protocol-reference).\n\n## Quickstart\n\nHere are a few pre-built filesystem backends that you can quickly use with your deep agent:\n\n| Built-in backend                                                 | Description                                                                                                                                                                                                                                                                                   |\n| ---------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Default](#statebackend-ephemeral)                               | `agent = create_deep_agent()` <br /> Ephemeral in state. The default filesystem backend for an agent is stored in `langgraph` state. Note that this filesystem only persists *for a single thread*.                                                                                           |\n| [Local filesystem persistence](#filesystembackend-local-disk)    | `agent = create_deep_agent(backend=FilesystemBackend(root_dir=\"/Users/nh/Desktop/\"))` <br />This gives the deep agent access to your local machine's filesystem. You can specify the root directory that the agent has access to. Note that any provided `root_dir` must be an absolute path. |\n| [Durable store (LangGraph store)](#storebackend-langgraph-store) | `agent = create_deep_agent(backend=lambda rt: StoreBackend(rt))` <br />This gives the agent access to long-term storage that is *persisted across threads*. This is great for storing longer term memories or instructions that are applicable to the agent over multiple executions.         |\n| [Composite](#compositebackend-router)                            | Ephemeral by default, `/memories/` persisted. The Composite backend is maximally flexible. You can specify different routes in the filesystem to point towards different backends. See Composite routing below for a ready-to-paste example.                                                  |\n\n## Built-in backends\n\n### StateBackend (ephemeral)\n\n```typescript  theme={null}\nimport { createDeepAgent, StateBackend } from \"deepagents\";\n\n// By default we provide a StateBackend\nconst agent = createDeepAgent();\n\n// Under the hood, it looks like\nconst agent2 = createDeepAgent({\n  backend: (rt) => new StateBackend(rt),   // Note that the tools access State through the runtime.state\n});\n```\n\n**How it works:**\n\n* Stores files in LangGraph agent state for the current thread.\n* Persists across multiple agent turns on the same thread via checkpoints.\n\n**Best for:**\n\n* A scratch pad for the agent to write intermediate results.\n* Automatic eviction of large tool outputs which the agent can then read back in piece by piece.\n\n### FilesystemBackend (local disk)\n\n```typescript  theme={null}\nimport { createDeepAgent, FilesystemBackend } from \"deepagents\";\n\nconst agent = createDeepAgent({\n  backend: new FilesystemBackend({ rootDir: \".\", virtualMode: true }),\n});\n```\n\n**How it works:**\n\n* Reads/writes real files under a configurable `root_dir`.\n* You can optionally set `virtual_mode=True` to sandbox and normalize paths under `root_dir`.\n* Uses secure path resolution, prevents unsafe symlink traversal when possible, can use ripgrep for fast `grep`.\n\n**Best for:**\n\n* Local projects on your machine\n* CI sandboxes\n* Mounted persistent volumes\n\n### StoreBackend (LangGraph Store)\n\n```typescript  theme={null}\nimport { createDeepAgent, StoreBackend } from \"deepagents\";\nimport { InMemoryStore } from \"@langchain/langgraph\";\n\nconst store = new InMemoryStore()\nconst agent = createDeepAgent({\n  backend: (rt) => new StoreBackend(rt),\n  store\n});\n```\n\n**How it works:**\n\n* Stores files in a LangGraph `BaseStore` provided by the runtime, enabling cross‑thread durable storage.\n\n**Best for:**\n\n* When you already run with a configured LangGraph store (for example, Redis, Postgres, or cloud implementations behind `BaseStore`).\n* When you're deploying your agent through LangSmith Deployments (a store is automatically provisioned for your agent).\n\n### CompositeBackend (router)\n\n```typescript  theme={null}\nimport { createDeepAgent, CompositeBackend, StateBackend, StoreBackend } from \"deepagents\";\nimport { InMemoryStore } from \"@langchain/langgraph\";\n\nconst compositeBackend = (rt) => new CompositeBackend(\n  new StateBackend(rt),\n  {\n    \"/memories/\": new StoreBackend(rt),\n  }\n);\n\nconst store = new InMemoryStore()\nconst agent = createDeepAgent({ backend: compositeBackend, store });\n```\n\n**How it works:**\n\n* Routes file operations to different backends based on path prefix.\n* Preserves the original path prefixes in listings and search results.\n\n**Best for:**\n\n* When you want to give your agent both ephemeral and cross-thread storage, a CompositeBackend allows you provide both a StateBackend and StoreBackend\n* When you have multiple sources of information that you want to provide to your agent as part of a single filesystem.\n  * e.g. You have long-term memories stored under /memories/ in one Store and you also have a custom backend that has documentation accessible at /docs/.\n\n## Specify a backend\n\n* Pass a backend to `create_deep_agent(backend=...)`. The filesystem middleware uses it for all tooling.\n* You can pass either:\n  * An instance implementing `BackendProtocol` (for example, `FilesystemBackend(root_dir=\".\")`), or\n  * A factory `BackendFactory = Callable[[ToolRuntime], BackendProtocol]` (for backends that need runtime like `StateBackend` or `StoreBackend`).\n* If omitted, the default is `lambda rt: StateBackend(rt)`.\n\n## Route to different backends\n\nRoute parts of the namespace to different backends. Commonly used to persist `/memories/*` and keep everything else ephemeral.\n\n```typescript  theme={null}\nimport { createDeepAgent, CompositeBackend, FilesystemBackend, StateBackend } from \"deepagents\";\n\nconst compositeBackend = (rt) => new CompositeBackend(\n  new StateBackend(rt),\n  {\n    \"/memories/\": new FilesystemBackend({ rootDir: \"/deepagents/myagent\", virtualMode: true }),\n  },\n);\n\nconst agent = createDeepAgent({ backend: compositeBackend });\n```\n\nBehavior:\n\n* `/workspace/plan.md` → StateBackend (ephemeral)\n* `/memories/agent.md` → FilesystemBackend under `/deepagents/myagent`\n* `ls`, `glob`, `grep` aggregate results and show original path prefixes.\n\nNotes:\n\n* Longer prefixes win (for example, route `\"/memories/projects/\"` can override `\"/memories/\"`).\n* For StoreBackend routing, ensure the agent runtime provides a store (`runtime.store`).\n\n## Use a virtual filesystem\n\nBuild a custom backend to project a remote or database filesystem (e.g., S3 or Postgres) into the tools namespace.\n\nDesign guidelines:\n\n* Paths are absolute (`/x/y.txt`). Decide how to map them to your storage keys/rows.\n* Implement `ls_info` and `glob_info` efficiently (server-side listing where available, otherwise local filter).\n* Return user-readable error strings for missing files or invalid regex patterns.\n* For external persistence, set `files_update=None` in results; only in-state backends should return a `files_update` dict.\n\nS3-style outline:\n\nPostgres-style outline:\n\n* Table `files(path text primary key, content text, created_at timestamptz, modified_at timestamptz)`\n* Map tool operations onto SQL:\n  * `ls_info` uses `WHERE path LIKE $1 || '%'`\n  * `glob_info` filter in SQL or fetch then apply glob in Python\n  * `grep_raw` can fetch candidate rows by extension or last modified time, then scan lines\n\n## Add policy hooks\n\nEnforce enterprise rules by subclassing or wrapping a backend.\n\nBlock writes/edits under selected prefixes (subclass):\n\nGeneric wrapper (works with any backend):\n\n## Protocol reference\n\nBackends must implement the `BackendProtocol`.\n\nRequired endpoints:\n\n* `ls_info(path: str) -> list[FileInfo]`\n  * Return entries with at least `path`. Include `is_dir`, `size`, `modified_at` when available. Sort by `path` for deterministic output.\n* `read(file_path: str, offset: int = 0, limit: int = 2000) -> str`\n  * Return numbered content. On missing file, return `\"Error: File '/x' not found\"`.\n* `grep_raw(pattern: str, path: Optional[str] = None, glob: Optional[str] = None) -> list[GrepMatch] | str`\n  * Return structured matches. For an invalid regex, return a string like `\"Invalid regex pattern: ...\"` (do not raise).\n* `glob_info(pattern: str, path: str = \"/\") -> list[FileInfo]`\n  * Return matched files as `FileInfo` entries (empty list if none).\n* `write(file_path: str, content: str) -> WriteResult`\n  * Create-only. On conflict, return `WriteResult(error=...)`. On success, set `path` and for state backends set `files_update={...}`; external backends should use `files_update=None`.\n* `edit(file_path: str, old_string: str, new_string: str, replace_all: bool = False) -> EditResult`\n  * Enforce uniqueness of `old_string` unless `replace_all=True`. If not found, return error. Include `occurrences` on success.\n\nSupporting types:\n\n* `WriteResult(error, path, files_update)`\n* `EditResult(error, path, files_update, occurrences)`\n* `FileInfo` with fields: `path` (required), optionally `is_dir`, `size`, `modified_at`.\n* `GrepMatch` with fields: `path`, `line`, `text`.\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/deepagents/backends.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 10767
}