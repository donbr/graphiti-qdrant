{
  "title": "Test",
  "source_url": "https://docs.langchain.com/oss/python/langgraph/test",
  "content": "After you've prototyped your LangGraph agent, a natural next step is to add tests. This guide covers some useful patterns you can use when writing unit tests.\n\nNote that this guide is LangGraph-specific and covers scenarios around graphs with custom structures - if you are just getting started, check out [this section](/oss/python/langchain/test/) that uses LangChain's built-in [`create_agent`](https://reference.langchain.com/python/langchain/agents/#langchain.agents.create_agent) instead.\n\n## Prerequisites\n\nFirst, make sure you have [`pytest`](https://docs.pytest.org/) installed:\n\n```bash  theme={null}\n$ pip install -U pytest\n```\n\n## Getting started\n\nBecause many LangGraph agents depend on state, a useful pattern is to create your graph before each test where you use it, then compile it within tests with a new checkpointer instance.\n\nThe below example shows how this works with a simple, linear graph that progresses through `node1` and `node2`. Each node updates the single state key `my_key`:\n\n```python  theme={null}\nimport pytest\n\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.checkpoint.memory import MemorySaver\n\ndef create_graph() -> StateGraph:\n    class MyState(TypedDict):\n        my_key: str\n\n    graph = StateGraph(MyState)\n    graph.add_node(\"node1\", lambda state: {\"my_key\": \"hello from node1\"})\n    graph.add_node(\"node2\", lambda state: {\"my_key\": \"hello from node2\"})\n    graph.add_edge(START, \"node1\")\n    graph.add_edge(\"node1\", \"node2\")\n    graph.add_edge(\"node2\", END)\n    return graph\n\ndef test_basic_agent_execution() -> None:\n    checkpointer = MemorySaver()\n    graph = create_graph()\n    compiled_graph = graph.compile(checkpointer=checkpointer)\n    result = compiled_graph.invoke(\n        {\"my_key\": \"initial_value\"},\n        config={\"configurable\": {\"thread_id\": \"1\"}}\n    )\n    assert result[\"my_key\"] == \"hello from node2\"\n```\n\n## Testing individual nodes and edges\n\nCompiled LangGraph agents expose references to each individual node as `graph.nodes`. You can take advantage of this to test individual nodes within your agent. Note that this will bypass any checkpointers passed when compiling the graph:\n\n```python  theme={null}\nimport pytest\n\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.checkpoint.memory import MemorySaver\n\ndef create_graph() -> StateGraph:\n    class MyState(TypedDict):\n        my_key: str\n\n    graph = StateGraph(MyState)\n    graph.add_node(\"node1\", lambda state: {\"my_key\": \"hello from node1\"})\n    graph.add_node(\"node2\", lambda state: {\"my_key\": \"hello from node2\"})\n    graph.add_edge(START, \"node1\")\n    graph.add_edge(\"node1\", \"node2\")\n    graph.add_edge(\"node2\", END)\n    return graph\n\ndef test_individual_node_execution() -> None:\n    # Will be ignored in this example\n    checkpointer = MemorySaver()\n    graph = create_graph()\n    compiled_graph = graph.compile(checkpointer=checkpointer)\n    # Only invoke node 1\n    result = compiled_graph.nodes[\"node1\"].invoke(\n        {\"my_key\": \"initial_value\"},\n    )\n    assert result[\"my_key\"] == \"hello from node1\"\n```\n\n## Partial execution\n\nFor agents made up of larger graphs, you may wish to test partial execution paths within your agent rather than the entire flow end-to-end. In some cases, it may make semantic sense to [restructure these sections as subgraphs](/oss/python/langgraph/use-subgraphs), which you can invoke in isolation as normal.\n\nHowever, if you do not wish to make changes to your agent graph's overall structure, you can use LangGraph's persistence mechanisms to simulate a state where your agent is paused right before the beginning of the desired section, and will pause again at the end of the desired section. The steps are as follows:\n\n1. Compile your agent with a checkpointer (the in-memory checkpointer [`InMemorySaver`](https://reference.langchain.com/python/langgraph/checkpoints/#langgraph.checkpoint.memory.InMemorySaver) will suffice for testing).\n2. Call your agent's [`update_state`](/oss/python/langgraph/use-time-travel) method with an [`as_node`](/oss/python/langgraph/persistence#as-node) parameter set to the name of the node *before* the one you want to start your test.\n3. Invoke your agent with the same `thread_id` you used to update the state and an `interrupt_after` parameter set to the name of the node you want to stop at.\n\nHere's an example that executes only the second and third nodes in a linear graph:\n\n```python  theme={null}\nimport pytest\n\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END\nfrom langgraph.checkpoint.memory import MemorySaver\n\ndef create_graph() -> StateGraph:\n    class MyState(TypedDict):\n        my_key: str\n\n    graph = StateGraph(MyState)\n    graph.add_node(\"node1\", lambda state: {\"my_key\": \"hello from node1\"})\n    graph.add_node(\"node2\", lambda state: {\"my_key\": \"hello from node2\"})\n    graph.add_node(\"node3\", lambda state: {\"my_key\": \"hello from node3\"})\n    graph.add_node(\"node4\", lambda state: {\"my_key\": \"hello from node4\"})\n    graph.add_edge(START, \"node1\")\n    graph.add_edge(\"node1\", \"node2\")\n    graph.add_edge(\"node2\", \"node3\")\n    graph.add_edge(\"node3\", \"node4\")\n    graph.add_edge(\"node4\", END)\n    return graph\n\ndef test_partial_execution_from_node2_to_node3() -> None:\n    checkpointer = MemorySaver()\n    graph = create_graph()\n    compiled_graph = graph.compile(checkpointer=checkpointer)\n    compiled_graph.update_state(\n        config={\n          \"configurable\": {\n            \"thread_id\": \"1\"\n          }\n        },\n        # The state passed into node 2 - simulating the state at\n        # the end of node 1\n        values={\"my_key\": \"initial_value\"},\n        # Update saved state as if it came from node 1\n        # Execution will resume at node 2\n        as_node=\"node1\",\n    )\n    result = compiled_graph.invoke(\n        # Resume execution by passing None\n        None,\n        config={\"configurable\": {\"thread_id\": \"1\"}},\n        # Stop after node 3 so that node 4 doesn't run\n        interrupt_after=\"node3\",\n    )\n    assert result[\"my_key\"] == \"hello from node3\"\n```\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/test.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 6514
}