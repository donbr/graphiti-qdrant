{
  "title": "Model Context Protocol (MCP)",
  "source_url": "https://docs.langchain.com/oss/javascript/langchain/mcp",
  "content": "[Model Context Protocol (MCP)](https://modelcontextprotocol.io/introduction) is an open protocol that standardizes how applications provide tools and context to LLMs. LangChain agents can use tools defined on MCP servers using the [`langchain-mcp-adapters`](https://github.com/langchain-ai/langchainjs/tree/main/libs/langchain-mcp-adapters/adapters) library.\n\n## Install\n\nInstall the `@langchain/mcp-adapters` library to use MCP tools in LangGraph:\n\n<CodeGroup>\n  ```bash npm theme={null}\n  npm install @langchain/mcp-adapters\n  ```\n\n  ```bash pnpm theme={null}\n  pnpm add @langchain/mcp-adapters\n  ```\n\n  ```bash yarn theme={null}\n  yarn add @langchain/mcp-adapters\n  ```\n\n  ```bash bun theme={null}\n  bun add @langchain/mcp-adapters\n  ```\n</CodeGroup>\n\n## Transport types\n\nMCP supports different transport mechanisms for client-server communication:\n\n* **stdio** – Client launches server as a subprocess and communicates via standard input/output. Best for local tools and simple setups.\n* **Streamable HTTP** – Server runs as an independent process handling HTTP requests. Supports remote connections and multiple clients.\n* **Server-Sent Events (SSE)** – a variant of streamable HTTP optimized for real-time streaming communication.\n\n## Use MCP tools\n\n`@langchain/mcp-adapters` enables agents to use tools defined across one or more MCP server.\n\n```ts Accessing multiple MCP servers icon=\"server\" theme={null}\nimport { MultiServerMCPClient } from \"@langchain/mcp-adapters\";  // [!code highlight]\nimport { ChatAnthropic } from \"@langchain/anthropic\";\nimport { createAgent } from \"langchain\";\n\nconst client = new MultiServerMCPClient({  // [!code highlight]\n    math: {\n        transport: \"stdio\",  // Local subprocess communication\n        command: \"node\",\n        // Replace with absolute path to your math_server.js file\n        args: [\"/path/to/math_server.js\"],\n    },\n    weather: {\n        transport: \"sse\",  // Server-Sent Events for streaming\n        // Ensure you start your weather server on port 8000\n        url: \"http://localhost:8000/mcp\",\n    },\n});\n\nconst tools = await client.getTools();  // [!code highlight]\nconst agent = createAgent({\n    model: \"claude-sonnet-4-5-20250929\",\n    tools,  // [!code highlight]\n});\n\nconst mathResponse = await agent.invoke({\n    messages: [{ role: \"user\", content: \"what's (3 + 5) x 12?\" }],\n});\n\nconst weatherResponse = await agent.invoke({\n    messages: [{ role: \"user\", content: \"what is the weather in nyc?\" }],\n});\n```\n\n<Note>\n  `MultiServerMCPClient` is **stateless by default**. Each tool invocation creates a fresh MCP `ClientSession`, executes the tool, and then cleans up.\n</Note>\n\n## Custom MCP servers\n\nTo create your own MCP servers, you can use the `@modelcontextprotocol/sdk` library. This library provides a simple way to define [tools](https://modelcontextprotocol.io/docs/learn/server-concepts#tools-ai-actions) and run them as servers.\n\n<CodeGroup>\n  ```bash npm theme={null}\n  npm install @modelcontextprotocol/sdk\n  ```\n\n  ```bash pnpm theme={null}\n  pnpm add @modelcontextprotocol/sdk\n  ```\n\n  ```bash yarn theme={null}\n  yarn add @modelcontextprotocol/sdk\n  ```\n\n  ```bash bun theme={null}\n  bun add @modelcontextprotocol/sdk\n  ```\n</CodeGroup>\n\nUse the following reference implementations to test your agent with MCP tool servers.\n\n```typescript title=\"Math server (stdio transport)\" icon=\"floppy-disk\" theme={null}\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n    CallToolRequestSchema,\n    ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nconst server = new Server(\n    {\n        name: \"math-server\",\n        version: \"0.1.0\",\n    },\n    {\n        capabilities: {\n        tools: {},\n        },\n    }\n);\n\nserver.setRequestHandler(ListToolsRequestSchema, async () => {\n    return {\n        tools: [\n        {\n            name: \"add\",\n            description: \"Add two numbers\",\n            inputSchema: {\n            type: \"object\",\n            properties: {\n                a: {\n                type: \"number\",\n                description: \"First number\",\n                },\n                b: {\n                type: \"number\",\n                description: \"Second number\",\n                },\n            },\n            required: [\"a\", \"b\"],\n            },\n        },\n        {\n            name: \"multiply\",\n            description: \"Multiply two numbers\",\n            inputSchema: {\n            type: \"object\",\n            properties: {\n                a: {\n                type: \"number\",\n                description: \"First number\",\n                },\n                b: {\n                type: \"number\",\n                description: \"Second number\",\n                },\n            },\n            required: [\"a\", \"b\"],\n            },\n        },\n        ],\n    };\n});\n\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n    switch (request.params.name) {\n        case \"add\": {\n        const { a, b } = request.params.arguments as { a: number; b: number };\n        return {\n            content: [\n            {\n                type: \"text\",\n                text: String(a + b),\n            },\n            ],\n        };\n        }\n        case \"multiply\": {\n        const { a, b } = request.params.arguments as { a: number; b: number };\n        return {\n            content: [\n            {\n                type: \"text\",\n                text: String(a * b),\n            },\n            ],\n        };\n        }\n        default:\n        throw new Error(`Unknown tool: ${request.params.name}`);\n    }\n});\n\nasync function main() {\n    const transport = new StdioServerTransport();\n    await server.connect(transport);\n    console.error(\"Math MCP server running on stdio\");\n}\n\nmain();\n```\n\n```typescript title=\"Weather server (SSE transport)\" icon=\"wifi\" theme={null}\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { SSEServerTransport } from \"@modelcontextprotocol/sdk/server/sse.js\";\nimport {\n    CallToolRequestSchema,\n    ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport express from \"express\";\n\nconst app = express();\napp.use(express.json());\n\nconst server = new Server(\n    {\n        name: \"weather-server\",\n        version: \"0.1.0\",\n    },\n    {\n        capabilities: {\n        tools: {},\n        },\n    }\n);\n\nserver.setRequestHandler(ListToolsRequestSchema, async () => {\n    return {\n        tools: [\n        {\n            name: \"get_weather\",\n            description: \"Get weather for location\",\n            inputSchema: {\n            type: \"object\",\n            properties: {\n                location: {\n                type: \"string\",\n                description: \"Location to get weather for\",\n                },\n            },\n            required: [\"location\"],\n            },\n        },\n        ],\n    };\n});\n\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n    switch (request.params.name) {\n        case \"get_weather\": {\n        const { location } = request.params.arguments as { location: string };\n        return {\n            content: [\n            {\n                type: \"text\",\n                text: `It's always sunny in ${location}`,\n            },\n            ],\n        };\n        }\n        default:\n        throw new Error(`Unknown tool: ${request.params.name}`);\n    }\n});\n\napp.post(\"/mcp\", async (req, res) => {\n    const transport = new SSEServerTransport(\"/mcp\", res);\n    await server.connect(transport);\n});\n\nconst PORT = process.env.PORT || 8000;\napp.listen(PORT, () => {\n    console.log(`Weather MCP server running on port ${PORT}`);\n});\n```\n\n## Stateful tool usage\n\nFor stateful servers that maintain context between tool calls, use `client.session()` to create a persistent `ClientSession`.\n\n```typescript Using MCP ClientSession for stateful tool usage theme={null}\nimport { loadMCPTools } from \"@langchain/mcp-adapters/tools.js\";\n\nconst client = new MultiServerMCPClient({...});\nconst session = await client.session(\"math\");\nconst tools = await loadMCPTools(session);\n```\n\n## Additional resources\n\n* [MCP documentation](https://modelcontextprotocol.io/introduction)\n\n* [MCP Transport documentation](https://modelcontextprotocol.io/docs/concepts/transports)\n\n* [`langchain-mcp-adapters`](https://github.com/langchain-ai/langchainjs/tree/main/libs/langchain-mcp-adapters/)\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/mcp.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 8762
}