{
  "title": "LangGraph runtime",
  "source_url": "https://docs.langchain.com/oss/python/langgraph/pregel",
  "content": "[`Pregel`](https://reference.langchain.com/python/langgraph/pregel/) implements LangGraph's runtime, managing the execution of LangGraph applications.\n\nCompiling a [StateGraph](https://reference.langchain.com/python/langgraph/graphs/#langgraph.graph.state.StateGraph) or creating an [`@entrypoint`](https://reference.langchain.com/python/langgraph/func/#langgraph.func.entrypoint) produces a [`Pregel`](https://reference.langchain.com/python/langgraph/pregel/) instance that can be invoked with input.\n\nThis guide explains the runtime at a high level and provides instructions for directly implementing applications with Pregel.\n\n> **Note:** The [`Pregel`](https://reference.langchain.com/python/langgraph/pregel/) runtime is named after [Google's Pregel algorithm](https://research.google/pubs/pub37252/), which describes an efficient method for large-scale parallel computation using graphs.\n\n## Overview\n\nIn LangGraph, Pregel combines [**actors**](https://en.wikipedia.org/wiki/Actor_model) and **channels** into a single application. **Actors** read data from channels and write data to channels. Pregel organizes the execution of the application into multiple steps, following the **Pregel Algorithm**/**Bulk Synchronous Parallel** model.\n\nEach step consists of three phases:\n\n* **Plan**: Determine which **actors** to execute in this step. For example, in the first step, select the **actors** that subscribe to the special **input** channels; in subsequent steps, select the **actors** that subscribe to channels updated in the previous step.\n* **Execution**: Execute all selected **actors** in parallel, until all complete, or one fails, or a timeout is reached. During this phase, channel updates are invisible to actors until the next step.\n* **Update**: Update the channels with the values written by the **actors** in this step.\n\nRepeat until no **actors** are selected for execution, or a maximum number of steps is reached.\n\n## Actors\n\nAn **actor** is a `PregelNode`. It subscribes to channels, reads data from them, and writes data to them. It can be thought of as an **actor** in the Pregel algorithm. `PregelNodes` implement LangChain's Runnable interface.\n\n## Channels\n\nChannels are used to communicate between actors (PregelNodes). Each channel has a value type, an update type, and an update function â€“ which takes a sequence of updates and modifies the stored value. Channels can be used to send data from one chain to another, or to send data from a chain to itself in a future step. LangGraph provides a number of built-in channels:\n\n* [`LastValue`](https://reference.langchain.com/python/langgraph/channels/#langgraph.channels.LastValue): The default channel, stores the last value sent to the channel, useful for input and output values, or for sending data from one step to the next.\n* [`Topic`](https://reference.langchain.com/python/langgraph/channels/#langgraph.channels.Topic): A configurable PubSub Topic, useful for sending multiple values between **actors**, or for accumulating output. Can be configured to deduplicate values or to accumulate values over the course of multiple steps.\n* [`BinaryOperatorAggregate`](https://reference.langchain.com/python/langgraph/pregel/#langgraph.pregel.Pregel--advanced-channels-context-and-binaryoperatoraggregate): stores a persistent value, updated by applying a binary operator to the current value and each update sent to the channel, useful for computing aggregates over multiple steps; e.g.,`total = BinaryOperatorAggregate(int, operator.add)`\n\n## Examples\n\nWhile most users will interact with Pregel through the [StateGraph](https://reference.langchain.com/python/langgraph/graphs/#langgraph.graph.state.StateGraph) API or the [`@entrypoint`](https://reference.langchain.com/python/langgraph/func/#langgraph.func.entrypoint) decorator, it is possible to interact with Pregel directly.\n\nBelow are a few different examples to give you a sense of the Pregel API.\n\n<Tabs>\n  <Tab title=\"Single node\">\n    ```python  theme={null}\n    from langgraph.channels import EphemeralValue\n    from langgraph.pregel import Pregel, NodeBuilder\n\n    node1 = (\n        NodeBuilder().subscribe_only(\"a\")\n        .do(lambda x: x + x)\n        .write_to(\"b\")\n    )\n\n    app = Pregel(\n        nodes={\"node1\": node1},\n        channels={\n            \"a\": EphemeralValue(str),\n            \"b\": EphemeralValue(str),\n        },\n        input_channels=[\"a\"],\n        output_channels=[\"b\"],\n    )\n\n    app.invoke({\"a\": \"foo\"})\n    ```\n\n    ```con  theme={null}\n    {'b': 'foofoo'}\n    ```\n  </Tab>\n\n  <Tab title=\"Multiple nodes\">\n    ```python  theme={null}\n    from langgraph.channels import LastValue, EphemeralValue\n    from langgraph.pregel import Pregel, NodeBuilder\n\n    node1 = (\n        NodeBuilder().subscribe_only(\"a\")\n        .do(lambda x: x + x)\n        .write_to(\"b\")\n    )\n\n    node2 = (\n        NodeBuilder().subscribe_only(\"b\")\n        .do(lambda x: x + x)\n        .write_to(\"c\")\n    )\n\n\n    app = Pregel(\n        nodes={\"node1\": node1, \"node2\": node2},\n        channels={\n            \"a\": EphemeralValue(str),\n            \"b\": LastValue(str),\n            \"c\": EphemeralValue(str),\n        },\n        input_channels=[\"a\"],\n        output_channels=[\"b\", \"c\"],\n    )\n\n    app.invoke({\"a\": \"foo\"})\n    ```\n\n    ```con  theme={null}\n    {'b': 'foofoo', 'c': 'foofoofoofoo'}\n    ```\n  </Tab>\n\n  <Tab title=\"Topic\">\n    ```python  theme={null}\n    from langgraph.channels import EphemeralValue, Topic\n    from langgraph.pregel import Pregel, NodeBuilder\n\n    node1 = (\n        NodeBuilder().subscribe_only(\"a\")\n        .do(lambda x: x + x)\n        .write_to(\"b\", \"c\")\n    )\n\n    node2 = (\n        NodeBuilder().subscribe_to(\"b\")\n        .do(lambda x: x[\"b\"] + x[\"b\"])\n        .write_to(\"c\")\n    )\n\n    app = Pregel(\n        nodes={\"node1\": node1, \"node2\": node2},\n        channels={\n            \"a\": EphemeralValue(str),\n            \"b\": EphemeralValue(str),\n            \"c\": Topic(str, accumulate=True),\n        },\n        input_channels=[\"a\"],\n        output_channels=[\"c\"],\n    )\n\n    app.invoke({\"a\": \"foo\"})\n    ```\n\n    ```pycon  theme={null}\n    {'c': ['foofoo', 'foofoofoofoo']}\n    ```\n  </Tab>\n\n  <Tab title=\"BinaryOperatorAggregate\">\n    This example demonstrates how to use the [`BinaryOperatorAggregate`](https://reference.langchain.com/python/langgraph/pregel/#langgraph.pregel.Pregel--advanced-channels-context-and-binaryoperatoraggregate) channel to implement a reducer.\n\n    ```python  theme={null}\n    from langgraph.channels import EphemeralValue, BinaryOperatorAggregate\n    from langgraph.pregel import Pregel, NodeBuilder\n\n\n    node1 = (\n        NodeBuilder().subscribe_only(\"a\")\n        .do(lambda x: x + x)\n        .write_to(\"b\", \"c\")\n    )\n\n    node2 = (\n        NodeBuilder().subscribe_only(\"b\")\n        .do(lambda x: x + x)\n        .write_to(\"c\")\n    )\n\n    def reducer(current, update):\n        if current:\n            return current + \" | \" + update\n        else:\n            return update\n\n    app = Pregel(\n        nodes={\"node1\": node1, \"node2\": node2},\n        channels={\n            \"a\": EphemeralValue(str),\n            \"b\": EphemeralValue(str),\n            \"c\": BinaryOperatorAggregate(str, operator=reducer),\n        },\n        input_channels=[\"a\"],\n        output_channels=[\"c\"],\n    )\n\n    app.invoke({\"a\": \"foo\"})\n    ```\n  </Tab>\n\n  <Tab title=\"Cycle\">\n    This example demonstrates how to introduce a cycle in the graph, by having\n    a chain write to a channel it subscribes to. Execution will continue\n    until a `None` value is written to the channel.\n\n    ```python  theme={null}\n    from langgraph.channels import EphemeralValue\n    from langgraph.pregel import Pregel, NodeBuilder, ChannelWriteEntry\n\n    example_node = (\n        NodeBuilder().subscribe_only(\"value\")\n        .do(lambda x: x + x if len(x) < 10 else None)\n        .write_to(ChannelWriteEntry(\"value\", skip_none=True))\n    )\n\n    app = Pregel(\n        nodes={\"example_node\": example_node},\n        channels={\n            \"value\": EphemeralValue(str),\n        },\n        input_channels=[\"value\"],\n        output_channels=[\"value\"],\n    )\n\n    app.invoke({\"value\": \"a\"})\n    ```\n\n    ```pycon  theme={null}\n    {'value': 'aaaaaaaaaaaaaaaa'}\n    ```\n  </Tab>\n</Tabs>\n\n## High-level API\n\nLangGraph provides two high-level APIs for creating a Pregel application: the [StateGraph (Graph API)](/oss/python/langgraph/graph-api) and the [Functional API](/oss/python/langgraph/functional-api).\n\n<Tabs>\n  <Tab title=\"StateGraph (Graph API)\">\n    The [StateGraph (Graph API)](https://reference.langchain.com/python/langgraph/graphs/#langgraph.graph.state.StateGraph) is a higher-level abstraction that simplifies the creation of Pregel applications. It allows you to define a graph of nodes and edges. When you compile the graph, the StateGraph API automatically creates the Pregel application for you.\n\n    ```python  theme={null}\n    from typing import TypedDict\n\n    from langgraph.constants import START\n    from langgraph.graph import StateGraph\n\n    class Essay(TypedDict):\n        topic: str\n        content: str | None\n        score: float | None\n\n    def write_essay(essay: Essay):\n        return {\n            \"content\": f\"Essay about {essay['topic']}\",\n        }\n\n    def score_essay(essay: Essay):\n        return {\n            \"score\": 10\n        }\n\n    builder = StateGraph(Essay)\n    builder.add_node(write_essay)\n    builder.add_node(score_essay)\n    builder.add_edge(START, \"write_essay\")\n    builder.add_edge(\"write_essay\", \"score_essay\")\n\n    # Compile the graph.\n    # This will return a Pregel instance.\n    graph = builder.compile()\n    ```\n\n    The compiled Pregel instance will be associated with a list of nodes and channels. You can inspect the nodes and channels by printing them.\n\n    ```python  theme={null}\n    print(graph.nodes)\n    ```\n\n    You will see something like this:\n\n    ```pycon  theme={null}\n    {'__start__': <langgraph.pregel.read.PregelNode at 0x7d05e3ba1810>,\n     'write_essay': <langgraph.pregel.read.PregelNode at 0x7d05e3ba14d0>,\n     'score_essay': <langgraph.pregel.read.PregelNode at 0x7d05e3ba1710>}\n    ```\n\n    ```python  theme={null}\n    print(graph.channels)\n    ```\n\n    You should see something like this\n\n    ```pycon  theme={null}\n    {'topic': <langgraph.channels.last_value.LastValue at 0x7d05e3294d80>,\n     'content': <langgraph.channels.last_value.LastValue at 0x7d05e3295040>,\n     'score': <langgraph.channels.last_value.LastValue at 0x7d05e3295980>,\n     '__start__': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e3297e00>,\n     'write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e32960c0>,\n     'score_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d8ab80>,\n     'branch:__start__:__self__:write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e32941c0>,\n     'branch:__start__:__self__:score_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d88800>,\n     'branch:write_essay:__self__:write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e3295ec0>,\n     'branch:write_essay:__self__:score_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d8ac00>,\n     'branch:score_essay:__self__:write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d89700>,\n     'branch:score_essay:__self__:score_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d8b400>,\n     'start:write_essay': <langgraph.channels.ephemeral_value.EphemeralValue at 0x7d05e2d8b280>}\n    ```\n  </Tab>\n\n  <Tab title=\"Functional API\">\n    In the [Functional API](/oss/python/langgraph/functional-api), you can use an [`@entrypoint`](https://reference.langchain.com/python/langgraph/func/#langgraph.func.entrypoint) to create a Pregel application. The `entrypoint` decorator allows you to define a function that takes input and returns output.\n\n    ```python  theme={null}\n    from typing import TypedDict\n\n    from langgraph.checkpoint.memory import InMemorySaver\n    from langgraph.func import entrypoint\n\n    class Essay(TypedDict):\n        topic: str\n        content: str | None\n        score: float | None\n\n\n    checkpointer = InMemorySaver()\n\n    @entrypoint(checkpointer=checkpointer)\n    def write_essay(essay: Essay):\n        return {\n            \"content\": f\"Essay about {essay['topic']}\",\n        }\n\n    print(\"Nodes: \")\n    print(write_essay.nodes)\n    print(\"Channels: \")\n    print(write_essay.channels)\n    ```\n\n    ```pycon  theme={null}\n    Nodes:\n    {'write_essay': <langgraph.pregel.read.PregelNode object at 0x7d05e2f9aad0>}\n    Channels:\n    {'__start__': <langgraph.channels.ephemeral_value.EphemeralValue object at 0x7d05e2c906c0>, '__end__': <langgraph.channels.last_value.LastValue object at 0x7d05e2c90c40>, '__previous__': <langgraph.channels.last_value.LastValue object at 0x7d05e1007280>}\n    ```\n  </Tab>\n</Tabs>\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/pregel.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 13265
}