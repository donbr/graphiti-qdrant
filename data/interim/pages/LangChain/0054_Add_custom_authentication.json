{
  "title": "Add custom authentication",
  "source_url": "https://docs.langchain.com/langsmith/custom-auth",
  "content": "This guide shows you how to add custom authentication to your LangSmith application. The steps on this page apply to both [cloud](/langsmith/cloud) and [self-hosted](/langsmith/self-hosted) deployments. It does not apply to isolated usage of the [LangGraph open source library](/oss/python/langgraph/overview) in your own custom server.\n\n## Add custom authentication to your deployment\n\nTo leverage custom authentication and access user-level metadata in your deployments, set up custom authentication to automatically populate the `config[\"configurable\"][\"langgraph_auth_user\"]` object through a custom authentication handler. You can then access this object in your graph with the `langgraph_auth_user` key to [allow an agent to perform authenticated actions on behalf of the user](#enable-agent-authentication).\n\n1. Implement authentication:\n\n   <Note>\n     Without a custom `@auth.authenticate` handler, LangGraph sees only the API-key owner (usually the developer), so requests arenâ€™t scoped to individual end-users. To propagate custom tokens, you must implement your own handler.\n   </Note>\n\n   ```python  theme={null}\n   from langgraph_sdk import Auth\n   import requests\n\n   auth = Auth()\n\n   def is_valid_key(api_key: str) -> bool:\n       is_valid = # your API key validation logic\n       return is_valid\n\n   @auth.authenticate # (1)!\n   async def authenticate(headers: dict) -> Auth.types.MinimalUserDict:\n       api_key = headers.get(b\"x-api-key\")\n       if not api_key or not is_valid_key(api_key):\n           raise Auth.exceptions.HTTPException(status_code=401, detail=\"Invalid API key\")\n\n       # Fetch user-specific tokens from your secret store\n       user_tokens = await fetch_user_tokens(api_key)\n\n       return { # (2)!\n           \"identity\": api_key,  #  fetch user ID from LangSmith\n           \"github_token\" : user_tokens.github_token\n           \"jira_token\" : user_tokens.jira_token\n           # ... custom fields/secrets here\n       }\n   ```\n\n* This handler receives the request (headers, etc.), validates the user, and returns a dictionary with at least an identity field.\n* You can add any custom fields you want (e.g., OAuth tokens, roles, org IDs, etc.).\n\n2. In your [`langgraph.json`](/langsmith/application-structure#configuration-file), add the path to your auth file:\n\n   ```json highlight={7-9} theme={null}\n   {\n       \"dependencies\": [\".\"],\n       \"graphs\": {\n       \"agent\": \"./agent.py:graph\"\n       },\n       \"env\": \".env\",\n       \"auth\": {\n           \"path\": \"./auth.py:my_auth\"\n       }\n   }\n   ```\n3. Once you've set up authentication in your server, requests must include the required authorization information based on your chosen scheme. Assuming you are using JWT token authentication, you could access your deployments using any of the following methods:\n\n   <Tabs>\n     <Tab title=\"Python Client\">\n       ```python  theme={null}\n       from langgraph_sdk import get_client\n\n       my_token = \"your-token\" # In practice, you would generate a signed token with your auth provider\n       client = get_client(\n           url=\"http://localhost:2024\",\n           headers={\"Authorization\": f\"Bearer {my_token}\"}\n       )\n       threads = await client.threads.search()\n       ```\n     </Tab>\n\n     <Tab title=\"Python RemoteGraph\">\n       ```python  theme={null}\n       from langgraph.pregel.remote import RemoteGraph\n\n       my_token = \"your-token\" # In practice, you would generate a signed token with your auth provider\n       remote-graph = RemoteGraph(\n           \"agent\",\n           url=\"http://localhost:2024\",\n           headers={\"Authorization\": f\"Bearer {my_token}\"}\n       )\n       threads = await remote-graph.ainvoke(...)\n       ```\n     </Tab>\n\n     <Tab title=\"JavaScript Client\">\n       ```javascript  theme={null}\n       import { Client } from \"@langchain/langgraph-sdk\";\n\n       const my_token = \"your-token\"; // In practice, you would generate a signed token with your auth provider\n       const client = new Client({\n       apiUrl: \"http://localhost:2024\",\n       defaultHeaders: { Authorization: `Bearer ${my_token}` },\n       });\n       const threads = await client.threads.search();\n       ```\n     </Tab>\n\n     <Tab title=\"JavaScript RemoteGraph\">\n       ```javascript  theme={null}\n       import { RemoteGraph } from \"@langchain/langgraph/remote\";\n\n       const my_token = \"your-token\"; // In practice, you would generate a signed token with your auth provider\n       const remoteGraph = new RemoteGraph({\n       graphId: \"agent\",\n       url: \"http://localhost:2024\",\n       headers: { Authorization: `Bearer ${my_token}` },\n       });\n       const threads = await remoteGraph.invoke(...);\n       ```\n     </Tab>\n\n     <Tab title=\"CURL\">\n       ```bash  theme={null}\n       curl -H \"Authorization: Bearer ${your-token}\" http://localhost:2024/threads\n       ```\n     </Tab>\n   </Tabs>\n\n   For more details on RemoteGraph, refer to the [Use RemoteGraph](/langsmith/use-remote-graph) guide.\n\n## Enable agent authentication\n\nAfter [authentication](#add-custom-authentication-to-your-deployment), the platform creates a special configuration object (`config`) that is passed to LangSmith deployment. This object contains information about the current user, including any custom fields you return from your `@auth.authenticate` handler.\n\nTo allow an agent to perform authenticated actions on behalf of the user, access this object in your graph with the `langgraph_auth_user` key:\n\n```python  theme={null}\ndef my_node(state, config):\n    user_config = config[\"configurable\"].get(\"langgraph_auth_user\")\n    # token was resolved during the @auth.authenticate function\n    token = user_config.get(\"github_token\",\"\")\n    ...\n```\n\n<Note>\n  Fetch user credentials from a secure secret store. Storing secrets in graph state is not recommended.\n</Note>\n\n### Authorizing a user for Studio\n\nBy default, if you add custom authorization on your resources, this will also apply to interactions made from [Studio](/langsmith/studio). If you want, you can handle logged-in Studio users differently by checking [is\\_studio\\_user()](https://langchain-ai.github.io/langgraph/cloud/reference/sdk/python_sdk_ref/#langgraph_sdk.auth.types.StudioUser).\n\n<Note>\n  `is_studio_user` was added in version 0.1.73 of the langgraph-sdk. If you're on an older version, you can still check whether `isinstance(ctx.user, StudioUser)`.\n</Note>\n\n```python  theme={null}\nfrom langgraph_sdk.auth import is_studio_user, Auth\nauth = Auth()\n\n# ... Setup authenticate, etc.\n\n@auth.on\nasync def add_owner(\n    ctx: Auth.types.AuthContext,\n    value: dict  # The payload being sent to this access method\n) -> dict:  # Returns a filter dict that restricts access to resources\n    if is_studio_user(ctx.user):\n        return {}\n\n    filters = {\"owner\": ctx.user.identity}\n    metadata = value.setdefault(\"metadata\", {})\n    metadata.update(filters)\n    return filters\n```\n\nOnly use this if you want to permit developer access to a graph deployed on the managed LangSmith SaaS.\n\n## Learn more\n\n* [Authentication & Access Control](/langsmith/auth)\n* [Setting up custom authentication tutorial](/langsmith/set-up-custom-auth)\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/custom-auth.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 7489
}