{
  "title": "Subgraphs",
  "source_url": "https://docs.langchain.com/oss/python/langgraph/use-subgraphs",
  "content": "This guide explains the mechanics of using subgraphs. A subgraph is a [graph](/oss/python/langgraph/graph-api#graphs) that is used as a [node](/oss/python/langgraph/graph-api#nodes) in another graph.\n\nSubgraphs are useful for:\n\n* Building [multi-agent systems](/oss/python/langchain/multi-agent)\n* Re-using a set of nodes in multiple graphs\n* Distributing development: when you want different teams to work on different parts of the graph independently, you can define each part as a subgraph, and as long as the subgraph interface (the input and output schemas) is respected, the parent graph can be built without knowing any details of the subgraph\n\nWhen adding subgraphs, you need to define how the parent graph and the subgraph communicate:\n\n* [Invoke a graph from a node](#invoke-a-graph-from-a-node) — subgraphs are called from inside a node in the parent graph\n* [Add a graph as a node](#add-a-graph-as-a-node) — a subgraph is added directly as a node in the parent and **shares [state keys](/oss/python/langgraph/graph-api#state)** with the parent\n\n## Setup\n\n<CodeGroup>\n  ```bash pip theme={null}\n  pip install -U langgraph\n  ```\n\n  ```bash uv theme={null}\n  uv add langgraph\n  ```\n</CodeGroup>\n\n<Tip>\n  **Set up LangSmith for LangGraph development**\n  Sign up for [LangSmith](https://smith.langchain.com) to quickly spot issues and improve the performance of your LangGraph projects. LangSmith lets you use trace data to debug, test, and monitor your LLM apps built with LangGraph — read more about how to get started [here](https://docs.smith.langchain.com).\n</Tip>\n\n## Invoke a graph from a node\n\nA simple way to implement a subgraph is to invoke a graph from inside the node of another graph. In this case subgraphs can have **completely different schemas** from the parent graph (no shared keys). For example, you might want to keep a private message history for each of the agents in a [multi-agent](/oss/python/langchain/multi-agent) system.\n\nIf that's the case for your application, you need to define a node **function that invokes the subgraph**. This function needs to transform the input (parent) state to the subgraph state before invoking the subgraph, and transform the results back to the parent state before returning the state update from the node.\n\n```python  theme={null}\nfrom typing_extensions import TypedDict\nfrom langgraph.graph.state import StateGraph, START\n\nclass SubgraphState(TypedDict):\n    bar: str\n\n# Subgraph\n\ndef subgraph_node_1(state: SubgraphState):\n    return {\"bar\": \"hi! \" + state[\"bar\"]}\n\nsubgraph_builder = StateGraph(SubgraphState)\nsubgraph_builder.add_node(subgraph_node_1)\nsubgraph_builder.add_edge(START, \"subgraph_node_1\")\nsubgraph = subgraph_builder.compile()\n\n# Parent graph\n\nclass State(TypedDict):\n    foo: str\n\ndef call_subgraph(state: State):\n    # Transform the state to the subgraph state\n    subgraph_output = subgraph.invoke({\"bar\": state[\"foo\"]})  # [!code highlight]\n    # Transform response back to the parent state\n    return {\"foo\": subgraph_output[\"bar\"]}\n\nbuilder = StateGraph(State)\nbuilder.add_node(\"node_1\", call_subgraph)\nbuilder.add_edge(START, \"node_1\")\ngraph = builder.compile()\n```\n\n<Accordion title=\"Full example: different state schemas\">\n  ```python  theme={null}\n  from typing_extensions import TypedDict\n  from langgraph.graph.state import StateGraph, START\n\n  # Define subgraph\n  class SubgraphState(TypedDict):\n      # note that none of these keys are shared with the parent graph state\n      bar: str\n      baz: str\n\n  def subgraph_node_1(state: SubgraphState):\n      return {\"baz\": \"baz\"}\n\n  def subgraph_node_2(state: SubgraphState):\n      return {\"bar\": state[\"bar\"] + state[\"baz\"]}\n\n  subgraph_builder = StateGraph(SubgraphState)\n  subgraph_builder.add_node(subgraph_node_1)\n  subgraph_builder.add_node(subgraph_node_2)\n  subgraph_builder.add_edge(START, \"subgraph_node_1\")\n  subgraph_builder.add_edge(\"subgraph_node_1\", \"subgraph_node_2\")\n  subgraph = subgraph_builder.compile()\n\n  # Define parent graph\n  class ParentState(TypedDict):\n      foo: str\n\n  def node_1(state: ParentState):\n      return {\"foo\": \"hi! \" + state[\"foo\"]}\n\n  def node_2(state: ParentState):\n      # Transform the state to the subgraph state\n      response = subgraph.invoke({\"bar\": state[\"foo\"]})\n      # Transform response back to the parent state\n      return {\"foo\": response[\"bar\"]}\n\n\n  builder = StateGraph(ParentState)\n  builder.add_node(\"node_1\", node_1)\n  builder.add_node(\"node_2\", node_2)\n  builder.add_edge(START, \"node_1\")\n  builder.add_edge(\"node_1\", \"node_2\")\n  graph = builder.compile()\n\n  for chunk in graph.stream({\"foo\": \"foo\"}, subgraphs=True):\n      print(chunk)\n  ```\n\n  ```\n  ((), {'node_1': {'foo': 'hi! foo'}})\n  (('node_2:9c36dd0f-151a-cb42-cbad-fa2f851f9ab7',), {'grandchild_1': {'my_grandchild_key': 'hi Bob, how are you'}})\n  (('node_2:9c36dd0f-151a-cb42-cbad-fa2f851f9ab7',), {'grandchild_2': {'bar': 'hi! foobaz'}})\n  ((), {'node_2': {'foo': 'hi! foobaz'}})\n  ```\n</Accordion>\n\n<Accordion title=\"Full example: different state schemas (two levels of subgraphs)\">\n  This is an example with two levels of subgraphs: parent -> child -> grandchild.\n\n  ```python  theme={null}\n  # Grandchild graph\n  from typing_extensions import TypedDict\n  from langgraph.graph.state import StateGraph, START, END\n\n  class GrandChildState(TypedDict):\n      my_grandchild_key: str\n\n  def grandchild_1(state: GrandChildState) -> GrandChildState:\n      # NOTE: child or parent keys will not be accessible here\n      return {\"my_grandchild_key\": state[\"my_grandchild_key\"] + \", how are you\"}\n\n\n  grandchild = StateGraph(GrandChildState)\n  grandchild.add_node(\"grandchild_1\", grandchild_1)\n\n  grandchild.add_edge(START, \"grandchild_1\")\n  grandchild.add_edge(\"grandchild_1\", END)\n\n  grandchild_graph = grandchild.compile()\n\n  # Child graph\n  class ChildState(TypedDict):\n      my_child_key: str\n\n  def call_grandchild_graph(state: ChildState) -> ChildState:\n      # NOTE: parent or grandchild keys won't be accessible here\n      grandchild_graph_input = {\"my_grandchild_key\": state[\"my_child_key\"]}\n      grandchild_graph_output = grandchild_graph.invoke(grandchild_graph_input)\n      return {\"my_child_key\": grandchild_graph_output[\"my_grandchild_key\"] + \" today?\"}\n\n  child = StateGraph(ChildState)\n  # We're passing a function here instead of just compiled graph (`grandchild_graph`)\n  child.add_node(\"child_1\", call_grandchild_graph)\n  child.add_edge(START, \"child_1\")\n  child.add_edge(\"child_1\", END)\n  child_graph = child.compile()\n\n  # Parent graph\n  class ParentState(TypedDict):\n      my_key: str\n\n  def parent_1(state: ParentState) -> ParentState:\n      # NOTE: child or grandchild keys won't be accessible here\n      return {\"my_key\": \"hi \" + state[\"my_key\"]}\n\n  def parent_2(state: ParentState) -> ParentState:\n      return {\"my_key\": state[\"my_key\"] + \" bye!\"}\n\n  def call_child_graph(state: ParentState) -> ParentState:\n      child_graph_input = {\"my_child_key\": state[\"my_key\"]}\n      child_graph_output = child_graph.invoke(child_graph_input)\n      return {\"my_key\": child_graph_output[\"my_child_key\"]}\n\n  parent = StateGraph(ParentState)\n  parent.add_node(\"parent_1\", parent_1)\n  # We're passing a function here instead of just a compiled graph (`child_graph`)\n  parent.add_node(\"child\", call_child_graph)\n  parent.add_node(\"parent_2\", parent_2)\n\n  parent.add_edge(START, \"parent_1\")\n  parent.add_edge(\"parent_1\", \"child\")\n  parent.add_edge(\"child\", \"parent_2\")\n  parent.add_edge(\"parent_2\", END)\n\n  parent_graph = parent.compile()\n\n  for chunk in parent_graph.stream({\"my_key\": \"Bob\"}, subgraphs=True):\n      print(chunk)\n  ```\n\n  ```\n  ((), {'parent_1': {'my_key': 'hi Bob'}})\n  (('child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b', 'child_1:781bb3b1-3971-84ce-810b-acf819a03f9c'), {'grandchild_1': {'my_grandchild_key': 'hi Bob, how are you'}})\n  (('child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b',), {'child_1': {'my_child_key': 'hi Bob, how are you today?'}})\n  ((), {'child': {'my_key': 'hi Bob, how are you today?'}})\n  ((), {'parent_2': {'my_key': 'hi Bob, how are you today? bye!'}})\n  ```\n</Accordion>\n\n## Add a graph as a node\n\nWhen the parent graph and subgraph can communicate over a shared state key (channel) in the [schema](/oss/python/langgraph/graph-api#state), you can add a graph as a [node](/oss/python/langgraph/graph-api#nodes) in another graph. For example, in [multi-agent](/oss/python/langchain/multi-agent) systems, the agents often communicate over a shared [messages](/oss/python/langgraph/graph-api#why-use-messages) key.\n\n<img src=\"https://mintcdn.com/langchain-5e9cc07a/ybiAaBfoBvFquMDz/oss/images/subgraph.png?fit=max&auto=format&n=ybiAaBfoBvFquMDz&q=85&s=c280df5c968cd4237b0b5d03823d8946\" alt=\"SQL agent graph\" style={{ height: \"450px\" }} data-og-width=\"1177\" width=\"1177\" data-og-height=\"818\" height=\"818\" data-path=\"oss/images/subgraph.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/ybiAaBfoBvFquMDz/oss/images/subgraph.png?w=280&fit=max&auto=format&n=ybiAaBfoBvFquMDz&q=85&s=e3d08dae8fb81e15b4d8069a48999eac 280w, https://mintcdn.com/langchain-5e9cc07a/ybiAaBfoBvFquMDz/oss/images/subgraph.png?w=560&fit=max&auto=format&n=ybiAaBfoBvFquMDz&q=85&s=8d8942031ba051119e0cb772ef697e0b 560w, https://mintcdn.com/langchain-5e9cc07a/ybiAaBfoBvFquMDz/oss/images/subgraph.png?w=840&fit=max&auto=format&n=ybiAaBfoBvFquMDz&q=85&s=0d5285bd104c542fe660bc09fed53e5e 840w, https://mintcdn.com/langchain-5e9cc07a/ybiAaBfoBvFquMDz/oss/images/subgraph.png?w=1100&fit=max&auto=format&n=ybiAaBfoBvFquMDz&q=85&s=32bc8ffa0eda13a0f3bb163631774a60 1100w, https://mintcdn.com/langchain-5e9cc07a/ybiAaBfoBvFquMDz/oss/images/subgraph.png?w=1650&fit=max&auto=format&n=ybiAaBfoBvFquMDz&q=85&s=6a511f3b9dc44383614803d32390875a 1650w, https://mintcdn.com/langchain-5e9cc07a/ybiAaBfoBvFquMDz/oss/images/subgraph.png?w=2500&fit=max&auto=format&n=ybiAaBfoBvFquMDz&q=85&s=169d55e154e5ea0146a57373235f768e 2500w\" />\n\nIf your subgraph shares state keys with the parent graph, you can follow these steps to add it to your graph:\n\n1. Define the subgraph workflow (`subgraph_builder` in the example below) and compile it\n2. Pass compiled subgraph to the [`add_node`](https://reference.langchain.com/python/langgraph/graphs/#langgraph.graph.state.StateGraph.add_node) method when defining the parent graph workflow\n\n```python  theme={null}\nfrom typing_extensions import TypedDict\nfrom langgraph.graph.state import StateGraph, START\n\nclass State(TypedDict):\n    foo: str\n\n# Subgraph\n\ndef subgraph_node_1(state: State):\n    return {\"foo\": \"hi! \" + state[\"foo\"]}\n\nsubgraph_builder = StateGraph(State)\nsubgraph_builder.add_node(subgraph_node_1)\nsubgraph_builder.add_edge(START, \"subgraph_node_1\")\nsubgraph = subgraph_builder.compile()\n\n# Parent graph\n\nbuilder = StateGraph(State)\nbuilder.add_node(\"node_1\", subgraph)  # [!code highlight]\nbuilder.add_edge(START, \"node_1\")\ngraph = builder.compile()\n```\n\n<Accordion title=\"Full example: shared state schemas\">\n  ```python  theme={null}\n  from typing_extensions import TypedDict\n  from langgraph.graph.state import StateGraph, START\n\n  # Define subgraph\n  class SubgraphState(TypedDict):\n      foo: str  # shared with parent graph state\n      bar: str  # private to SubgraphState\n\n  def subgraph_node_1(state: SubgraphState):\n      return {\"bar\": \"bar\"}\n\n  def subgraph_node_2(state: SubgraphState):\n      # note that this node is using a state key ('bar') that is only available in the subgraph\n      # and is sending update on the shared state key ('foo')\n      return {\"foo\": state[\"foo\"] + state[\"bar\"]}\n\n  subgraph_builder = StateGraph(SubgraphState)\n  subgraph_builder.add_node(subgraph_node_1)\n  subgraph_builder.add_node(subgraph_node_2)\n  subgraph_builder.add_edge(START, \"subgraph_node_1\")\n  subgraph_builder.add_edge(\"subgraph_node_1\", \"subgraph_node_2\")\n  subgraph = subgraph_builder.compile()\n\n  # Define parent graph\n  class ParentState(TypedDict):\n      foo: str\n\n  def node_1(state: ParentState):\n      return {\"foo\": \"hi! \" + state[\"foo\"]}\n\n  builder = StateGraph(ParentState)\n  builder.add_node(\"node_1\", node_1)\n  builder.add_node(\"node_2\", subgraph)\n  builder.add_edge(START, \"node_1\")\n  builder.add_edge(\"node_1\", \"node_2\")\n  graph = builder.compile()\n\n  for chunk in graph.stream({\"foo\": \"foo\"}):\n      print(chunk)\n  ```\n\n  ```\n  {'node_1': {'foo': 'hi! foo'}}\n  {'node_2': {'foo': 'hi! foobar'}}\n  ```\n</Accordion>\n\n## Add persistence\n\nYou only need to **provide the checkpointer when compiling the parent graph**. LangGraph will automatically propagate the checkpointer to the child subgraphs.\n\n```python  theme={null}\nfrom langgraph.graph import START, StateGraph\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom typing_extensions import TypedDict\n\nclass State(TypedDict):\n    foo: str\n\n# Subgraph\n\ndef subgraph_node_1(state: State):\n    return {\"foo\": state[\"foo\"] + \"bar\"}\n\nsubgraph_builder = StateGraph(State)\nsubgraph_builder.add_node(subgraph_node_1)\nsubgraph_builder.add_edge(START, \"subgraph_node_1\")\nsubgraph = subgraph_builder.compile()\n\n# Parent graph\n\nbuilder = StateGraph(State)\nbuilder.add_node(\"node_1\", subgraph)\nbuilder.add_edge(START, \"node_1\")\n\ncheckpointer = MemorySaver()\ngraph = builder.compile(checkpointer=checkpointer)\n```\n\nIf you want the subgraph to **have its own memory**, you can compile it with the appropriate checkpointer option. This is useful in [multi-agent](/oss/python/langchain/multi-agent) systems, if you want agents to keep track of their internal message histories:\n\n```python  theme={null}\nsubgraph_builder = StateGraph(...)\nsubgraph = subgraph_builder.compile(checkpointer=True)\n```\n\n## View subgraph state\n\nWhen you enable [persistence](/oss/python/langgraph/persistence), you can [inspect the graph state](/oss/python/langgraph/persistence#checkpoints) (checkpoint) via the appropriate method. To view the subgraph state, you can use the subgraphs option.\n\nYou can inspect the graph state via `graph.get_state(config)`. To view the subgraph state, you can use `graph.get_state(config, subgraphs=True)`.\n\n<Warning>\n  **Available **only** when interrupted**\n  Subgraph state can only be viewed **when the subgraph is interrupted**. Once you resume the graph, you won't be able to access the subgraph state.\n</Warning>\n\n<Accordion title=\"View interrupted subgraph state\">\n  ```python  theme={null}\n  from langgraph.graph import START, StateGraph\n  from langgraph.checkpoint.memory import MemorySaver\n  from langgraph.types import interrupt, Command\n  from typing_extensions import TypedDict\n\n  class State(TypedDict):\n      foo: str\n\n  # Subgraph\n\n  def subgraph_node_1(state: State):\n      value = interrupt(\"Provide value:\")\n      return {\"foo\": state[\"foo\"] + value}\n\n  subgraph_builder = StateGraph(State)\n  subgraph_builder.add_node(subgraph_node_1)\n  subgraph_builder.add_edge(START, \"subgraph_node_1\")\n\n  subgraph = subgraph_builder.compile()\n\n  # Parent graph\n\n  builder = StateGraph(State)\n  builder.add_node(\"node_1\", subgraph)\n  builder.add_edge(START, \"node_1\")\n\n  checkpointer = MemorySaver()\n  graph = builder.compile(checkpointer=checkpointer)\n\n  config = {\"configurable\": {\"thread_id\": \"1\"}}\n\n  graph.invoke({\"foo\": \"\"}, config)\n  parent_state = graph.get_state(config)\n\n  # This will be available only when the subgraph is interrupted.\n  # Once you resume the graph, you won't be able to access the subgraph state.\n  subgraph_state = graph.get_state(config, subgraphs=True).tasks[0].state\n\n  # resume the subgraph\n  graph.invoke(Command(resume=\"bar\"), config)\n  ```\n\n  1. This will be available only when the subgraph is interrupted. Once you resume the graph, you won't be able to access the subgraph state.\n</Accordion>\n\n## Stream subgraph outputs\n\nTo include outputs from subgraphs in the streamed outputs, you can set the subgraphs option in the stream method of the parent graph. This will stream outputs from both the parent graph and any subgraphs.\n\n```python  theme={null}\nfor chunk in graph.stream(\n    {\"foo\": \"foo\"},\n    subgraphs=True, # [!code highlight]\n    stream_mode=\"updates\",\n):\n    print(chunk)\n```\n\n<Accordion title=\"Stream from subgraphs\">\n  ```python  theme={null}\n  from typing_extensions import TypedDict\n  from langgraph.graph.state import StateGraph, START\n\n  # Define subgraph\n  class SubgraphState(TypedDict):\n      foo: str\n      bar: str\n\n  def subgraph_node_1(state: SubgraphState):\n      return {\"bar\": \"bar\"}\n\n  def subgraph_node_2(state: SubgraphState):\n      # note that this node is using a state key ('bar') that is only available in the subgraph\n      # and is sending update on the shared state key ('foo')\n      return {\"foo\": state[\"foo\"] + state[\"bar\"]}\n\n  subgraph_builder = StateGraph(SubgraphState)\n  subgraph_builder.add_node(subgraph_node_1)\n  subgraph_builder.add_node(subgraph_node_2)\n  subgraph_builder.add_edge(START, \"subgraph_node_1\")\n  subgraph_builder.add_edge(\"subgraph_node_1\", \"subgraph_node_2\")\n  subgraph = subgraph_builder.compile()\n\n  # Define parent graph\n  class ParentState(TypedDict):\n      foo: str\n\n  def node_1(state: ParentState):\n      return {\"foo\": \"hi! \" + state[\"foo\"]}\n\n  builder = StateGraph(ParentState)\n  builder.add_node(\"node_1\", node_1)\n  builder.add_node(\"node_2\", subgraph)\n  builder.add_edge(START, \"node_1\")\n  builder.add_edge(\"node_1\", \"node_2\")\n  graph = builder.compile()\n\n  for chunk in graph.stream(\n      {\"foo\": \"foo\"},\n      stream_mode=\"updates\",\n      subgraphs=True, # [!code highlight]\n  ):\n      print(chunk)\n  ```\n\n  ```\n  ((), {'node_1': {'foo': 'hi! foo'}})\n  (('node_2:e58e5673-a661-ebb0-70d4-e298a7fc28b7',), {'subgraph_node_1': {'bar': 'bar'}})\n  (('node_2:e58e5673-a661-ebb0-70d4-e298a7fc28b7',), {'subgraph_node_2': {'foo': 'hi! foobar'}})\n  ((), {'node_2': {'foo': 'hi! foobar'}})\n  ```\n</Accordion>\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/use-subgraphs.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 18115
}