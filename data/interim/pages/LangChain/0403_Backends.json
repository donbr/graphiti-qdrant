{
  "title": "Backends",
  "source_url": "https://docs.langchain.com/oss/python/deepagents/backends",
  "content": "Choose and configure filesystem backends for deep agents. You can specify routes to different backends, implement virtual filesystems, and enforce policies.\n\nDeep agents expose a filesystem surface to the agent via tools like `ls`, `read_file`, `write_file`, `edit_file`, `glob`, and `grep`. These tools operate through a pluggable backend.\n\n```mermaid  theme={null}\ngraph TB\n    Tools[Filesystem Tools] --> Backend[Backend]\n\n    Backend --> State[State]\n    Backend --> Disk[Filesystem]\n    Backend --> Store[Store]\n    Backend --> Composite[Composite]\n    Backend --> Custom[Custom]\n\n    Composite --> Router{Routes}\n    Router --> State\n    Router --> Disk\n    Router --> Store\n```\n\nThis page explains how to [choose a backend](#specify-a-backend), [route different paths to different backends](#route-to-different-backends), [implement your own virtual filesystem](#use-a-virtual-filesystem) (e.g., S3 or Postgres), [add policy hooks](#add-policy-hooks), and [comply with the backend protocol](#protocol-reference).\n\n## Quickstart\n\nHere are a few pre-built filesystem backends that you can quickly use with your deep agent:\n\n| Built-in backend                                                 | Description                                                                                                                                                                                                                                                                                   |\n| ---------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Default](#statebackend-ephemeral)                               | `agent = create_deep_agent()` <br /> Ephemeral in state. The default filesystem backend for an agent is stored in `langgraph` state. Note that this filesystem only persists *for a single thread*.                                                                                           |\n| [Local filesystem persistence](#filesystembackend-local-disk)    | `agent = create_deep_agent(backend=FilesystemBackend(root_dir=\"/Users/nh/Desktop/\"))` <br />This gives the deep agent access to your local machine's filesystem. You can specify the root directory that the agent has access to. Note that any provided `root_dir` must be an absolute path. |\n| [Durable store (LangGraph store)](#storebackend-langgraph-store) | `agent = create_deep_agent(backend=lambda rt: StoreBackend(rt))` <br />This gives the agent access to long-term storage that is *persisted across threads*. This is great for storing longer term memories or instructions that are applicable to the agent over multiple executions.         |\n| [Composite](#compositebackend-router)                            | Ephemeral by default, `/memories/` persisted. The Composite backend is maximally flexible. You can specify different routes in the filesystem to point towards different backends. See Composite routing below for a ready-to-paste example.                                                  |\n\n## Built-in backends\n\n### StateBackend (ephemeral)\n\n```python  theme={null}\n# By default we provide a StateBackend\nagent = create_deep_agent()\n\n# Under the hood, it looks like\nfrom deepagents.backends import StateBackend\n\nagent = create_deep_agent(\n    backend=(lambda rt: StateBackend(rt))   # Note that the tools access State through the runtime.state\n)\n```\n\n**How it works:**\n\n* Stores files in LangGraph agent state for the current thread.\n* Persists across multiple agent turns on the same thread via checkpoints.\n\n**Best for:**\n\n* A scratch pad for the agent to write intermediate results.\n* Automatic eviction of large tool outputs which the agent can then read back in piece by piece.\n\n### FilesystemBackend (local disk)\n\n```python  theme={null}\nfrom deepagents.backends import FilesystemBackend\n\nagent = create_deep_agent(\n    backend=FilesystemBackend(root_dir=\".\", virtual_mode=True)\n)\n```\n\n**How it works:**\n\n* Reads/writes real files under a configurable `root_dir`.\n* You can optionally set `virtual_mode=True` to sandbox and normalize paths under `root_dir`.\n* Uses secure path resolution, prevents unsafe symlink traversal when possible, can use ripgrep for fast `grep`.\n\n**Best for:**\n\n* Local projects on your machine\n* CI sandboxes\n* Mounted persistent volumes\n\n### StoreBackend (LangGraph Store)\n\n```python  theme={null}\nfrom langgraph.store.memory import InMemoryStore\nfrom deepagents.backends import StoreBackend\n\nagent = create_deep_agent(\n    backend=(lambda rt: StoreBackend(rt)),   # Note that the tools access Store through the runtime.store\n    store=InMemoryStore()\n)\n```\n\n**How it works:**\n\n* Stores files in a LangGraph `BaseStore` provided by the runtime, enabling cross‑thread durable storage.\n\n**Best for:**\n\n* When you already run with a configured LangGraph store (for example, Redis, Postgres, or cloud implementations behind `BaseStore`).\n* When you're deploying your agent through LangSmith Deployments (a store is automatically provisioned for your agent).\n\n### CompositeBackend (router)\n\n```python  theme={null}\nfrom deepagents import create_deep_agent\nfrom deepagents.backends import CompositeBackend, StateBackend, StoreBackend\nfrom langgraph.store.memory import InMemoryStore\n\ncomposite_backend = lambda rt: CompositeBackend(\n    default=StateBackend(rt),\n    routes={\n        \"/memories/\": StoreBackend(rt),\n    }\n)\n\nagent = create_deep_agent(\n    backend=composite_backend,\n    store=InMemoryStore()  # Store passed to create_deep_agent, not backend\n)\n```\n\n**How it works:**\n\n* Routes file operations to different backends based on path prefix.\n* Preserves the original path prefixes in listings and search results.\n\n**Best for:**\n\n* When you want to give your agent both ephemeral and cross-thread storage, a CompositeBackend allows you provide both a StateBackend and StoreBackend\n* When you have multiple sources of information that you want to provide to your agent as part of a single filesystem.\n  * e.g. You have long-term memories stored under /memories/ in one Store and you also have a custom backend that has documentation accessible at /docs/.\n\n## Specify a backend\n\n* Pass a backend to `create_deep_agent(backend=...)`. The filesystem middleware uses it for all tooling.\n* You can pass either:\n  * An instance implementing `BackendProtocol` (for example, `FilesystemBackend(root_dir=\".\")`), or\n  * A factory `BackendFactory = Callable[[ToolRuntime], BackendProtocol]` (for backends that need runtime like `StateBackend` or `StoreBackend`).\n* If omitted, the default is `lambda rt: StateBackend(rt)`.\n\n## Route to different backends\n\nRoute parts of the namespace to different backends. Commonly used to persist `/memories/*` and keep everything else ephemeral.\n\n```python  theme={null}\nfrom deepagents import create_deep_agent\nfrom deepagents.backends import CompositeBackend, StateBackend, FilesystemBackend\n\ncomposite_backend = lambda rt: CompositeBackend(\n    default=StateBackend(rt),\n    routes={\n        \"/memories/\": FilesystemBackend(root_dir=\"/deepagents/myagent\", virtual_mode=True),\n    },\n)\n\nagent = create_deep_agent(backend=composite_backend)\n```\n\nBehavior:\n\n* `/workspace/plan.md` → StateBackend (ephemeral)\n* `/memories/agent.md` → FilesystemBackend under `/deepagents/myagent`\n* `ls`, `glob`, `grep` aggregate results and show original path prefixes.\n\nNotes:\n\n* Longer prefixes win (for example, route `\"/memories/projects/\"` can override `\"/memories/\"`).\n* For StoreBackend routing, ensure the agent runtime provides a store (`runtime.store`).\n\n## Use a virtual filesystem\n\nBuild a custom backend to project a remote or database filesystem (e.g., S3 or Postgres) into the tools namespace.\n\nDesign guidelines:\n\n* Paths are absolute (`/x/y.txt`). Decide how to map them to your storage keys/rows.\n* Implement `ls_info` and `glob_info` efficiently (server-side listing where available, otherwise local filter).\n* Return user-readable error strings for missing files or invalid regex patterns.\n* For external persistence, set `files_update=None` in results; only in-state backends should return a `files_update` dict.\n\nS3-style outline:\n\n```python  theme={null}\nfrom deepagents.backends.protocol import BackendProtocol, WriteResult, EditResult\nfrom deepagents.backends.utils import FileInfo, GrepMatch\n\nclass S3Backend(BackendProtocol):\n    def __init__(self, bucket: str, prefix: str = \"\"):\n        self.bucket = bucket\n        self.prefix = prefix.rstrip(\"/\")\n\n    def _key(self, path: str) -> str:\n        return f\"{self.prefix}{path}\"\n\n    def ls_info(self, path: str) -> list[FileInfo]:\n        # List objects under _key(path); build FileInfo entries (path, size, modified_at)\n        ...\n\n    def read(self, file_path: str, offset: int = 0, limit: int = 2000) -> str:\n        # Fetch object; return numbered content or an error string\n        ...\n\n    def grep_raw(self, pattern: str, path: str | None = None, glob: str | None = None) -> list[GrepMatch] | str:\n        # Optionally filter server‑side; else list and scan content\n        ...\n\n    def glob_info(self, pattern: str, path: str = \"/\") -> list[FileInfo]:\n        # Apply glob relative to path across keys\n        ...\n\n    def write(self, file_path: str, content: str) -> WriteResult:\n        # Enforce create‑only semantics; return WriteResult(path=file_path, files_update=None)\n        ...\n\n    def edit(self, file_path: str, old_string: str, new_string: str, replace_all: bool = False) -> EditResult:\n        # Read → replace (respect uniqueness vs replace_all) → write → return occurrences\n        ...\n```\n\nPostgres-style outline:\n\n* Table `files(path text primary key, content text, created_at timestamptz, modified_at timestamptz)`\n* Map tool operations onto SQL:\n  * `ls_info` uses `WHERE path LIKE $1 || '%'`\n  * `glob_info` filter in SQL or fetch then apply glob in Python\n  * `grep_raw` can fetch candidate rows by extension or last modified time, then scan lines\n\n## Add policy hooks\n\nEnforce enterprise rules by subclassing or wrapping a backend.\n\nBlock writes/edits under selected prefixes (subclass):\n\n```python  theme={null}\nfrom deepagents.backends.filesystem import FilesystemBackend\nfrom deepagents.backends.protocol import WriteResult, EditResult\n\nclass GuardedBackend(FilesystemBackend):\n    def __init__(self, *, deny_prefixes: list[str], **kwargs):\n        super().__init__(**kwargs)\n        self.deny_prefixes = [p if p.endswith(\"/\") else p + \"/\" for p in deny_prefixes]\n\n    def write(self, file_path: str, content: str) -> WriteResult:\n        if any(file_path.startswith(p) for p in self.deny_prefixes):\n            return WriteResult(error=f\"Writes are not allowed under {file_path}\")\n        return super().write(file_path, content)\n\n    def edit(self, file_path: str, old_string: str, new_string: str, replace_all: bool = False) -> EditResult:\n        if any(file_path.startswith(p) for p in self.deny_prefixes):\n            return EditResult(error=f\"Edits are not allowed under {file_path}\")\n        return super().edit(file_path, old_string, new_string, replace_all)\n```\n\nGeneric wrapper (works with any backend):\n\n```python  theme={null}\nfrom deepagents.backends.protocol import BackendProtocol, WriteResult, EditResult\nfrom deepagents.backends.utils import FileInfo, GrepMatch\n\nclass PolicyWrapper(BackendProtocol):\n    def __init__(self, inner: BackendProtocol, deny_prefixes: list[str] | None = None):\n        self.inner = inner\n        self.deny_prefixes = [p if p.endswith(\"/\") else p + \"/\" for p in (deny_prefixes or [])]\n\n    def _deny(self, path: str) -> bool:\n        return any(path.startswith(p) for p in self.deny_prefixes)\n\n    def ls_info(self, path: str) -> list[FileInfo]:\n        return self.inner.ls_info(path)\n    def read(self, file_path: str, offset: int = 0, limit: int = 2000) -> str:\n        return self.inner.read(file_path, offset=offset, limit=limit)\n    def grep_raw(self, pattern: str, path: str | None = None, glob: str | None = None) -> list[GrepMatch] | str:\n        return self.inner.grep_raw(pattern, path, glob)\n    def glob_info(self, pattern: str, path: str = \"/\") -> list[FileInfo]:\n        return self.inner.glob_info(pattern, path)\n    def write(self, file_path: str, content: str) -> WriteResult:\n        if self._deny(file_path):\n            return WriteResult(error=f\"Writes are not allowed under {file_path}\")\n        return self.inner.write(file_path, content)\n    def edit(self, file_path: str, old_string: str, new_string: str, replace_all: bool = False) -> EditResult:\n        if self._deny(file_path):\n            return EditResult(error=f\"Edits are not allowed under {file_path}\")\n        return self.inner.edit(file_path, old_string, new_string, replace_all)\n```\n\n## Protocol reference\n\nBackends must implement the `BackendProtocol`.\n\nRequired endpoints:\n\n* `ls_info(path: str) -> list[FileInfo]`\n  * Return entries with at least `path`. Include `is_dir`, `size`, `modified_at` when available. Sort by `path` for deterministic output.\n* `read(file_path: str, offset: int = 0, limit: int = 2000) -> str`\n  * Return numbered content. On missing file, return `\"Error: File '/x' not found\"`.\n* `grep_raw(pattern: str, path: Optional[str] = None, glob: Optional[str] = None) -> list[GrepMatch] | str`\n  * Return structured matches. For an invalid regex, return a string like `\"Invalid regex pattern: ...\"` (do not raise).\n* `glob_info(pattern: str, path: str = \"/\") -> list[FileInfo]`\n  * Return matched files as `FileInfo` entries (empty list if none).\n* `write(file_path: str, content: str) -> WriteResult`\n  * Create-only. On conflict, return `WriteResult(error=...)`. On success, set `path` and for state backends set `files_update={...}`; external backends should use `files_update=None`.\n* `edit(file_path: str, old_string: str, new_string: str, replace_all: bool = False) -> EditResult`\n  * Enforce uniqueness of `old_string` unless `replace_all=True`. If not found, return error. Include `occurrences` on success.\n\nSupporting types:\n\n* `WriteResult(error, path, files_update)`\n* `EditResult(error, path, files_update, occurrences)`\n* `FileInfo` with fields: `path` (required), optionally `is_dir`, `size`, `modified_at`.\n* `GrepMatch` with fields: `path`, `line`, `text`.\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/deepagents/backends.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 14823
}