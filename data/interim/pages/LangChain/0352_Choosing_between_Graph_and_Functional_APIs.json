{
  "title": "Choosing between Graph and Functional APIs",
  "source_url": "https://docs.langchain.com/oss/javascript/langgraph/choosing-apis",
  "content": "LangGraph provides two different APIs to build agent workflows: the **Graph API** and the **Functional API**. Both APIs share the same underlying runtime and can be used together in the same application, but they are designed for different use cases and development preferences.\n\nThis guide will help you understand when to use each API based on your specific requirements.\n\n## Quick decision guide\n\nUse the **Graph API** when you need:\n\n* **Complex workflow visualization** for debugging and documentation\n* **Explicit state management** with shared data across multiple nodes\n* **Conditional branching** with multiple decision points\n* **Parallel execution paths** that need to merge later\n* **Team collaboration** where visual representation aids understanding\n\nUse the **Functional API** when you want:\n\n* **Minimal code changes** to existing procedural code\n* **Standard control flow** (if/else, loops, function calls)\n* **Function-scoped state** without explicit state management\n* **Rapid prototyping** with less boilerplate\n* **Linear workflows** with simple branching logic\n\n## Detailed comparison\n\n### When to use the Graph API\n\nThe [Graph API](/oss/javascript/langgraph/graph-api) uses a declarative approach where you define nodes, edges, and shared state to create a visual graph structure.\n\n**1. Complex decision trees and branching logic**\n\nWhen your workflow has multiple decision points that depend on various conditions, the Graph API makes these branches explicit and easy to visualize.\n\n```python  theme={null}\n# Graph API: Clear visualization of decision paths\nfrom langgraph.graph import StateGraph\nfrom typing import TypedDict\n\nclass AgentState(TypedDict):\n    messages: list\n    current_tool: str\n    retry_count: int\n\ndef should_continue(state):\n    if state[\"retry_count\"] > 3:\n        return \"end\"\n    elif state[\"current_tool\"] == \"search\":\n        return \"process_search\"\n    else:\n        return \"call_llm\"\n\nworkflow = StateGraph(AgentState)\nworkflow.add_node(\"call_llm\", call_llm_node)\nworkflow.add_node(\"process_search\", search_node)\nworkflow.add_conditional_edges(\"call_llm\", should_continue)\n```\n\n**2. State management across multiple components**\n\nWhen you need to share and coordinate state between different parts of your workflow, the Graph API's explicit state management is beneficial.\n\n```python  theme={null}\n# Multiple nodes can access and modify shared state\nclass WorkflowState(TypedDict):\n    user_input: str\n    search_results: list\n    generated_response: str\n    validation_status: str\n\ndef search_node(state):\n    # Access shared state\n    results = search(state[\"user_input\"])\n    return {\"search_results\": results}\n\ndef validation_node(state):\n    # Access results from previous node\n    is_valid = validate(state[\"generated_response\"])\n    return {\"validation_status\": \"valid\" if is_valid else \"invalid\"}\n```\n\n**3. Parallel processing with synchronization**\n\nWhen you need to run multiple operations in parallel and then combine their results, the Graph API handles this naturally.\n\n```python  theme={null}\n# Parallel processing of multiple data sources\nworkflow.add_node(\"fetch_news\", fetch_news)\nworkflow.add_node(\"fetch_weather\", fetch_weather)\nworkflow.add_node(\"fetch_stocks\", fetch_stocks)\nworkflow.add_node(\"combine_data\", combine_all_data)\n\n# All fetch operations run in parallel\nworkflow.add_edge(START, \"fetch_news\")\nworkflow.add_edge(START, \"fetch_weather\")\nworkflow.add_edge(START, \"fetch_stocks\")\n\n# Combine waits for all parallel operations to complete\nworkflow.add_edge(\"fetch_news\", \"combine_data\")\nworkflow.add_edge(\"fetch_weather\", \"combine_data\")\nworkflow.add_edge(\"fetch_stocks\", \"combine_data\")\n```\n\n**4. Team development and documentation**\n\nThe visual nature of the Graph API makes it easier for teams to understand, document, and maintain complex workflows.\n\n```python  theme={null}\n# Clear separation of concerns - each team member can work on different nodes\nworkflow.add_node(\"data_ingestion\", data_team_function)\nworkflow.add_node(\"ml_processing\", ml_team_function)\nworkflow.add_node(\"business_logic\", product_team_function)\nworkflow.add_node(\"output_formatting\", frontend_team_function)\n```\n\n### When to use the Functional API\n\nThe [Functional API](/oss/javascript/langgraph/functional-api) uses an imperative approach that integrates LangGraph features into standard procedural code.\n\n**1. Existing procedural code**\n\nWhen you have existing code that uses standard control flow and want to add LangGraph features with minimal refactoring.\n\n```python  theme={null}\n# Functional API: Minimal changes to existing code\nfrom langgraph.func import entrypoint, task\n\n@task\ndef process_user_input(user_input: str) -> dict:\n    # Existing function with minimal changes\n    return {\"processed\": user_input.lower().strip()}\n\n@entrypoint(checkpointer=checkpointer)\ndef workflow(user_input: str) -> str:\n    # Standard Python control flow\n    processed = process_user_input(user_input).result()\n\n    if \"urgent\" in processed[\"processed\"]:\n        response = handle_urgent_request(processed).result()\n    else:\n        response = handle_normal_request(processed).result()\n\n    return response\n```\n\n**2. Linear workflows with simple logic**\n\nWhen your workflow is primarily sequential with straightforward conditional logic.\n\n```python  theme={null}\n@entrypoint(checkpointer=checkpointer)\ndef essay_workflow(topic: str) -> dict:\n    # Linear flow with simple branching\n    outline = create_outline(topic).result()\n\n    if len(outline[\"points\"]) < 3:\n        outline = expand_outline(outline).result()\n\n    draft = write_draft(outline).result()\n\n    # Human review checkpoint\n    feedback = interrupt({\"draft\": draft, \"action\": \"Please review\"})\n\n    if feedback == \"approve\":\n        final_essay = draft\n    else:\n        final_essay = revise_essay(draft, feedback).result()\n\n    return {\"essay\": final_essay}\n```\n\n**3. Rapid prototyping**\n\nWhen you want to quickly test ideas without the overhead of defining state schemas and graph structures.\n\n```python  theme={null}\n@entrypoint(checkpointer=checkpointer)\ndef quick_prototype(data: dict) -> dict:\n    # Fast iteration - no state schema needed\n    step1_result = process_step1(data).result()\n    step2_result = process_step2(step1_result).result()\n\n    return {\"final_result\": step2_result}\n```\n\n**4. Function-scoped state management**\n\nWhen your state is naturally scoped to individual functions and doesn't need to be shared broadly.\n\n```python  theme={null}\n@task\ndef analyze_document(document: str) -> dict:\n    # Local state management within function\n    sections = extract_sections(document)\n    summaries = [summarize(section) for section in sections]\n    key_points = extract_key_points(summaries)\n\n    return {\n        \"sections\": len(sections),\n        \"summaries\": summaries,\n        \"key_points\": key_points\n    }\n\n@entrypoint(checkpointer=checkpointer)\ndef document_processor(document: str) -> dict:\n    analysis = analyze_document(document).result()\n    # State is passed between functions as needed\n    return generate_report(analysis).result()\n```\n\n## Combining both APIs\n\nYou can use both APIs together in the same application. This is useful when different parts of your system have different requirements.\n\n```python  theme={null}\nfrom langgraph.graph import StateGraph\nfrom langgraph.func import entrypoint\n\n# Complex multi-agent coordination using Graph API\ncoordination_graph = StateGraph(CoordinationState)\ncoordination_graph.add_node(\"orchestrator\", orchestrator_node)\ncoordination_graph.add_node(\"agent_a\", agent_a_node)\ncoordination_graph.add_node(\"agent_b\", agent_b_node)\n\n# Simple data processing using Functional API\n@entrypoint()\ndef data_processor(raw_data: dict) -> dict:\n    cleaned = clean_data(raw_data).result()\n    transformed = transform_data(cleaned).result()\n    return transformed\n\n# Use the functional API result in the graph\ndef orchestrator_node(state):\n    processed_data = data_processor.invoke(state[\"raw_data\"])\n    return {\"processed_data\": processed_data}\n```\n\n## Migration between APIs\n\n### From Functional to Graph API\n\nWhen your functional workflow grows complex, you can migrate to the Graph API:\n\n```python  theme={null}\n# Before: Functional API\n@entrypoint(checkpointer=checkpointer)\ndef complex_workflow(input_data: dict) -> dict:\n    step1 = process_step1(input_data).result()\n\n    if step1[\"needs_analysis\"]:\n        analysis = analyze_data(step1).result()\n        if analysis[\"confidence\"] > 0.8:\n            result = high_confidence_path(analysis).result()\n        else:\n            result = low_confidence_path(analysis).result()\n    else:\n        result = simple_path(step1).result()\n\n    return result\n\n# After: Graph API\nclass WorkflowState(TypedDict):\n    input_data: dict\n    step1_result: dict\n    analysis: dict\n    final_result: dict\n\ndef should_analyze(state):\n    return \"analyze\" if state[\"step1_result\"][\"needs_analysis\"] else \"simple_path\"\n\ndef confidence_check(state):\n    return \"high_confidence\" if state[\"analysis\"][\"confidence\"] > 0.8 else \"low_confidence\"\n\nworkflow = StateGraph(WorkflowState)\nworkflow.add_node(\"step1\", process_step1_node)\nworkflow.add_conditional_edges(\"step1\", should_analyze)\nworkflow.add_node(\"analyze\", analyze_data_node)\nworkflow.add_conditional_edges(\"analyze\", confidence_check)\n# ... add remaining nodes and edges\n```\n\n### From Graph to Functional API\n\nWhen your graph becomes overly complex for simple linear processes:\n\n```python  theme={null}\n# Before: Over-engineered Graph API\nclass SimpleState(TypedDict):\n    input: str\n    step1: str\n    step2: str\n    result: str\n\n# After: Simplified Functional API\n@entrypoint(checkpointer=checkpointer)\ndef simple_workflow(input_data: str) -> str:\n    step1 = process_step1(input_data).result()\n    step2 = process_step2(step1).result()\n    return finalize_result(step2).result()\n```\n\n## Summary\n\nChoose the **Graph API** when you need explicit control over workflow structure, complex branching, parallel processing, or team collaboration benefits.\n\nChoose the **Functional API** when you want to add LangGraph features to existing code with minimal changes, have simple linear workflows, or need rapid prototyping capabilities.\n\nBoth APIs provide the same core LangGraph features (persistence, streaming, human-in-the-loop, memory) but package them in different paradigms to suit different development styles and use cases.\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/choosing-apis.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 10760
}