{
  "title": "LangGraph runtime",
  "source_url": "https://docs.langchain.com/oss/javascript/langgraph/pregel",
  "content": "[`Pregel`](https://reference.langchain.com/javascript/classes/_langchain_langgraph.pregel.Pregel.html) implements LangGraph's runtime, managing the execution of LangGraph applications.\n\nCompiling a [StateGraph](https://reference.langchain.com/javascript/classes/_langchain_langgraph.index.StateGraph.html) or creating an [entrypoint](https://reference.langchain.com/javascript/functions/_langchain_langgraph.index.entrypoint.html) produces a [`Pregel`](https://reference.langchain.com/javascript/classes/_langchain_langgraph.pregel.Pregel.html) instance that can be invoked with input.\n\nThis guide explains the runtime at a high level and provides instructions for directly implementing applications with Pregel.\n\n> **Note:** The [`Pregel`](https://reference.langchain.com/javascript/classes/_langchain_langgraph.pregel.Pregel.html) runtime is named after [Google's Pregel algorithm](https://research.google/pubs/pub37252/), which describes an efficient method for large-scale parallel computation using graphs.\n\n## Overview\n\nIn LangGraph, Pregel combines [**actors**](https://en.wikipedia.org/wiki/Actor_model) and **channels** into a single application. **Actors** read data from channels and write data to channels. Pregel organizes the execution of the application into multiple steps, following the **Pregel Algorithm**/**Bulk Synchronous Parallel** model.\n\nEach step consists of three phases:\n\n* **Plan**: Determine which **actors** to execute in this step. For example, in the first step, select the **actors** that subscribe to the special **input** channels; in subsequent steps, select the **actors** that subscribe to channels updated in the previous step.\n* **Execution**: Execute all selected **actors** in parallel, until all complete, or one fails, or a timeout is reached. During this phase, channel updates are invisible to actors until the next step.\n* **Update**: Update the channels with the values written by the **actors** in this step.\n\nRepeat until no **actors** are selected for execution, or a maximum number of steps is reached.\n\n## Actors\n\nAn **actor** is a `PregelNode`. It subscribes to channels, reads data from them, and writes data to them. It can be thought of as an **actor** in the Pregel algorithm. `PregelNodes` implement LangChain's Runnable interface.\n\n## Channels\n\nChannels are used to communicate between actors (PregelNodes). Each channel has a value type, an update type, and an update function â€“ which takes a sequence of updates and modifies the stored value. Channels can be used to send data from one chain to another, or to send data from a chain to itself in a future step. LangGraph provides a number of built-in channels:\n\n* [`LastValue`](https://reference.langchain.com/javascript/classes/_langchain_langgraph.channels.LastValue.html): The default channel, stores the last value sent to the channel, useful for input and output values, or for sending data from one step to the next.\n* [`Topic`](https://reference.langchain.com/javascript/classes/_langchain_langgraph.channels.Topic.html): A configurable PubSub Topic, useful for sending multiple values between **actors**, or for accumulating output. Can be configured to deduplicate values or to accumulate values over the course of multiple steps.\n* [`BinaryOperatorAggregate`](https://reference.langchain.com/javascript/classes/_langchain_langgraph.index.BinaryOperatorAggregate.html): stores a persistent value, updated by applying a binary operator to the current value and each update sent to the channel, useful for computing aggregates over multiple steps; e.g.,`total = BinaryOperatorAggregate(int, operator.add)`\n\n## Examples\n\nWhile most users will interact with Pregel through the [StateGraph](https://reference.langchain.com/javascript/classes/_langchain_langgraph.index.StateGraph.html) API or the [entrypoint](https://reference.langchain.com/javascript/functions/_langchain_langgraph.index.entrypoint.html) decorator, it is possible to interact with Pregel directly.\n\nBelow are a few different examples to give you a sense of the Pregel API.\n\n<Tabs>\n  <Tab title=\"Single node\">\n    ```typescript  theme={null}\n    import { EphemeralValue } from \"@langchain/langgraph/channels\";\n    import { Pregel, NodeBuilder } from \"@langchain/langgraph/pregel\";\n\n    const node1 = new NodeBuilder()\n      .subscribeOnly(\"a\")\n      .do((x: string) => x + x)\n      .writeTo(\"b\");\n\n    const app = new Pregel({\n      nodes: { node1 },\n      channels: {\n        a: new EphemeralValue<string>(),\n        b: new EphemeralValue<string>(),\n      },\n      inputChannels: [\"a\"],\n      outputChannels: [\"b\"],\n    });\n\n    await app.invoke({ a: \"foo\" });\n    ```\n\n    ```console  theme={null}\n    { b: 'foofoo' }\n    ```\n  </Tab>\n\n  <Tab title=\"Multiple nodes\">\n    ```typescript  theme={null}\n    import { LastValue, EphemeralValue } from \"@langchain/langgraph/channels\";\n    import { Pregel, NodeBuilder } from \"@langchain/langgraph/pregel\";\n\n    const node1 = new NodeBuilder()\n      .subscribeOnly(\"a\")\n      .do((x: string) => x + x)\n      .writeTo(\"b\");\n\n    const node2 = new NodeBuilder()\n      .subscribeOnly(\"b\")\n      .do((x: string) => x + x)\n      .writeTo(\"c\");\n\n    const app = new Pregel({\n      nodes: { node1, node2 },\n      channels: {\n        a: new EphemeralValue<string>(),\n        b: new LastValue<string>(),\n        c: new EphemeralValue<string>(),\n      },\n      inputChannels: [\"a\"],\n      outputChannels: [\"b\", \"c\"],\n    });\n\n    await app.invoke({ a: \"foo\" });\n    ```\n\n    ```console  theme={null}\n    { b: 'foofoo', c: 'foofoofoofoo' }\n    ```\n  </Tab>\n\n  <Tab title=\"Topic\">\n    ```typescript  theme={null}\n    import { EphemeralValue, Topic } from \"@langchain/langgraph/channels\";\n    import { Pregel, NodeBuilder } from \"@langchain/langgraph/pregel\";\n\n    const node1 = new NodeBuilder()\n      .subscribeOnly(\"a\")\n      .do((x: string) => x + x)\n      .writeTo(\"b\", \"c\");\n\n    const node2 = new NodeBuilder()\n      .subscribeTo(\"b\")\n      .do((x: { b: string }) => x.b + x.b)\n      .writeTo(\"c\");\n\n    const app = new Pregel({\n      nodes: { node1, node2 },\n      channels: {\n        a: new EphemeralValue<string>(),\n        b: new EphemeralValue<string>(),\n        c: new Topic<string>({ accumulate: true }),\n      },\n      inputChannels: [\"a\"],\n      outputChannels: [\"c\"],\n    });\n\n    await app.invoke({ a: \"foo\" });\n    ```\n\n    ```console  theme={null}\n    { c: ['foofoo', 'foofoofoofoo'] }\n    ```\n  </Tab>\n\n  <Tab title=\"BinaryOperatorAggregate\">\n    This example demonstrates how to use the [`BinaryOperatorAggregate`](https://reference.langchain.com/javascript/classes/_langchain_langgraph.index.BinaryOperatorAggregate.html) channel to implement a reducer.\n\n    ```typescript  theme={null}\n    import { EphemeralValue, BinaryOperatorAggregate } from \"@langchain/langgraph/channels\";\n    import { Pregel, NodeBuilder } from \"@langchain/langgraph/pregel\";\n\n    const node1 = new NodeBuilder()\n      .subscribeOnly(\"a\")\n      .do((x: string) => x + x)\n      .writeTo(\"b\", \"c\");\n\n    const node2 = new NodeBuilder()\n      .subscribeOnly(\"b\")\n      .do((x: string) => x + x)\n      .writeTo(\"c\");\n\n    const reducer = (current: string, update: string) => {\n      if (current) {\n        return current + \" | \" + update;\n      } else {\n        return update;\n      }\n    };\n\n    const app = new Pregel({\n      nodes: { node1, node2 },\n      channels: {\n        a: new EphemeralValue<string>(),\n        b: new EphemeralValue<string>(),\n        c: new BinaryOperatorAggregate<string>({ operator: reducer }),\n      },\n      inputChannels: [\"a\"],\n      outputChannels: [\"c\"],\n    });\n\n    await app.invoke({ a: \"foo\" });\n    ```\n  </Tab>\n\n  <Tab title=\"Cycle\">\n    This example demonstrates how to introduce a cycle in the graph, by having\n    a chain write to a channel it subscribes to. Execution will continue\n    until a `null` value is written to the channel.\n\n    ```typescript  theme={null}\n    import { EphemeralValue } from \"@langchain/langgraph/channels\";\n    import { Pregel, NodeBuilder, ChannelWriteEntry } from \"@langchain/langgraph/pregel\";\n\n    const exampleNode = new NodeBuilder()\n      .subscribeOnly(\"value\")\n      .do((x: string) => x.length < 10 ? x + x : null)\n      .writeTo(new ChannelWriteEntry(\"value\", { skipNone: true }));\n\n    const app = new Pregel({\n      nodes: { exampleNode },\n      channels: {\n        value: new EphemeralValue<string>(),\n      },\n      inputChannels: [\"value\"],\n      outputChannels: [\"value\"],\n    });\n\n    await app.invoke({ value: \"a\" });\n    ```\n\n    ```console  theme={null}\n    { value: 'aaaaaaaaaaaaaaaa' }\n    ```\n  </Tab>\n</Tabs>\n\n## High-level API\n\nLangGraph provides two high-level APIs for creating a Pregel application: the [StateGraph (Graph API)](/oss/javascript/langgraph/graph-api) and the [Functional API](/oss/javascript/langgraph/functional-api).\n\n<Tabs>\n  <Tab title=\"StateGraph (Graph API)\">\n    The [StateGraph (Graph API)](https://reference.langchain.com/javascript/classes/_langchain_langgraph.index.StateGraph.html) is a higher-level abstraction that simplifies the creation of Pregel applications. It allows you to define a graph of nodes and edges. When you compile the graph, the StateGraph API automatically creates the Pregel application for you.\n\n    ```typescript  theme={null}\n    import { START, StateGraph } from \"@langchain/langgraph\";\n\n    interface Essay {\n      topic: string;\n      content?: string;\n      score?: number;\n    }\n\n    const writeEssay = (essay: Essay) => {\n      return {\n        content: `Essay about ${essay.topic}`,\n      };\n    };\n\n    const scoreEssay = (essay: Essay) => {\n      return {\n        score: 10\n      };\n    };\n\n    const builder = new StateGraph<Essay>({\n      channels: {\n        topic: null,\n        content: null,\n        score: null,\n      }\n    })\n      .addNode(\"writeEssay\", writeEssay)\n      .addNode(\"scoreEssay\", scoreEssay)\n      .addEdge(START, \"writeEssay\")\n      .addEdge(\"writeEssay\", \"scoreEssay\");\n\n    // Compile the graph.\n    // This will return a Pregel instance.\n    const graph = builder.compile();\n    ```\n\n    The compiled Pregel instance will be associated with a list of nodes and channels. You can inspect the nodes and channels by printing them.\n\n    ```typescript  theme={null}\n    console.log(graph.nodes);\n    ```\n\n    You will see something like this:\n\n    ```console  theme={null}\n    {\n      __start__: PregelNode { ... },\n      writeEssay: PregelNode { ... },\n      scoreEssay: PregelNode { ... }\n    }\n    ```\n\n    ```typescript  theme={null}\n    console.log(graph.channels);\n    ```\n\n    You should see something like this\n\n    ```console  theme={null}\n    {\n      topic: LastValue { ... },\n      content: LastValue { ... },\n      score: LastValue { ... },\n      __start__: EphemeralValue { ... },\n      writeEssay: EphemeralValue { ... },\n      scoreEssay: EphemeralValue { ... },\n      'branch:__start__:__self__:writeEssay': EphemeralValue { ... },\n      'branch:__start__:__self__:scoreEssay': EphemeralValue { ... },\n      'branch:writeEssay:__self__:writeEssay': EphemeralValue { ... },\n      'branch:writeEssay:__self__:scoreEssay': EphemeralValue { ... },\n      'branch:scoreEssay:__self__:writeEssay': EphemeralValue { ... },\n      'branch:scoreEssay:__self__:scoreEssay': EphemeralValue { ... },\n      'start:writeEssay': EphemeralValue { ... }\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"Functional API\">\n    In the [Functional API](/oss/javascript/langgraph/functional-api), you can use an [`entrypoint`](https://reference.langchain.com/javascript/functions/_langchain_langgraph.index.entrypoint.html) to create a Pregel application. The `entrypoint` decorator allows you to define a function that takes input and returns output.\n\n    ```typescript  theme={null}\n    import { MemorySaver } from \"@langchain/langgraph\";\n    import { entrypoint } from \"@langchain/langgraph/func\";\n\n    interface Essay {\n      topic: string;\n      content?: string;\n      score?: number;\n    }\n\n    const checkpointer = new MemorySaver();\n\n    const writeEssay = entrypoint(\n      { checkpointer, name: \"writeEssay\" },\n      async (essay: Essay) => {\n        return {\n          content: `Essay about ${essay.topic}`,\n        };\n      }\n    );\n\n    console.log(\"Nodes: \");\n    console.log(writeEssay.nodes);\n    console.log(\"Channels: \");\n    console.log(writeEssay.channels);\n    ```\n\n    ```console  theme={null}\n    Nodes:\n    { writeEssay: PregelNode { ... } }\n    Channels:\n    {\n      __start__: EphemeralValue { ... },\n      __end__: LastValue { ... },\n      __previous__: LastValue { ... }\n    }\n    ```\n  </Tab>\n</Tabs>\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/pregel.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 12957
}