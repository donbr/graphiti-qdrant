{
  "title": "Authentication & access control",
  "source_url": "https://docs.langchain.com/langsmith/auth",
  "content": "LangSmith provides a flexible authentication and authorization system that can integrate with most authentication schemes.\n\n## Core Concepts\n\n### Authentication vs authorization\n\nWhile often used interchangeably, these terms represent distinct security concepts:\n\n* [**Authentication**](#authentication) (\"AuthN\") verifies *who* you are. This runs as middleware for every request.\n* [**Authorization**](#authorization) (\"AuthZ\") determines *what you can do*. This validates the user's privileges and roles on a per-resource basis.\n\nIn LangSmith, authentication is handled by your [`@auth.authenticate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth.authenticate) handler, and authorization is handled by your [`@auth.on`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth.on) handlers.\n\n## Default security models\n\nLangSmith provides different security defaults:\n\n### LangSmith\n\n* Uses LangSmith API keys by default\n* Requires valid API key in `x-api-key` header\n* Can be customized with your auth handler\n\n<Note>\n  **Custom auth**\n  Custom auth **is supported** for all plans in LangSmith.\n</Note>\n\n### Self-hosted\n\n* No default authentication\n* Complete flexibility to implement your security model\n* You control all aspects of authentication and authorization\n\n## System architecture\n\nA typical authentication setup involves three main components:\n\n1. **Authentication Provider** (Identity Provider/IdP)\n\n* A dedicated service that manages user identities and credentials\n* Handles user registration, login, password resets, etc.\n* Issues tokens (JWT, session tokens, etc.) after successful authentication\n* Examples: Auth0, Supabase Auth, Okta, or your own auth server\n\n2. **LangGraph Backend** (Resource Server)\n\n* Your LangGraph application that contains business logic and protected resources\n* Validates tokens with the auth provider\n* Enforces access control based on user identity and permissions\n* Doesn't store user credentials directly\n\n3. **Client Application** (Frontend)\n\n* Web app, mobile app, or API client\n* Collects time-sensitive user credentials and sends to auth provider\n* Receives tokens from auth provider\n* Includes these tokens in requests to LangGraph backend\n\nHere's how these components typically interact:\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant Client as Client App\n    participant Auth as Auth Provider\n    participant LG as LangGraph Backend\n\n    Client->>Auth: 1. Login (username/password)\n    Auth-->>Client: 2. Return token\n    Client->>LG: 3. Request with token\n    Note over LG: 4. Validate token (@auth.authenticate)\n    LG-->>Auth:  5. Fetch user info\n    Auth-->>LG: 6. Confirm validity\n    Note over LG: 7. Apply access control (@auth.on.*)\n    LG-->>Client: 8. Return resources\n```\n\nYour [`@auth.authenticate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth.authenticate) handler in LangGraph handles steps 4-6, while your [`@auth.on`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth.on) handlers implement step 7.\n\n## Authentication\n\nAuthentication in LangGraph runs as middleware on every request. Your [`@auth.authenticate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth.authenticate) handler receives request information and should:\n\n1. Validate the credentials\n2. Return [user info](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.MinimalUserDict) containing the user's identity and user information if valid\n3. Raise an [HTTP exception](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.exceptions.HTTPException) or AssertionError if invalid\n\n```python  theme={null}\nfrom langgraph_sdk import Auth\n\nauth = Auth()\n\n@auth.authenticate\nasync def authenticate(headers: dict) -> Auth.types.MinimalUserDict:\n    # Validate credentials (e.g., API key, JWT token)\n    api_key = headers.get(b\"x-api-key\")\n    if not api_key or not is_valid_key(api_key):\n        raise Auth.exceptions.HTTPException(\n            status_code=401,\n            detail=\"Invalid API key\"\n        )\n\n    # Return user info - only identity and is_authenticated are required\n    # Add any additional fields you need for authorization\n    return {\n        \"identity\": \"user-123\",        # Required: unique user identifier\n        \"is_authenticated\": True,      # Optional: assumed True by default\n        \"permissions\": [\"read\", \"write\"] # Optional: for permission-based auth\n        # You can add more custom fields if you want to implement other auth patterns\n        \"role\": \"admin\",\n        \"org_id\": \"org-456\"\n\n    }\n```\n\nThe returned user information is available:\n\n* To your authorization handlers via [`ctx.user`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.AuthContext)\n* In your application via `config[\"configuration\"][\"langgraph_auth_user\"]`\n\n<Accordion title=\"Supported Parameters\">\n  The [`@auth.authenticate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth.authenticate) handler can accept any of the following parameters by name:\n\n  * request (Request): The raw ASGI request object\n  * path (str): The request path, e.g., `\"/threads/abcd-1234-abcd-1234/runs/abcd-1234-abcd-1234/stream\"`\n  * method (str): The HTTP method, e.g., `\"GET\"`\n  * path\\_params (dict\\[str, str]): URL path parameters, e.g., `{\"thread_id\": \"abcd-1234-abcd-1234\", \"run_id\": \"abcd-1234-abcd-1234\"}`\n  * query\\_params (dict\\[str, str]): URL query parameters, e.g., `{\"stream\": \"true\"}`\n  * headers (dict\\[bytes, bytes]): Request headers\n  * authorization (str | None): The Authorization header value (e.g., `\"Bearer <token>\"`)\n\n  In many of our tutorials, we will just show the \"authorization\" parameter to be concise, but you can opt to accept more information as needed\n  to implement your custom authentication scheme.\n</Accordion>\n\n### Agent authentication\n\nCustom authentication permits delegated access. The values you return in  `@auth.authenticate` are added to the run context, giving agents user-scoped credentials lets them access resources on the userâ€™s behalf.\n\n```mermaid  theme={null}\nsequenceDiagram\n  %% Actors\n  participant ClientApp as Client\n  participant AuthProv  as Auth Provider\n  participant LangGraph as LangGraph Backend\n  participant SecretStore as Secret Store\n  participant ExternalService as External Service\n\n  %% Platform login / AuthN\n  ClientApp  ->> AuthProv: 1. Login (username / password)\n  AuthProv   -->> ClientApp: 2. Return token\n  ClientApp  ->> LangGraph: 3. Request with token\n\n  Note over LangGraph: 4. Validate token (@auth.authenticate)\n  LangGraph  -->> AuthProv: 5. Fetch user info\n  AuthProv   -->> LangGraph: 6. Confirm validity\n\n  %% Fetch user tokens from secret store\n  LangGraph  ->> SecretStore: 6a. Fetch user tokens\n  SecretStore -->> LangGraph: 6b. Return tokens\n\n  Note over LangGraph: 7. Apply access control (@auth.on.*)\n\n  %% External Service round-trip\n  LangGraph  ->> ExternalService: 8. Call external service (with header)\n  Note over ExternalService: 9. External service validates header and executes action\n  ExternalService  -->> LangGraph: 10. Service response\n\n  %% Return to caller\n  LangGraph  -->> ClientApp: 11. Return resources\n```\n\nAfter authentication, the platform creates a special configuration object that is passed to your graph and all nodes via the configurable context.\nThis object contains information about the current user, including any custom fields you return from your [`@auth.authenticate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth.authenticate) handler.\n\nTo enable an agent to act on behalf of the user, use [custom authentication middleware](/langsmith/custom-auth). This will allow the agent to interact with external systems like MCP servers, external databases, and even other agents on behalf of the user.\n\nFor more information, see the [Use custom auth](/langsmith/custom-auth#enable-agent-authentication) guide.\n\n### Agent authentication with MCP\n\nFor information on how to authenticate an agent to an MCP server, see the [MCP conceptual guide](/oss/python/langchain/mcp).\n\n## Authorization\n\nAfter authentication, LangGraph calls your [`@auth.on`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth) handlers to control access to specific resources (e.g., threads, assistants, crons). These handlers can:\n\n1. Add metadata to be saved during resource creation by mutating the `value[\"metadata\"]` dictionary directly. See the [supported actions table](#supported-actions) for the list of types the value can take for each action.\n2. Filter resources by metadata during search/list or read operations by returning a [filter dictionary](#filter-operations).\n3. Raise an HTTP exception if access is denied.\n\nIf you want to just implement simple user-scoped access control, you can use a single [`@auth.on`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth) handler for all resources and actions. If you want to have different control depending on the resource and action, you can use [resource-specific handlers](#resource-specific-handlers). See the [Supported Resources](#supported-resources) section for a full list of the resources that support access control.\n\n```python  theme={null}\n@auth.on\nasync def add_owner(\n    ctx: Auth.types.AuthContext,\n    value: dict  # The payload being sent to this access method\n) -> dict:  # Returns a filter dict that restricts access to resources\n    \"\"\"Authorize all access to threads, runs, crons, and assistants.\n\n    This handler does two things:\n        - Adds a value to resource metadata (to persist with the resource so it can be filtered later)\n        - Returns a filter (to restrict access to existing resources)\n\n    Args:\n        ctx: Authentication context containing user info, permissions, the path, and\n        value: The request payload sent to the endpoint. For creation\n              operations, this contains the resource parameters. For read\n              operations, this contains the resource being accessed.\n\n    Returns:\n        A filter dictionary that LangGraph uses to restrict access to resources.\n        See [Filter Operations](#filter-operations) for supported operators.\n    \"\"\"\n    # Create filter to restrict access to just this user's resources\n    filters = {\"owner\": ctx.user.identity}\n\n    # Get or create the metadata dictionary in the payload\n    # This is where we store persistent info about the resource\n    metadata = value.setdefault(\"metadata\", {})\n\n    # Add owner to metadata - if this is a create or update operation,\n    # this information will be saved with the resource\n    # So we can filter by it later in read operations\n    metadata.update(filters)\n\n    # Return filters to restrict access\n    # These filters are applied to ALL operations (create, read, update, search, etc.)\n    # to ensure users can only access their own resources\n    return filters\n```\n\n<a id=\"resource-specific-handlers\" />\n\n### Resource-specific handlers\n\nYou can register handlers for specific resources and actions by chaining the resource and action names together with the [`@auth.on`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth) decorator.\nWhen a request is made, the most specific handler that matches that resource and action is called. Below is an example of how to register handlers for specific resources and actions. For the following setup:\n\n1. Authenticated users are able to create threads, read threads, and create runs on threads\n2. Only users with the \"assistants:create\" permission are allowed to create new assistants\n3. All other endpoints (e.g., e.g., delete assistant, crons, store) are disabled for all users.\n\n<Tip>\n  **Supported Handlers**\n  For a full list of supported resources and actions, see the [Supported Resources](#supported-resources) section below.\n</Tip>\n\n```python  theme={null}\n# Generic / global handler catches calls that aren't handled by more specific handlers\n@auth.on\nasync def reject_unhandled_requests(ctx: Auth.types.AuthContext, value: Any) -> False:\n    print(f\"Request to {ctx.path} by {ctx.user.identity}\")\n    raise Auth.exceptions.HTTPException(\n        status_code=403,\n        detail=\"Forbidden\"\n    )\n\n# Matches the \"thread\" resource and all actions - create, read, update, delete, search\n# Since this is **more specific** than the generic @auth.on handler, it will take precedence\n# over the generic handler for all actions on the \"threads\" resource\n@auth.on.threads\nasync def on_thread(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.threads.create.value\n):\n    # Setting metadata on the thread being created\n    # will ensure that the resource contains an \"owner\" field\n    # Then any time a user tries to access this thread or runs within the thread,\n    # we can filter by owner\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    return {\"owner\": ctx.user.identity}\n\n\n# Thread creation. This will match only on thread create actions\n# Since this is **more specific** than both the generic @auth.on handler and the @auth.on.threads handler,\n# it will take precedence for any \"create\" actions on the \"threads\" resources\n@auth.on.threads.create\nasync def on_thread_create(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.threads.create.value\n):\n    # Reject if the user does not have write access\n    if \"write\" not in ctx.permissions:\n        raise Auth.exceptions.HTTPException(\n            status_code=403,\n            detail=\"User lacks the required permissions.\"\n        )\n    # Setting metadata on the thread being created\n    # will ensure that the resource contains an \"owner\" field\n    # Then any time a user tries to access this thread or runs within the thread,\n    # we can filter by owner\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    return {\"owner\": ctx.user.identity}\n\n# Reading a thread. Since this is also more specific than the generic @auth.on handler, and the @auth.on.threads handler,\n# it will take precedence for any \"read\" actions on the \"threads\" resource\n@auth.on.threads.read\nasync def on_thread_read(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.threads.read.value\n):\n    # Since we are reading (and not creating) a thread,\n    # we don't need to set metadata. We just need to\n    # return a filter to ensure users can only see their own threads\n    return {\"owner\": ctx.user.identity}\n\n# Run creation, streaming, updates, etc.\n# This takes precedenceover the generic @auth.on handler and the @auth.on.threads handler\n@auth.on.threads.create_run\nasync def on_run_create(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.threads.create_run.value\n):\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    # Inherit thread's access control\n    return {\"owner\": ctx.user.identity}\n\n# Assistant creation\n@auth.on.assistants.create\nasync def on_assistant_create(\n    ctx: Auth.types.AuthContext,\n    value: Auth.types.assistants.create.value\n):\n    if \"assistants:create\" not in ctx.permissions:\n        raise Auth.exceptions.HTTPException(\n            status_code=403,\n            detail=\"User lacks the required permissions.\"\n        )\n```\n\nNotice that we are mixing global and resource-specific handlers in the above example. Since each request is handled by the most specific handler, a request to create a `thread` would match the `on_thread_create` handler but NOT the `reject_unhandled_requests` handler. A request to `update` a thread, however would be handled by the global handler, since we don't have a more specific handler for that resource and action.\n\n<a id=\"filter-operations\" />\n\n### Filter operations\n\nAuthorization handlers can return `None`, a boolean, or a filter dictionary.\n\n* `None` and `True` mean \"authorize access to all underling resources\"\n* `False` means \"deny access to all underling resources (raises a 403 exception)\"\n* A metadata filter dictionary will restrict access to resources\n\nA filter dictionary is a dictionary with keys that match the resource metadata. It supports three operators:\n\n* The default value is a shorthand for exact match, or \"\\$eq\", below. For example, `{\"owner\": user_id}` will include only resources with metadata containing `{\"owner\": user_id}`\n* `$eq`: Exact match (e.g., `{\"owner\": {\"$eq\": user_id}}`) - this is equivalent to the shorthand above, `{\"owner\": user_id}`\n* `$contains`: List membership (e.g., `{\"allowed_users\": {\"$contains\": user_id}}`) or list containment (e.g., `{\"allowed_users\": {\"$contains\": [user_id_1, user_id_2]}}`). The value here must be an element of the list or a subset of the elements of the list, respectively. The metadata in the stored resource must be a list/container type.\n\nA dictionary with multiple keys is treated using a logical `AND` filter. For example, `{\"owner\": org_id, \"allowed_users\": {\"$contains\": user_id}}` will only match resources with metadata whose \"owner\" is `org_id` and whose \"allowed\\_users\" list contains `user_id`.\nSee the reference [`Auth`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.Auth)(Auth) for more information.\n\n## Common access patterns\n\nHere are some typical authorization patterns:\n\n### Single-owner resources\n\nThis common pattern lets you scope all threads, assistants, crons, and runs to a single user. It's useful for common single-user use cases like regular chatbot-style apps.\n\n```python  theme={null}\n@auth.on\nasync def owner_only(ctx: Auth.types.AuthContext, value: dict):\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    return {\"owner\": ctx.user.identity}\n```\n\n### Permission-based access\n\nThis pattern lets you control access based on **permissions**. It's useful if you want certain roles to have broader or more restricted access to resources.\n\n```python  theme={null}\n# In your auth handler:\n@auth.authenticate\nasync def authenticate(headers: dict) -> Auth.types.MinimalUserDict:\n    ...\n    return {\n        \"identity\": \"user-123\",\n        \"is_authenticated\": True,\n        \"permissions\": [\"threads:write\", \"threads:read\"]  # Define permissions in auth\n    }\n\ndef _default(ctx: Auth.types.AuthContext, value: dict):\n    metadata = value.setdefault(\"metadata\", {})\n    metadata[\"owner\"] = ctx.user.identity\n    return {\"owner\": ctx.user.identity}\n\n@auth.on.threads.create\nasync def create_thread(ctx: Auth.types.AuthContext, value: dict):\n    if \"threads:write\" not in ctx.permissions:\n        raise Auth.exceptions.HTTPException(\n            status_code=403,\n            detail=\"Unauthorized\"\n        )\n    return _default(ctx, value)\n\n\n@auth.on.threads.read\nasync def rbac_create(ctx: Auth.types.AuthContext, value: dict):\n    if \"threads:read\" not in ctx.permissions and \"threads:write\" not in ctx.permissions:\n        raise Auth.exceptions.HTTPException(\n            status_code=403,\n            detail=\"Unauthorized\"\n        )\n    return _default(ctx, value)\n```\n\n## Supported resources\n\nLangGraph provides three levels of authorization handlers, from most general to most specific:\n\n1. **Global Handler** (`@auth.on`): Matches all resources and actions\n2. **Resource Handler** (e.g., `@auth.on.threads`, `@auth.on.assistants`, `@auth.on.crons`): Matches all actions for a specific resource\n3. **Action Handler** (e.g., `@auth.on.threads.create`, `@auth.on.threads.read`): Matches a specific action on a specific resource\n\nThe most specific matching handler will be used. For example, `@auth.on.threads.create` takes precedence over `@auth.on.threads` for thread creation.\nIf a more specific handler is registered, the more general handler will not be called for that resource and action.\n\n<Tip>\n  \"Type Safety\"\n  Each handler has type hints available for its `value` parameter at `Auth.types.on.<resource>.<action>.value`. For example:\n\n  ```python  theme={null}\n  @auth.on.threads.create\n  async def on_thread_create(\n  ctx: Auth.types.AuthContext,\n  value: Auth.types.on.threads.create.value  # Specific type for thread creation\n  ):\n  ...\n\n  @auth.on.threads\n  async def on_threads(\n  ctx: Auth.types.AuthContext,\n  value: Auth.types.on.threads.value  # Union type of all thread actions\n  ):\n  ...\n\n  @auth.on\n  async def on_all(\n  ctx: Auth.types.AuthContext,\n  value: dict  # Union type of all possible actions\n  ):\n  ...\n  ```\n\n  More specific handlers provide better type hints since they handle fewer action types.\n</Tip>\n\n<a id=\"supported-actions\" />\n\n#### Supported actions and types\n\nHere are all the supported action handlers:\n\n| Resource       | Handler                       | Description                | Value Type                                                                                                                       |\n| -------------- | ----------------------------- | -------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |\n| **Threads**    | `@auth.on.threads.create`     | Thread creation            | [`ThreadsCreate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.ThreadsCreate)       |\n|                | `@auth.on.threads.read`       | Thread retrieval           | [`ThreadsRead`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.ThreadsRead)           |\n|                | `@auth.on.threads.update`     | Thread updates             | [`ThreadsUpdate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.ThreadsUpdate)       |\n|                | `@auth.on.threads.delete`     | Thread deletion            | [`ThreadsDelete`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.ThreadsDelete)       |\n|                | `@auth.on.threads.search`     | Listing threads            | [`ThreadsSearch`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.ThreadsSearch)       |\n|                | `@auth.on.threads.create_run` | Creating or updating a run | [`RunsCreate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.RunsCreate)             |\n| **Assistants** | `@auth.on.assistants.create`  | Assistant creation         | [`AssistantsCreate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.AssistantsCreate) |\n|                | `@auth.on.assistants.read`    | Assistant retrieval        | [`AssistantsRead`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.AssistantsRead)     |\n|                | `@auth.on.assistants.update`  | Assistant updates          | [`AssistantsUpdate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.AssistantsUpdate) |\n|                | `@auth.on.assistants.delete`  | Assistant deletion         | [`AssistantsDelete`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.AssistantsDelete) |\n|                | `@auth.on.assistants.search`  | Listing assistants         | [`AssistantsSearch`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.AssistantsSearch) |\n| **Crons**      | `@auth.on.crons.create`       | Cron job creation          | [`CronsCreate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.CronsCreate)           |\n|                | `@auth.on.crons.read`         | Cron job retrieval         | [`CronsRead`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.CronsRead)               |\n|                | `@auth.on.crons.update`       | Cron job updates           | [`CronsUpdate`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.CronsUpdate)           |\n|                | `@auth.on.crons.delete`       | Cron job deletion          | [`CronsDelete`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.CronsDelete)           |\n|                | `@auth.on.crons.search`       | Listing cron jobs          | [`CronsSearch`](https://reference.langchain.com/python/langsmith/deployment/sdk/#langgraph_sdk.auth.types.CronsSearch)           |\n\n<Note>\n  \"About Runs\"\n\n  Runs are scoped to their parent thread for access control. This means permissions are typically inherited from the thread, reflecting the conversational nature of the data model. All run operations (reading, listing) except creation are controlled by the thread's handlers.\n  There is a specific `create_run` handler for creating new runs because it had more arguments that you can view in the handler.\n</Note>\n\n## Next steps\n\nFor implementation details:\n\n* Check out the introductory tutorial on [setting up authentication](/langsmith/set-up-custom-auth)\n* See the how-to guide on implementing a [custom auth handlers](/langsmith/custom-auth)\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/auth.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 25671
}