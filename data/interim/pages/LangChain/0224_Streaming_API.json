{
  "title": "Streaming API",
  "source_url": "https://docs.langchain.com/langsmith/streaming",
  "content": "[LangGraph SDK](/langsmith/langgraph-python-sdk) allows you to [stream outputs](/oss/python/langgraph/streaming/) from the [LangSmith Deployment API](/langsmith/server-api-ref).\n\n<Note>\n  LangGraph SDK and Agent Server are a part of [LangSmith](/langsmith/home).\n</Note>\n\n## Basic usage\n\nBasic usage example:\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python {highlight={12}} theme={null}\n    from langgraph_sdk import get_client\n    client = get_client(url=<DEPLOYMENT_URL>, api_key=<API_KEY>)\n\n    # Using the graph deployed with the name \"agent\"\n    assistant_id = \"agent\"\n\n    # create a thread\n    thread = await client.threads.create()\n    thread_id = thread[\"thread_id\"]\n\n    # create a streaming run\n    async for chunk in client.runs.stream(\n        thread_id,\n        assistant_id,\n        input=inputs,\n        stream_mode=\"updates\"\n    ):\n        print(chunk.data)\n    ```\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```javascript {highlight={12}} theme={null}\n    import { Client } from \"@langchain/langgraph-sdk\";\n    const client = new Client({ apiUrl: <DEPLOYMENT_URL>, apiKey: <API_KEY> });\n\n    // Using the graph deployed with the name \"agent\"\n    const assistantID = \"agent\";\n\n    // create a thread\n    const thread = await client.threads.create();\n    const threadID = thread[\"thread_id\"];\n\n    // create a streaming run\n    const streamResponse = client.runs.stream(\n      threadID,\n      assistantID,\n      {\n        input,\n        streamMode: \"updates\"\n      }\n    );\n    for await (const chunk of streamResponse) {\n      console.log(chunk.data);\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"cURL\">\n    Create a thread:\n\n    ```bash  theme={null}\n    curl --request POST \\\n    --url <DEPLOYMENT_URL>/threads \\\n    --header 'Content-Type: application/json' \\\n    --data '{}'\n    ```\n\n    Create a streaming run:\n\n    ```bash  theme={null}\n    curl --request POST \\\n    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n    --header 'Content-Type: application/json' \\\n    --header 'x-api-key: <API_KEY>'\n    --data \"{\n      \\\"assistant_id\\\": \\\"agent\\\",\n      \\\"input\\\": <inputs>,\n      \\\"stream_mode\\\": \\\"updates\\\"\n    }\"\n    ```\n  </Tab>\n</Tabs>\n\n<Accordion title=\"Extended example: streaming updates\">\n  This is an example graph you can run in the Agent Server.\n  See [LangSmith quickstart](/langsmith/deployment-quickstart) for more details.\n\n  ```python  theme={null}\n  # graph.py\n  from typing import TypedDict\n  from langgraph.graph import StateGraph, START, END\n\n  class State(TypedDict):\n      topic: str\n      joke: str\n\n  def refine_topic(state: State):\n      return {\"topic\": state[\"topic\"] + \" and cats\"}\n\n  def generate_joke(state: State):\n      return {\"joke\": f\"This is a joke about {state['topic']}\"}\n\n  graph = (\n      StateGraph(State)\n      .add_node(refine_topic)\n      .add_node(generate_joke)\n      .add_edge(START, \"refine_topic\")\n      .add_edge(\"refine_topic\", \"generate_joke\")\n      .add_edge(\"generate_joke\", END)\n      .compile()\n  )\n  ```\n\n  Once you have a running Agent Server, you can interact with it using\n  [LangGraph SDK](/langsmith/langgraph-python-sdk)\n\n  <Tabs>\n    <Tab title=\"Python\">\n      ```python {highlight={12,16}} theme={null}\n      from langgraph_sdk import get_client\n      client = get_client(url=<DEPLOYMENT_URL>)\n\n      # Using the graph deployed with the name \"agent\"\n      assistant_id = \"agent\"\n\n      # create a thread\n      thread = await client.threads.create()\n      thread_id = thread[\"thread_id\"]\n\n      # create a streaming run\n      async for chunk in client.runs.stream(  # (1)!\n          thread_id,\n          assistant_id,\n          input={\"topic\": \"ice cream\"},\n          stream_mode=\"updates\"  # (2)!\n      ):\n          print(chunk.data)\n      ```\n\n      1. The `client.runs.stream()` method returns an iterator that yields streamed outputs.\n         2\\. Set `stream_mode=\"updates\"` to stream only the updates to the graph state after each node. Other stream modes are also available. See [supported stream modes](#supported-stream-modes) for details.\n    </Tab>\n\n    <Tab title=\"JavaScript\">\n      ```javascript {highlight={12,17}} theme={null}\n      import { Client } from \"@langchain/langgraph-sdk\";\n      const client = new Client({ apiUrl: <DEPLOYMENT_URL> });\n\n      // Using the graph deployed with the name \"agent\"\n      const assistantID = \"agent\";\n\n      // create a thread\n      const thread = await client.threads.create();\n      const threadID = thread[\"thread_id\"];\n\n      // create a streaming run\n      const streamResponse = client.runs.stream(  // (1)!\n        threadID,\n        assistantID,\n        {\n          input: { topic: \"ice cream\" },\n          streamMode: \"updates\"  // (2)!\n        }\n      );\n      for await (const chunk of streamResponse) {\n        console.log(chunk.data);\n      }\n      ```\n\n      1. The `client.runs.stream()` method returns an iterator that yields streamed outputs.\n      2. Set `streamMode: \"updates\"` to stream only the updates to the graph state after each node. Other stream modes are also available. See [supported stream modes](#supported-stream-modes) for details.\n    </Tab>\n\n    <Tab title=\"cURL\">\n      Create a thread:\n\n      ```bash  theme={null}\n      curl --request POST \\\n      --url <DEPLOYMENT_URL>/threads \\\n      --header 'Content-Type: application/json' \\\n      --data '{}'\n      ```\n\n      Create a streaming run:\n\n      ```bash  theme={null}\n      curl --request POST \\\n      --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n      --header 'Content-Type: application/json' \\\n      --data \"{\n        \\\"assistant_id\\\": \\\"agent\\\",\n        \\\"input\\\": {\\\"topic\\\": \\\"ice cream\\\"},\n        \\\"stream_mode\\\": \\\"updates\\\"\n      }\"\n      ```\n    </Tab>\n  </Tabs>\n\n  ```output  theme={null}\n  {'run_id': '1f02c2b3-3cef-68de-b720-eec2a4a8e920', 'attempt': 1}\n  {'refine_topic': {'topic': 'ice cream and cats'}}\n  {'generate_joke': {'joke': 'This is a joke about ice cream and cats'}}\n  ```\n</Accordion>\n\n### Supported stream modes\n\n| Mode                             | Description                                                                                                                                                                         | LangGraph Library Method                                                                                      |\n| -------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |\n| [`values`](#stream-graph-state)  | Stream the full graph state after each [super-step](/langsmith/graph-rebuild#graphs).                                                                                               | `.stream()` / `.astream()` with [`stream_mode=\"values\"`](/oss/python/langgraph/streaming#stream-graph-state)  |\n| [`updates`](#stream-graph-state) | Streams the updates to the state after each step of the graph. If multiple updates are made in the same step (e.g., multiple nodes are run), those updates are streamed separately. | `.stream()` / `.astream()` with [`stream_mode=\"updates\"`](/oss/python/langgraph/streaming#stream-graph-state) |\n| [`messages-tuple`](#messages)    | Streams LLM tokens and metadata for the graph node where the LLM is invoked (useful for chat apps).                                                                                 | `.stream()` / `.astream()` with [`stream_mode=\"messages\"`](/oss/python/langgraph/streaming#messages)          |\n| [`debug`](#debug)                | Streams as much information as possible throughout the execution of the graph.                                                                                                      | `.stream()` / `.astream()` with [`stream_mode=\"debug\"`](/oss/python/langgraph/streaming#stream-graph-state)   |\n| [`custom`](#stream-custom-data)  | Streams custom data from inside your graph                                                                                                                                          | `.stream()` / `.astream()` with [`stream_mode=\"custom\"`](/oss/python/langgraph/streaming#stream-custom-data)  |\n| [`events`](#stream-events)       | Stream all events (including the state of the graph); mainly useful when migrating large LCEL apps.                                                                                 | `.astream_events()`                                                                                           |\n\n### Stream multiple modes\n\nYou can pass a list as the `stream_mode` parameter to stream multiple modes at once.\n\nThe streamed outputs will be tuples of `(mode, chunk)` where `mode` is the name of the stream mode and `chunk` is the data streamed by that mode.\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python  theme={null}\n    async for chunk in client.runs.stream(\n        thread_id,\n        assistant_id,\n        input=inputs,\n        stream_mode=[\"updates\", \"custom\"]\n    ):\n        print(chunk)\n    ```\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```js  theme={null}\n    const streamResponse = client.runs.stream(\n      threadID,\n      assistantID,\n      {\n        input,\n        streamMode: [\"updates\", \"custom\"]\n      }\n    );\n    for await (const chunk of streamResponse) {\n      console.log(chunk);\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"cURL\">\n    ```bash  theme={null}\n    curl --request POST \\\n     --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n     --header 'Content-Type: application/json' \\\n     --data \"{\n       \\\"assistant_id\\\": \\\"agent\\\",\n       \\\"input\\\": <inputs>,\n       \\\"stream_mode\\\": [\n         \\\"updates\\\"\n         \\\"custom\\\"\n       ]\n     }\"\n    ```\n  </Tab>\n</Tabs>\n\n## Stream graph state\n\nUse the stream modes `updates` and `values` to stream the state of the graph as it executes.\n\n* `updates` streams the **updates** to the state after each step of the graph.\n* `values` streams the **full value** of the state after each step of the graph.\n\n<Accordion title=\"Example graph\">\n  ```python  theme={null}\n  from typing import TypedDict\n  from langgraph.graph import StateGraph, START, END\n\n  class State(TypedDict):\n    topic: str\n    joke: str\n\n  def refine_topic(state: State):\n      return {\"topic\": state[\"topic\"] + \" and cats\"}\n\n  def generate_joke(state: State):\n      return {\"joke\": f\"This is a joke about {state['topic']}\"}\n\n  graph = (\n    StateGraph(State)\n    .add_node(refine_topic)\n    .add_node(generate_joke)\n    .add_edge(START, \"refine_topic\")\n    .add_edge(\"refine_topic\", \"generate_joke\")\n    .add_edge(\"generate_joke\", END)\n    .compile()\n  )\n  ```\n</Accordion>\n\n<Note>\n  **Stateful runs**\n  Examples below assume that you want to **persist the outputs** of a streaming run in the [checkpointer](/oss/python/langgraph/persistence) DB and have created a thread. To create a thread:\n\n  <Tabs>\n    <Tab title=\"Python\">\n      ```python  theme={null}\n      from langgraph_sdk import get_client\n      client = get_client(url=<DEPLOYMENT_URL>)\n\n      # Using the graph deployed with the name \"agent\"\n      assistant_id = \"agent\"\n      # create a thread\n      thread = await client.threads.create()\n      thread_id = thread[\"thread_id\"]\n      ```\n    </Tab>\n\n    <Tab title=\"JavaScript\">\n      ```js  theme={null}\n      import { Client } from \"@langchain/langgraph-sdk\";\n      const client = new Client({ apiUrl: <DEPLOYMENT_URL> });\n\n      // Using the graph deployed with the name \"agent\"\n      const assistantID = \"agent\";\n      // create a thread\n      const thread = await client.threads.create();\n      const threadID = thread[\"thread_id\"]\n      ```\n    </Tab>\n\n    <Tab title=\"cURL\">\n      ```bash  theme={null}\n      curl --request POST \\\n      --url <DEPLOYMENT_URL>/threads \\\n      --header 'Content-Type: application/json' \\\n      --data '{}'\n      ```\n    </Tab>\n  </Tabs>\n\n  If you don't need to persist the outputs of a run, you can pass `None` instead of `thread_id` when streaming.\n</Note>\n\n### Stream Mode: `updates`\n\nUse this to stream only the **state updates** returned by the nodes after each step. The streamed outputs include the name of the node as well as the update.\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python {highlight={5}} theme={null}\n    async for chunk in client.runs.stream(\n        thread_id,\n        assistant_id,\n        input={\"topic\": \"ice cream\"},\n        stream_mode=\"updates\"\n    ):\n        print(chunk.data)\n    ```\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```javascript {highlight={6}} theme={null}\n    const streamResponse = client.runs.stream(\n      threadID,\n      assistantID,\n      {\n        input: { topic: \"ice cream\" },\n        streamMode: \"updates\"\n      }\n    );\n    for await (const chunk of streamResponse) {\n      console.log(chunk.data);\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"cURL\">\n    ```bash  theme={null}\n    curl --request POST \\\n    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n    --header 'Content-Type: application/json' \\\n    --data \"{\n      \\\"assistant_id\\\": \\\"agent\\\",\n      \\\"input\\\": {\\\"topic\\\": \\\"ice cream\\\"},\n      \\\"stream_mode\\\": \\\"updates\\\"\n    }\"\n    ```\n  </Tab>\n</Tabs>\n\n### Stream Mode: `values`\n\nUse this to stream the **full state** of the graph after each step.\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python {highlight={5}} theme={null}\n    async for chunk in client.runs.stream(\n        thread_id,\n        assistant_id,\n        input={\"topic\": \"ice cream\"},\n        stream_mode=\"values\"\n    ):\n        print(chunk.data)\n    ```\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```javascript {highlight={6}} theme={null}\n    const streamResponse = client.runs.stream(\n      threadID,\n      assistantID,\n      {\n        input: { topic: \"ice cream\" },\n        streamMode: \"values\"\n      }\n    );\n    for await (const chunk of streamResponse) {\n      console.log(chunk.data);\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"cURL\">\n    ```bash  theme={null}\n    curl --request POST \\\n    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n    --header 'Content-Type: application/json' \\\n    --data \"{\n      \\\"assistant_id\\\": \\\"agent\\\",\n      \\\"input\\\": {\\\"topic\\\": \\\"ice cream\\\"},\n      \\\"stream_mode\\\": \\\"values\\\"\n    }\"\n    ```\n  </Tab>\n</Tabs>\n\n## Subgraphs\n\nTo include outputs from [subgraphs](/oss/python/langgraph/use-subgraphs) in the streamed outputs, you can set `subgraphs=True` in the `.stream()` method of the parent graph. This will stream outputs from both the parent graph and any subgraphs.\n\n```python {highlight={5}} theme={null}\nasync for chunk in client.runs.stream(\n    thread_id,\n    assistant_id,\n    input={\"foo\": \"foo\"},\n    stream_subgraphs=True, # (1)!\n    stream_mode=\"updates\",\n):\n    print(chunk)\n```\n\n1. Set `stream_subgraphs=True` to stream outputs from subgraphs.\n\n<Accordion title=\"Extended example: streaming from subgraphs\">\n  This is an example graph you can run in the Agent Server.\n  See [LangSmith quickstart](/langsmith/deployment-quickstart) for more details.\n\n  ```python  theme={null}\n  # graph.py\n  from langgraph.graph import START, StateGraph\n  from typing import TypedDict\n\n  # Define subgraph\n  class SubgraphState(TypedDict):\n      foo: str  # note that this key is shared with the parent graph state\n      bar: str\n\n  def subgraph_node_1(state: SubgraphState):\n      return {\"bar\": \"bar\"}\n\n  def subgraph_node_2(state: SubgraphState):\n      return {\"foo\": state[\"foo\"] + state[\"bar\"]}\n\n  subgraph_builder = StateGraph(SubgraphState)\n  subgraph_builder.add_node(subgraph_node_1)\n  subgraph_builder.add_node(subgraph_node_2)\n  subgraph_builder.add_edge(START, \"subgraph_node_1\")\n  subgraph_builder.add_edge(\"subgraph_node_1\", \"subgraph_node_2\")\n  subgraph = subgraph_builder.compile()\n\n  # Define parent graph\n  class ParentState(TypedDict):\n      foo: str\n\n  def node_1(state: ParentState):\n      return {\"foo\": \"hi! \" + state[\"foo\"]}\n\n  builder = StateGraph(ParentState)\n  builder.add_node(\"node_1\", node_1)\n  builder.add_node(\"node_2\", subgraph)\n  builder.add_edge(START, \"node_1\")\n  builder.add_edge(\"node_1\", \"node_2\")\n  graph = builder.compile()\n  ```\n\n  Once you have a running Agent Server, you can interact with it using\n  [LangGraph SDK](/langsmith/langgraph-python-sdk)\n\n  <Tabs>\n    <Tab title=\"Python\">\n      ```python {highlight={15}} theme={null}\n      from langgraph_sdk import get_client\n      client = get_client(url=<DEPLOYMENT_URL>)\n\n      # Using the graph deployed with the name \"agent\"\n      assistant_id = \"agent\"\n\n      # create a thread\n      thread = await client.threads.create()\n      thread_id = thread[\"thread_id\"]\n\n      async for chunk in client.runs.stream(\n          thread_id,\n          assistant_id,\n          input={\"foo\": \"foo\"},\n          stream_subgraphs=True, # (1)!\n          stream_mode=\"updates\",\n      ):\n          print(chunk)\n      ```\n\n      1. Set `stream_subgraphs=True` to stream outputs from subgraphs.\n    </Tab>\n\n    <Tab title=\"JavaScript\">\n      ```javascript {highlight={17}} theme={null}\n      import { Client } from \"@langchain/langgraph-sdk\";\n      const client = new Client({ apiUrl: <DEPLOYMENT_URL> });\n\n      // Using the graph deployed with the name \"agent\"\n      const assistantID = \"agent\";\n\n      // create a thread\n      const thread = await client.threads.create();\n      const threadID = thread[\"thread_id\"];\n\n      // create a streaming run\n      const streamResponse = client.runs.stream(\n        threadID,\n        assistantID,\n        {\n          input: { foo: \"foo\" },\n          streamSubgraphs: true,  // (1)!\n          streamMode: \"updates\"\n        }\n      );\n      for await (const chunk of streamResponse) {\n        console.log(chunk);\n      }\n      ```\n\n      1. Set `streamSubgraphs: true` to stream outputs from subgraphs.\n    </Tab>\n\n    <Tab title=\"cURL\">\n      Create a thread:\n\n      ```bash  theme={null}\n      curl --request POST \\\n      --url <DEPLOYMENT_URL>/threads \\\n      --header 'Content-Type: application/json' \\\n      --data '{}'\n      ```\n\n      Create a streaming run:\n\n      ```bash  theme={null}\n      curl --request POST \\\n      --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n      --header 'Content-Type: application/json' \\\n      --data \"{\n        \\\"assistant_id\\\": \\\"agent\\\",\n        \\\"input\\\": {\\\"foo\\\": \\\"foo\\\"},\n        \\\"stream_subgraphs\\\": true,\n        \\\"stream_mode\\\": [\n          \\\"updates\\\"\n        ]\n      }\"\n      ```\n    </Tab>\n  </Tabs>\n\n  **Note** that we are receiving not just the node updates, but we also the namespaces which tell us what graph (or subgraph) we are streaming from.\n</Accordion>\n\n<a id=\"debug\" />\n\n## Debugging\n\nUse the `debug` streaming mode to stream as much information as possible throughout the execution of the graph. The streamed outputs include the name of the node as well as the full state.\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python {highlight={5}} theme={null}\n    async for chunk in client.runs.stream(\n        thread_id,\n        assistant_id,\n        input={\"topic\": \"ice cream\"},\n        stream_mode=\"debug\"\n    ):\n        print(chunk.data)\n    ```\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```javascript {highlight={6}} theme={null}\n    const streamResponse = client.runs.stream(\n      threadID,\n      assistantID,\n      {\n        input: { topic: \"ice cream\" },\n        streamMode: \"debug\"\n      }\n    );\n    for await (const chunk of streamResponse) {\n      console.log(chunk.data);\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"cURL\">\n    ```bash  theme={null}\n    curl --request POST \\\n    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n    --header 'Content-Type: application/json' \\\n    --data \"{\n      \\\"assistant_id\\\": \\\"agent\\\",\n      \\\"input\\\": {\\\"topic\\\": \\\"ice cream\\\"},\n      \\\"stream_mode\\\": \\\"debug\\\"\n    }\"\n    ```\n  </Tab>\n</Tabs>\n\n<a id=\"messages\" />\n\n## LLM tokens\n\nUse the `messages-tuple` streaming mode to stream Large Language Model (LLM) outputs **token by token** from any part of your graph, including nodes, tools, subgraphs, or tasks.\n\nThe streamed output from [`messages-tuple` mode](#supported-stream-modes) is a tuple `(message_chunk, metadata)` where:\n\n* `message_chunk`: the token or message segment from the LLM.\n* `metadata`: a dictionary containing details about the graph node and LLM invocation.\n\n<Accordion title=\"Example graph\">\n  ```python {highlight={15}} theme={null}\n  from dataclasses import dataclass\n\n  from langchain.chat_models import init_chat_model\n  from langgraph.graph import StateGraph, START\n\n  @dataclass\n  class MyState:\n      topic: str\n      joke: str = \"\"\n\n  model = init_chat_model(model=\"gpt-4o-mini\")\n\n  def call_model(state: MyState):\n      \"\"\"Call the LLM to generate a joke about a topic\"\"\"\n      model_response = model.invoke( # (1)!\n          [\n              {\"role\": \"user\", \"content\": f\"Generate a joke about {state.topic}\"}\n          ]\n      )\n      return {\"joke\": model_response.content}\n\n  graph = (\n      StateGraph(MyState)\n      .add_node(call_model)\n      .add_edge(START, \"call_model\")\n      .compile()\n  )\n  ```\n\n  1. Note that the message events are emitted even when the LLM is run using `invoke` rather than `stream`.\n</Accordion>\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python {highlight={5}} theme={null}\n    async for chunk in client.runs.stream(\n        thread_id,\n        assistant_id,\n        input={\"topic\": \"ice cream\"},\n        stream_mode=\"messages-tuple\",\n    ):\n        if chunk.event != \"messages\":\n            continue\n\n        message_chunk, metadata = chunk.data  # (1)!\n        if message_chunk[\"content\"]:\n            print(message_chunk[\"content\"], end=\"|\", flush=True)\n    ```\n\n    1. The \"messages-tuple\" stream mode returns an iterator of tuples `(message_chunk, metadata)` where `message_chunk` is the token streamed by the LLM and `metadata` is a dictionary with information about the graph node where the LLM was called and other information.\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```javascript {highlight={6}} theme={null}\n    const streamResponse = client.runs.stream(\n      threadID,\n      assistantID,\n      {\n        input: { topic: \"ice cream\" },\n        streamMode: \"messages-tuple\"\n      }\n    );\n    for await (const chunk of streamResponse) {\n      if (chunk.event !== \"messages\") {\n        continue;\n      }\n      console.log(chunk.data[0][\"content\"]);  // (1)!\n    }\n    ```\n\n    1. The \"messages-tuple\" stream mode returns an iterator of tuples `(message_chunk, metadata)` where `message_chunk` is the token streamed by the LLM and `metadata` is a dictionary with information about the graph node where the LLM was called and other information.\n  </Tab>\n\n  <Tab title=\"cURL\">\n    ```bash  theme={null}\n    curl --request POST \\\n    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n    --header 'Content-Type: application/json' \\\n    --data \"{\n      \\\"assistant_id\\\": \\\"agent\\\",\n      \\\"input\\\": {\\\"topic\\\": \\\"ice cream\\\"},\n      \\\"stream_mode\\\": \\\"messages-tuple\\\"\n    }\"\n    ```\n  </Tab>\n</Tabs>\n\n### Filter LLM tokens\n\n* To filter the streamed tokens by LLM invocation, you can [associate `tags` with LLM invocations](/oss/python/langgraph/streaming#filter-by-llm-invocation).\n* To stream tokens only from specific nodes, use `stream_mode=\"messages\"` and [filter the outputs by the `langgraph_node` field](/oss/python/langgraph/streaming#filter-by-node) in the streamed metadata.\n\n## Stream custom data\n\nTo send **custom user-defined data**:\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python {highlight={5}} theme={null}\n    async for chunk in client.runs.stream(\n        thread_id,\n        assistant_id,\n        input={\"query\": \"example\"},\n        stream_mode=\"custom\"\n    ):\n        print(chunk.data)\n    ```\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```javascript {highlight={6}} theme={null}\n    const streamResponse = client.runs.stream(\n      threadID,\n      assistantID,\n      {\n        input: { query: \"example\" },\n        streamMode: \"custom\"\n      }\n    );\n    for await (const chunk of streamResponse) {\n      console.log(chunk.data);\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"cURL\">\n    ```bash  theme={null}\n    curl --request POST \\\n    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n    --header 'Content-Type: application/json' \\\n    --data \"{\n      \\\"assistant_id\\\": \\\"agent\\\",\n      \\\"input\\\": {\\\"query\\\": \\\"example\\\"},\n      \\\"stream_mode\\\": \\\"custom\\\"\n    }\"\n    ```\n  </Tab>\n</Tabs>\n\n## Stream events\n\nTo stream all events, including the state of the graph:\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python {highlight={5}} theme={null}\n    async for chunk in client.runs.stream(\n        thread_id,\n        assistant_id,\n        input={\"topic\": \"ice cream\"},\n        stream_mode=\"events\"\n    ):\n        print(chunk.data)\n    ```\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```javascript {highlight={6}} theme={null}\n    const streamResponse = client.runs.stream(\n      threadID,\n      assistantID,\n      {\n        input: { topic: \"ice cream\" },\n        streamMode: \"events\"\n      }\n    );\n    for await (const chunk of streamResponse) {\n      console.log(chunk.data);\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"cURL\">\n    ```bash  theme={null}\n    curl --request POST \\\n    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/stream \\\n    --header 'Content-Type: application/json' \\\n    --data \"{\n      \\\"assistant_id\\\": \\\"agent\\\",\n      \\\"input\\\": {\\\"topic\\\": \\\"ice cream\\\"},\n      \\\"stream_mode\\\": \\\"events\\\"\n    }\"\n    ```\n  </Tab>\n</Tabs>\n\n## Stateless runs\n\nIf you don't want to **persist the outputs** of a streaming run in the [checkpointer](/oss/python/langgraph/persistence) DB, you can create a stateless run without creating a thread:\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python {highlight={5}} theme={null}\n    from langgraph_sdk import get_client\n    client = get_client(url=<DEPLOYMENT_URL>, api_key=<API_KEY>)\n\n    async for chunk in client.runs.stream(\n        None,  # (1)!\n        assistant_id,\n        input=inputs,\n        stream_mode=\"updates\"\n    ):\n        print(chunk.data)\n    ```\n\n    1. We are passing `None` instead of a `thread_id` UUID.\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```javascript {highlight={5,6}} theme={null}\n    import { Client } from \"@langchain/langgraph-sdk\";\n    const client = new Client({ apiUrl: <DEPLOYMENT_URL>, apiKey: <API_KEY> });\n\n    // create a streaming run\n    const streamResponse = client.runs.stream(\n      null,  // (1)!\n      assistantID,\n      {\n        input,\n        streamMode: \"updates\"\n      }\n    );\n    for await (const chunk of streamResponse) {\n      console.log(chunk.data);\n    }\n    ```\n\n    1. We are passing `None` instead of a `thread_id` UUID.\n  </Tab>\n\n  <Tab title=\"cURL\">\n    ```bash  theme={null}\n    curl --request POST \\\n    --url <DEPLOYMENT_URL>/runs/stream \\\n    --header 'Content-Type: application/json' \\\n    --header 'x-api-key: <API_KEY>'\n    --data \"{\n      \\\"assistant_id\\\": \\\"agent\\\",\n      \\\"input\\\": <inputs>,\n      \\\"stream_mode\\\": \\\"updates\\\"\n    }\"\n    ```\n  </Tab>\n</Tabs>\n\n## Join and stream\n\nLangSmith allows you to join an active [background run](/langsmith/background-run) and stream outputs from it. To do so, you can use [LangGraph SDK's](/langsmith/langgraph-python-sdk) `client.runs.join_stream` method:\n\n<Tabs>\n  <Tab title=\"Python\">\n    ```python {highlight={4,6}} theme={null}\n    from langgraph_sdk import get_client\n    client = get_client(url=<DEPLOYMENT_URL>, api_key=<API_KEY>)\n\n    async for chunk in client.runs.join_stream(\n        thread_id,\n        run_id,  # (1)!\n    ):\n        print(chunk)\n    ```\n\n    1. This is the `run_id` of an existing run you want to join.\n  </Tab>\n\n  <Tab title=\"JavaScript\">\n    ```javascript {highlight={4,6}} theme={null}\n    import { Client } from \"@langchain/langgraph-sdk\";\n    const client = new Client({ apiUrl: <DEPLOYMENT_URL>, apiKey: <API_KEY> });\n\n    const streamResponse = client.runs.joinStream(\n      threadID,\n      runId  // (1)!\n    );\n    for await (const chunk of streamResponse) {\n      console.log(chunk);\n    }\n    ```\n\n    1. This is the `run_id` of an existing run you want to join.\n  </Tab>\n\n  <Tab title=\"cURL\">\n    ```bash  theme={null}\n    curl --request GET \\\n    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/<RUN_ID>/stream \\\n    --header 'Content-Type: application/json' \\\n    --header 'x-api-key: <API_KEY>'\n    ```\n  </Tab>\n</Tabs>\n\n<Warning>\n  **Outputs not buffered**\n  When you use `.join_stream`, output is not buffered, so any output produced before joining will not be received.\n</Warning>\n\n***\n\n## API reference\n\nFor API usage and implementation, refer to the [API reference](https://langchain-ai.github.io/langgraph/cloud/reference/api/api_ref.html#tag/thread-runs/POST/threads/\\{thread_id}/runs/stream).\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/streaming.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 29066
}