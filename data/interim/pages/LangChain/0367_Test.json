{
  "title": "Test",
  "source_url": "https://docs.langchain.com/oss/javascript/langgraph/test",
  "content": "After you've prototyped your LangGraph agent, a natural next step is to add tests. This guide covers some useful patterns you can use when writing unit tests.\n\nNote that this guide is LangGraph-specific and covers scenarios around graphs with custom structures - if you are just getting started, check out [this section](/oss/javascript/langchain/test/) that uses LangChain's built-in [`createAgent`](https://reference.langchain.com/javascript/functions/langchain.index.createAgent.html) instead.\n\n## Prerequisites\n\nFirst, make sure you have [`vitest`](https://vitest.dev/) installed:\n\n```bash  theme={null}\n$ npm install -D vitest\n```\n\n## Getting started\n\nBecause many LangGraph agents depend on state, a useful pattern is to create your graph before each test where you use it, then compile it within tests with a new checkpointer instance.\n\nThe below example shows how this works with a simple, linear graph that progresses through `node1` and `node2`. Each node updates the single state key `my_key`:\n\n```ts  theme={null}\nimport { test, expect } from 'vitest';\nimport {\n  StateGraph,\n  START,\n  END,\n  MemorySaver,\n} from '@langchain/langgraph';\nimport { z } from \"zod/v4\";\n\nconst State = z.object({\n  my_key: z.string(),\n});\n\nconst createGraph = () => {\n  return new StateGraph(State)\n    .addNode('node1', (state) => ({ my_key: 'hello from node1' }))\n    .addNode('node2', (state) => ({ my_key: 'hello from node2' }))\n    .addEdge(START, 'node1')\n    .addEdge('node1', 'node2')\n    .addEdge('node2', END);\n};\n\ntest('basic agent execution', async () => {\n  const uncompiledGraph = createGraph();\n  const checkpointer = new MemorySaver();\n  const compiledGraph = uncompiledGraph.compile({ checkpointer });\n  const result = await compiledGraph.invoke(\n    { my_key: 'initial_value' },\n    { configurable: { thread_id: '1' } }\n  );\n  expect(result.my_key).toBe('hello from node2');\n});\n```\n\n## Testing individual nodes and edges\n\nCompiled LangGraph agents expose references to each individual node as `graph.nodes`. You can take advantage of this to test individual nodes within your agent. Note that this will bypass any checkpointers passed when compiling the graph:\n\n```ts  theme={null}\nimport { test, expect } from 'vitest';\nimport {\n  StateGraph,\n  START,\n  END,\n  MemorySaver,\n} from '@langchain/langgraph';\nimport { z } from \"zod/v4\";\n\nconst State = z.object({\n  my_key: z.string(),\n});\n\nconst createGraph = () => {\n  return new StateGraph(State)\n    .addNode('node1', (state) => ({ my_key: 'hello from node1' }))\n    .addNode('node2', (state) => ({ my_key: 'hello from node2' }))\n    .addEdge(START, 'node1')\n    .addEdge('node1', 'node2')\n    .addEdge('node2', END);\n};\n\ntest('individual node execution', async () => {\n  const uncompiledGraph = createGraph();\n  // Will be ignored in this example\n  const checkpointer = new MemorySaver();\n  const compiledGraph = uncompiledGraph.compile({ checkpointer });\n  // Only invoke node 1\n  const result = await compiledGraph.nodes['node1'].invoke(\n    { my_key: 'initial_value' },\n  );\n  expect(result.my_key).toBe('hello from node1');\n});\n```\n\n## Partial execution\n\nFor agents made up of larger graphs, you may wish to test partial execution paths within your agent rather than the entire flow end-to-end. In some cases, it may make semantic sense to [restructure these sections as subgraphs](/oss/javascript/langgraph/use-subgraphs), which you can invoke in isolation as normal.\n\nHowever, if you do not wish to make changes to your agent graph's overall structure, you can use LangGraph's persistence mechanisms to simulate a state where your agent is paused right before the beginning of the desired section, and will pause again at the end of the desired section. The steps are as follows:\n\n1. Compile your agent with a checkpointer (the in-memory checkpointer [`MemorySaver`](https://reference.langchain.com/javascript/classes/_langchain_langgraph-checkpoint.MemorySaver.html) will suffice for testing).\n2. Call your agent's [`update_state`](/oss/javascript/langgraph/use-time-travel) method with an [`asNode`](/oss/javascript/langgraph/persistence#as-node) parameter set to the name of the node *before* the one you want to start your test.\n3. Invoke your agent with the same `thread_id` you used to update the state and an `interruptBefore` parameter set to the name of the node you want to stop at.\n\nHere's an example that executes only the second and third nodes in a linear graph:\n\n```ts  theme={null}\nimport { test, expect } from 'vitest';\nimport {\n  StateGraph,\n  START,\n  END,\n  MemorySaver,\n} from '@langchain/langgraph';\nimport { z } from \"zod/v4\";\n\nconst State = z.object({\n  my_key: z.string(),\n});\n\nconst createGraph = () => {\n  return new StateGraph(State)\n    .addNode('node1', (state) => ({ my_key: 'hello from node1' }))\n    .addNode('node2', (state) => ({ my_key: 'hello from node2' }))\n    .addNode('node3', (state) => ({ my_key: 'hello from node3' }))\n    .addNode('node4', (state) => ({ my_key: 'hello from node4' }))\n    .addEdge(START, 'node1')\n    .addEdge('node1', 'node2')\n    .addEdge('node2', 'node3')\n    .addEdge('node3', 'node4')\n    .addEdge('node4', END);\n};\n\ntest('partial execution from node2 to node3', async () => {\n  const uncompiledGraph = createGraph();\n  const checkpointer = new MemorySaver();\n  const compiledGraph = uncompiledGraph.compile({ checkpointer });\n  await compiledGraph.updateState(\n    { configurable: { thread_id: '1' } },\n    // The state passed into node 2 - simulating the state at\n    // the end of node 1\n    { my_key: 'initial_value' },\n    // Update saved state as if it came from node 1\n    // Execution will resume at node 2\n    'node1',\n  );\n  const result = await compiledGraph.invoke(\n    // Resume execution by passing None\n    null,\n    {\n      configurable: { thread_id: '1' },\n      // Stop after node 3 so that node 4 doesn't run\n      interruptAfter: ['node3']\n    },\n  );\n  expect(result.my_key).toBe('hello from node3');\n});\n```\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/test.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 6314
}