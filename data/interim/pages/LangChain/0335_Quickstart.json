{
  "title": "Quickstart",
  "source_url": "https://docs.langchain.com/oss/javascript/langchain/quickstart",
  "content": "This quickstart takes you from a simple setup to a fully functional AI agent in just a few minutes.\n\n## Build a basic agent\n\nStart by creating a simple agent that can answer questions and call tools. The agent will use Claude Sonnet 4.5 as its language model, a basic weather function as a tool, and a simple prompt to guide its behavior.\n\n<Info>\n  For this example, you will need to set up a [Claude (Anthropic)](https://www.anthropic.com/) account and get an API key. Then, set the `ANTHROPIC_API_KEY` environment variable in your terminal.\n</Info>\n\n```ts  theme={null}\nimport { createAgent, tool } from \"langchain\";\nimport * as z from \"zod\";\n\nconst getWeather = tool(\n  (input) => `It's always sunny in ${input.city}!`,\n  {\n    name: \"get_weather\",\n    description: \"Get the weather for a given city\",\n    schema: z.object({\n      city: z.string().describe(\"The city to get the weather for\"),\n    }),\n  }\n);\n\nconst agent = createAgent({\n  model: \"claude-sonnet-4-5-20250929\",\n  tools: [getWeather],\n});\n\nconsole.log(\n  await agent.invoke({\n    messages: [{ role: \"user\", content: \"What's the weather in Tokyo?\" }],\n  })\n);\n```\n\n<Tip>\n  To learn how to trace your agent with LangSmith, see the [LangSmith documentation](/langsmith/trace-with-langchain).\n</Tip>\n\n## Build a real-world agent\n\nNext, build a practical weather forecasting agent that demonstrates key production concepts:\n\n1. **Detailed system prompts** for better agent behavior\n2. **Create tools** that integrate with external data\n3. **Model configuration** for consistent responses\n4. **Structured output** for predictable results\n5. **Conversational memory** for chat-like interactions\n6. **Create and run the agent** create a fully functional agent\n\nLet's walk through each step:\n\n<Steps>\n  <Step title=\"Define the system prompt\">\n    The system prompt defines your agentâ€™s role and behavior. Keep it specific and actionable:\n\n    ```ts  theme={null}\n    const systemPrompt = `You are an expert weather forecaster, who speaks in puns.\n\n    You have access to two tools:\n\n    - get_weather_for_location: use this to get the weather for a specific location\n    - get_user_location: use this to get the user's location\n\n    If a user asks you for the weather, make sure you know the location. If you can tell from the question that they mean wherever they are, use the get_user_location tool to find their location.`;\n    ```\n  </Step>\n\n  <Step title=\"Create tools\">\n    [Tools](/oss/javascript/langchain/tools) are functions your agent can call. Oftentimes tools will want to connect to external systems, and will rely on runtime configuration to do so. Notice here how the `getUserLocation` tool does exactly that:\n\n    ```ts  theme={null}\n    import { tool, type ToolRuntime } from \"langchain\";\n    import * as z from \"zod\";\n\n    const getWeather = tool(\n      (input) => `It's always sunny in ${input.city}!`,\n      {\n        name: \"get_weather_for_location\",\n        description: \"Get the weather for a given city\",\n        schema: z.object({\n          city: z.string().describe(\"The city to get the weather for\"),\n        }),\n      }\n    );\n\n    type AgentRuntime = ToolRuntime<unknown, { user_id: string }>;\n\n    const getUserLocation = tool(\n      (_, config: AgentRuntime) => {\n        const { user_id } = config.context;\n        return user_id === \"1\" ? \"Florida\" : \"SF\";\n      },\n      {\n        name: \"get_user_location\",\n        description: \"Retrieve user information based on user ID\",\n      }\n    );\n    ```\n\n    <Note>\n      [Zod](https://zod.dev/) is a library for validating and parsing pre-defined schemas. You can use it to define the input schema for your tools to make sure the agent only calls the tool with the correct arguments.\n\n      Alternatively, you can define the `schema` property as a [JSON schema](https://json-schema.org/overview/what-is-jsonschema) object. Keep in mind that JSON schemas **won't** be validated at runtime.\n\n      <Accordion title=\"Example: Using JSON schema for tool input\">\n        ```ts  theme={null}\n        const getWeather = tool(\n          ({ city }) => `It's always sunny in ${city}!`,\n          {\n            name: \"get_weather_for_location\",\n            description: \"Get the weather for a given city\",\n            schema: {\n              type: \"object\",\n              properties: {\n                city: {\n                  type: \"string\",\n                  description: \"The city to get the weather for\"\n                }\n              },\n              required: [\"city\"]\n            },\n          }\n        );\n        ```\n      </Accordion>\n    </Note>\n  </Step>\n\n  <Step title=\"Configure your model\">\n    Set up your [language model](/oss/javascript/langchain/models) with the right [parameters](/oss/javascript/langchain/models#parameters) for your use case:\n\n    ```ts  theme={null}\n    import { initChatModel } from \"langchain\";\n\n    const model = await initChatModel(\n      \"claude-sonnet-4-5-20250929\",\n      { temperature: 0.5, timeout: 10, maxTokens: 1000 }\n    );\n    ```\n  </Step>\n\n  <Step title=\"Define response format\">\n    Optionally, define a structured response format if you need the agent responses to match\n    a specific schema.\n\n    ```ts  theme={null}\n    const responseFormat = z.object({\n      punny_response: z.string(),\n      weather_conditions: z.string().optional(),\n    });\n    ```\n  </Step>\n\n  <Step title=\"Add memory\">\n    Add [memory](/oss/javascript/langchain/short-term-memory) to your agent to maintain state across interactions. This allows\n    the agent to remember previous conversations and context.\n\n    ```ts  theme={null}\n    import { MemorySaver } from \"@langchain/langgraph\";\n\n    const checkpointer = new MemorySaver();\n    ```\n\n    <Info>\n      In production, use a persistent checkpointer that saves to a database.\n      See [Add and manage memory](/oss/javascript/langgraph/add-memory#manage-short-term-memory) for more details.\n    </Info>\n  </Step>\n\n  <Step title=\"Create and run the agent\">\n    Now assemble your agent with all the components and run it!\n\n    ```ts  theme={null}\n    import { createAgent } from \"langchain\";\n\n    const agent = createAgent({\n      model: \"claude-sonnet-4-5-20250929\",\n      systemPrompt: systemPrompt,\n      tools: [getUserLocation, getWeather],\n      responseFormat,\n      checkpointer,\n    });\n\n    // `thread_id` is a unique identifier for a given conversation.\n    const config = {\n      configurable: { thread_id: \"1\" },\n      context: { user_id: \"1\" },\n    };\n\n    const response = await agent.invoke(\n      { messages: [{ role: \"user\", content: \"what is the weather outside?\" }] },\n      config\n    );\n    console.log(response.structuredResponse);\n    // {\n    //   punny_response: \"Florida is still having a 'sun-derful' day ...\",\n    //   weather_conditions: \"It's always sunny in Florida!\"\n    // }\n\n    // Note that we can continue the conversation using the same `thread_id`.\n    const thankYouResponse = await agent.invoke(\n      { messages: [{ role: \"user\", content: \"thank you!\" }] },\n      config\n    );\n    console.log(thankYouResponse.structuredResponse);\n    // {\n    //   punny_response: \"You're 'thund-erfully' welcome! ...\",\n    //   weather_conditions: undefined\n    // }\n    ```\n  </Step>\n</Steps>\n\n<Expandable title=\"Full example code\">\n  ```ts  theme={null}\n  import { createAgent, tool, initChatModel } from \"langchain\";\n  import { MemorySaver, type Runtime } from \"@langchain/langgraph\";\n  import * as z from \"zod\";\n\n  // Define system prompt\n  const systemPrompt = `You are an expert weather forecaster, who speaks in puns.\n\n  You have access to two tools:\n\n  - get_weather_for_location: use this to get the weather for a specific location\n  - get_user_location: use this to get the user's location\n\n  If a user asks you for the weather, make sure you know the location. If you can tell from the question that they mean wherever they are, use the get_user_location tool to find their location.`;\n\n  // Define tools\n  const getWeather = tool(\n    ({ city }) => `It's always sunny in ${city}!`,\n    {\n      name: \"get_weather_for_location\",\n      description: \"Get the weather for a given city\",\n      schema: z.object({\n        city: z.string(),\n      }),\n    }\n  );\n\n  type AgentRuntime = ToolRuntime<unknown, { user_id: string }>;\n\n  const getUserLocation = tool(\n    (_, config: AgentRuntime) => {\n      const { user_id } = config.context;\n      return user_id === \"1\" ? \"Florida\" : \"SF\";\n    },\n    {\n      name: \"get_user_location\",\n      description: \"Retrieve user information based on user ID\",\n      schema: z.object({}),\n    }\n  );\n\n  // Configure model\n  const model = await initChatModel(\n    \"claude-sonnet-4-5-20250929\",\n    { temperature: 0 }\n  );\n\n  // Define response format\n  const responseFormat = z.object({\n    punny_response: z.string(),\n    weather_conditions: z.string().optional(),\n  });\n\n  // Set up memory\n  const checkpointer = new MemorySaver();\n\n  // Create agent\n  const agent = createAgent({\n    model,\n    systemPrompt,\n    responseFormat,\n    checkpointer,\n    tools: [getUserLocation, getWeather],\n  });\n\n  // Run agent\n  // `thread_id` is a unique identifier for a given conversation.\n  const config = {\n    configurable: { thread_id: \"1\" },\n    context: { user_id: \"1\" },\n  };\n\n  const response = await agent.invoke(\n    { messages: [{ role: \"user\", content: \"what is the weather outside?\" }] },\n    config\n  );\n  console.log(response.structuredResponse);\n  // {\n  //   punny_response: \"Florida is still having a 'sun-derful' day! The sunshine is playing 'ray-dio' hits all day long! I'd say it's the perfect weather for some 'solar-bration'! If you were hoping for rain, I'm afraid that idea is all 'washed up' - the forecast remains 'clear-ly' brilliant!\",\n  //   weather_conditions: \"It's always sunny in Florida!\"\n  // }\n\n  // Note that we can continue the conversation using the same `thread_id`.\n  const thankYouResponse = await agent.invoke(\n    { messages: [{ role: \"user\", content: \"thank you!\" }] },\n    config\n  );\n  console.log(thankYouResponse.structuredResponse);\n  // {\n  //   punny_response: \"You're 'thund-erfully' welcome! It's always a 'breeze' to help you stay 'current' with the weather. I'm just 'cloud'-ing around waiting to 'shower' you with more forecasts whenever you need them. Have a 'sun-sational' day in the Florida sunshine!\",\n  //   weather_conditions: undefined\n  // }\n  ```\n</Expandable>\n\n<Tip>\n  To learn how to trace your agent with LangSmith, see the [LangSmith documentation](/langsmith/trace-with-langchain).\n</Tip>\n\nCongratulations! You now have an AI agent that can:\n\n* **Understand context** and remember conversations\n* **Use multiple tools** intelligently\n* **Provide structured responses** in a consistent format\n* **Handle user-specific information** through context\n* **Maintain conversation state** across interactions\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/quickstart.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 11203
}