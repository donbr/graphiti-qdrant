{
  "title": "Trace with the Vercel AI SDK (JS/TS only)",
  "source_url": "https://docs.langchain.com/langsmith/trace-with-vercel-ai-sdk",
  "content": "You can use LangSmith to trace runs from the Vercel AI SDK. This guide will walk through an example.\n\n## Installation\n\n<Note>\n  This wrapper requires AI SDK v5 and `langsmith>=0.3.63`. If you are using an older version of the AI SDK or `langsmith`, see the OpenTelemetry (OTEL)\n  based approach [on this page](/langsmith/legacy-trace-with-vercel-ai-sdk).\n</Note>\n\nInstall the Vercel AI SDK. This guide uses Vercel's OpenAI integration for the code snippets below, but you can use any of their other options as well.\n\n<CodeGroup>\n  ```bash npm theme={null}\n  npm install ai @ai-sdk/openai zod\n  ```\n\n  ```bash yarn theme={null}\n  yarn add ai @ai-sdk/openai zod\n  ```\n\n  ```bash pnpm theme={null}\n  pnpm add ai @ai-sdk/openai zod\n  ```\n</CodeGroup>\n\n## Environment configuration\n\n<CodeGroup>\n  ```bash Shell theme={null}\n  export LANGSMITH_TRACING=true\n  export LANGSMITH_API_KEY=<your-api-key>\n\n  # The examples use OpenAI, but you can use any LLM provider of choice\n  export OPENAI_API_KEY=<your-openai-api-key>\n\n  # For LangSmith API keys linked to multiple workspaces, set the LANGSMITH_WORKSPACE_ID environment variable to specify which workspace to use.\n  export LANGSMITH_WORKSPACE_ID=<your-workspace-id>\n  ```\n</CodeGroup>\n\n## Basic setup\n\nImport and wrap AI SDK methods, then use them as you normally would:\n\n```typescript  theme={null}\nimport { openai } from \"@ai-sdk/openai\";\nimport * as ai from \"ai\";\n\nimport { wrapAISDK } from \"langsmith/experimental/vercel\";\n\nconst { generateText, streamText, generateObject, streamObject } =\n  wrapAISDK(ai);\n\nawait generateText({\n  model: openai(\"gpt-5-nano\"),\n  prompt: \"Write a vegetarian lasagna recipe for 4 people.\",\n});\n```\n\nYou should see a trace in your LangSmith dashboard [like this one](https://smith.langchain.com/public/4f0e689e-c801-44d3-8857-93b47ab100cc/r).\n\nYou can also trace runs with tool calls:\n\n```typescript  theme={null}\nimport * as ai from \"ai\";\nimport { tool, stepCountIs } from \"ai\";\nimport { openai } from \"@ai-sdk/openai\";\nimport { z } from \"zod\";\n\nimport { wrapAISDK } from \"langsmith/experimental/vercel\";\n\nconst { generateText, streamText, generateObject, streamObject } =\n  wrapAISDK(ai);\n\nawait generateText({\n  model: openai(\"gpt-5-nano\"),\n  messages: [\n    {\n      role: \"user\",\n      content: \"What are my orders and where are they? My user ID is 123\",\n    },\n  ],\n  tools: {\n    listOrders: tool({\n      description: \"list all orders\",\n      inputSchema: z.object({ userId: z.string() }),\n      execute: async ({ userId }) =>\n        `User ${userId} has the following orders: 1`,\n    }),\n    viewTrackingInformation: tool({\n      description: \"view tracking information for a specific order\",\n      inputSchema: z.object({ orderId: z.string() }),\n      execute: async ({ orderId }) =>\n        `Here is the tracking information for ${orderId}`,\n    }),\n  },\n  stopWhen: stepCountIs(5),\n});\n```\n\nWhich results in a trace like [this one](https://smith.langchain.com/public/6075fa2c-d255-4885-a66a-4fc798afaa9f/r).\n\nYou can use other AI SDK methods exactly as you usually would.\n\n### With `traceable`\n\nYou can wrap `traceable` calls around AI SDK calls or within AI SDK tool calls. This is useful if you\nwant to group runs together in LangSmith:\n\n```typescript  theme={null}\nimport * as ai from \"ai\";\nimport { tool, stepCountIs } from \"ai\";\nimport { openai } from \"@ai-sdk/openai\";\nimport { z } from \"zod\";\n\nimport { traceable } from \"langsmith/traceable\";\nimport { wrapAISDK } from \"langsmith/experimental/vercel\";\n\nconst { generateText, streamText, generateObject, streamObject } =\n  wrapAISDK(ai);\n\nconst wrapper = traceable(async (input: string) => {\n  const { text } = await generateText({\n    model: openai(\"gpt-5-nano\"),\n    messages: [\n      {\n        role: \"user\",\n        content: input,\n      },\n    ],\n    tools: {\n      listOrders: tool({\n        description: \"list all orders\",\n        inputSchema: z.object({ userId: z.string() }),\n        execute: async ({ userId }) =>\n          `User ${userId} has the following orders: 1`,\n      }),\n      viewTrackingInformation: tool({\n        description: \"view tracking information for a specific order\",\n        inputSchema: z.object({ orderId: z.string() }),\n        execute: async ({ orderId }) =>\n          `Here is the tracking information for ${orderId}`,\n      }),\n    },\n    stopWhen: stepCountIs(5),\n  });\n  return text;\n}, {\n  name: \"wrapper\",\n});\n\nawait wrapper(\"What are my orders and where are they? My user ID is 123.\");\n```\n\nThe resulting trace will look [like this](https://smith.langchain.com/public/ff25bc26-9389-4798-8b91-2bdcc95d4a8e/r).\n\n## Tracing in serverless environments\n\nWhen tracing in serverless environments, you must wait for all runs to flush before your environment\nshuts down. To do this, you can pass a LangSmith [`Client`](https://docs.smith.langchain.com/reference/js/classes/client.Client) instance when wrapping the AI SDK method,\nthen call `await client.awaitPendingTraceBatches()`.\nMake sure to also pass it into any `traceable` wrappers you create as well:\n\n```typescript  theme={null}\nimport * as ai from \"ai\";\nimport { tool, stepCountIs } from \"ai\";\nimport { openai } from \"@ai-sdk/openai\";\nimport { z } from \"zod\";\n\nimport { Client } from \"langsmith\";\nimport { traceable } from \"langsmith/traceable\";\nimport { wrapAISDK } from \"langsmith/experimental/vercel\";\n\nconst client = new Client();\n\nconst { generateText, streamText, generateObject, streamObject } =\n  wrapAISDK(ai, { client });\n\nconst wrapper = traceable(async (input: string) => {\n  const { text } = await generateText({\n    model: openai(\"gpt-5-nano\"),\n    messages: [\n      {\n        role: \"user\",\n        content: input,\n      },\n    ],\n    tools: {\n      listOrders: tool({\n        description: \"list all orders\",\n        inputSchema: z.object({ userId: z.string() }),\n        execute: async ({ userId }) =>\n          `User ${userId} has the following orders: 1`,\n      }),\n      viewTrackingInformation: tool({\n        description: \"view tracking information for a specific order\",\n        inputSchema: z.object({ orderId: z.string() }),\n        execute: async ({ orderId }) =>\n          `Here is the tracking information for ${orderId}`,\n      }),\n    },\n    stopWhen: stepCountIs(5),\n  });\n  return text;\n}, {\n  name: \"wrapper\",\n  client,\n});\n\ntry {\n  await wrapper(\"What are my orders and where are they? My user ID is 123.\");\n} finally {\n  await client.awaitPendingTraceBatches();\n}\n```\n\nIf you are using `Next.js`, there is a convenient [`after`](https://nextjs.org/docs/app/api-reference/functions/after) hook\nwhere you can put this logic:\n\n```typescript  theme={null}\nimport { after } from \"next/server\"\nimport { Client } from \"langsmith\";\n\n\nexport async function POST(request: Request) {\n  const client = new Client();\n\n  ...\n\n  after(async () => {\n    await client.awaitPendingTraceBatches();\n  });\n\n  return new Response(JSON.stringify({ ... }), {\n    status: 200,\n    headers: { \"Content-Type\": \"application/json\" },\n  });\n};\n```\n\nSee [this page](/langsmith/serverless-environments) for more detail, including information\naround managing rate limits in serverless environments.\n\n## Passing LangSmith config\n\nYou can pass LangSmith-specific config to your wrapper both when initially wrapping your\nAI SDK methods and while running them via `providerOptions.langsmith`.\nThis includes metadata (which you can later use to filter runs in LangSmith), top-level run name,\ntags, custom client instances, and more.\n\nConfig passed while wrapping will apply to all future calls you make with the wrapped method:\n\n```typescript  theme={null}\nimport { openai } from \"@ai-sdk/openai\";\nimport * as ai from \"ai\";\n\nimport { wrapAISDK } from \"langsmith/experimental/vercel\";\n\nconst { generateText, streamText, generateObject, streamObject } =\n  wrapAISDK(ai, {\n    metadata: {\n      key_for_all_runs: \"value\",\n    },\n    tags: [\"myrun\"],\n  });\n\nawait generateText({\n  model: openai(\"gpt-5-nano\"),\n  prompt: \"Write a vegetarian lasagna recipe for 4 people.\",\n});\n```\n\nWhile passing config at runtime via `providerOptions.langsmith` will apply only to that run.\nWe suggest importing and wrapping your config in `createLangSmithProviderOptions` to ensure\nproper typing:\n\n```typescript  theme={null}\nimport { openai } from \"@ai-sdk/openai\";\nimport * as ai from \"ai\";\n\nimport {\n  wrapAISDK,\n  createLangSmithProviderOptions,\n} from \"langsmith/experimental/vercel\";\n\nconst { generateText, streamText, generateObject, streamObject } =\n  wrapAISDK(ai);\n\nconst lsConfig = createLangSmithProviderOptions({\n  metadata: {\n    individual_key: \"value\",\n  },\n  name: \"my_individual_run\",\n});\n\nawait generateText({\n  model: openai(\"gpt-5-nano\"),\n  prompt: \"Write a vegetarian lasagna recipe for 4 people.\",\n  providerOptions: {\n    langsmith: lsConfig,\n  },\n});\n```\n\n## Redacting data\n\nYou can customize what inputs and outputs the AI SDK sends to LangSmith by specifying custom input/output\nprocessing functions. This is useful if you are dealing with sensitive data that you would like to\navoid sending to LangSmith.\n\nBecause output formats vary depending on which AI SDK method you are using, we suggest defining and passing config\nindividually into wrapped methods. You will also need to provide separate functions for child LLM runs within\nAI SDK calls, since calling `generateText` at top level calls the LLM internally and can do so multiple times.\n\nWe also suggest passing a generic parameter into `createLangSmithProviderOptions` to get proper types for inputs and outputs.\nHere's an example for `generateText`:\n\n```typescript  theme={null}\nimport {\n  wrapAISDK,\n  createLangSmithProviderOptions,\n} from \"langsmith/experimental/vercel\";\nimport * as ai from \"ai\";\nimport { openai } from \"@ai-sdk/openai\";\n\nconst { generateText } = wrapAISDK(ai);\n\nconst lsConfig = createLangSmithProviderOptions<typeof generateText>({\n  processInputs: (inputs) => {\n    const { messages } = inputs;\n    return {\n      messages: messages?.map((message) => ({\n        providerMetadata: message.providerOptions,\n        role: \"assistant\",\n        content: \"REDACTED\",\n      })),\n      prompt: \"REDACTED\",\n    };\n  },\n  processOutputs: (outputs) => {\n    return {\n      providerMetadata: outputs.providerMetadata,\n      role: \"assistant\",\n      content: \"REDACTED\",\n    };\n  },\n  processChildLLMRunInputs: (inputs) => {\n    const { prompt } = inputs;\n    return {\n      messages: prompt.map((message) => ({\n        ...message,\n        content: \"REDACTED CHILD INPUTS\",\n      })),\n    };\n  },\n  processChildLLMRunOutputs: (outputs) => {\n    return {\n      providerMetadata: outputs.providerMetadata,\n      content: \"REDACTED CHILD OUTPUTS\",\n      role: \"assistant\",\n    };\n  },\n});\n\nconst { text } = await generateText({\n  model: openai(\"gpt-5-nano\"),\n  prompt: \"What is the capital of France?\",\n  providerOptions: {\n    langsmith: lsConfig,\n  },\n});\n\n// Paris.\nconsole.log(text);\n```\n\nThe actual return value will contain the original, non-redacted result but the trace in LangSmith\nwill be redacted. [Here's an example](https://smith.langchain.com/public/b4c69c8e-285b-4c0c-8492-e571e2cf562f/r).\n\nFor redacting tool input/output, wrap your `execute` method in a `traceable` like this:\n\n```typescript  theme={null}\nimport * as ai from \"ai\";\nimport { tool, stepCountIs } from \"ai\";\nimport { openai } from \"@ai-sdk/openai\";\nimport { z } from \"zod\";\n\nimport { Client } from \"langsmith\";\nimport { traceable } from \"langsmith/traceable\";\nimport { wrapAISDK } from \"langsmith/experimental/vercel\";\n\nconst client = new Client();\n\nconst { generateText, streamText, generateObject, streamObject } =\n  wrapAISDK(ai, { client });\n\nconst { text } = await generateText({\n  model: openai(\"gpt-5-nano\"),\n  messages: [\n    {\n      role: \"user\",\n      content: \"What are my orders? My user ID is 123.\",\n    },\n  ],\n  tools: {\n    listOrders: tool({\n      description: \"list all orders\",\n      inputSchema: z.object({ userId: z.string() }),\n      execute: traceable(\n        async ({ userId }) => {\n          return `User ${userId} has the following orders: 1`;\n        },\n        {\n          processInputs: (input) => ({ text: \"REDACTED\" }),\n          processOutputs: (outputs) => ({ text: \"REDACTED\" }),\n          run_type: \"tool\",\n          name: \"listOrders\",\n        }\n      ) as (input: { userId: string }) => Promise<string>,\n    }),\n  },\n  stopWhen: stepCountIs(5),\n});\n```\n\nThe `traceable` return type is complex, which makes the castÂ necessary. You may also omit the AI SDK `tool` wrapper function\nif you wish to avoid the cast.\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/trace-with-vercel-ai-sdk.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 12900
}