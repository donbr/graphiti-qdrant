{
  "title": "Models",
  "source_url": "https://docs.langchain.com/oss/javascript/langchain/models",
  "content": "[LLMs](https://en.wikipedia.org/wiki/Large_language_model) are powerful AI tools that can interpret and generate text like humans. They're versatile enough to write content, translate languages, summarize, and answer questions without needing specialized training for each task.\n\nIn addition to text generation, many models support:\n\n* <Icon icon=\"hammer\" size={16} /> [Tool calling](#tool-calling) - calling external tools (like databases queries or API calls) and use results in their responses.\n* <Icon icon=\"shapes\" size={16} /> [Structured output](#structured-output) - where the model's response is constrained to follow a defined format.\n* <Icon icon=\"image\" size={16} /> [Multimodality](#multimodal) - process and return data other than text, such as images, audio, and video.\n* <Icon icon=\"brain\" size={16} /> [Reasoning](#reasoning) - models perform multi-step reasoning to arrive at a conclusion.\n\nModels are the reasoning engine of [agents](/oss/javascript/langchain/agents). They drive the agent's decision-making process, determining which tools to call, how to interpret results, and when to provide a final answer.\n\nThe quality and capabilities of the model you choose directly impact your agent's baseline reliability and performance. Different models excel at different tasks - some are better at following complex instructions, others at structured reasoning, and some support larger context windows for handling more information.\n\nLangChain's standard model interfaces give you access to many different provider integrations, which makes it easy to experiment with and switch between models to find the best fit for your use case.\n\n<Info>\n  For provider-specific integration information and capabilities, see the provider's [chat model page](/oss/javascript/integrations/chat).\n</Info>\n\n## Basic usage\n\nModels can be utilized in two ways:\n\n1. **With agents** - Models can be dynamically specified when creating an [agent](/oss/javascript/langchain/agents#model).\n2. **Standalone** - Models can be called directly (outside of the agent loop) for tasks like text generation, classification, or extraction without the need for an agent framework.\n\nThe same model interface works in both contexts, which gives you the flexibility to start simple and scale up to more complex agent-based workflows as needed.\n\n### Initialize a model\n\nThe easiest way to get started with a standalone model in LangChain is to use `initChatModel` to initialize one from a [chat model provider](/oss/javascript/integrations/chat) of your choice (examples below):\n\n<Tabs>\n  <Tab title=\"OpenAI\">\n    ðŸ‘‰ Read the [OpenAI chat model integration docs](/oss/javascript/integrations/chat/openai/)\n\n    <CodeGroup>\n      ```bash npm theme={null}\n      npm install @langchain/openai\n      ```\n\n      ```bash pnpm theme={null}\n      pnpm install @langchain/openai\n      ```\n\n      ```bash yarn theme={null}\n      yarn add @langchain/openai\n      ```\n\n      ```bash bun theme={null}\n      bun add @langchain/openai\n      ```\n    </CodeGroup>\n\n    <CodeGroup>\n      ```typescript initChatModel theme={null}\n      import { initChatModel } from \"langchain\";\n\n      process.env.OPENAI_API_KEY = \"your-api-key\";\n\n      const model = await initChatModel(\"gpt-4.1\");\n      ```\n\n      ```typescript Model Class theme={null}\n      import { ChatOpenAI } from \"@langchain/openai\";\n\n      const model = new ChatOpenAI({\n        model: \"gpt-4.1\",\n        apiKey: \"your-api-key\"\n      });\n      ```\n    </CodeGroup>\n  </Tab>\n\n  <Tab title=\"Anthropic\">\n    ðŸ‘‰ Read the [Anthropic chat model integration docs](/oss/javascript/integrations/chat/anthropic/)\n\n    <CodeGroup>\n      ```bash npm theme={null}\n      npm install @langchain/anthropic\n      ```\n\n      ```bash pnpm theme={null}\n      pnpm install @langchain/anthropic\n      ```\n\n      ```bash yarn theme={null}\n      yarn add @langchain/anthropic\n      ```\n\n      ```bash pnpm theme={null}\n      pnpm add @langchain/anthropic\n      ```\n    </CodeGroup>\n\n    <CodeGroup>\n      ```typescript initChatModel theme={null}\n      import { initChatModel } from \"langchain\";\n\n      process.env.ANTHROPIC_API_KEY = \"your-api-key\";\n\n      const model = await initChatModel(\"claude-sonnet-4-5-20250929\");\n      ```\n\n      ```typescript Model Class theme={null}\n      import { ChatAnthropic } from \"@langchain/anthropic\";\n\n      const model = new ChatAnthropic({\n        model: \"claude-sonnet-4-5-20250929\",\n        apiKey: \"your-api-key\"\n      });\n      ```\n    </CodeGroup>\n  </Tab>\n\n  <Tab title=\"Azure\">\n    ðŸ‘‰ Read the [Azure chat model integration docs](/oss/javascript/integrations/chat/azure/)\n\n    <CodeGroup>\n      ```bash npm theme={null}\n      npm install @langchain/azure\n      ```\n\n      ```bash pnpm theme={null}\n      pnpm install @langchain/azure\n      ```\n\n      ```bash yarn theme={null}\n      yarn add @langchain/azure\n      ```\n\n      ```bash bun theme={null}\n      bun add @langchain/azure\n      ```\n    </CodeGroup>\n\n    <CodeGroup>\n      ```typescript initChatModel theme={null}\n      import { initChatModel } from \"langchain\";\n\n      process.env.AZURE_OPENAI_API_KEY = \"your-api-key\";\n      process.env.AZURE_OPENAI_ENDPOINT = \"your-endpoint\";\n      process.env.OPENAI_API_VERSION = \"your-api-version\";\n\n      const model = await initChatModel(\"azure_openai:gpt-4.1\");\n      ```\n\n      ```typescript Model Class theme={null}\n      import { AzureChatOpenAI } from \"@langchain/openai\";\n\n      const model = new AzureChatOpenAI({\n        model: \"gpt-4.1\",\n        azureOpenAIApiKey: \"your-api-key\",\n        azureOpenAIApiEndpoint: \"your-endpoint\",\n        azureOpenAIApiVersion: \"your-api-version\"\n      });\n      ```\n    </CodeGroup>\n  </Tab>\n\n  <Tab title=\"Google Gemini\">\n    ðŸ‘‰ Read the [Google GenAI chat model integration docs](/oss/javascript/integrations/chat/google_generative_ai/)\n\n    <CodeGroup>\n      ```bash npm theme={null}\n      npm install @langchain/google-genai\n      ```\n\n      ```bash pnpm theme={null}\n      pnpm install @langchain/google-genai\n      ```\n\n      ```bash yarn theme={null}\n      yarn add @langchain/google-genai\n      ```\n\n      ```bash bun theme={null}\n      bun add @langchain/google-genai\n      ```\n    </CodeGroup>\n\n    <CodeGroup>\n      ```typescript initChatModel theme={null}\n      import { initChatModel } from \"langchain\";\n\n      process.env.GOOGLE_API_KEY = \"your-api-key\";\n\n      const model = await initChatModel(\"google-genai:gemini-2.5-flash-lite\");\n      ```\n\n      ```typescript Model Class theme={null}\n      import { ChatGoogleGenerativeAI } from \"@langchain/google-genai\";\n\n      const model = new ChatGoogleGenerativeAI({\n        model: \"gemini-2.5-flash-lite\",\n        apiKey: \"your-api-key\"\n      });\n      ```\n    </CodeGroup>\n  </Tab>\n\n  <Tab title=\"Bedrock Converse\">\n    ðŸ‘‰ Read the [AWS Bedrock chat model integration docs](/oss/javascript/integrations/chat/bedrock_converse/)\n\n    <CodeGroup>\n      ```bash npm theme={null}\n      npm install @langchain/aws\n      ```\n\n      ```bash pnpm theme={null}\n      pnpm install @langchain/aws\n      ```\n\n      ```bash yarn theme={null}\n      yarn add @langchain/aws\n      ```\n\n      ```bash bun theme={null}\n      bun add @langchain/aws\n      ```\n    </CodeGroup>\n\n    <CodeGroup>\n      ```typescript initChatModel theme={null}\n      import { initChatModel } from \"langchain\";\n\n      // Follow the steps here to configure your credentials:\n      // https://docs.aws.amazon.com/bedrock/latest/userguide/getting-started.html\n\n      const model = await initChatModel(\"bedrock:gpt-4.1\");\n      ```\n\n      ```typescript Model Class theme={null}\n      import { ChatBedrockConverse } from \"@langchain/aws\";\n\n      // Follow the steps here to configure your credentials:\n      // https://docs.aws.amazon.com/bedrock/latest/userguide/getting-started.html\n\n      const model = new ChatBedrockConverse({\n        model: \"gpt-4.1\",\n        region: \"us-east-2\"\n      });\n      ```\n    </CodeGroup>\n  </Tab>\n</Tabs>\n\n```typescript  theme={null}\nconst response = await model.invoke(\"Why do parrots talk?\");\n```\n\nSee [`initChatModel`](https://reference.langchain.com/javascript/functions/langchain.chat_models_universal.initChatModel.html) for more detail, including information on how to pass model [parameters](#parameters).\n\n### Key methods\n\n<Card title=\"Invoke\" href=\"#invoke\" icon=\"paper-plane\" arrow=\"true\" horizontal>\n  The model takes messages as input and outputs messages after generating a complete response.\n</Card>\n\n<Card title=\"Stream\" href=\"#stream\" icon=\"tower-broadcast\" arrow=\"true\" horizontal>\n  Invoke the model, but stream the output as it is generated in real-time.\n</Card>\n\n<Card title=\"Batch\" href=\"#batch\" icon=\"grip\" arrow=\"true\" horizontal>\n  Send multiple requests to a model in a batch for more efficient processing.\n</Card>\n\n<Info>\n  In addition to chat models, LangChain provides support for other adjacent technologies, such as embedding models and vector stores. See the [integrations page](/oss/javascript/integrations/providers/overview) for details.\n</Info>\n\n## Parameters\n\nA chat model takes parameters that can be used to configure its behavior. The full set of supported parameters varies by model and provider, but standard ones include:\n\n<ParamField body=\"model\" type=\"string\" required>\n  The name or identifier of the specific model you want to use with a provider. You can also specify both the model and its provider in a single argument using the '{model_provider}:{model}' format, for example, 'openai:o1'.\n</ParamField>\n\n<ParamField body=\"apiKey\" type=\"string\">\n  The key required for authenticating with the model's provider. This is usually issued when you sign up for access to the model. Often accessed by setting an <Tooltip tip=\"A variable whose value is set outside the program, typically through functionality built into the operating system or microservice.\">environment variable</Tooltip>.\n</ParamField>\n\n<ParamField body=\"temperature\" type=\"number\">\n  Controls the randomness of the model's output. A higher number makes responses more creative; lower ones make them more deterministic.\n</ParamField>\n\n<ParamField body=\"maxTokens\" type=\"number\">\n  Limits the total number of <Tooltip tip=\"The basic unit that a model reads and generates. Providers may define them differently, but in general, they can represent a whole or part of word.\">tokens</Tooltip> in the response, effectively controlling how long the output can be.\n</ParamField>\n\n<ParamField body=\"timeout\" type=\"number\">\n  The maximum time (in seconds) to wait for a response from the model before canceling the request.\n</ParamField>\n\n<ParamField body=\"maxRetries\" type=\"number\">\n  The maximum number of attempts the system will make to resend a request if it fails due to issues like network timeouts or rate limits.\n</ParamField>\n\nUsing `initChatModel`, pass these parameters as inline parameters:\n\n```typescript Initialize using model parameters theme={null}\nconst model = await initChatModel(\n    \"claude-sonnet-4-5-20250929\",\n    { temperature: 0.7, timeout: 30, max_tokens: 1000 }\n)\n```\n\n<Info>\n  Each chat model integration may have additional params used to control provider-specific functionality.\n\n  For example, [`ChatOpenAI`](https://reference.langchain.com/javascript/classes/_langchain_openai.ChatOpenAI.html) has `use_responses_api` to dictate whether to use the OpenAI Responses or Completions API.\n\n  To find all the parameters supported by a given chat model, head to the [chat model integrations](/oss/javascript/integrations/chat) page.\n</Info>\n\n***\n\n## Invocation\n\nA chat model must be invoked to generate an output. There are three primary invocation methods, each suited to different use cases.\n\n### Invoke\n\nThe most straightforward way to call a model is to use [`invoke()`](https://reference.langchain.com/javascript/classes/_langchain_core.language_models_chat_models.BaseChatModel.html#invoke) with a single message or a list of messages.\n\n```typescript Single message theme={null}\nconst response = await model.invoke(\"Why do parrots have colorful feathers?\");\nconsole.log(response);\n```\n\nA list of messages can be provided to a chat model to represent conversation history. Each message has a role that models use to indicate who sent the message in the conversation.\n\nSee the [messages](/oss/javascript/langchain/messages) guide for more detail on roles, types, and content.\n\n```typescript Object format theme={null}\nconst conversation = [\n  { role: \"system\", content: \"You are a helpful assistant that translates English to French.\" },\n  { role: \"user\", content: \"Translate: I love programming.\" },\n  { role: \"assistant\", content: \"J'adore la programmation.\" },\n  { role: \"user\", content: \"Translate: I love building applications.\" },\n];\n\nconst response = await model.invoke(conversation);\nconsole.log(response);  // AIMessage(\"J'adore crÃ©er des applications.\")\n```\n\n```typescript Message objects theme={null}\nimport { HumanMessage, AIMessage, SystemMessage } from \"langchain\";\n\nconst conversation = [\n  new SystemMessage(\"You are a helpful assistant that translates English to French.\"),\n  new HumanMessage(\"Translate: I love programming.\"),\n  new AIMessage(\"J'adore la programmation.\"),\n  new HumanMessage(\"Translate: I love building applications.\"),\n];\n\nconst response = await model.invoke(conversation);\nconsole.log(response);  // AIMessage(\"J'adore crÃ©er des applications.\")\n```\n\n<Info>\n  If the return type of your invocation is a string, ensure that you are using a chat model as opposed to a LLM. Legacy, text-completion LLMs return strings directly. LangChain chat models are prefixed with \"Chat\", e.g., [`ChatOpenAI`](https://reference.langchain.com/javascript/classes/_langchain_openai.ChatOpenAI.html)(/oss/integrations/chat/openai).\n</Info>\n\n### Stream\n\nMost models can stream their output content while it is being generated. By displaying output progressively, streaming significantly improves user experience, particularly for longer responses.\n\nCalling [`stream()`](https://reference.langchain.com/javascript/classes/_langchain_core.language_models_chat_models.BaseChatModel.html#stream) returns an <Tooltip tip=\"An object that progressively provides access to each item of a collection, in order.\">iterator</Tooltip> that yields output chunks as they are produced. You can use a loop to process each chunk in real-time:\n\n<CodeGroup>\n  ```typescript Basic text streaming theme={null}\n  const stream = await model.stream(\"Why do parrots have colorful feathers?\");\n  for await (const chunk of stream) {\n    console.log(chunk.text)\n  }\n  ```\n\n  ```typescript Stream tool calls, reasoning, and other content theme={null}\n  const stream = await model.stream(\"What color is the sky?\");\n  for await (const chunk of stream) {\n    for (const block of chunk.contentBlocks) {\n      if (block.type === \"reasoning\") {\n        console.log(`Reasoning: ${block.reasoning}`);\n      } else if (block.type === \"tool_call_chunk\") {\n        console.log(`Tool call chunk: ${block}`);\n      } else if (block.type === \"text\") {\n        console.log(block.text);\n      } else {\n        ...\n      }\n    }\n  }\n  ```\n</CodeGroup>\n\nAs opposed to [`invoke()`](#invoke), which returns a single [`AIMessage`](https://reference.langchain.com/javascript/classes/_langchain_core.messages.AIMessage.html) after the model has finished generating its full response, `stream()` returns multiple [`AIMessageChunk`](https://reference.langchain.com/javascript/classes/_langchain_core.messages.AIMessageChunk.html) objects, each containing a portion of the output text. Importantly, each chunk in a stream is designed to be gathered into a full message via summation:\n\n```typescript Construct AIMessage theme={null}\nlet full: AIMessageChunk | null = null;\nfor await (const chunk of stream) {\n  full = full ? full.concat(chunk) : chunk;\n  console.log(full.text);\n}\n\n// The\n// The sky\n// The sky is\n// The sky is typically\n// The sky is typically blue\n// ...\n\nconsole.log(full.contentBlocks);\n// [{\"type\": \"text\", \"text\": \"The sky is typically blue...\"}]\n```\n\nThe resulting message can be treated the same as a message that was generated with [`invoke()`](#invoke) â€“ for example, it can be aggregated into a message history and passed back to the model as conversational context.\n\n<Warning>\n  Streaming only works if all steps in the program know how to process a stream of chunks. For instance, an application that isn't streaming-capable would be one that needs to store the entire output in memory before it can be processed.\n</Warning>\n\n<Accordion title=\"Advanced streaming topics\">\n  <Accordion title=\"Streaming events\">\n    LangChain chat models can also stream semantic events using\n    \\[`streamEvents()`]\\[BaseChatModel.streamEvents].\n\n    This simplifies filtering based on event types and other metadata, and will aggregate the full message in the background. See below for an example.\n\n    ```typescript  theme={null}\n    const stream = await model.streamEvents(\"Hello\");\n    for await (const event of stream) {\n        if (event.event === \"on_chat_model_start\") {\n            console.log(`Input: ${event.data.input}`);\n        }\n        if (event.event === \"on_chat_model_stream\") {\n            console.log(`Token: ${event.data.chunk.text}`);\n        }\n        if (event.event === \"on_chat_model_end\") {\n            console.log(`Full message: ${event.data.output.text}`);\n        }\n    }\n    ```\n\n    ```txt  theme={null}\n    Input: Hello\n    Token: Hi\n    Token:  there\n    Token: !\n    Token:  How\n    Token:  can\n    Token:  I\n    ...\n    Full message: Hi there! How can I help today?\n    ```\n\n    See the [`streamEvents()`](https://reference.langchain.com/javascript/classes/_langchain_core.language_models_chat_models.BaseChatModel.html#streamEvents) reference for event types and other details.\n  </Accordion>\n\n  <Accordion title=\"&#x22;Auto-streaming&#x22; chat models\">\n    LangChain simplifies streaming from chat models by automatically enabling streaming mode in certain cases, even when you're not explicitly calling the streaming methods. This is particularly useful when you use the non-streaming invoke method but still want to stream the entire application, including intermediate results from the chat model.\n\n    In [LangGraph agents](/oss/javascript/langchain/agents), for example, you can call `model.invoke()` within nodes, but LangChain will automatically delegate to streaming if running in a streaming mode.\n\n    #### How it works\n\n    When you `invoke()` a chat model, LangChain will automatically switch to an internal streaming mode if it detects that you are trying to stream the overall application. The result of the invocation will be the same as far as the code that was using invoke is concerned; however, while the chat model is being streamed, LangChain will take care of invoking [`on_llm_new_token`](https://reference.langchain.com/javascript/interfaces/_langchain_core.callbacks_base.BaseCallbackHandlerMethods.html#onLlmNewToken) events in LangChain's callback system.\n\n    Callback events allow LangGraph `stream()` and `streamEvents()` to surface the chat model's output in real-time.\n  </Accordion>\n</Accordion>\n\n### Batch\n\nBatching a collection of independent requests to a model can significantly improve performance and reduce costs, as the processing can be done in parallel:\n\n```typescript Batch theme={null}\nconst responses = await model.batch([\n  \"Why do parrots have colorful feathers?\",\n  \"How do airplanes fly?\",\n  \"What is quantum computing?\",\n  \"Why do parrots have colorful feathers?\",\n  \"How do airplanes fly?\",\n  \"What is quantum computing?\",\n]);\nfor (const response of responses) {\n  console.log(response);\n}\n```\n\n<Tip>\n  When processing a large number of inputs using `batch()`, you may want to control the maximum number of parallel calls. This can be done by setting the `maxConcurrency` attribute in the [`RunnableConfig`](https://reference.langchain.com/javascript/interfaces/_langchain_core.runnables.RunnableConfig.html) dictionary.\n\n  ```typescript Batch with max concurrency theme={null}\n  model.batch(\n    listOfInputs,\n    {\n      maxConcurrency: 5,  // Limit to 5 parallel calls\n    }\n  )\n  ```\n\n  See the [`RunnableConfig`](https://reference.langchain.com/javascript/interfaces/_langchain_core.runnables.RunnableConfig.html) reference for a full list of supported attributes.\n</Tip>\n\nFor more details on batching, see the [reference](https://reference.langchain.com/javascript/classes/_langchain_core.language_models_chat_models.BaseChatModel.html#batch).\n\n***\n\n## Tool calling\n\nModels can request to call tools that perform tasks such as fetching data from a database, searching the web, or running code. Tools are pairings of:\n\n1. A schema, including the name of the tool, a description, and/or argument definitions (often a JSON schema)\n2. A function or <Tooltip tip=\"A method that can suspend execution and resume at a later time\">coroutine</Tooltip> to execute.\n\n<Note>\n  You may hear the term \"function calling\". We use this interchangeably with \"tool calling\".\n</Note>\n\nHere's the basic tool calling flow between a user and a model:\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant U as User\n    participant M as Model\n    participant T as Tools\n\n    U->>M: \"What's the weather in SF and NYC?\"\n    M->>M: Analyze request & decide tools needed\n\n    par Parallel Tool Calls\n        M->>T: getWeather(\"San Francisco\")\n        M->>T: getWeather(\"New York\")\n    end\n\n    par Tool Execution\n        T-->>M: SF weather data\n        T-->>M: NYC weather data\n    end\n\n    M->>M: Process results & generate response\n    M->>U: \"SF: 72Â°F sunny, NYC: 68Â°F cloudy\"\n```\n\nTo make tools that you have defined available for use by a model, you must bind them using [`bindTools`](https://reference.langchain.com/javascript/classes/_langchain_core.language_models_chat_models.BaseChatModel.html#bindTools). In subsequent invocations, the model can choose to call any of the bound tools as needed.\n\nSome model providers offer <Tooltip tip=\"Tools that are executed server-side, such as web search and code interpreters\">built-in tools</Tooltip> that can be enabled via model or invocation parameters (e.g. [`ChatOpenAI`](/oss/javascript/integrations/chat/openai), [`ChatAnthropic`](/oss/javascript/integrations/chat/anthropic)). Check the respective [provider reference](/oss/javascript/integrations/providers/overview) for details.\n\n<Tip>\n  See the [tools guide](/oss/javascript/langchain/tools) for details and other options for creating tools.\n</Tip>\n\n```typescript Binding user tools theme={null}\nimport { tool } from \"langchain\";\nimport * as z from \"zod\";\nimport { ChatOpenAI } from \"@langchain/openai\";\n\nconst getWeather = tool(\n  (input) => `It's sunny in ${input.location}.`,\n  {\n    name: \"get_weather\",\n    description: \"Get the weather at a location.\",\n    schema: z.object({\n      location: z.string().describe(\"The location to get the weather for\"),\n    }),\n  },\n);\n\nconst model = new ChatOpenAI({ model: \"gpt-4o\" });\nconst modelWithTools = model.bindTools([getWeather]);  // [!code highlight]\n\nconst response = await modelWithTools.invoke(\"What's the weather like in Boston?\");\nconst toolCalls = response.tool_calls || [];\nfor (const tool_call of toolCalls) {\n  // View tool calls made by the model\n  console.log(`Tool: ${tool_call.name}`);\n  console.log(`Args: ${tool_call.args}`);\n}\n```\n\nWhen binding user-defined tools, the model's response includes a **request** to execute a tool. When using a model separately from an [agent](/oss/javascript/langchain/agents), it is up to you to execute the requested tool and return the result back to the model for use in subsequent reasoning. When using an [agent](/oss/javascript/langchain/agents), the agent loop will handle the tool execution loop for you.\n\nBelow, we show some common ways you can use tool calling.\n\n<AccordionGroup>\n  <Accordion title=\"Tool execution loop\" icon=\"arrow-rotate-right\">\n    When a model returns tool calls, you need to execute the tools and pass the results back to the model. This creates a conversation loop where the model can use tool results to generate its final response. LangChain includes [agent](/oss/javascript/langchain/agents) abstractions that handle this orchestration for you.\n\n    Here's a simple example of how to do this:\n\n    ```typescript Tool execution loop theme={null}\n    // Bind (potentially multiple) tools to the model\n    const modelWithTools = model.bindTools([get_weather])\n\n    // Step 1: Model generates tool calls\n    const messages = [{\"role\": \"user\", \"content\": \"What's the weather in Boston?\"}]\n    const ai_msg = await modelWithTools.invoke(messages)\n    messages.push(ai_msg)\n\n    // Step 2: Execute tools and collect results\n    for (const tool_call of ai_msg.tool_calls) {\n        // Execute the tool with the generated arguments\n        const tool_result = await get_weather.invoke(tool_call)\n        messages.push(tool_result)\n    }\n\n    // Step 3: Pass results back to model for final response\n    const final_response = await modelWithTools.invoke(messages)\n    console.log(final_response.text)\n    // \"The current weather in Boston is 72Â°F and sunny.\"\n    ```\n\n    Each [`ToolMessage`](https://reference.langchain.com/javascript/classes/_langchain_core.messages.ToolMessage.html) returned by the tool includes a `tool_call_id` that matches the original tool call, helping the model correlate results with requests.\n  </Accordion>\n\n  <Accordion title=\"Forcing tool calls\" icon=\"asterisk\">\n    By default, the model has the freedom to choose which bound tool to use based on the user's input. However, you might want to force choosing a tool, ensuring the model uses either a particular tool or **any** tool from a given list:\n\n    <CodeGroup>\n      ```typescript Force use of any tool theme={null}\n      const modelWithTools = model.bindTools([tool_1], { toolChoice: \"any\" })\n      ```\n\n      ```typescript Force use of specific tools theme={null}\n      const modelWithTools = model.bindTools([tool_1], { toolChoice: \"tool_1\" })\n      ```\n    </CodeGroup>\n  </Accordion>\n\n  <Accordion title=\"Parallel tool calls\" icon=\"layer-group\">\n    Many models support calling multiple tools in parallel when appropriate. This allows the model to gather information from different sources simultaneously.\n\n    ```typescript Parallel tool calls theme={null}\n    const modelWithTools = model.bind_tools([get_weather])\n\n    const response = await modelWithTools.invoke(\n        \"What's the weather in Boston and Tokyo?\"\n    )\n\n\n    // The model may generate multiple tool calls\n    console.log(response.tool_calls)\n    // [\n    //   { name: 'get_weather', args: { location: 'Boston' }, id: 'call_1' },\n    //   { name: 'get_time', args: { location: 'Tokyo' }, id: 'call_2' }\n    // ]\n\n\n    // Execute all tools (can be done in parallel with async)\n    const results = []\n    for (const tool_call of response.tool_calls || []) {\n        if (tool_call.name === 'get_weather') {\n            const result = await get_weather.invoke(tool_call)\n            results.push(result)\n        }\n    }\n    ```\n\n    The model intelligently determines when parallel execution is appropriate based on the independence of the requested operations.\n\n    <Tip>\n      Most models supporting tool calling enable parallel tool calls by default. Some (including [OpenAI](/oss/javascript/integrations/chat/openai) and [Anthropic](/oss/javascript/integrations/chat/anthropic)) allow you to disable this feature. To do this, set `parallel_tool_calls=False`:\n\n      ```python  theme={null}\n      model.bind_tools([get_weather], parallel_tool_calls=False)\n      ```\n    </Tip>\n  </Accordion>\n\n  <Accordion title=\"Streaming tool calls\" icon=\"rss\">\n    When streaming responses, tool calls are progressively built through [`ToolCallChunk`](https://reference.langchain.com/javascript/classes/_langchain_core.messages.ToolCallChunk.html). This allows you to see tool calls as they're being generated rather than waiting for the complete response.\n\n    ```typescript Streaming tool calls theme={null}\n    const stream = await modelWithTools.stream(\n        \"What's the weather in Boston and Tokyo?\"\n    )\n    for await (const chunk of stream) {\n        // Tool call chunks arrive progressively\n        if (chunk.tool_call_chunks) {\n            for (const tool_chunk of chunk.tool_call_chunks) {\n            console.log(`Tool: ${tool_chunk.get('name', '')}`)\n            console.log(`Args: ${tool_chunk.get('args', '')}`)\n            }\n        }\n    }\n\n    // Output:\n    // Tool: get_weather\n    // Args:\n    // Tool:\n    // Args: {\"loc\n    // Tool:\n    // Args: ation\": \"BOS\"}\n    // Tool: get_time\n    // Args:\n    // Tool:\n    // Args: {\"timezone\": \"Tokyo\"}\n    ```\n\n    You can accumulate chunks to build complete tool calls:\n\n    ```typescript Accumulate tool calls theme={null}\n    let full: AIMessageChunk | null = null\n    const stream = await modelWithTools.stream(\"What's the weather in Boston?\")\n    for await (const chunk of stream) {\n        full = full ? full.concat(chunk) : chunk\n        console.log(full.contentBlocks)\n    }\n    ```\n  </Accordion>\n</AccordionGroup>\n\n***\n\n## Structured output\n\nModels can be requested to provide their response in a format matching a given schema. This is useful for ensuring the output can be easily parsed and used in subsequent processing. LangChain supports multiple schema types and methods for enforcing structured output.\n\n<Tabs>\n  <Tab title=\"Zod\">\n    A [zod schema](https://zod.dev/) is the preferred method of defining an output schema. Note that when a zod schema is provided, the model output will also be validated against the schema using zod's parse methods.\n\n    ```typescript  theme={null}\n    import * as z from \"zod\";\n\n    const Movie = z.object({\n      title: z.string().describe(\"The title of the movie\"),\n      year: z.number().describe(\"The year the movie was released\"),\n      director: z.string().describe(\"The director of the movie\"),\n      rating: z.number().describe(\"The movie's rating out of 10\"),\n    });\n\n    const modelWithStructure = model.withStructuredOutput(Movie);\n\n    const response = await modelWithStructure.invoke(\"Provide details about the movie Inception\");\n    console.log(response);\n    // {\n    //   title: \"Inception\",\n    //   year: 2010,\n    //   director: \"Christopher Nolan\",\n    //   rating: 8.8,\n    // }\n    ```\n  </Tab>\n\n  <Tab title=\"JSON Schema\">\n    For maximum control or interoperability, you can provide a raw JSON Schema.\n\n    ```typescript  theme={null}\n    const jsonSchema = {\n      \"title\": \"Movie\",\n      \"description\": \"A movie with details\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"title\": {\n          \"type\": \"string\",\n          \"description\": \"The title of the movie\",\n        },\n        \"year\": {\n          \"type\": \"integer\",\n          \"description\": \"The year the movie was released\",\n        },\n        \"director\": {\n          \"type\": \"string\",\n          \"description\": \"The director of the movie\",\n        },\n        \"rating\": {\n          \"type\": \"number\",\n          \"description\": \"The movie's rating out of 10\",\n        },\n      },\n      \"required\": [\"title\", \"year\", \"director\", \"rating\"],\n    }\n\n    const modelWithStructure = model.withStructuredOutput(\n      jsonSchema,\n      { method: \"jsonSchema\" },\n    )\n\n    const response = await modelWithStructure.invoke(\"Provide details about the movie Inception\")\n    console.log(response)  // {'title': 'Inception', 'year': 2010, ...}\n    ```\n  </Tab>\n</Tabs>\n\n<Note>\n  **Key considerations for structured output:**\n\n  * **Method parameter**: Some providers support different methods (`'jsonSchema'`, `'functionCalling'`, `'jsonMode'`)\n  * **Include raw**: Use [`includeRaw: true`](https://reference.langchain.com/javascript/classes/_langchain_core.language_models_chat_models.BaseChatModel.html#withStructuredOutput) to get both the parsed output and the raw [`AIMessage`](https://reference.langchain.com/javascript/classes/_langchain_core.messages.AIMessage.html)\n  * **Validation**: Zod models provide automatic validation, while JSON Schema requires manual validation\n</Note>\n\n<Accordion title=\"Example: Message output alongside parsed structure\">\n  It can be useful to return the raw [`AIMessage`](https://reference.langchain.com/javascript/classes/_langchain_core.messages.AIMessage.html) object alongside the parsed representation to access response metadata such as [token counts](#token-usage). To do this, set [`include_raw=True`](https://reference.langchain.com/javascript/classes/_langchain_core.language_models_chat_models.BaseChatModel.html#withStructuredOutput) when calling [`with_structured_output`](https://reference.langchain.com/javascript/classes/_langchain_core.language_models_chat_models.BaseChatModel.html#withStructuredOutput):\n\n  ```typescript  theme={null}\n  import * as z from \"zod\";\n\n  const Movie = z.object({\n    title: z.string().describe(\"The title of the movie\"),\n    year: z.number().describe(\"The year the movie was released\"),\n    director: z.string().describe(\"The director of the movie\"),\n    rating: z.number().describe(\"The movie's rating out of 10\"),\n    title: z.string().describe(\"The title of the movie\"),\n    year: z.number().describe(\"The year the movie was released\"),\n    director: z.string().describe(\"The director of the movie\"),  // [!code highlight]\n    rating: z.number().describe(\"The movie's rating out of 10\"),\n  });\n\n  const modelWithStructure = model.withStructuredOutput(Movie, { includeRaw: true });\n\n  const response = await modelWithStructure.invoke(\"Provide details about the movie Inception\");\n  console.log(response);\n  // {\n  //   raw: AIMessage { ... },\n  //   parsed: { title: \"Inception\", ... }\n  // }\n  ```\n</Accordion>\n\n<Accordion title=\"Example: Nested structures\">\n  Schemas can be nested:\n\n  ```typescript  theme={null}\n  import * as z from \"zod\";\n\n  const Actor = z.object({\n    name: str\n    role: z.string(),\n  });\n\n  const MovieDetails = z.object({\n    title: z.string(),\n    year: z.number(),\n    cast: z.array(Actor),\n    genres: z.array(z.string()),\n    budget: z.number().nullable().describe(\"Budget in millions USD\"),\n  });\n\n  const modelWithStructure = model.withStructuredOutput(MovieDetails);\n  ```\n</Accordion>\n\n***\n\n## Supported models\n\nLangChain supports all major model providers, including OpenAI, Anthropic, Google, Azure, AWS Bedrock, and more. Each provider offers a variety of models with different capabilities. For a full list of supported models in LangChain, see the [integrations page](/oss/javascript/integrations/providers/overview).\n\n***\n\n## Advanced topics\n\n### Model profiles\n\n<Warning> This is a beta feature. The format of model profiles is subject to change. </Warning>\n\n<Info> Model profiles require `langchain>=1.1`. </Info>\n\nLangChain chat models can expose a dictionary of supported features and capabilities through a `.profile` property:\n\n```typescript  theme={null}\nmodel.profile;\n// {\n//   maxInputTokens: 400000,\n//   imageInputs: true,\n//   reasoningOutput: true,\n//   toolCalling: true,\n//   ...\n// }\n```\n\nRefer to the full set of fields in the [API reference](https://reference.langchain.com/javascript/interfaces/_langchain_core.language_models_profile.ModelProfile.html).\n\nMuch of the model profile data is powered by the [models.dev](https://github.com/sst/models.dev) project, an open source initiative that provides model capability data. This data is augmented with additional fields for purposes of use with LangChain. These augmentations are kept aligned with the upstream project as it evolves.\n\nModel profile data allow applications to work around model capabilities dynamically. For example:\n\n1. [Summarization middleware](/oss/javascript/langchain/middleware/built-in#summarization) can trigger summarization based on a model's context window size.\n2. [Structured output](/oss/javascript/langchain/structured-output) strategies in `createAgent` can be inferred automatically (e.g., by checking support for native structured output features).\n3. Model inputs can be gated based on supported [modalities](#multimodal) and maximum input tokens.\n\n<Accordion title=\"Modify profile data\">\n  Model profile data can be changed if it is missing, stale, or incorrect.\n\n  **Option 1 (quick fix)**\n\n  You can instantiate a chat model with any valid profile:\n\n  ```typescript  theme={null}\n  const customProfile = {\n  maxInputTokens: 100_000,\n  toolCalling: true,\n  structuredOutput: true,\n  // ...\n  };\n  const model = initChatModel(\"...\", { profile: customProfile });\n  ```\n\n  **Option 2 (fix data upstream)**\n\n  The primary source for the data is the [models.dev](https://models.dev/) project. These data are merged with additional fields and overrides in LangChain [integration packages](/oss/javascript/integrations/providers/overview) and are shipped with those packages.\n\n  Model profile data can be updated through the following process:\n\n  1. (If needed) update the source data at [models.dev](https://models.dev/) through a pull request to its [repository on Github](https://github.com/sst/models.dev).\n  2. (If needed) update additional fields and overrides in `langchain-<package>/profiles.toml` through a pull request to the LangChain [integration package](/oss/javascript/integrations/providers/overview).\n</Accordion>\n\n### Multimodal\n\nCertain models can process and return non-textual data such as images, audio, and video. You can pass non-textual data to a model by providing [content blocks](/oss/javascript/langchain/messages#message-content).\n\n<Tip>\n  All LangChain chat models with underlying multimodal capabilities support:\n\n  1. Data in the cross-provider standard format (see [our messages guide](/oss/javascript/langchain/messages))\n  2. OpenAI [chat completions](https://platform.openai.com/docs/api-reference/chat) format\n  3. Any format that is native to that specific provider (e.g., Anthropic models accept Anthropic native format)\n</Tip>\n\nSee the [multimodal section](/oss/javascript/langchain/messages#multimodal) of the messages guide for details.\n\n<Tooltip tip=\"Not all LLMs are made equally!\" cta=\"See reference\" href=\"https://models.dev/\">Some models</Tooltip> can return multimodal data as part of their response. If invoked to do so, the resulting [`AIMessage`](https://reference.langchain.com/javascript/classes/_langchain_core.messages.AIMessage.html) will have content blocks with multimodal types.\n\n```typescript Multimodal output theme={null}\nconst response = await model.invoke(\"Create a picture of a cat\");\nconsole.log(response.contentBlocks);\n// [\n//   { type: \"text\", text: \"Here's a picture of a cat\" },\n//   { type: \"image\", data: \"...\", mimeType: \"image/jpeg\" },\n// ]\n```\n\nSee the [integrations page](/oss/javascript/integrations/providers/overview) for details on specific providers.\n\n### Reasoning\n\nMany models are capable of performing multi-step reasoning to arrive at a conclusion. This involves breaking down complex problems into smaller, more manageable steps.\n\n**If supported by the underlying model,** you can surface this reasoning process to better understand how the model arrived at its final answer.\n\n<CodeGroup>\n  ```typescript Stream reasoning output theme={null}\n  const stream = model.stream(\"Why do parrots have colorful feathers?\");\n  for await (const chunk of stream) {\n      const reasoningSteps = chunk.contentBlocks.filter(b => b.type === \"reasoning\");\n      console.log(reasoningSteps.length > 0 ? reasoningSteps : chunk.text);\n  }\n  ```\n\n  ```typescript Complete reasoning output theme={null}\n  const response = await model.invoke(\"Why do parrots have colorful feathers?\");\n  const reasoningSteps = response.contentBlocks.filter(b => b.type === \"reasoning\");\n  console.log(reasoningSteps.map(step => step.reasoning).join(\" \"));\n  ```\n</CodeGroup>\n\nDepending on the model, you can sometimes specify the level of effort it should put into reasoning. Similarly, you can request that the model turn off reasoning entirely. This may take the form of categorical \"tiers\" of reasoning (e.g., `'low'` or `'high'`) or integer token budgets.\n\nFor details, see the [integrations page](/oss/javascript/integrations/providers/overview) or [reference](https://reference.langchain.com/python/integrations/) for your respective chat model.\n\n### Local models\n\nLangChain supports running models locally on your own hardware. This is useful for scenarios where either data privacy is critical, you want to invoke a custom model, or when you want to avoid the costs incurred when using a cloud-based model.\n\n[Ollama](/oss/javascript/integrations/chat/ollama) is one of the easiest ways to run models locally. See the full list of local integrations on the [integrations page](/oss/javascript/integrations/providers/overview).\n\n### Prompt caching\n\nMany providers offer prompt caching features to reduce latency and cost on repeat processing of the same tokens. These features can be **implicit** or **explicit**:\n\n* **Implicit prompt caching:** providers will automatically pass on cost savings if a request hits a cache. Examples: [OpenAI](/oss/javascript/integrations/chat/openai) and [Gemini](/oss/javascript/integrations/chat/google_generative_ai).\n* **Explicit caching:** providers allow you to manually indicate cache points for greater control or to guarantee cost savings. Examples:\n  * [`ChatOpenAI`](https://reference.langchain.com/javascript/classes/_langchain_openai.ChatOpenAI.html) (via `prompt_cache_key`)\n  * Anthropic's [`AnthropicPromptCachingMiddleware`](/oss/javascript/integrations/chat/anthropic#prompt-caching)\n  * [Gemini](https://python.langchain.com/api_reference/google_genai/chat_models/langchain_google_genai.chat_models.ChatGoogleGenerativeAI.html).\n  * [AWS Bedrock](/oss/javascript/integrations/chat/bedrock#prompt-caching)\n\n<Warning>\n  Prompt caching is often only engaged above a minimum input token threshold. See [provider pages](/oss/javascript/integrations/chat) for details.\n</Warning>\n\nCache usage will be reflected in the [usage metadata](/oss/javascript/langchain/messages#token-usage) of the model response.\n\n### Server-side tool use\n\nSome providers support server-side [tool-calling](#tool-calling) loops: models can interact with web search, code interpreters, and other tools and analyze the results in a single conversational turn.\n\nIf a model invokes a tool server-side, the content of the response message will include content representing the invocation and result of the tool. Accessing the [content blocks](/oss/javascript/langchain/messages#standard-content-blocks) of the response will return the server-side tool calls and results in a provider-agnostic format:\n\n```typescript  theme={null}\nimport { initChatModel } from \"langchain\";\n\nconst model = await initChatModel(\"gpt-4.1-mini\");\nconst modelWithTools = model.bindTools([{ type: \"web_search\" }])\n\nconst message = await modelWithTools.invoke(\"What was a positive news story from today?\");\nconsole.log(message.contentBlocks);\n```\n\nThis represents a single conversational turn; there are no associated [ToolMessage](/oss/javascript/langchain/messages#tool-message) objects that need to be passed in as in client-side [tool-calling](#tool-calling).\n\nSee the [integration page](/oss/javascript/integrations/chat) for your given provider for available tools and usage details.\n\n### Base URL or proxy\n\nFor many chat model integrations, you can configure the base URL for API requests, which allows you to use model providers that have OpenAI-compatible APIs or to use a proxy server.\n\n<Accordion title=\"Base URL\" icon=\"link\">\n  Many model providers offer OpenAI-compatible APIs (e.g., [Together AI](https://www.together.ai/), [vLLM](https://github.com/vllm-project/vllm)). You can use `initChatModel` with these providers by specifying the appropriate `base_url` parameter:\n\n  ```python  theme={null}\n  model = initChatModel(\n      \"MODEL_NAME\",\n      {\n          modelProvider: \"openai\",\n          baseUrl: \"BASE_URL\",\n          apiKey: \"YOUR_API_KEY\",\n      }\n  )\n  ```\n\n  <Note>\n    When using direct chat model class instantiation, the parameter name may vary by provider. Check the respective [reference](/oss/javascript/integrations/providers/overview) for details.\n  </Note>\n</Accordion>\n\n### Log probabilities\n\nCertain models can be configured to return token-level log probabilities representing the likelihood of a given token by setting the `logprobs` parameter when initializing the model:\n\n```typescript  theme={null}\nconst model = new ChatOpenAI({\n    model: \"gpt-4o\",\n    logprobs: true,\n});\n\nconst responseMessage = await model.invoke(\"Why do parrots talk?\");\n\nresponseMessage.response_metadata.logprobs.content.slice(0, 5);\n```\n\n### Token usage\n\nA number of model providers return token usage information as part of the invocation response. When available, this information will be included on the [`AIMessage`](https://reference.langchain.com/javascript/classes/_langchain_core.messages.AIMessage.html) objects produced by the corresponding model. For more details, see the [messages](/oss/javascript/langchain/messages) guide.\n\n<Note>\n  Some provider APIs, notably OpenAI and Azure OpenAI chat completions, require users opt-in to receiving token usage data in streaming contexts. See the [streaming usage metadata](/oss/javascript/integrations/chat/openai#streaming-usage-metadata) section of the integration guide for details.\n</Note>\n\n### Invocation config\n\nWhen invoking a model, you can pass additional configuration through the `config` parameter using a [`RunnableConfig`](https://reference.langchain.com/javascript/interfaces/_langchain_core.runnables.RunnableConfig.html) object. This provides run-time control over execution behavior, callbacks, and metadata tracking.\n\nCommon configuration options include:\n\n```typescript Invocation with config theme={null}\nconst response = await model.invoke(\n    \"Tell me a joke\",\n    {\n        runName: \"joke_generation\",      // Custom name for this run\n        tags: [\"humor\", \"demo\"],          // Tags for categorization\n        metadata: {\"user_id\": \"123\"},     // Custom metadata\n        callbacks: [my_callback_handler], // Callback handlers\n    }\n)\n```\n\nThese configuration values are particularly useful when:\n\n* Debugging with [LangSmith](https://docs.smith.langchain.com/) tracing\n* Implementing custom logging or monitoring\n* Controlling resource usage in production\n* Tracking invocations across complex pipelines\n\n<Accordion title=\"Key configuration attributes\">\n  <ParamField body=\"runName\" type=\"string\">\n    Identifies this specific invocation in logs and traces. Not inherited by sub-calls.\n  </ParamField>\n\n  <ParamField body=\"tags\" type=\"string[]\">\n    Labels inherited by all sub-calls for filtering and organization in debugging tools.\n  </ParamField>\n\n  <ParamField body=\"metadata\" type=\"object\">\n    Custom key-value pairs for tracking additional context, inherited by all sub-calls.\n  </ParamField>\n\n  <ParamField body=\"maxConcurrency\" type=\"number\">\n    Controls the maximum number of parallel calls when using `batch()`.\n  </ParamField>\n\n  <ParamField body=\"callbacks\" type=\"CallbackHandler[]\">\n    Handlers for monitoring and responding to events during execution.\n  </ParamField>\n\n  <ParamField body=\"recursion_limit\" type=\"number\">\n    Maximum recursion depth for chains to prevent infinite loops in complex pipelines.\n  </ParamField>\n</Accordion>\n\n<Tip>\n  See full [`RunnableConfig`](https://reference.langchain.com/javascript/interfaces/_langchain_core.runnables.RunnableConfig.html) reference for all supported attributes.\n</Tip>\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/models.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 47862
}