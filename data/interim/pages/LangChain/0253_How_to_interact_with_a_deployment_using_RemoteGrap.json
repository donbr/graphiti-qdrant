{
  "title": "How to interact with a deployment using RemoteGraph",
  "source_url": "https://docs.langchain.com/langsmith/use-remote-graph",
  "content": "[`RemoteGraph`](https://langchain-ai.github.io/langgraph/reference/remote_graph) is a client-side interface that allows you to interact with your [deployment](/langsmith/deployments) as if it were a local graph. It provides API parity with [`CompiledGraph`](/oss/python/langgraph/graph-api#compiling-your-graph), which means that you can use the same methods (`invoke()`, `stream()`, `get_state()`, etc.) in your development and production environments. This page describes how to initialize a `RemoteGraph` and interact with it.\n\n`RemoteGraph` is useful for the following:\n\n* Separation of development and deployment: Build and test a graph locally with `CompiledGraph`, deploy it to LangSmith, and then [use `RemoteGraph`](#initialize-the-graph) to call it in production while working with the same API interface.\n* Thread-level persistence: [Persist and fetch the state](#persist-state-at-the-thread-level) of a conversation across calls with a thread ID.\n* Subgraph embedding: Compose modular graphs for a multi-agent workflow by embedding a `RemoteGraph` as a [subgraph](#use-as-a-subgraph) within another graph.\n* Reusable workflows: Use deployed graphs as nodes or [tools](https://langchain-ai.github.io/langgraph/reference/remote_graph/#langgraph.pregel.remote.RemoteGraph.as_tool), so that you can reuse and expose complex logic.\n\n<Warning>\n  **Important: Avoid calling the same deployment**\n\n  `RemoteGraph` is designed to call graphs on other deployments. Do not use `RemoteGraph` to call itself or another graph on the same deployment, as this can lead to deadlocks and resource exhaustion. Instead, use local graph composition or [subgraphs](/oss/python/langgraph/use-subgraphs) for graphs within the same deployment.\n</Warning>\n\n## Prerequisites\n\nBefore getting started with `RemoteGraph`, make sure you have:\n\n* Access to [LangSmith](/langsmith/home), where your graphs are developed and managed.\n* A running [Agent Server](/langsmith/agent-server), which hosts your deployed graphs for remote interaction.\n\n## Initialize the graph\n\nWhen initializing a `RemoteGraph`, you must always specify:\n\n* `name`: The name of the graph you want to interact with **or** an assistant ID. If you specify a graph name, the default assistant will be used. If you specify an assistant ID, that specific assistant will be used. The graph name is the same name you use in the `langgraph.json` configuration file for your deployment.\n* `api_key`: A valid [LangSmith API key](/langsmith/create-account-api-key). You can set as an environment variable (`LANGSMITH_API_KEY`) or pass directly in the `api_key` argument. You can also provide the API key in the `client` / `sync_client` arguments, if `LangGraphClient` / `SyncLangGraphClient` was initialized with the `api_key` argument.\n\nAdditionally, you have to provide one of the following:\n\n* [`url`](#use-a-url): The URL of the deployment you want to interact with. If you pass the `url` argument, both sync and async clients will be created using the provided URL, headers (if provided), and default configuration values (e.g., timeout).\n* [`client`](#use-a-client): A `LangGraphClient` instance for interacting with the deployment asynchronously (e.g., using `.astream()`, `.ainvoke()`, `.aget_state()`, `.aupdate_state()`).\n* `sync_client`: A `SyncLangGraphClient` instance for interacting with the deployment synchronously (e.g., using `.stream()`, `.invoke()`, `.get_state()`, `.update_state()`).\n\n<Note>\n  If you pass both `client` or `sync_client` as well as the `url` argument, they will take precedence over the `url` argument. If none of the `client` / `sync_client` / `url` arguments are provided, `RemoteGraph` will raise a `ValueError` at runtime.\n</Note>\n\n### Use a URL\n\n<CodeGroup>\n  ```python Python theme={null}\n  from langgraph.pregel.remote import RemoteGraph\n\n  url = \"<DEPLOYMENT_URL>\"\n\n  # Using graph name (uses default assistant)\n  graph_name = \"agent\"\n  remote_graph = RemoteGraph(graph_name, url=url)\n\n  # Using assistant ID\n  assistant_id = \"<ASSISTANT_ID>\"\n  remote_graph = RemoteGraph(assistant_id, url=url)\n  ```\n\n  ```typescript JavaScript theme={null}\n  import { RemoteGraph } from \"@langchain/langgraph/remote\";\n\n  const url = \"<DEPLOYMENT_URL>\";\n\n  // Using graph name (uses default assistant)\n  const graphName = \"agent\";\n  const remoteGraph = new RemoteGraph({ graphId: graphName, url });\n\n  // Using assistant ID\n  const assistantId = \"<ASSISTANT_ID>\";\n  const remoteGraph = new RemoteGraph({ graphId: assistantId, url });\n  ```\n</CodeGroup>\n\n### Use a client\n\n<CodeGroup>\n  ```python Python theme={null}\n  from langgraph_sdk import get_client, get_sync_client\n  from langgraph.pregel.remote import RemoteGraph\n\n  url = \"<DEPLOYMENT_URL>\"\n  client = get_client(url=url)\n  sync_client = get_sync_client(url=url)\n\n  # Using graph name (uses default assistant)\n  graph_name = \"agent\"\n  remote_graph = RemoteGraph(graph_name, client=client, sync_client=sync_client)\n\n  # Using assistant ID\n  assistant_id = \"<ASSISTANT_ID>\"\n  remote_graph = RemoteGraph(assistant_id, client=client, sync_client=sync_client)\n  ```\n\n  ```typescript JavaScript theme={null}\n  import { Client } from \"@langchain/langgraph-sdk\";\n  import { RemoteGraph } from \"@langchain/langgraph/remote\";\n\n  const client = new Client({ apiUrl: \"<DEPLOYMENT_URL>\" });\n\n  // Using graph name (uses default assistant)\n  const graphName = \"agent\";\n  const remoteGraph = new RemoteGraph({ graphId: graphName, client });\n\n  // Using assistant ID\n  const assistantId = \"<ASSISTANT_ID>\";\n  const remoteGraph = new RemoteGraph({ graphId: assistantId, client });\n  ```\n</CodeGroup>\n\n## Invoke the graph\n\n`RemoteGraph` implements the same Runnable interface as `CompiledGraph`, so you can use it in the same way as a compiled graph. It supports the full set of standard methods, including `.invoke()`, `.stream()`, `.get_state()`, and `.update_state()`, as well as their asynchronous variants.\n\n### Asynchronously\n\n<Note>\n  To use the graph asynchronously, you must provide either the `url` or `client` when initializing the `RemoteGraph`.\n</Note>\n\n<CodeGroup>\n  ```python Python theme={null}\n  # invoke the graph\n  result = await remote_graph.ainvoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n  })\n\n  # stream outputs from the graph\n  async for chunk in remote_graph.astream({\n      \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in la\"}]\n  }):\n      print(chunk)\n  ```\n\n  ```typescript JavaScript theme={null}\n  // invoke the graph\n  const result = await remoteGraph.invoke({\n      messages: [{role: \"user\", content: \"what's the weather in sf\"}]\n  })\n\n  // stream outputs from the graph\n  for await (const chunk of await remoteGraph.stream({\n      messages: [{role: \"user\", content: \"what's the weather in la\"}]\n  })):\n      console.log(chunk)\n  ```\n</CodeGroup>\n\n### Synchronously\n\n<Note>\n  To use the graph synchronously, you must provide either the `url` or `sync_client` when initializing the `RemoteGraph`.\n</Note>\n\n<CodeGroup>\n  ```python Python theme={null}\n  # invoke the graph\n  result = remote_graph.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n  })\n\n  # stream outputs from the graph\n  for chunk in remote_graph.stream({\n      \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in la\"}]\n  }):\n      print(chunk)\n  ```\n</CodeGroup>\n\n## Persist state at the thread level\n\nBy default, graph runs (for example, calls made with `.invoke()` or `.stream()`) are stateless, which means that intermediate checkpoints and the final state are not persisted after a run.\n\nIf you want to preserve the outputs of a run—for example, to support human-in-the-loop workflows—you can create a thread and pass its ID through the `config` argument. This works the same way as with a regular compiled graph:\n\n<CodeGroup>\n  ```python Python theme={null}\n  from langgraph_sdk import get_sync_client\n\n  url = \"<DEPLOYMENT_URL>\"\n  graph_name = \"agent\"\n  sync_client = get_sync_client(url=url)\n  remote_graph = RemoteGraph(graph_name, url=url)\n\n  # create a thread (or use an existing thread instead)\n  thread = sync_client.threads.create()\n\n  # invoke the graph with the thread config\n  config = {\"configurable\": {\"thread_id\": thread[\"thread_id\"]}}\n  result = remote_graph.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n  }, config=config)\n\n  # verify that the state was persisted to the thread\n  thread_state = remote_graph.get_state(config)\n  print(thread_state)\n  ```\n\n  ```typescript JavaScript theme={null}\n  import { Client } from \"@langchain/langgraph-sdk\";\n  import { RemoteGraph } from \"@langchain/langgraph/remote\";\n\n  const url = \"<DEPLOYMENT_URL>\";\n  const graphName = \"agent\";\n  const client = new Client({ apiUrl: url });\n  const remoteGraph = new RemoteGraph({ graphId: graphName, url });\n\n  // create a thread (or use an existing thread instead)\n  const thread = await client.threads.create();\n\n  // invoke the graph with the thread config\n  const config = { configurable: { thread_id: thread.thread_id }};\n  const result = await remoteGraph.invoke({\n    messages: [{ role: \"user\", content: \"what's the weather in sf\" }],\n  }, config);\n\n  // verify that the state was persisted to the thread\n  const threadState = await remoteGraph.getState(config);\n  console.log(threadState);\n  ```\n</CodeGroup>\n\n## Use as a subgraph\n\n<Note>\n  If you need to use a `checkpointer` with a graph that has a `RemoteGraph` subgraph node, make sure to use UUIDs as thread IDs.\n</Note>\n\nA graph can also call out to multiple `RemoteGraph` instances as [*subgraph*](/oss/python/langgraph/use-subgraphs) nodes. This allows for modular, scalable workflows where different responsibilities are split across separate graphs.\n\n`RemoteGraph` exposes the same interface as a regular `CompiledGraph`, so you can use it directly as a subgraph inside another graph. For example:\n\n<CodeGroup>\n  ```python Python theme={null}\n  from langgraph_sdk import get_sync_client\n  from langgraph.graph import StateGraph, MessagesState, START\n  from typing import TypedDict\n\n  url = \"<DEPLOYMENT_URL>\"\n  graph_name = \"agent\"\n  remote_graph = RemoteGraph(graph_name, url=url)\n\n  # define parent graph\n  builder = StateGraph(MessagesState)\n  # add remote graph directly as a node\n  builder.add_node(\"child\", remote_graph)\n  builder.add_edge(START, \"child\")\n  graph = builder.compile()\n\n  # invoke the parent graph\n  result = graph.invoke({\n      \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n  })\n  print(result)\n\n  # stream outputs from both the parent graph and subgraph\n  for chunk in graph.stream({\n      \"messages\": [{\"role\": \"user\", \"content\": \"what's the weather in sf\"}]\n  }, subgraphs=True):\n      print(chunk)\n  ```\n\n  ```typescript JavaScript theme={null}\n  import { MessagesAnnotation, StateGraph, START } from \"@langchain/langgraph\";\n  import { RemoteGraph } from \"@langchain/langgraph/remote\";\n\n  const url = \"<DEPLOYMENT_URL>\";\n  const graphName = \"agent\";\n  const remoteGraph = new RemoteGraph({ graphId: graphName, url });\n\n  // define parent graph and add remote graph directly as a node\n  const graph = new StateGraph(MessagesAnnotation)\n    .addNode(\"child\", remoteGraph)\n    .addEdge(START, \"child\")\n    .compile()\n\n  // invoke the parent graph\n  const result = await graph.invoke({\n    messages: [{ role: \"user\", content: \"what's the weather in sf\" }]\n  });\n  console.log(result);\n\n  // stream outputs from both the parent graph and subgraph\n  for await (const chunk of await graph.stream({\n    messages: [{ role: \"user\", content: \"what's the weather in la\" }]\n  }, { subgraphs: true })) {\n    console.log(chunk);\n  }\n  ```\n</CodeGroup>\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/use-remote-graph.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 12066
}