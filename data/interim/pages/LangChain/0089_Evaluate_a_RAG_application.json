{
  "title": "Evaluate a RAG application",
  "source_url": "https://docs.langchain.com/langsmith/evaluate-rag-tutorial",
  "content": "<Info>\n  [RAG evaluation](/langsmith/evaluation-concepts#retrieval-augmented-generation-rag) | [Evaluators](/langsmith/evaluation-concepts#evaluators) | [LLM-as-judge evaluators](/langsmith/evaluation-concepts#llm-as-judge)\n</Info>\n\nRetrieval Augmented Generation (RAG) is a technique that enhances Large Language Models (LLMs) by providing them with relevant external knowledge. It has become one of the most widely used approaches for building LLM applications.\n\nThis tutorial will show you how to evaluate your RAG applications using LangSmith. You'll learn:\n\n1. How to create test datasets\n2. How to run your RAG application on those datasets\n3. How to measure your application's performance using different evaluation metrics\n\n## Overview\n\nA typical RAG evaluation workflow consists of three main steps:\n\n1. Creating a dataset with questions and their expected answers\n\n2. Running your RAG application on those questions\n\n3. Using evaluators to measure how well your application performed, looking at factors like:\n\n   * Answer relevance\n   * Answer accuracy\n   * Retrieval quality\n\nFor this tutorial, we'll create and evaluate a bot that answers questions about a few of [Lilian Weng's](https://lilianweng.github.io/) insightful blog posts.\n\n## Setup\n\n### Environment\n\nFirst, let's set our environment variables:\n\n<CodeGroup>\n  ```python Python theme={null}\n  import os\n  os.environ[\"LANGSMITH_TRACING\"] = \"true\"\n  os.environ[\"LANGSMITH_API_KEY\"] = \"YOUR LANGSMITH API KEY\"\n  os.environ[\"OPENAI_API_KEY\"] = \"YOUR OPENAI API KEY\"\n  ```\n\n  ```typescript TypeScript theme={null}\n  process.env.LANGSMITH_TRACING = \"true\";\n  process.env.LANGSMITH_API_KEY = \"YOUR LANGSMITH API KEY\";\n  process.env.OPENAI_API_KEY = \"YOUR OPENAI API KEY\";\n  ```\n</CodeGroup>\n\nAnd install the dependencies we'll need:\n\n<CodeGroup>\n  ```bash Python theme={null}\n  pip install -U langsmith langchain[openai] langchain-community\n  ```\n\n  ```bash TypeScript theme={null}\n  yarn add langsmith langchain @langchain/community @langchain/openai\n  ```\n</CodeGroup>\n\n### Application\n\n<Info>\n  While this tutorial uses LangChain, the evaluation techniques and LangSmith functionality demonstrated here work with any framework. Feel free to use your preferred tools and libraries.\n</Info>\n\nIn this section, we'll build a basic Retrieval-Augmented Generation (RAG) application.\n\nWe'll stick to a simple implementation that:\n\n* Indexing: chunks and indexes a few of Lilian Weng's blogs in a vector store\n* Retrieval: retrieves those chunks based on the user question\n* Generation: passes the question and retrieved docs to an LLM.\n\n#### Indexing and retrieval\n\nFirst, lets load the blog posts we want to build a chatbot for and index them.\n\n<CodeGroup>\n  ```python Python theme={null}\n  from langchain_community.document_loaders import WebBaseLoader\n  from langchain_core.vectorstores import InMemoryVectorStore\n  from langchain_openai import OpenAIEmbeddings\n  from langchain_text_splitters import RecursiveCharacterTextSplitter\n\n  # List of URLs to load documents from\n  urls = [\n      \"https://lilianweng.github.io/posts/2023-06-23-agent/\",\n      \"https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/\",\n      \"https://lilianweng.github.io/posts/2023-10-25-adv-attack-llm/\",\n  ]\n\n  # Load documents from the URLs\n  docs = [WebBaseLoader(url).load() for url in urls]\n  docs_list = [item for sublist in docs for item in sublist]\n\n  # Initialize a text splitter with specified chunk size and overlap\n  text_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(\n      chunk_size=250, chunk_overlap=0\n  )\n\n  # Split the documents into chunks\n  doc_splits = text_splitter.split_documents(docs_list)\n\n  # Add the document chunks to the \"vector store\" using OpenAIEmbeddings\n  vectorstore = InMemoryVectorStore.from_documents(\n      documents=doc_splits,\n      embedding=OpenAIEmbeddings(),\n  )\n\n  # With langchain we can easily turn any vector store into a retrieval component:\n  retriever = vectorstore.as_retriever(k=6)\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { OpenAIEmbeddings } from \"@langchain/openai\";\n  import { MemoryVectorStore } from \"@langchain/classic/vectorstores/memory\";\n  import { BrowserbaseLoader } from \"@langchain/community/document_loaders/web/browserbase\";\n  import { RecursiveCharacterTextSplitter } from \"@langchain/text_splitters\";\n\n  // List of URLs to load documents from\n  const urls = [\n      \"https://lilianweng.github.io/posts/2023-06-23-agent/\",\n      \"https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/\",\n      \"https://lilianweng.github.io/posts/2023-10-25-adv-attack-llm/\",\n  ]\n\n  const loader = new BrowserbaseLoader(urls, {\n      textContent: true,\n  });\n\n  const docs = await loader.load();\n\n  const splitter = new RecursiveCharacterTextSplitter({\n      chunkSize: 1000, chunkOverlap: 200\n  });\n\n  const allSplits = await splitter.splitDocuments(docs);\n\n  const embeddings = new OpenAIEmbeddings({\n      model: \"text-embedding-3-large\"\n  });\n\n  const vectorStore = new MemoryVectorStore(embeddings);  // Index chunks\n  await vectorStore.addDocuments(allSplits)\n  ```\n</CodeGroup>\n\n#### Generation\n\nWe can now define the generative pipeline.\n\n<CodeGroup>\n  ```python Python theme={null}\n  from langchain_openai import ChatOpenAI\n  from langsmith import traceable\n\n  llm = ChatOpenAI(model=\"gpt-4o\", temperature=1)\n\n  # Add decorator so this function is traced in LangSmith\n  @traceable()\n  def rag_bot(question: str) -> dict:\n      # LangChain retriever will be automatically traced\n      docs = retriever.invoke(question)\n      docs_string = \"\".join(doc.page_content for doc in docs)\n      instructions = f\"\"\"You are a helpful assistant who is good at analyzing source information and answering questions.\n         Use the following source documents to answer the user's questions.\n         If you don't know the answer, just say that you don't know.\n         Use three sentences maximum and keep the answer concise.\n\n  Documents:\n  {docs_string}\"\"\"\n      # langchain ChatModel will be automatically traced\n      ai_msg = llm.invoke([\n              {\"role\": \"system\", \"content\": instructions},\n              {\"role\": \"user\", \"content\": question},\n          ],\n      )\n      return {\"answer\": ai_msg.content, \"documents\": docs}\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { ChatOpenAI } from \"@langchain/openai\";\n  import { traceable } from \"langsmith/traceable\";\n\n  const llm = new ChatOpenAI({\n    model: \"gpt-4o\",\n    temperature: 1,\n  })\n\n  // Add decorator so this function is traced in LangSmith\n  const ragBot = traceable(\n      async (question: string) => {\n          // LangChain retriever will be automatically traced\n          const retrievedDocs = await vectorStore.similaritySearch(question);\n          const docsContent = retrievedDocs.map((doc) => doc.pageContent).join(\"\");\n\n          const instructions = `You are a helpful assistant who is good at analyzing source information and answering questions\n          Use the following source documents to answer the user's questions.\n          If you don't know the answer, just say that you don't know.\n          Use three sentences maximum and keep the answer concise.\n          Documents:\n          ${docsContent}`;\n\n          const aiMsg = await llm.invoke([\n              {\n                  role: \"system\",\n                  content: instructions\n              },\n              {\n                  role: \"user\",\n                  content: question\n              }\n          ])\n\n          return {\"answer\": aiMsg.content, \"documents\": retrievedDocs}\n      }\n  )\n  ```\n</CodeGroup>\n\n## Dataset\n\nNow that we've got our application, let's build a dataset to evaluate it. Our dataset will be very simple in this case: we'll have example questions and reference answers.\n\n<CodeGroup>\n  ```python Python theme={null}\n  from langsmith import Client\n\n  client = Client()\n\n  # Define the examples for the dataset\n  examples = [\n      {\n          \"inputs\": {\"question\": \"How does the ReAct agent use self-reflection? \"},\n          \"outputs\": {\"answer\": \"ReAct integrates reasoning and acting, performing actions - such tools like Wikipedia search API - and then observing / reasoning about the tool outputs.\"},\n      },\n      {\n          \"inputs\": {\"question\": \"What are the types of biases that can arise with few-shot prompting?\"},\n          \"outputs\": {\"answer\": \"The biases that can arise with few-shot prompting include (1) Majority label bias, (2) Recency bias, and (3) Common token bias.\"},\n      },\n      {\n          \"inputs\": {\"question\": \"What are five types of adversarial attacks?\"},\n          \"outputs\": {\"answer\": \"Five types of adversarial attacks are (1) Token manipulation, (2) Gradient based attack, (3) Jailbreak prompting, (4) Human red-teaming, (5) Model red-teaming.\"},\n      },\n  ]\n\n  # Create the dataset and examples in LangSmith\n  dataset_name = \"Lilian Weng Blogs Q&A\"\n  dataset = client.create_dataset(dataset_name=dataset_name)\n  client.create_examples(\n      dataset_id=dataset.id,\n      examples=examples\n  )\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { Client } from \"langsmith\";\n\n  const client = new Client();\n\n  // Define the examples for the dataset\n  const examples = [\n      [\n          \"How does the ReAct agent use self-reflection? \",\n          \"ReAct integrates reasoning and acting, performing actions - such tools like Wikipedia search API - and then observing / reasoning about the tool outputs.\",\n      ],\n      [\n          \"What are the types of biases that can arise with few-shot prompting?\",\n          \"The biases that can arise with few-shot prompting include (1) Majority label bias, (2) Recency bias, and (3) Common token bias.\",\n      ],\n      [\n          \"What are five types of adversarial attacks?\",\n          \"Five types of adversarial attacks are (1) Token manipulation, (2) Gradient based attack, (3) Jailbreak prompting, (4) Human red-teaming, (5) Model red-teaming.\",\n      ]\n  ]\n\n  const [inputs, outputs] = examples.reduce<[Array<{ input: string }>, Array<{ outputs: string }>]>(\n      ([inputs, outputs], item) => [\n          [...inputs, { input: item[0] }],\n          [...outputs, { outputs: item[1] }],\n      ],\n      [[], []]\n  );\n\n  const datasetName = \"Lilian Weng Blogs Q&A\";\n  const dataset = await client.createDataset(datasetName);\n  await client.createExamples({ inputs, outputs, datasetId: dataset.id })\n  ```\n</CodeGroup>\n\n## Evaluators\n\nOne way to think about different types of RAG evaluators is as a tuple of what is being evaluated X what its being evaluated against:\n\n1. **Correctness**: Response vs reference answer\n\n* `Goal`: Measure \"*how similar/correct is the RAG chain answer, relative to a ground-truth answer*\"\n* `Mode`: Requires a ground truth (reference) answer supplied through a dataset\n* `Evaluator`: Use LLM-as-judge to assess answer correctness.\n\n2. **Relevance**: Response vs input\n\n* `Goal`: Measure \"*how well does the generated response address the initial user input*\"\n* `Mode`: Does not require reference answer, because it will compare the answer to the input question\n* `Evaluator`: Use LLM-as-judge to assess answer relevance, helpfulness, etc.\n\n3. **Groundedness**: Response vs retrieved docs\n\n* `Goal`: Measure \"*to what extent does the generated response agree with the retrieved context*\"\n* `Mode`: Does not require reference answer, because it will compare the answer to the retrieved context\n* `Evaluator`: Use LLM-as-judge to assess faithfulness, hallucinations, etc.\n\n4. **Retrieval relevance**: Retrieved docs vs input\n\n* `Goal`: Measure \"*how relevant are my retrieved results for this query*\"\n* `Mode`: Does not require reference answer, because it will compare the question to the retrieved context\n* `Evaluator`: Use LLM-as-judge to assess relevance\n\n<img src=\"https://mintcdn.com/langchain-5e9cc07a/Fr2lazPB4XVeEA7l/langsmith/images/rag-eval-overview.png?fit=max&auto=format&n=Fr2lazPB4XVeEA7l&q=85&s=6f303c2a284296b42e7d2d2e658f5171\" alt=\"\" data-og-width=\"1252\" width=\"1252\" data-og-height=\"547\" height=\"547\" data-path=\"langsmith/images/rag-eval-overview.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/langchain-5e9cc07a/Fr2lazPB4XVeEA7l/langsmith/images/rag-eval-overview.png?w=280&fit=max&auto=format&n=Fr2lazPB4XVeEA7l&q=85&s=b5531116cdd61ca9e8ea6fcd760643db 280w, https://mintcdn.com/langchain-5e9cc07a/Fr2lazPB4XVeEA7l/langsmith/images/rag-eval-overview.png?w=560&fit=max&auto=format&n=Fr2lazPB4XVeEA7l&q=85&s=8f83816ac849c05dd8d3dee4c9670729 560w, https://mintcdn.com/langchain-5e9cc07a/Fr2lazPB4XVeEA7l/langsmith/images/rag-eval-overview.png?w=840&fit=max&auto=format&n=Fr2lazPB4XVeEA7l&q=85&s=8656d8f8af7ffa7f2684376cf2f70874 840w, https://mintcdn.com/langchain-5e9cc07a/Fr2lazPB4XVeEA7l/langsmith/images/rag-eval-overview.png?w=1100&fit=max&auto=format&n=Fr2lazPB4XVeEA7l&q=85&s=4299367332fbefd15e938aefc23ca6fe 1100w, https://mintcdn.com/langchain-5e9cc07a/Fr2lazPB4XVeEA7l/langsmith/images/rag-eval-overview.png?w=1650&fit=max&auto=format&n=Fr2lazPB4XVeEA7l&q=85&s=0bc19645279f119031a5cb8ca32f2f7d 1650w, https://mintcdn.com/langchain-5e9cc07a/Fr2lazPB4XVeEA7l/langsmith/images/rag-eval-overview.png?w=2500&fit=max&auto=format&n=Fr2lazPB4XVeEA7l&q=85&s=185b7c4ba4f4127f780d5fa17b96c752 2500w\" />\n\n### Correctness: Response vs reference answer\n\n<CodeGroup>\n  ```python Python theme={null}\n  from typing_extensions import Annotated, TypedDict\n\n  # Grade output schema\n  class CorrectnessGrade(TypedDict):\n      # Note that the order in the fields are defined is the order in which the model will generate them.\n      # It is useful to put explanations before responses because it forces the model to think through\n      # its final response before generating it:\n      explanation: Annotated[str, ..., \"Explain your reasoning for the score\"]\n      correct: Annotated[bool, ..., \"True if the answer is correct, False otherwise.\"]\n\n  # Grade prompt\n  correctness_instructions = \"\"\"You are a teacher grading a quiz. You will be given a QUESTION, the GROUND TRUTH (correct) ANSWER, and the STUDENT ANSWER. Here is the grade criteria to follow:\n  (1) Grade the student answers based ONLY on their factual accuracy relative to the ground truth answer. (2) Ensure that the student answer does not contain any conflicting statements.\n  (3) It is OK if the student answer contains more information than the ground truth answer, as long as it is factually accurate relative to the  ground truth answer.\n\n  Correctness:\n  A correctness value of True means that the student's answer meets all of the criteria.\n  A correctness value of False means that the student's answer does not meet all of the criteria.\n\n  Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.\"\"\"\n\n  # Grader LLM\n  grader_llm = ChatOpenAI(model=\"gpt-4o\", temperature=0).with_structured_output(\n      CorrectnessGrade, method=\"json_schema\", strict=True\n  )\n\n  def correctness(inputs: dict, outputs: dict, reference_outputs: dict) -> bool:\n      \"\"\"An evaluator for RAG answer accuracy\"\"\"\n      answers = f\"\"\"\\\n  QUESTION: {inputs['question']}\n  GROUND TRUTH ANSWER: {reference_outputs['answer']}\n  STUDENT ANSWER: {outputs['answer']}\"\"\"\n      # Run evaluator\n      grade = grader_llm.invoke([\n          {\"role\": \"system\", \"content\": correctness_instructions},\n          {\"role\": \"user\", \"content\": answers}\n      ])\n      return grade[\"correct\"]\n  ```\n\n  ```typescript TypeScript theme={null}\n  import type { EvaluationResult } from \"langsmith/evaluation\";\n  import { z } from \"zod\";\n\n  // Grade prompt\n  const correctnessInstructions = `You are a teacher grading a quiz. You will be given a QUESTION, the GROUND TRUTH (correct) ANSWER, and the STUDENT ANSWER. Here is the grade criteria to follow:\n  (1) Grade the student answers based ONLY on their factual accuracy relative to the ground truth answer. (2) Ensure that the student answer does not contain any conflicting statements.\n  (3) It is OK if the student answer contains more information than the ground truth answer, as long as it is factually accurate relative to the  ground truth answer.\n\n  Correctness:\n  A correctness value of True means that the student's answer meets all of the criteria.\n  A correctness value of False means that the student's answer does not meet all of the criteria.\n\n  Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.`\n\n  const graderLLM = new ChatOpenAI({\n    model: \"gpt-4o\",\n    temperature: 0,\n  }).withStructuredOutput(\n    z\n      .object({\n        explanation: z\n          .string()\n          .describe(\"Explain your reasoning for the score\"),\n        correct: z\n          .boolean()\n          .describe(\"True if the answer is correct, False otherwise.\")\n      })\n      .describe(\"Correctness score for reference answer v.s. generated answer.\")\n  );\n\n  async function correctness({\n    inputs,\n    outputs,\n    referenceOutputs,\n  }: {\n    inputs: Record<string, any>;\n    outputs: Record<string, any>;\n    referenceOutputs?: Record<string, any>;\n  }): Promise<EvaluationResult> => {\n    const answer = `QUESTION: ${inputs.question}\n      GROUND TRUTH ANSWER: ${referenceOutputs.answer}\n      STUDENT ANSWER: ${outputs.answer}`\n\n    // Run evaluator\n    const grade = graderLLM.invoke([{role: \"system\", content: correctnessInstructions}, {role: \"user\", content: answer}])\n    return grade.score;\n  };\n  ```\n</CodeGroup>\n\n### Relevance: Response vs input\n\nThe flow is similar to above, but we simply look at the `inputs` and `outputs` without needing the `reference_outputs`. Without a reference answer we can't grade accuracy, but can still grade relevanceâ€”as in, did the model address the user's question or not.\n\n<CodeGroup>\n  ```python Python theme={null}\n  # Grade output schema\n  class RelevanceGrade(TypedDict):\n      explanation: Annotated[str, ..., \"Explain your reasoning for the score\"]\n      relevant: Annotated[\n          bool, ..., \"Provide the score on whether the answer addresses the question\"\n      ]\n\n  # Grade prompt\n  relevance_instructions = \"\"\"You are a teacher grading a quiz. You will be given a QUESTION and a STUDENT ANSWER. Here is the grade criteria to follow:\n  (1) Ensure the STUDENT ANSWER is concise and relevant to the QUESTION\n  (2) Ensure the STUDENT ANSWER helps to answer the QUESTION\n\n  Relevance:\n  A relevance value of True means that the student's answer meets all of the criteria.\n  A relevance value of False means that the student's answer does not meet all of the criteria.\n\n  Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.\"\"\"\n\n  # Grader LLM\n  relevance_llm = ChatOpenAI(model=\"gpt-4o\", temperature=0).with_structured_output(\n      RelevanceGrade, method=\"json_schema\", strict=True\n  )\n\n  # Evaluator\n  def relevance(inputs: dict, outputs: dict) -> bool:\n      \"\"\"A simple evaluator for RAG answer helpfulness.\"\"\"\n      answer = f\"QUESTION: {inputs['question']}\\nSTUDENT ANSWER: {outputs['answer']}\"\n      grade = relevance_llm.invoke([\n          {\"role\": \"system\", \"content\": relevance_instructions},\n          {\"role\": \"user\", \"content\": answer}\n      ])\n      return grade[\"relevant\"]\n  ```\n\n  ```typescript TypeScript theme={null}\n  import type { EvaluationResult } from \"langsmith/evaluation\";\n  import { z } from \"zod\";\n\n  // Grade prompt\n  const relevanceInstructions = `You are a teacher grading a quiz. You will be given a QUESTION and a STUDENT ANSWER. Here is the grade criteria to follow:\n  (1) Ensure the STUDENT ANSWER is concise and relevant to the QUESTION\n  (2) Ensure the STUDENT ANSWER helps to answer the QUESTION\n\n  Relevance:\n  A relevance value of True means that the student's answer meets all of the criteria.\n  A relevance value of False means that the student's answer does not meet all of the criteria.\n\n  Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.`\n\n  const relevanceLLM = new ChatOpenAI({\n    model: \"gpt-4o\",\n    temperature: 0,\n  }).withStructuredOutput(\n    z\n      .object({\n        explanation: z\n          .string()\n          .describe(\"Explain your reasoning for the score\"),\n        relevant: z\n          .boolean()\n          .describe(\"Provide the score on whether the answer addresses the question\")\n      })\n      .describe(\"Relevance score for generated answer v.s. input question.\")\n  );\n\n  async function relevance({\n    inputs,\n    outputs,\n  }: {\n    inputs: Record<string, any>;\n    outputs: Record<string, any>;\n  }): Promise<EvaluationResult> => {\n    const answer = `QUESTION: ${inputs.question}\n  STUDENT ANSWER: ${outputs.answer}`\n\n    // Run evaluator\n    const grade = relevanceLLM.invoke([{role: \"system\", content: relevanceInstructions}, {role: \"user\", content: answer}])\n    return grade.relevant;\n  };\n  ```\n</CodeGroup>\n\n### Groundedness: Response vs retrieved docs\n\nAnother useful way to evaluate responses without needing reference answers is to check if the response is justified by (or \"grounded in\") the retrieved documents.\n\n<CodeGroup>\n  ```python Python theme={null}\n  # Grade output schema\n  class GroundedGrade(TypedDict):\n      explanation: Annotated[str, ..., \"Explain your reasoning for the score\"]\n      grounded: Annotated[\n          bool, ..., \"Provide the score on if the answer hallucinates from the documents\"\n      ]\n\n  # Grade prompt\n  grounded_instructions = \"\"\"You are a teacher grading a quiz. You will be given FACTS and a STUDENT ANSWER. Here is the grade criteria to follow:\n  (1) Ensure the STUDENT ANSWER is grounded in the FACTS. (2) Ensure the STUDENT ANSWER does not contain \"hallucinated\" information outside the scope of the FACTS.\n\n  Grounded:\n  A grounded value of True means that the student's answer meets all of the criteria.\n  A grounded value of False means that the student's answer does not meet all of the criteria.\n\n  Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.\"\"\"\n\n  # Grader LLM\n  grounded_llm = ChatOpenAI(model=\"gpt-4o\", temperature=0).with_structured_output(\n      GroundedGrade, method=\"json_schema\", strict=True\n  )\n\n  # Evaluator\n  def groundedness(inputs: dict, outputs: dict) -> bool:\n      \"\"\"A simple evaluator for RAG answer groundedness.\"\"\"\n      doc_string = \"\\n\\n\".join(doc.page_content for doc in outputs[\"documents\"])\n      answer = f\"FACTS: {doc_string}\\nSTUDENT ANSWER: {outputs['answer']}\"\n      grade = grounded_llm.invoke([\n          {\"role\": \"system\", \"content\": grounded_instructions},\n          {\"role\": \"user\", \"content\": answer}\n      ])\n      return grade[\"grounded\"]\n  ```\n\n  ```typescript TypeScript theme={null}\n  import type { EvaluationResult } from \"langsmith/evaluation\";\n  import { z } from \"zod\";\n\n  // Grade prompt\n  const groundedInstructions = `You are a teacher grading a quiz. You will be given FACTS and a STUDENT ANSWER. Here is the grade criteria to follow:\n  (1) Ensure the STUDENT ANSWER is grounded in the FACTS. (2) Ensure the STUDENT ANSWER does not contain \"hallucinated\" information outside the scope of the FACTS.\n\n  Grounded:\n  A grounded value of True means that the student's answer meets all of the criteria.\n  A grounded value of False means that the student's answer does not meet all of the criteria.\n\n  Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.`\n\n  const groundedLLM = new ChatOpenAI({\n    model: \"gpt-4o\",\n    temperature: 0,\n  }).withStructuredOutput(\n    z\n      .object({\n        explanation: z\n          .string()\n          .describe(\"Explain your reasoning for the score\"),\n        grounded: z\n          .boolean()\n          .describe(\"Provide the score on if the answer hallucinates from the documents\")\n      })\n      .describe(\"Grounded score for the answer from the retrieved documents.\")\n  );\n\n  async function grounded({\n    inputs,\n    outputs,\n  }: {\n    inputs: Record<string, any>;\n    outputs: Record<string, any>;\n  }): Promise<EvaluationResult> => {\n    const docString = outputs.documents.map((doc) => doc.pageContent).join(\"\");\n    const answer = `FACTS: ${docString}\n      STUDENT ANSWER: ${outputs.answer}`\n\n    // Run evaluator\n    const grade = groundedLLM.invoke([{role: \"system\", content: groundedInstructions}, {role: \"user\", content: answer}])\n    return grade.grounded;\n  };\n  ```\n</CodeGroup>\n\n### Retrieval relevance: Retrieved docs vs input\n\n<CodeGroup>\n  ```python Python theme={null}\n  # Grade output schema\n  class RetrievalRelevanceGrade(TypedDict):\n      explanation: Annotated[str, ..., \"Explain your reasoning for the score\"]\n      relevant: Annotated[\n          bool,\n          ...,\n          \"True if the retrieved documents are relevant to the question, False otherwise\",\n      ]\n\n  # Grade prompt\n  retrieval_relevance_instructions = \"\"\"You are a teacher grading a quiz. You will be given a QUESTION and a set of FACTS provided by the student. Here is the grade criteria to follow:\n  (1) You goal is to identify FACTS that are completely unrelated to the QUESTION\n  (2) If the facts contain ANY keywords or semantic meaning related to the question, consider them relevant\n  (3) It is OK if the facts have SOME information that is unrelated to the question as long as (2) is met\n\n  Relevance:\n  A relevance value of True means that the FACTS contain ANY keywords or semantic meaning related to the QUESTION and are therefore relevant.\n  A relevance value of False means that the FACTS are completely unrelated to the QUESTION.\n\n  Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.\"\"\"\n\n  # Grader LLM\n  retrieval_relevance_llm = ChatOpenAI(\n      model=\"gpt-4o\", temperature=0\n  ).with_structured_output(RetrievalRelevanceGrade, method=\"json_schema\", strict=True)\n\n  def retrieval_relevance(inputs: dict, outputs: dict) -> bool:\n      \"\"\"An evaluator for document relevance\"\"\"\n      doc_string = \"\\n\\n\".join(doc.page_content for doc in outputs[\"documents\"])\n      answer = f\"FACTS: {doc_string}\\nQUESTION: {inputs['question']}\"\n      # Run evaluator\n      grade = retrieval_relevance_llm.invoke([\n          {\"role\": \"system\", \"content\": retrieval_relevance_instructions},\n          {\"role\": \"user\", \"content\": answer}\n      ])\n      return grade[\"relevant\"]\n  ```\n\n  ```typescript TypeScript theme={null}\n  import type { EvaluationResult } from \"langsmith/evaluation\";\n  import { z } from \"zod\";\n\n  // Grade prompt\n  const retrievalRelevanceInstructions = `You are a teacher grading a quiz. You will be given a QUESTION and a set of FACTS provided by the student. Here is the grade criteria to follow:\n  (1) You goal is to identify FACTS that are completely unrelated to the QUESTION\n  (2) If the facts contain ANY keywords or semantic meaning related to the question, consider them relevant\n  (3) It is OK if the facts have SOME information that is unrelated to the question as long as (2) is met\n\n  Relevance:\n  A relevance value of True means that the FACTS contain ANY keywords or semantic meaning related to the QUESTION and are therefore relevant.\n  A relevance value of False means that the FACTS are completely unrelated to the QUESTION.\n\n  Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.`\n\n  const retrievalRelevanceLLM = new ChatOpenAI({\n    model: \"gpt-4o\",\n    temperature: 0,\n  }).withStructuredOutput(\n    z\n      .object({\n        explanation: z\n          .string()\n          .describe(\"Explain your reasoning for the score\"),\n        relevant: z\n          .boolean()\n          .describe(\"True if the retrieved documents are relevant to the question, False otherwise\")\n      })\n      .describe(\"Retrieval relevance score for the retrieved documents v.s. the question.\")\n  );\n\n  async function retrievalRelevance({\n    inputs,\n    outputs,\n  }: {\n    inputs: Record<string, any>;\n    outputs: Record<string, any>;\n  }): Promise<EvaluationResult> => {\n    const docString = outputs.documents.map((doc) => doc.pageContent).join(\"\");\n    const answer = `FACTS: ${docString}\n      QUESTION: ${inputs.question}`\n\n    // Run evaluator\n    const grade = retrievalRelevanceLLM.invoke([{role: \"system\", content: retrievalRelevanceInstructions}, {role: \"user\", content: answer}])\n    return grade.relevant;\n  };\n  ```\n</CodeGroup>\n\n## Run evaluation\n\nWe can now kick off our evaluation job with all of our different evaluators.\n\n<CodeGroup>\n  ```python Python theme={null}\n  def target(inputs: dict) -> dict:\n      return rag_bot(inputs[\"question\"])\n\n  experiment_results = client.evaluate(\n      target,\n      data=dataset_name,\n      evaluators=[correctness, groundedness, relevance, retrieval_relevance],\n      experiment_prefix=\"rag-doc-relevance\",\n      metadata={\"version\": \"LCEL context, gpt-4-0125-preview\"},\n  )\n\n  # Explore results locally as a dataframe if you have pandas installed\n  # experiment_results.to_pandas()\n  ```\n\n  ```typescript TypeScript theme={null}\n  import { evaluate } from \"langsmith/evaluation\";\n\n  const targetFunc = (inputs: Record<string, any>) => {\n      return ragBot(inputs.question)\n  };\n\n  const experimentResults = await evaluate(targetFunc, {\n      data: datasetName,\n      evaluators: [correctness, groundedness, relevance, retrievalRelevance],\n      experimentPrefix: \"rag-doc-relevance\",\n      metadata: {version: \"LCEL context, gpt-4-0125-preview\"},\n  });\n  ```\n</CodeGroup>\n\nYou can see an example of what these results look like here: [LangSmith link](https://smith.langchain.com/public/302573e2-20bf-4f8c-bdad-e97c20f33f1b/d)\n\n## Reference code\n\n<Accordion title=\"Here's a consolidated script with all the above code:\">\n  <CodeGroup>\n    ```python Python theme={null}\n    from langchain_community.document_loaders import WebBaseLoader\n    from langchain_core.vectorstores import InMemoryVectorStore\n    from langchain_openai import ChatOpenAI, OpenAIEmbeddings\n    from langchain_text_splitters import RecursiveCharacterTextSplitter\n    from langsmith import Client, traceable\n    from typing_extensions import Annotated, TypedDict\n\n    # List of URLs to load documents from\n    urls = [\n        \"https://lilianweng.github.io/posts/2023-06-23-agent/\",\n        \"https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/\",\n        \"https://lilianweng.github.io/posts/2023-10-25-adv-attack-llm/\",\n    ]\n\n    # Load documents from the URLs\n    docs = [WebBaseLoader(url).load() for url in urls]\n    docs_list = [item for sublist in docs for item in sublist]\n\n    # Initialize a text splitter with specified chunk size and overlap\n    text_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(\n        chunk_size=250, chunk_overlap=0\n    )\n\n    # Split the documents into chunks\n    doc_splits = text_splitter.split_documents(docs_list)\n\n    # Add the document chunks to the \"vector store\" using OpenAIEmbeddings\n    vectorstore = InMemoryVectorStore.from_documents(\n        documents=doc_splits,\n        embedding=OpenAIEmbeddings(),\n    )\n\n    # With langchain we can easily turn any vector store into a retrieval component:\n    retriever = vectorstore.as_retriever(k=6)\n\n    llm = ChatOpenAI(model=\"gpt-4o\", temperature=1)\n\n    # Add decorator so this function is traced in LangSmith\n    @traceable()\n    def rag_bot(question: str) -> dict:\n        # langchain Retriever will be automatically traced\n        docs = retriever.invoke(question)\n        docs_string = \"\".join(doc.page_content for doc in docs)\n        instructions = f\"\"\"You are a helpful assistant who is good at analyzing source information and answering questions.\n           Use the following source documents to answer the user's questions.\n           If you don't know the answer, just say that you don't know.\n           Use three sentences maximum and keep the answer concise.\n\n    Documents:\n    {docs_string}\"\"\"\n        # langchain ChatModel will be automatically traced\n        ai_msg = llm.invoke([\n                {\"role\": \"system\", \"content\": instructions},\n                {\"role\": \"user\", \"content\": question},\n            ],\n        )\n        return {\"answer\": ai_msg.content, \"documents\": docs}\n\n    client = Client()\n\n    # Define the examples for the dataset\n    examples = [\n        {\n            \"inputs\": {\"question\": \"How does the ReAct agent use self-reflection? \"},\n            \"outputs\": {\"answer\": \"ReAct integrates reasoning and acting, performing actions - such tools like Wikipedia search API - and then observing / reasoning about the tool outputs.\"},\n        },\n        {\n            \"inputs\": {\"question\": \"What are the types of biases that can arise with few-shot prompting?\"},\n            \"outputs\": {\"answer\": \"The biases that can arise with few-shot prompting include (1) Majority label bias, (2) Recency bias, and (3) Common token bias.\"},\n        },\n        {\n            \"inputs\": {\"question\": \"What are five types of adversarial attacks?\"},\n            \"outputs\": {\"answer\": \"Five types of adversarial attacks are (1) Token manipulation, (2) Gradient based attack, (3) Jailbreak prompting, (4) Human red-teaming, (5) Model red-teaming.\"},\n        },\n    ]\n\n    # Create the dataset and examples in LangSmith\n    dataset_name = \"Lilian Weng Blogs Q&A\"\n    if not client.has_dataset(dataset_name=dataset_name):\n        dataset = client.create_dataset(dataset_name=dataset_name)\n        client.create_examples(\n            dataset_id=dataset.id,\n            examples=examples\n        )\n\n    # Grade output schema\n    class CorrectnessGrade(TypedDict):\n        # Note that the order in the fields are defined is the order in which the model will generate them.\n        # It is useful to put explanations before responses because it forces the model to think through\n        # its final response before generating it:\n        explanation: Annotated[str, ..., \"Explain your reasoning for the score\"]\n        correct: Annotated[bool, ..., \"True if the answer is correct, False otherwise.\"]\n\n    # Grade prompt\n    correctness_instructions = \"\"\"You are a teacher grading a quiz. You will be given a QUESTION, the GROUND TRUTH (correct) ANSWER, and the STUDENT ANSWER. Here is the grade criteria to follow:\n    (1) Grade the student answers based ONLY on their factual accuracy relative to the ground truth answer. (2) Ensure that the student answer does not contain any conflicting statements.\n    (3) It is OK if the student answer contains more information than the ground truth answer, as long as it is factually accurate relative to the  ground truth answer.\n\n    Correctness:\n    A correctness value of True means that the student's answer meets all of the criteria.\n    A correctness value of False means that the student's answer does not meet all of the criteria.\n\n    Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.\"\"\"\n\n    # Grader LLM\n    grader_llm = ChatOpenAI(model=\"gpt-4o\", temperature=0).with_structured_output(\n        CorrectnessGrade, method=\"json_schema\", strict=True\n    )\n\n    def correctness(inputs: dict, outputs: dict, reference_outputs: dict) -> bool:\n        \"\"\"An evaluator for RAG answer accuracy\"\"\"\n        answers = f\"\"\"\\\n    QUESTION: {inputs['question']}\n    GROUND TRUTH ANSWER: {reference_outputs['answer']}\n    STUDENT ANSWER: {outputs['answer']}\"\"\"\n        # Run evaluator\n        grade = grader_llm.invoke([\n                {\"role\": \"system\", \"content\": correctness_instructions},\n                {\"role\": \"user\", \"content\": answers},\n            ]\n        )\n        return grade[\"correct\"]\n\n    # Grade output schema\n    class RelevanceGrade(TypedDict):\n        explanation: Annotated[str, ..., \"Explain your reasoning for the score\"]\n        relevant: Annotated[\n            bool, ..., \"Provide the score on whether the answer addresses the question\"\n        ]\n\n    # Grade prompt\n    relevance_instructions = \"\"\"You are a teacher grading a quiz. You will be given a QUESTION and a STUDENT ANSWER. Here is the grade criteria to follow:\n    (1) Ensure the STUDENT ANSWER is concise and relevant to the QUESTION\n    (2) Ensure the STUDENT ANSWER helps to answer the QUESTION\n\n    Relevance:\n    A relevance value of True means that the student's answer meets all of the criteria.\n    A relevance value of False means that the student's answer does not meet all of the criteria.\n\n    Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.\"\"\"\n\n    # Grader LLM\n    relevance_llm = ChatOpenAI(model=\"gpt-4o\", temperature=0).with_structured_output(\n        RelevanceGrade, method=\"json_schema\", strict=True\n    )\n\n    # Evaluator\n    def relevance(inputs: dict, outputs: dict) -> bool:\n        \"\"\"A simple evaluator for RAG answer helpfulness.\"\"\"\n        answer = f\"QUESTION: {inputs['question']}\\nSTUDENT ANSWER: {outputs['answer']}\"\n        grade = relevance_llm.invoke([\n                {\"role\": \"system\", \"content\": relevance_instructions},\n                {\"role\": \"user\", \"content\": answer},\n            ]\n        )\n        return grade[\"relevant\"]\n\n    # Grade output schema\n    class GroundedGrade(TypedDict):\n        explanation: Annotated[str, ..., \"Explain your reasoning for the score\"]\n        grounded: Annotated[\n            bool, ..., \"Provide the score on if the answer hallucinates from the documents\"\n        ]\n\n    # Grade prompt\n    grounded_instructions = \"\"\"You are a teacher grading a quiz. You will be given FACTS and a STUDENT ANSWER. Here is the grade criteria to follow:\n    (1) Ensure the STUDENT ANSWER is grounded in the FACTS. (2) Ensure the STUDENT ANSWER does not contain \"hallucinated\" information outside the scope of the FACTS.\n\n    Grounded:\n    A grounded value of True means that the student's answer meets all of the criteria.\n    A grounded value of False means that the student's answer does not meet all of the criteria.\n\n    Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.\"\"\"\n\n    # Grader LLM\n    grounded_llm = ChatOpenAI(model=\"gpt-4o\", temperature=0).with_structured_output(\n        GroundedGrade, method=\"json_schema\", strict=True\n    )\n\n    # Evaluator\n    def groundedness(inputs: dict, outputs: dict) -> bool:\n        \"\"\"A simple evaluator for RAG answer groundedness.\"\"\"\n        doc_string = \"\\n\\n\".join(doc.page_content for doc in outputs[\"documents\"])\n        answer = f\"FACTS: {doc_string}\\nSTUDENT ANSWER: {outputs['answer']}\"\n        grade = grounded_llm.invoke([\n                {\"role\": \"system\", \"content\": grounded_instructions},\n                {\"role\": \"user\", \"content\": answer},\n            ]\n        )\n        return grade[\"grounded\"]\n\n    # Grade output schema\n    class RetrievalRelevanceGrade(TypedDict):\n        explanation: Annotated[str, ..., \"Explain your reasoning for the score\"]\n        relevant: Annotated[\n            bool,\n            ...,\n            \"True if the retrieved documents are relevant to the question, False otherwise\",\n        ]\n\n    # Grade prompt\n    retrieval_relevance_instructions = \"\"\"You are a teacher grading a quiz. You will be given a QUESTION and a set of FACTS provided by the student. Here is the grade criteria to follow:\n    (1) You goal is to identify FACTS that are completely unrelated to the QUESTION\n    (2) If the facts contain ANY keywords or semantic meaning related to the question, consider them relevant\n    (3) It is OK if the facts have SOME information that is unrelated to the question as long as (2) is met\n\n    Relevance:\n    A relevance value of True means that the FACTS contain ANY keywords or semantic meaning related to the QUESTION and are therefore relevant.\n    A relevance value of False means that the FACTS are completely unrelated to the QUESTION.\n\n    Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.\"\"\"\n\n    # Grader LLM\n    retrieval_relevance_llm = ChatOpenAI(\n        model=\"gpt-4o\", temperature=0\n    ).with_structured_output(RetrievalRelevanceGrade, method=\"json_schema\", strict=True)\n\n    def retrieval_relevance(inputs: dict, outputs: dict) -> bool:\n        \"\"\"An evaluator for document relevance\"\"\"\n        doc_string = \"\\n\\n\".join(doc.page_content for doc in outputs[\"documents\"])\n        answer = f\"FACTS: {doc_string}\\nQUESTION: {inputs['question']}\"\n        # Run evaluator\n        grade = retrieval_relevance_llm.invoke([\n                {\"role\": \"system\", \"content\": retrieval_relevance_instructions},\n                {\"role\": \"user\", \"content\": answer},\n            ]\n        )\n        return grade[\"relevant\"]\n\n    def target(inputs: dict) -> dict:\n        return rag_bot(inputs[\"question\"])\n\n    experiment_results = client.evaluate(\n        target,\n        data=dataset_name,\n        evaluators=[correctness, groundedness, relevance, retrieval_relevance],\n        experiment_prefix=\"rag-doc-relevance\",\n        metadata={\"version\": \"LCEL context, gpt-4-0125-preview\"},\n    )\n\n    # Explore results locally as a dataframe if you have pandas installed\n    # experiment_results.to_pandas()\n    ```\n\n    ```typescript TypeScript theme={null}\n    import { OpenAIEmbeddings, ChatOpenAI } from \"@langchain/openai\";\n    import { MemoryVectorStore } from \"@langchain/classic/vectorstores/memory\";\n    import { BrowserbaseLoader } from \"@langchain/community/document_loaders/web/browserbase\";\n    import { traceable } from \"langsmith/traceable\";\n    import { Client } from \"langsmith\";\n    import { evaluate, type EvaluationResult } from \"langsmith/evaluation\";\n    import { z } from \"zod\";\n\n    // List of URLs to load documents from\n    const urls = [\n        \"https://lilianweng.github.io/posts/2023-06-23-agent/\",\n        \"https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/\",\n        \"https://lilianweng.github.io/posts/2023-10-25-adv-attack-llm/\",\n    ]\n\n    const loader = new BrowserbaseLoader(urls, {\n        textContent: true,\n    });\n\n    const docs = await loader.load();\n\n    const splitter = new RecursiveCharacterTextSplitter({\n        chunkSize: 1000, chunkOverlap: 200\n    });\n\n    const allSplits = await splitter.splitDocuments(docs);\n\n    const embeddings = new OpenAIEmbeddings({\n        model: \"text-embedding-3-large\"\n    });\n\n    const vectorStore = new MemoryVectorStore(embeddings);  // Index chunks\n    await vectorStore.addDocuments(allSplits)\n\n    const llm = new ChatOpenAI({\n      model: \"gpt-4o\",\n      temperature: 1,\n    })\n\n    // Add decorator so this function is traced in LangSmith\n    const ragBot = traceable(\n        async (question: string) => {\n            // LangChain retriever will be automatically traced\n            const retrievedDocs = await vectorStore.similaritySearch(question);\n            const docsContent = retrievedDocs.map((doc) => doc.pageContent).join(\"\");\n\n            const instructions = `You are a helpful assistant who is good at analyzing source information and answering questions\n            Use the following source documents to answer the user's questions.\n            If you don't know the answer, just say that you don't know.\n            Use three sentences maximum and keep the answer concise.\n            Documents:\n            ${docsContent}`;\n\n            const aiMsg = await llm.invoke([\n                {\n                    role: \"system\",\n                    content: instructions\n                },\n                {\n                    role: \"user\",\n                    content: question\n                }\n            ])\n\n            return {\"answer\": aiMsg.content, \"documents\": retrievedDocs}\n        }\n    )\n\n    const client = new Client();\n\n    // Define the examples for the dataset\n    const examples = [\n        [\n            \"How does the ReAct agent use self-reflection? \",\n            \"ReAct integrates reasoning and acting, performing actions - such tools like Wikipedia search API - and then observing / reasoning about the tool outputs.\",\n        ],\n        [\n            \"What are the types of biases that can arise with few-shot prompting?\",\n            \"The biases that can arise with few-shot prompting include (1) Majority label bias, (2) Recency bias, and (3) Common token bias.\",\n        ],\n        [\n            \"What are five types of adversarial attacks?\",\n            \"Five types of adversarial attacks are (1) Token manipulation, (2) Gradient based attack, (3) Jailbreak prompting, (4) Human red-teaming, (5) Model red-teaming.\",\n        ]\n    ]\n\n    const [inputs, outputs] = examples.reduce<[Array<{ input: string }>, Array<{ outputs: string }>]>(\n        ([inputs, outputs], item) => [\n            [...inputs, { input: item[0] }],\n            [...outputs, { outputs: item[1] }],\n        ],\n        [[], []]\n    );\n\n    const datasetName = \"Lilian Weng Blogs Q&A\";\n    const dataset = await client.createDataset(datasetName);\n    await client.createExamples({ inputs, outputs, datasetId: dataset.id })\n\n    // Grade prompt\n    const correctnessInstructions = `You are a teacher grading a quiz. You will be given a QUESTION, the GROUND TRUTH (correct) ANSWER, and the STUDENT ANSWER. Here is the grade criteria to follow:\n    (1) Grade the student answers based ONLY on their factual accuracy relative to the ground truth answer. (2) Ensure that the student answer does not contain any conflicting statements.\n    (3) It is OK if the student answer contains more information than the ground truth answer, as long as it is factually accurate relative to the  ground truth answer.\n\n    Correctness:\n    A correctness value of True means that the student's answer meets all of the criteria.\n    A correctness value of False means that the student's answer does not meet all of the criteria.\n\n    Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.`\n\n    const graderLLM = new ChatOpenAI({\n      model: \"gpt-4o\",\n      temperature: 0,\n    }).withStructuredOutput(\n      z\n        .object({\n          explanation: z\n            .string()\n            .describe(\"Explain your reasoning for the score\"),\n          correct: z\n            .boolean()\n            .describe(\"True if the answer is correct, False otherwise.\")\n        })\n        .describe(\"Correctness score for reference answer v.s. generated answer.\")\n    );\n\n    async function correctness({\n      inputs,\n      outputs,\n      referenceOutputs,\n    }: {\n      inputs: Record<string, any>;\n      outputs: Record<string, any>;\n      referenceOutputs?: Record<string, any>;\n    }): Promise<EvaluationResult> => {\n      const answer = `QUESTION: ${inputs.question}\n        GROUND TRUTH ANSWER: ${referenceOutputs.answer}\n        STUDENT ANSWER: ${outputs.answer}`\n\n      // Run evaluator\n      const grade = graderLLM.invoke([{role: \"system\", content: correctnessInstructions}, {role: \"user\", content: answer}])\n      return grade.score;\n    };\n\n    // Grade prompt\n    const relevanceInstructions = `You are a teacher grading a quiz. You will be given a QUESTION and a STUDENT ANSWER. Here is the grade criteria to follow:\n    (1) Ensure the STUDENT ANSWER is concise and relevant to the QUESTION\n    (2) Ensure the STUDENT ANSWER helps to answer the QUESTION\n\n    Relevance:\n    A relevance value of True means that the student's answer meets all of the criteria.\n    A relevance value of False means that the student's answer does not meet all of the criteria.\n\n    Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.`\n\n    const relevanceLLM = new ChatOpenAI({\n      model: \"gpt-4o\",\n      temperature: 0,\n    }).withStructuredOutput(\n      z\n        .object({\n          explanation: z\n            .string()\n            .describe(\"Explain your reasoning for the score\"),\n          relevant: z\n            .boolean()\n            .describe(\"Provide the score on whether the answer addresses the question\")\n        })\n        .describe(\"Relevance score for generated answer v.s. input question.\")\n    );\n\n    async function relevance({\n      inputs,\n      outputs,\n    }: {\n      inputs: Record<string, any>;\n      outputs: Record<string, any>;\n    }): Promise<EvaluationResult> => {\n      const answer = `QUESTION: ${inputs.question}\n    STUDENT ANSWER: ${outputs.answer}`\n\n      // Run evaluator\n      const grade = relevanceLLM.invoke([{role: \"system\", content: relevanceInstructions}, {role: \"user\", content: answer}])\n      return grade.relevant;\n    };\n\n    // Grade prompt\n    const groundedInstructions = `You are a teacher grading a quiz. You will be given FACTS and a STUDENT ANSWER. Here is the grade criteria to follow:\n    (1) Ensure the STUDENT ANSWER is grounded in the FACTS. (2) Ensure the STUDENT ANSWER does not contain \"hallucinated\" information outside the scope of the FACTS.\n\n    Grounded:\n    A grounded value of True means that the student's answer meets all of the criteria.\n    A grounded value of False means that the student's answer does not meet all of the criteria.\n\n    Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.`\n\n    const groundedLLM = new ChatOpenAI({\n      model: \"gpt-4o\",\n      temperature: 0,\n    }).withStructuredOutput(\n      z\n        .object({\n          explanation: z\n            .string()\n            .describe(\"Explain your reasoning for the score\"),\n          grounded: z\n            .boolean()\n            .describe(\"Provide the score on if the answer hallucinates from the documents\")\n        })\n        .describe(\"Grounded score for the answer from the retrieved documents.\")\n    );\n\n    async function grounded({\n      inputs,\n      outputs,\n    }: {\n      inputs: Record<string, any>;\n      outputs: Record<string, any>;\n    }): Promise<EvaluationResult> => {\n      const docString = outputs.documents.map((doc) => doc.pageContent).join(\"\");\n      const answer = `FACTS: ${docString}\n        STUDENT ANSWER: ${outputs.answer}`\n\n      // Run evaluator\n      const grade = groundedLLM.invoke([{role: \"system\", content: groundedInstructions}, {role: \"user\", content: answer}])\n      return grade.grounded;\n    };\n\n    // Grade prompt\n    const retrievalRelevanceInstructions = `You are a teacher grading a quiz. You will be given a QUESTION and a set of FACTS provided by the student. Here is the grade criteria to follow:\n    (1) You goal is to identify FACTS that are completely unrelated to the QUESTION\n    (2) If the facts contain ANY keywords or semantic meaning related to the question, consider them relevant\n    (3) It is OK if the facts have SOME information that is unrelated to the question as long as (2) is met\n\n    Relevance:\n    A relevance value of True means that the FACTS contain ANY keywords or semantic meaning related to the QUESTION and are therefore relevant.\n    A relevance value of False means that the FACTS are completely unrelated to the QUESTION.\n\n    Explain your reasoning in a step-by-step manner to ensure your reasoning and conclusion are correct. Avoid simply stating the correct answer at the outset.`\n\n    const retrievalRelevanceLLM = new ChatOpenAI({\n      model: \"gpt-4o\",\n      temperature: 0,\n    }).withStructuredOutput(\n      z\n        .object({\n          explanation: z\n            .string()\n            .describe(\"Explain your reasoning for the score\"),\n          relevant: z\n            .boolean()\n            .describe(\"True if the retrieved documents are relevant to the question, False otherwise\")\n        })\n        .describe(\"Retrieval relevance score for the retrieved documents v.s. the question.\")\n    );\n\n    async function retrievalRelevance({\n      inputs,\n      outputs,\n    }: {\n      inputs: Record<string, any>;\n      outputs: Record<string, any>;\n    }): Promise<EvaluationResult> => {\n      const docString = outputs.documents.map((doc) => doc.pageContent).join(\"\");\n      const answer = `FACTS: ${docString}\n        QUESTION: ${inputs.question}`\n\n      // Run evaluator\n      const grade = retrievalRelevanceLLM.invoke([{role: \"system\", content: retrievalRelevanceInstructions}, {role: \"user\", content: answer}])\n      return grade.relevant;\n    };\n\n    const targetFunc = (inputs: Record<string, any>) => {\n        return ragBot(inputs.question)\n    };\n\n    const experimentResults = await evaluate(targetFunc, {\n        data: datasetName,\n        evaluators: [correctness, groundedness, relevance, retrievalRelevance],\n        experimentPrefix: \"rag-doc-relevance\",\n        metadata: {version: \"LCEL context, gpt-4-0125-preview\"},\n    });\n    ```\n  </CodeGroup>\n</Accordion>\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/evaluate-rag-tutorial.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 53695
}