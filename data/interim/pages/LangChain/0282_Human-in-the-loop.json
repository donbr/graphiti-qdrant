{
  "title": "Human-in-the-loop",
  "source_url": "https://docs.langchain.com/oss/javascript/deepagents/human-in-the-loop",
  "content": "Learn how to configure human approval for sensitive tool operations\n\nSome tool operations may be sensitive and require human approval before execution. Deep agents support human-in-the-loop workflows through LangGraph's interrupt capabilities. You can configure which tools require approval using the `interrupt_on` parameter.\n\n```mermaid  theme={null}\ngraph LR\n    Agent[Agent] --> Check{Interrupt?}\n    Check --> |no| Execute[Execute]\n    Check --> |yes| Human{Human}\n\n    Human --> |approve| Execute\n    Human --> |edit| Execute\n    Human --> |reject| Cancel[Cancel]\n\n    Execute --> Agent\n    Cancel --> Agent\n```\n\n## Basic configuration\n\nThe `interrupt_on` parameter accepts a dictionary mapping tool names to interrupt configurations. Each tool can be configured with:\n\n* **`True`**: Enable interrupts with default behavior (approve, edit, reject allowed)\n* **`False`**: Disable interrupts for this tool\n* **`{\"allowed_decisions\": [...]}`**: Custom configuration with specific allowed decisions\n\n```typescript  theme={null}\nimport { tool } from \"langchain\";\nimport { createDeepAgent } from \"deepagents\";\nimport { MemorySaver } from \"@langchain/langgraph\";\nimport { z } from \"zod\";\nimport { v4 as uuidv4 } from 'uuid'; // install uuid package: npm install uuid\n\nconst deleteFile = tool(\n  async ({ path }: { path: string }) => {\n    return `Deleted ${path}`;\n  },\n  {\n    name: \"delete_file\",\n    description: \"Delete a file from the filesystem.\",\n    schema: z.object({\n      path: z.string(),\n    }),\n  },\n);\n\nconst sendEmail = tool(\n  async ({ to, subject, body }: { to: string; subject: string; body: string }) => {\n    return `Sent email to ${to}`;\n  },\n  {\n    name: \"send_email\",\n    description: \"Send an email.\",\n    schema: z.object({\n      to: z.string(),\n      subject: z.string(),\n      body: z.string(),\n    }),\n  },\n);\n\n// Checkpointer is REQUIRED for human-in-the-loop\nconst checkpointer = new MemorySaver();\n\nconst agent = createDeepAgent({\n  model: \"claude-sonnet-4-5-20250929\",\n  tools: [deleteFile, sendEmail],\n  interruptOn: {\n    delete_file: true,  // Default: approve, edit, reject\n    read_file: false,   // No interrupts needed\n    send_email: { allowedDecisions: [\"approve\", \"reject\"] },  // No editing\n  },\n  checkpointer,  // Required!\n});\n```\n\n## Decision types\n\nThe `allowed_decisions` list controls what actions a human can take when reviewing a tool call:\n\n* **`\"approve\"`**: Execute the tool with the original arguments as proposed by the agent\n* **`\"edit\"`**: Modify the tool arguments before execution\n* **`\"reject\"`**: Skip executing this tool call entirely\n\nYou can customize which decisions are available for each tool:\n\n```typescript  theme={null}\nconst interruptOn = {\n  // Sensitive operations: allow all options\n  delete_file: { allowedDecisions: [\"approve\", \"edit\", \"reject\"] },\n\n  // Moderate risk: approval or rejection only\n  write_file: { allowedDecisions: [\"approve\", \"reject\"] },\n\n  // Must approve (no rejection allowed)\n  critical_operation: { allowedDecisions: [\"approve\"] },\n};\n```\n\n## Handle interrupts\n\nWhen an interrupt is triggered, the agent pauses execution and returns control. Check for interrupts in the result and handle them accordingly.\n\n```typescript  theme={null}\nimport { v4 as uuidv4 } from \"uuid\";\nimport { Command } from \"@langchain/langgraph\";\n\n// Create config with thread_id for state persistence\nconst config = { configurable: { thread_id: uuidv4() } };\n\n// Invoke the agent\nlet result = await agent.invoke({\n  messages: [{ role: \"user\", content: \"Delete the file temp.txt\" }],\n}, config);\n\n// Check if execution was interrupted\nif (result.__interrupt__) {\n  // Extract interrupt information\n  const interrupts = result.__interrupt__[0].value;\n  const actionRequests = interrupts.actionRequests;\n  const reviewConfigs = interrupts.reviewConfigs;\n\n  // Create a lookup map from tool name to review config\n  const configMap = Object.fromEntries(\n    reviewConfigs.map((cfg) => [cfg.actionName, cfg])\n  );\n\n  // Display the pending actions to the user\n  for (const action of actionRequests) {\n    const reviewConfig = configMap[action.name];\n    console.log(`Tool: ${action.name}`);\n    console.log(`Arguments: ${JSON.stringify(action.args)}`);\n    console.log(`Allowed decisions: ${reviewConfig.allowedDecisions}`);\n  }\n\n  // Get user decisions (one per actionRequest, in order)\n  const decisions = [\n    { type: \"approve\" }  // User approved the deletion\n  ];\n\n  // Resume execution with decisions\n  result = await agent.invoke(\n    new Command({ resume: { decisions } }),\n    config  // Must use the same config!\n  );\n}\n\n// Process final result\nconsole.log(result.messages[result.messages.length - 1].content);\n```\n\n## Multiple tool calls\n\nWhen the agent calls multiple tools that require approval, all interrupts are batched together in a single interrupt. You must provide decisions for each one in order.\n\n```typescript  theme={null}\nconst config = { configurable: { thread_id: uuidv4() } };\n\nlet result = await agent.invoke({\n  messages: [{\n    role: \"user\",\n    content: \"Delete temp.txt and send an email to admin@example.com\"\n  }]\n}, config);\n\nif (result.__interrupt__) {\n  const interrupts = result.__interrupt__[0].value;\n  const actionRequests = interrupts.actionRequests;\n\n  // Two tools need approval\n  console.assert(actionRequests.length === 2);\n\n  // Provide decisions in the same order as actionRequests\n  const decisions = [\n    { type: \"approve\" },  // First tool: delete_file\n    { type: \"reject\" }    // Second tool: send_email\n  ];\n\n  result = await agent.invoke(\n    new Command({ resume: { decisions } }),\n    config\n  );\n}\n```\n\n## Edit tool arguments\n\nWhen `\"edit\"` is in the allowed decisions, you can modify the tool arguments before execution:\n\n```typescript  theme={null}\nif (result.__interrupt__) {\n  const interrupts = result.__interrupt__[0].value;\n  const actionRequest = interrupts.actionRequests[0];\n\n  // Original args from the agent\n  console.log(actionRequest.args);  // { to: \"everyone@company.com\", ... }\n\n  // User decides to edit the recipient\n  const decisions = [{\n    type: \"edit\",\n    editedAction: {\n      name: actionRequest.name,  // Must include the tool name\n      args: { to: \"team@company.com\", subject: \"...\", body: \"...\" }\n    }\n  }];\n\n  result = await agent.invoke(\n    new Command({ resume: { decisions } }),\n    config\n  );\n}\n```\n\n## Subagent interrupts\n\nEach subagent can have its own `interrupt_on` configuration that overrides the main agent's settings:\n\n```typescript  theme={null}\nconst agent = createDeepAgent({\n  tools: [deleteFile, readFile],\n  interruptOn: {\n    delete_file: true,\n    read_file: false,\n  },\n  subagents: [{\n    name: \"file-manager\",\n    description: \"Manages file operations\",\n    systemPrompt: \"You are a file management assistant.\",\n    tools: [deleteFile, readFile],\n    interruptOn: {\n      // Override: require approval for reads in this subagent\n      delete_file: true,\n      read_file: true,  // Different from main agent!\n    }\n  }],\n  checkpointer\n});\n```\n\nWhen a subagent triggers an interrupt, the handling is the same â€“ check for `__interrupt__` and resume with `Command`.\n\n## Best practices\n\n### Always use a checkpointer\n\nHuman-in-the-loop requires a checkpointer to persist agent state between the interrupt and resume:\n\n### Use the same thread ID\n\nWhen resuming, you must use the same config with the same `thread_id`:\n\n### Match decision order to actions\n\nThe decisions list must match the order of `action_requests`:\n\n### Tailor configurations by risk\n\nConfigure different tools based on their risk level:\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/deepagents/human-in-the-loop.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 7954
}