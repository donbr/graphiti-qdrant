{
  "title": "Human-in-the-loop",
  "source_url": "https://docs.langchain.com/oss/python/deepagents/human-in-the-loop",
  "content": "Learn how to configure human approval for sensitive tool operations\n\nSome tool operations may be sensitive and require human approval before execution. Deep agents support human-in-the-loop workflows through LangGraph's interrupt capabilities. You can configure which tools require approval using the `interrupt_on` parameter.\n\n```mermaid  theme={null}\ngraph LR\n    Agent[Agent] --> Check{Interrupt?}\n    Check --> |no| Execute[Execute]\n    Check --> |yes| Human{Human}\n\n    Human --> |approve| Execute\n    Human --> |edit| Execute\n    Human --> |reject| Cancel[Cancel]\n\n    Execute --> Agent\n    Cancel --> Agent\n```\n\n## Basic configuration\n\nThe `interrupt_on` parameter accepts a dictionary mapping tool names to interrupt configurations. Each tool can be configured with:\n\n* **`True`**: Enable interrupts with default behavior (approve, edit, reject allowed)\n* **`False`**: Disable interrupts for this tool\n* **`{\"allowed_decisions\": [...]}`**: Custom configuration with specific allowed decisions\n\n```python  theme={null}\nfrom langchain.tools import tool\nfrom deepagents import create_deep_agent\nfrom langgraph.checkpoint.memory import MemorySaver\n\n@tool\ndef delete_file(path: str) -> str:\n    \"\"\"Delete a file from the filesystem.\"\"\"\n    return f\"Deleted {path}\"\n\n@tool\ndef read_file(path: str) -> str:\n    \"\"\"Read a file from the filesystem.\"\"\"\n    return f\"Contents of {path}\"\n\n@tool\ndef send_email(to: str, subject: str, body: str) -> str:\n    \"\"\"Send an email.\"\"\"\n    return f\"Sent email to {to}\"\n\n# Checkpointer is REQUIRED for human-in-the-loop\ncheckpointer = MemorySaver()\n\nagent = create_deep_agent(\n    model=\"claude-sonnet-4-5-20250929\",\n    tools=[delete_file, read_file, send_email],\n    interrupt_on={\n        \"delete_file\": True,  # Default: approve, edit, reject\n        \"read_file\": False,   # No interrupts needed\n        \"send_email\": {\"allowed_decisions\": [\"approve\", \"reject\"]},  # No editing\n    },\n    checkpointer=checkpointer  # Required!\n)\n```\n\n## Decision types\n\nThe `allowed_decisions` list controls what actions a human can take when reviewing a tool call:\n\n* **`\"approve\"`**: Execute the tool with the original arguments as proposed by the agent\n* **`\"edit\"`**: Modify the tool arguments before execution\n* **`\"reject\"`**: Skip executing this tool call entirely\n\nYou can customize which decisions are available for each tool:\n\n```python  theme={null}\ninterrupt_on = {\n    # Sensitive operations: allow all options\n    \"delete_file\": {\"allowed_decisions\": [\"approve\", \"edit\", \"reject\"]},\n\n    # Moderate risk: approval or rejection only\n    \"write_file\": {\"allowed_decisions\": [\"approve\", \"reject\"]},\n\n    # Must approve (no rejection allowed)\n    \"critical_operation\": {\"allowed_decisions\": [\"approve\"]},\n}\n```\n\n## Handle interrupts\n\nWhen an interrupt is triggered, the agent pauses execution and returns control. Check for interrupts in the result and handle them accordingly.\n\n```python  theme={null}\nimport uuid\nfrom langgraph.types import Command\n\n# Create config with thread_id for state persistence\nconfig = {\"configurable\": {\"thread_id\": str(uuid.uuid4())}}\n\n# Invoke the agent\nresult = agent.invoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"Delete the file temp.txt\"}]\n}, config=config)\n\n# Check if execution was interrupted\nif result.get(\"__interrupt__\"):\n    # Extract interrupt information\n    interrupts = result[\"__interrupt__\"][0].value\n    action_requests = interrupts[\"action_requests\"]\n    review_configs = interrupts[\"review_configs\"]\n\n    # Create a lookup map from tool name to review config\n    config_map = {cfg[\"action_name\"]: cfg for cfg in review_configs}\n\n    # Display the pending actions to the user\n    for action in action_requests:\n        review_config = config_map[action[\"name\"]]\n        print(f\"Tool: {action['name']}\")\n        print(f\"Arguments: {action['args']}\")\n        print(f\"Allowed decisions: {review_config['allowed_decisions']}\")\n\n    # Get user decisions (one per action_request, in order)\n    decisions = [\n        {\"type\": \"approve\"}  # User approved the deletion\n    ]\n\n    # Resume execution with decisions\n    result = agent.invoke(\n        Command(resume={\"decisions\": decisions}),\n        config=config  # Must use the same config!\n    )\n\n# Process final result\nprint(result[\"messages\"][-1][\"content\"])\n```\n\n## Multiple tool calls\n\nWhen the agent calls multiple tools that require approval, all interrupts are batched together in a single interrupt. You must provide decisions for each one in order.\n\n```python  theme={null}\nconfig = {\"configurable\": {\"thread_id\": str(uuid.uuid4())}}\n\nresult = agent.invoke({\n    \"messages\": [{\n        \"role\": \"user\",\n        \"content\": \"Delete temp.txt and send an email to admin@example.com\"\n    }]\n}, config=config)\n\nif result.get(\"__interrupt__\"):\n    interrupts = result[\"__interrupt__\"][0].value\n    action_requests = interrupts[\"action_requests\"]\n\n    # Two tools need approval\n    assert len(action_requests) == 2\n\n    # Provide decisions in the same order as action_requests\n    decisions = [\n        {\"type\": \"approve\"},  # First tool: delete_file\n        {\"type\": \"reject\"}    # Second tool: send_email\n    ]\n\n    result = agent.invoke(\n        Command(resume={\"decisions\": decisions}),\n        config=config\n    )\n```\n\n## Edit tool arguments\n\nWhen `\"edit\"` is in the allowed decisions, you can modify the tool arguments before execution:\n\n```python  theme={null}\nif result.get(\"__interrupt__\"):\n    interrupts = result[\"__interrupt__\"][0].value\n    action_request = interrupts[\"action_requests\"][0]\n\n    # Original args from the agent\n    print(action_request[\"args\"])  # {\"to\": \"everyone@company.com\", ...}\n\n    # User decides to edit the recipient\n    decisions = [{\n        \"type\": \"edit\",\n        \"edited_action\": {\n            \"name\": action_request[\"name\"],  # Must include the tool name\n            \"args\": {\"to\": \"team@company.com\", \"subject\": \"...\", \"body\": \"...\"}\n        }\n    }]\n\n    result = agent.invoke(\n        Command(resume={\"decisions\": decisions}),\n        config=config\n    )\n```\n\n## Subagent interrupts\n\nEach subagent can have its own `interrupt_on` configuration that overrides the main agent's settings:\n\n```python  theme={null}\nagent = create_deep_agent(\n    tools=[delete_file, read_file],\n    interrupt_on={\n        \"delete_file\": True,\n        \"read_file\": False,\n    },\n    subagents=[{\n        \"name\": \"file-manager\",\n        \"description\": \"Manages file operations\",\n        \"system_prompt\": \"You are a file management assistant.\",\n        \"tools\": [delete_file, read_file],\n        \"interrupt_on\": {\n            # Override: require approval for reads in this subagent\n            \"delete_file\": True,\n            \"read_file\": True,  # Different from main agent!\n        }\n    }],\n    checkpointer=checkpointer\n)\n```\n\nWhen a subagent triggers an interrupt, the handling is the same â€“ check for `__interrupt__` and resume with `Command`.\n\n## Best practices\n\n### Always use a checkpointer\n\nHuman-in-the-loop requires a checkpointer to persist agent state between the interrupt and resume:\n\n```python  theme={null}\nfrom langgraph.checkpoint.memory import MemorySaver\n\ncheckpointer = MemorySaver()\nagent = create_deep_agent(\n    tools=[...],\n    interrupt_on={...},\n    checkpointer=checkpointer  # Required for HITL\n)\n```\n\n### Use the same thread ID\n\nWhen resuming, you must use the same config with the same `thread_id`:\n\n```python  theme={null}\n# First call\nconfig = {\"configurable\": {\"thread_id\": \"my-thread\"}}\nresult = agent.invoke(input, config=config)\n\n# Resume (use same config)\nresult = agent.invoke(Command(resume={...}), config=config)\n```\n\n### Match decision order to actions\n\nThe decisions list must match the order of `action_requests`:\n\n```python  theme={null}\nif result.get(\"__interrupt__\"):\n    interrupts = result[\"__interrupt__\"][0].value\n    action_requests = interrupts[\"action_requests\"]\n\n    # Create one decision per action, in order\n    decisions = []\n    for action in action_requests:\n        decision = get_user_decision(action)  # Your logic\n        decisions.append(decision)\n\n    result = agent.invoke(\n        Command(resume={\"decisions\": decisions}),\n        config=config\n    )\n```\n\n### Tailor configurations by risk\n\nConfigure different tools based on their risk level:\n\n```python  theme={null}\ninterrupt_on = {\n    # High risk: full control (approve, edit, reject)\n    \"delete_file\": {\"allowed_decisions\": [\"approve\", \"edit\", \"reject\"]},\n    \"send_email\": {\"allowed_decisions\": [\"approve\", \"edit\", \"reject\"]},\n\n    # Medium risk: no editing allowed\n    \"write_file\": {\"allowed_decisions\": [\"approve\", \"reject\"]},\n\n    # Low risk: no interrupts\n    \"read_file\": False,\n    \"list_files\": False,\n}\n```\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/deepagents/human-in-the-loop.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 9066
}