{
  "title": "Runtime",
  "source_url": "https://docs.langchain.com/oss/javascript/langchain/runtime",
  "content": "## Overview\n\nLangChain's `createAgent` runs on LangGraph's runtime under the hood.\n\nLangGraph exposes a [`Runtime`](https://reference.langchain.com/javascript/interfaces/_langchain_langgraph.index.Runtime.html) object with the following information:\n\n1. **Context**: static information like user id, db connections, or other dependencies for an agent invocation\n2. **Store**: a [BaseStore](https://reference.langchain.com/javascript/classes/_langchain_langgraph-checkpoint.BaseStore.html) instance used for [long-term memory](/oss/javascript/langchain/long-term-memory)\n3. **Stream writer**: an object used for streaming information via the `\"custom\"` stream mode\n\n<Tip>\n  The runtime context is how you thread data through your agent. Rather than storing things in global state, you can attach values — like a database connection, user session, or configuration — to the context and access them inside tools and middleware. This keeps things stateless, testable, and reusable.\n</Tip>\n\nYou can access the runtime information within [tools](#inside-tools) and [middleware](#inside-middleware).\n\n## Access\n\nWhen creating an agent with `createAgent`, you can specify a `contextSchema` to define the structure of the `context` stored in the agent [`Runtime`](https://reference.langchain.com/javascript/interfaces/_langchain_langgraph.index.Runtime.html).\n\nWhen invoking the agent, pass the `context` argument with the relevant configuration for the run:\n\n```ts  theme={null}\nimport * as z from \"zod\";\nimport { createAgent } from \"langchain\";\n\nconst contextSchema = z.object({ // [!code highlight]\n  userName: z.string(), // [!code highlight]\n}); // [!code highlight]\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [\n    /* ... */\n  ],\n  contextSchema, // [!code highlight]\n});\n\nconst result = await agent.invoke(\n  { messages: [{ role: \"user\", content: \"What's my name?\" }] },\n  { context: { userName: \"John Smith\" } } // [!code highlight]\n);\n```\n\n### Inside tools\n\nYou can access the runtime information inside tools to:\n\n* Access the context\n* Read or write long-term memory\n* Write to the [custom stream](/oss/javascript/langchain/streaming#custom-updates) (ex, tool progress / updates)\n\nUse the `runtime` parameter to access the [`Runtime`](https://reference.langchain.com/javascript/interfaces/_langchain_langgraph.index.Runtime.html) object inside a tool.\n\n```ts  theme={null}\nimport * as z from \"zod\";\nimport { tool } from \"langchain\";\nimport { type ToolRuntime } from \"@langchain/core/tools\"; // [!code highlight]\n\nconst contextSchema = z.object({\n  userName: z.string(),\n});\n\nconst fetchUserEmailPreferences = tool(\n  async (_, runtime: ToolRuntime<any, typeof contextSchema>) => { // [!code highlight]\n    const userName = runtime.context?.userName; // [!code highlight]\n    if (!userName) {\n      throw new Error(\"userName is required\");\n    }\n\n    let preferences = \"The user prefers you to write a brief and polite email.\";\n    if (runtime.store) { // [!code highlight]\n      const memory = await runtime.store?.get([\"users\"], userName); // [!code highlight]\n      if (memory) {\n        preferences = memory.value.preferences;\n      }\n    }\n    return preferences;\n  },\n  {\n    name: \"fetch_user_email_preferences\",\n    description: \"Fetch the user's email preferences.\",\n    schema: z.object({}),\n  }\n);\n```\n\n### Inside middleware\n\nYou can access runtime information in middleware to create dynamic prompts, modify messages, or control agent behavior based on user context.\n\nUse the `runtime` parameter to access the [`Runtime`](https://reference.langchain.com/javascript/interfaces/_langchain_langgraph.index.Runtime.html) object inside middleware.\n\n```ts  theme={null}\nimport * as z from \"zod\";\nimport { createAgent, createMiddleware, SystemMessage } from \"langchain\";\n\nconst contextSchema = z.object({\n  userName: z.string(),\n});\n\n// Dynamic prompt middleware\nconst dynamicPromptMiddleware = createMiddleware({\n  name: \"DynamicPrompt\",\n  contextSchema,\n  beforeModel: (state, runtime) => { // [!code highlight]\n    const userName = runtime.context?.userName; // [!code highlight]\n    if (!userName) {\n      throw new Error(\"userName is required\");\n    }\n\n    const systemMsg = `You are a helpful assistant. Address the user as ${userName}.`;\n    return {\n      messages: [new SystemMessage(systemMsg), ...state.messages],\n    };\n  },\n});\n\n// Logging middleware\nconst loggingMiddleware = createMiddleware({\n  name: \"Logging\",\n  contextSchema,\n  beforeModel: (state, runtime) => {  // [!code highlight]\n    console.log(`Processing request for user: ${runtime.context?.userName}`);  // [!code highlight]\n    return;\n  },\n  afterModel: (state, runtime) => {  // [!code highlight]\n    console.log(`Completed request for user: ${runtime.context?.userName}`);  // [!code highlight]\n    return;\n  },\n});\n\nconst agent = createAgent({\n  model: \"gpt-4o\",\n  tools: [\n    /* ... */\n  ],\n  middleware: [dynamicPromptMiddleware, loggingMiddleware],  // [!code highlight]\n  contextSchema,\n});\n\nconst result = await agent.invoke(\n  { messages: [{ role: \"user\", content: \"What's my name?\" }] },\n  { context: { userName: \"John Smith\" } }\n);\n\n```\n\n***\n\n<Callout icon=\"pen-to-square\" iconType=\"regular\">\n  [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/runtime.mdx)\n</Callout>\n\n<Tip icon=\"terminal\" iconType=\"regular\">\n  [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for real-time answers.\n</Tip>",
  "content_length": 5503
}