{
  "title": "Token Verification",
  "source_url": "https://gofastmcp.com/servers/auth/token-verification",
  "content": "Protect your server by validating bearer tokens issued by external systems.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.11.0\" />\n\nToken verification enables your FastMCP server to validate bearer tokens issued by external systems without participating in user authentication flows. Your server acts as a pure resource server, focusing on token validation and authorization decisions while delegating identity management to other systems in your infrastructure.\n\n<Note>\n  Token verification operates somewhat outside the formal MCP authentication flow, which expects OAuth-style discovery. It's best suited for internal systems, microservices architectures, or when you have full control over token generation and distribution.\n</Note>\n\n## Understanding Token Verification\n\nToken verification addresses scenarios where authentication responsibility is distributed across multiple systems. Your MCP server receives structured tokens containing identity and authorization information, validates their authenticity, and makes access control decisions based on their contents.\n\nThis pattern emerges naturally in microservices architectures where a central authentication service issues tokens that multiple downstream services validate independently. It also works well when integrating MCP servers into existing systems that already have established token-based authentication mechanisms.\n\n### The Token Verification Model\n\nToken verification treats your MCP server as a resource server in OAuth terminology. The key insight is that token validation and token issuance are separate concerns that can be handled by different systems.\n\n**Token Issuance**: Another system (API gateway, authentication service, or identity provider) handles user authentication and creates signed tokens containing identity and permission information.\n\n**Token Validation**: Your MCP server receives these tokens, verifies their authenticity using cryptographic signatures, and extracts authorization information from their claims.\n\n**Access Control**: Based on token contents, your server determines what resources, tools, and prompts the client can access.\n\nThis separation allows your MCP server to focus on its core functionality while leveraging existing authentication infrastructure. The token acts as a portable proof of identity that travels with each request.\n\n### Token Security Considerations\n\nToken-based authentication relies on cryptographic signatures to ensure token integrity. Your MCP server validates tokens using public keys corresponding to the private keys used for token creation. This asymmetric approach means your server never needs access to signing secrets.\n\nToken validation must address several security requirements: signature verification ensures tokens haven't been tampered with, expiration checking prevents use of stale tokens, and audience validation ensures tokens intended for your server aren't accepted by other systems.\n\nThe challenge in MCP environments is that clients need to obtain valid tokens before making requests, but the MCP protocol doesn't provide built-in discovery mechanisms for token endpoints. Clients must obtain tokens through separate channels or prior configuration.\n\n## TokenVerifier Class\n\nFastMCP provides the `TokenVerifier` class to handle token validation complexity while remaining flexible about token sources and validation strategies.\n\n`TokenVerifier` focuses exclusively on token validation without providing OAuth discovery metadata. This makes it ideal for internal systems where clients already know how to obtain tokens, or for microservices that trust tokens from known issuers.\n\nThe class validates token signatures, checks expiration timestamps, and extracts authorization information from token claims. It supports various token formats and validation strategies while maintaining a consistent interface for authorization decisions.\n\nYou can subclass `TokenVerifier` to implement custom validation logic for specialized token formats or validation requirements. The base class handles common patterns while allowing extension for unique use cases.\n\n## JWT Token Verification\n\nJSON Web Tokens (JWTs) represent the most common token format for modern applications. FastMCP's `JWTVerifier` validates JWTs using industry-standard cryptographic techniques and claim validation.\n\n### JWKS Endpoint Integration\n\nJWKS endpoint integration provides the most flexible approach for production systems. The verifier automatically fetches public keys from a JSON Web Key Set endpoint, enabling automatic key rotation without server configuration changes.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth.providers.jwt import JWTVerifier\n\n# Configure JWT verification against your identity provider\nverifier = JWTVerifier(\n    jwks_uri=\"https://auth.yourcompany.com/.well-known/jwks.json\",\n    issuer=\"https://auth.yourcompany.com\",\n    audience=\"mcp-production-api\"\n)\n\nmcp = FastMCP(name=\"Protected API\", auth=verifier)\n```\n\nThis configuration creates a server that validates JWTs issued by `auth.yourcompany.com`. The verifier periodically fetches public keys from the JWKS endpoint and validates incoming tokens against those keys. Only tokens with the correct issuer and audience claims will be accepted.\n\nThe `issuer` parameter ensures tokens come from your trusted authentication system, while `audience` validation prevents tokens intended for other services from being accepted by your MCP server.\n\n### Symmetric Key Verification (HMAC)\n\nSymmetric key verification uses a shared secret for both signing and validation, making it ideal for internal microservices and trusted environments where the same secret can be securely distributed to both token issuers and validators.\n\nThis approach is commonly used in microservices architectures where services share a secret key, or when your authentication service and MCP server are both managed by the same organization. The HMAC algorithms (HS256, HS384, HS512) provide strong security when the shared secret is properly managed.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth.providers.jwt import JWTVerifier\n\n# Use a shared secret for symmetric key verification\nverifier = JWTVerifier(\n    public_key=\"your-shared-secret-key-minimum-32-chars\",  # Despite the name, this accepts symmetric secrets\n    issuer=\"internal-auth-service\",\n    audience=\"mcp-internal-api\",\n    algorithm=\"HS256\"  # or HS384, HS512 for stronger security\n)\n\nmcp = FastMCP(name=\"Internal API\", auth=verifier)\n```\n\nThe verifier will validate tokens signed with the same secret using the specified HMAC algorithm. This approach offers several advantages for internal systems:\n\n* **Simplicity**: No key pair management or certificate distribution\n* **Performance**: HMAC operations are typically faster than RSA\n* **Compatibility**: Works well with existing microservice authentication patterns\n\n<Note>\n  The parameter is named `public_key` for backwards compatibility, but when using HMAC algorithms (HS256/384/512), it accepts the symmetric secret string.\n</Note>\n\n<Warning>\n  **Security Considerations for Symmetric Keys:**\n\n  * Use a strong, randomly generated secret (minimum 32 characters recommended)\n  * Never expose the secret in logs, error messages, or version control\n  * Implement secure key distribution and rotation mechanisms\n  * Consider using asymmetric keys (RSA/ECDSA) for external-facing APIs\n</Warning>\n\n### Static Public Key Verification\n\nStatic public key verification works when you have a fixed RSA or ECDSA signing key and don't need automatic key rotation. This approach is primarily useful for development environments or controlled deployments where JWKS endpoints aren't available.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth.providers.jwt import JWTVerifier\n\n# Use a static public key for token verification\npublic_key_pem = \"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...\n-----END PUBLIC KEY-----\"\"\"\n\nverifier = JWTVerifier(\n    public_key=public_key_pem,\n    issuer=\"https://auth.yourcompany.com\",\n    audience=\"mcp-production-api\"\n)\n\nmcp = FastMCP(name=\"Protected API\", auth=verifier)\n```\n\nThis configuration validates tokens using a specific RSA or ECDSA public key. The key must correspond to the private key used by your token issuer. While less flexible than JWKS endpoints, this approach can be useful in development environments or when testing with fixed keys.\n\n## Opaque Token Verification\n\nMany authorization servers issue opaque tokens rather than self-contained JWTs. Opaque tokens are random strings that carry no information themselves - the authorization server maintains their state and validation requires querying the server. FastMCP supports opaque token validation through OAuth 2.0 Token Introspection (RFC 7662).\n\n### Understanding Opaque Tokens\n\nOpaque tokens differ fundamentally from JWTs in their verification model. Where JWTs carry signed claims that can be validated locally, opaque tokens require network calls to the issuing authorization server for validation. The authorization server maintains token state and can revoke tokens immediately, providing stronger security guarantees for sensitive operations.\n\nThis approach trades performance (network latency on each validation) for security and flexibility. Authorization servers can revoke opaque tokens instantly, implement complex authorization logic, and maintain detailed audit logs of token usage. Many enterprise OAuth providers default to opaque tokens for these security advantages.\n\n### Token Introspection Protocol\n\nRFC 7662 standardizes how resource servers validate opaque tokens. The protocol defines an introspection endpoint where resource servers authenticate using client credentials and receive token metadata including active status, scopes, expiration, and subject identity.\n\nFastMCP implements this protocol through the `IntrospectionTokenVerifier` class, handling authentication, request formatting, and response parsing according to the specification.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth.providers.introspection import IntrospectionTokenVerifier\n\n# Configure introspection with your OAuth provider\nverifier = IntrospectionTokenVerifier(\n    introspection_url=\"https://auth.yourcompany.com/oauth/introspect\",\n    client_id=\"mcp-resource-server\",\n    client_secret=\"your-client-secret\",\n    required_scopes=[\"api:read\", \"api:write\"]\n)\n\nmcp = FastMCP(name=\"Protected API\", auth=verifier)\n```\n\nThe verifier authenticates to the introspection endpoint using HTTP Basic Auth with your client credentials. When a request arrives with a bearer token, FastMCP queries the introspection endpoint to determine if the token is active and has sufficient scopes.\n\n## Development and Testing\n\nDevelopment environments often need simpler token management without the complexity of full JWT infrastructure. FastMCP provides tools specifically designed for these scenarios.\n\n### Static Token Verification\n\nStatic token verification enables rapid development by accepting predefined tokens with associated claims. This approach eliminates the need for token generation infrastructure during development and testing.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth.providers.jwt import StaticTokenVerifier\n\n# Define development tokens and their associated claims\nverifier = StaticTokenVerifier(\n    tokens={\n        \"dev-alice-token\": {\n            \"client_id\": \"alice@company.com\",\n            \"scopes\": [\"read:data\", \"write:data\", \"admin:users\"]\n        },\n        \"dev-guest-token\": {\n            \"client_id\": \"guest-user\",\n            \"scopes\": [\"read:data\"]\n        }\n    },\n    required_scopes=[\"read:data\"]\n)\n\nmcp = FastMCP(name=\"Development Server\", auth=verifier)\n```\n\nClients can now authenticate using `Authorization: Bearer dev-alice-token` headers. The server will recognize the token and load the associated claims for authorization decisions. This approach enables immediate development without external dependencies.\n\n<Warning>\n  Static token verification stores tokens as plain text and should never be used in production environments. It's designed exclusively for development and testing scenarios.\n</Warning>\n\n### Debug/Custom Token Verification\n\n<VersionBadge version=\"2.13.1\" />\n\nThe `DebugTokenVerifier` provides maximum flexibility for testing and special cases where standard token verification isn't applicable. It delegates validation to a user-provided callable, making it useful for prototyping, testing scenarios, or handling opaque tokens without introspection endpoints.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth.providers.debug import DebugTokenVerifier\n\n# Accept all tokens (useful for rapid development)\nverifier = DebugTokenVerifier()\n\nmcp = FastMCP(name=\"Development Server\", auth=verifier)\n```\n\nBy default, `DebugTokenVerifier` accepts any non-empty token as valid. This eliminates authentication barriers during early development, allowing you to focus on core functionality before adding security.\n\nFor more controlled testing, provide custom validation logic:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.auth.providers.debug import DebugTokenVerifier\n\n# Synchronous validation - check token prefix\nverifier = DebugTokenVerifier(\n    validate=lambda token: token.startswith(\"dev-\"),\n    client_id=\"development-client\",\n    scopes=[\"read\", \"write\"]\n)\n\nmcp = FastMCP(name=\"Development Server\", auth=verifier)\n```\n\nThe validation callable can also be async, enabling database lookups or external service calls:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.auth.providers.debug import DebugTokenVerifier\n\n# Asynchronous validation - check against cache\nasync def validate_token(token: str) -> bool:\n    # Check if token exists in Redis, database, etc.\n    return await redis.exists(f\"valid_tokens:{token}\")\n\nverifier = DebugTokenVerifier(\n    validate=validate_token,\n    client_id=\"api-client\",\n    scopes=[\"api:access\"]\n)\n\nmcp = FastMCP(name=\"Custom API\", auth=verifier)\n```\n\n**Use Cases:**\n\n* **Testing**: Accept any token during integration tests without setting up token infrastructure\n* **Prototyping**: Quickly validate concepts without authentication complexity\n* **Opaque tokens without introspection**: When you have tokens from an IDP that provides no introspection endpoint, and you're willing to accept tokens without validation (validation happens later at the upstream service)\n* **Custom token formats**: Implement validation for non-standard token formats or legacy systems\n\n<Warning>\n  `DebugTokenVerifier` bypasses standard security checks. Only use in controlled environments (development, testing) or when you fully understand the security implications. For production, use proper JWT or introspection-based verification.\n</Warning>\n\n### Test Token Generation\n\nTest token generation helps when you need to test JWT verification without setting up complete identity infrastructure. FastMCP includes utilities for generating test key pairs and signed tokens.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.auth.providers.jwt import JWTVerifier, RSAKeyPair\n\n# Generate a key pair for testing\nkey_pair = RSAKeyPair.generate()\n\n# Configure your server with the public key\nverifier = JWTVerifier(\n    public_key=key_pair.public_key,\n    issuer=\"https://test.yourcompany.com\",\n    audience=\"test-mcp-server\"\n)\n\n# Generate a test token using the private key\ntest_token = key_pair.create_token(\n    subject=\"test-user-123\",\n    issuer=\"https://test.yourcompany.com\", \n    audience=\"test-mcp-server\",\n    scopes=[\"read\", \"write\", \"admin\"]\n)\n\nprint(f\"Test token: {test_token}\")\n```\n\nThis pattern enables comprehensive testing of JWT validation logic without depending on external token issuers. The generated tokens are cryptographically valid and will pass all standard JWT validation checks.\n\n## Environment Configuration\n\n<VersionBadge version=\"2.12.1\" />\n\nFastMCP supports both programmatic and environment-based configuration for token verification, enabling flexible deployment across different environments.\n\nEnvironment-based configuration separates authentication settings from application code, following twelve-factor app principles and simplifying deployment pipelines.\n\n```bash  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Enable JWT verification\nexport FASTMCP_SERVER_AUTH=fastmcp.server.auth.providers.jwt.JWTVerifier\n\n# For asymmetric verification with JWKS endpoint:\nexport FASTMCP_SERVER_AUTH_JWT_JWKS_URI=\"https://auth.company.com/.well-known/jwks.json\"\nexport FASTMCP_SERVER_AUTH_JWT_ISSUER=\"https://auth.company.com\"\nexport FASTMCP_SERVER_AUTH_JWT_AUDIENCE=\"mcp-production-api\"\nexport FASTMCP_SERVER_AUTH_JWT_REQUIRED_SCOPES=\"read:data,write:data\"\n\n# OR for symmetric key verification (HMAC):\nexport FASTMCP_SERVER_AUTH_JWT_PUBLIC_KEY=\"your-shared-secret-key-minimum-32-chars\"\nexport FASTMCP_SERVER_AUTH_JWT_ALGORITHM=\"HS256\"  # or HS384, HS512\nexport FASTMCP_SERVER_AUTH_JWT_ISSUER=\"internal-auth-service\"\nexport FASTMCP_SERVER_AUTH_JWT_AUDIENCE=\"mcp-internal-api\"\n```\n\nWith these environment variables configured, your FastMCP server automatically enables JWT verification:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\n# Authentication automatically configured from environment\nmcp = FastMCP(name=\"Production API\")\n```\n\nThis approach enables the same codebase to run across development, staging, and production environments with different authentication requirements. Development might use static tokens while production uses JWT verification, all controlled through environment configuration.",
  "content_length": 18491
}