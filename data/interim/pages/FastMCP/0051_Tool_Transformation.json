{
  "title": "Tool Transformation",
  "source_url": "https://gofastmcp.com/patterns/tool-transformation",
  "content": "Create enhanced tool variants with modified schemas, argument mappings, and custom behavior.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.8.0\" />\n\nTool transformation allows you to create new, enhanced tools from existing ones. This powerful feature enables you to adapt tools for different contexts, simplify complex interfaces, or add custom logic without duplicating code.\n\n## Why Transform Tools?\n\nOften, an existing tool is *almost* perfect for your use case, but it might have:\n\n* A confusing description (or no description at all).\n* Argument names or descriptions that are not intuitive for an LLM (e.g., `q` instead of `query`).\n* Unnecessary parameters that you want to hide from the LLM.\n* A need for input validation before the original tool is called.\n* A need to modify or format the tool's output.\n\nInstead of rewriting the tool from scratch, you can **transform** it to fit your needs.\n\n## Basic Transformation\n\nThe primary way to create a transformed tool is with the `Tool.from_tool()` class method. At its simplest, you can use it to change a tool's top-level metadata like its `name`, `description`, or `tags`.\n\nIn the following simple example, we take a generic `search` tool and adjust its name and description to help an LLM client better understand its purpose.\n\n```python {13-21} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.tools import Tool\n\nmcp = FastMCP()\n\n# The original, generic tool\n@mcp.tool\ndef search(query: str, category: str = \"all\") -> list[dict]:\n    \"\"\"Searches for items in the database.\"\"\"\n    return database.search(query, category)\n\n# Create a more domain-specific version by changing its metadata\nproduct_search_tool = Tool.from_tool(\n    search,\n    name=\"find_products\",\n    description=\"\"\"\n        Search for products in the e-commerce catalog. \n        Use this when customers ask about finding specific items, \n        checking availability, or browsing product categories.\n        \"\"\",\n)\n\nmcp.add_tool(product_search_tool)\n```\n\n<Tip>\n  When you transform a tool, the original tool remains registered on the server. To avoid confusing an LLM with two similar tools, you can disable the original one:\n\n  ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from fastmcp import FastMCP\n  from fastmcp.tools import Tool\n\n  mcp = FastMCP()\n\n  # The original, generic tool\n  @mcp.tool\n  def search(query: str, category: str = \"all\") -> list[dict]:\n      ...\n\n  # Create a more domain-specific version\n  product_search_tool = Tool.from_tool(search, ...)\n  mcp.add_tool(product_search_tool)\n\n  # Disable the original tool\n  search.disable()\n  ```\n</Tip>\n\nNow, clients see a tool named `find_products` with a clear, domain-specific purpose and relevant tags, even though it still uses the original generic `search` function's logic.\n\n### Parameters\n\nThe `Tool.from_tool()` class method is the primary way to create a transformed tool. It takes the following parameters:\n\n* `tool`: The tool to transform. This is the only required argument.\n* `name`: An optional name for the new tool.\n* `description`: An optional description for the new tool.\n* `transform_args`: A dictionary of `ArgTransform` objects, one for each argument you want to modify.\n* `transform_fn`: An optional function that will be called instead of the parent tool's logic.\n* `output_schema`: Control output schema and structured outputs (see [Output Schema Control](#output-schema-control)).\n* `tags`: An optional set of tags for the new tool.\n* `annotations`: An optional set of `ToolAnnotations` for the new tool.\n* `serializer`: An optional function that will be called to serialize the result of the new tool.\n* `meta`: Control meta information for the tool. Use `None` to remove meta, any dict to set meta, or leave unset to inherit from parent.\n\nThe result is a new `TransformedTool` object that wraps the parent tool and applies the transformations you specify. You can add this tool to your MCP server using its `add_tool()` method.\n\n## Modifying Arguments\n\nTo modify a tool's parameters, provide a dictionary of `ArgTransform` objects to the `transform_args` parameter of `Tool.from_tool()`. Each key is the name of the *original* argument you want to modify.\n\n<Tip>\n  You only need to provide a `transform_args` entry for arguments you want to modify. All other arguments will be passed through unchanged.\n</Tip>\n\n### The ArgTransform Class\n\nTo modify an argument, you need to create an `ArgTransform` object. This object has the following parameters:\n\n* `name`: The new name for the argument.\n* `description`: The new description for the argument.\n* `default`: The new default value for the argument.\n* `default_factory`: A function that will be called to generate a default value for the argument. This is useful for arguments that need to be generated for each tool call, such as timestamps or unique IDs.\n* `hide`: Whether to hide the argument from the LLM.\n* `required`: Whether the argument is required, usually used to make an optional argument be required instead.\n* `type`: The new type for the argument.\n\n<Tip>\n  Certain combinations of parameters are not allowed. For example, you can only use `default_factory` with `hide=True`, because dynamic defaults cannot be represented in a JSON schema for the client. You can only set required=True for arguments that do not declare a default value.\n</Tip>\n\n### Descriptions\n\nBy far the most common reason to transform a tool, after its own description, is to improve its argument descriptions. A good description is crucial for helping an LLM understand how to use a parameter correctly. This is especially important when wrapping tools from external APIs, whose argument descriptions may be missing or written for developers, not LLMs.\n\nIn this example, we add a helpful description to the `user_id` argument:\n\n```python {16-19} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.tools import Tool\nfrom fastmcp.tools.tool_transform import ArgTransform\n\nmcp = FastMCP()\n\n@mcp.tool\ndef find_user(user_id: str):\n    \"\"\"Finds a user by their ID.\"\"\"\n    ...\n\nnew_tool = Tool.from_tool(\n    find_user,\n    transform_args={\n        \"user_id\": ArgTransform(\n            description=(\n                \"The unique identifier for the user, \"\n                \"usually in the format 'usr-xxxxxxxx'.\"\n            )\n        )\n    }\n)\n```\n\n### Names\n\nAt times, you may want to rename an argument to make it more intuitive for an LLM.\n\nFor example, in the following example, we take a generic `q` argument and expand it to `search_query`:\n\n```python {15} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.tools import Tool\nfrom fastmcp.tools.tool_transform import ArgTransform\n\nmcp = FastMCP()\n\n@mcp.tool\ndef search(q: str):\n    \"\"\"Searches for items in the database.\"\"\"\n    return database.search(q)\n\nnew_tool = Tool.from_tool(\n    search,\n    transform_args={\n        \"q\": ArgTransform(name=\"search_query\")\n    }\n)\n```\n\n### Default Values\n\nYou can update the default value for any argument using the `default` parameter. Here, we change the default value of the `y` argument to 10:\n\n```python{15}  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.tools import Tool\nfrom fastmcp.tools.tool_transform import ArgTransform\n\nmcp = FastMCP()\n\n@mcp.tool\ndef add(x: int, y: int) -> int:\n    \"\"\"Adds two numbers.\"\"\"\n    return x + y\n\nnew_tool = Tool.from_tool(\n    add,\n    transform_args={\n        \"y\": ArgTransform(default=10)\n    }\n)\n```\n\nDefault values are especially useful in combination with hidden arguments.\n\n### Hiding Arguments\n\nSometimes a tool requires arguments that shouldn't be exposed to the LLM, such as API keys, configuration flags, or internal IDs. You can hide these parameters using `hide=True`. Note that you can only hide arguments that have a default value (or for which you provide a new default), because the LLM can't provide a value at call time.\n\n<Tip>\n  To pass a constant value to the parent tool, combine `hide=True` with `default=<value>`.\n</Tip>\n\n```python {19-20} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport os\nfrom fastmcp import FastMCP\nfrom fastmcp.tools import Tool\nfrom fastmcp.tools.tool_transform import ArgTransform\n\nmcp = FastMCP()\n\n@mcp.tool\ndef send_email(to: str, subject: str, body: str, api_key: str):\n    \"\"\"Sends an email.\"\"\"\n    ...\n    \n# Create a simplified version that hides the API key\nnew_tool = Tool.from_tool(\n    send_email,\n    name=\"send_notification\",\n    transform_args={\n        \"api_key\": ArgTransform(\n            hide=True, \n            default=os.environ.get(\"EMAIL_API_KEY\"),\n        )\n    }\n)\n```\n\nThe LLM now only sees the `to`, `subject`, and `body` parameters. The `api_key` is supplied automatically from an environment variable.\n\nFor values that must be generated for each tool call (like timestamps or unique IDs), use `default_factory`, which is called with no arguments every time the tool is called. For example,\n\n```python {3-4} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\ntransform_args = {\n    'timestamp': ArgTransform(\n        hide=True,\n        default_factory=lambda: datetime.now(),\n    )\n}\n```\n\n<Warning>\n  `default_factory` can only be used with `hide=True`. This is because visible parameters need static defaults that can be represented in a JSON schema for the client.\n</Warning>\n\n### Meta Information\n\n<VersionBadge version=\"2.11.0\" />\n\nYou can control meta information on transformed tools using the `meta` parameter. Meta information is additional data about the tool that doesn't affect its functionality but can be used by clients for categorization, routing, or other purposes.\n\n```python {15-17} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.tools import Tool\n\nmcp = FastMCP()\n\n@mcp.tool\ndef analyze_data(data: str) -> dict:\n    \"\"\"Analyzes the provided data.\"\"\"\n    return {\"result\": f\"Analysis of {data}\"}\n\n# Add custom meta information\nenhanced_tool = Tool.from_tool(\n    analyze_data,\n    name=\"enhanced_analyzer\",\n    meta={\n        \"category\": \"analytics\",\n        \"priority\": \"high\",\n        \"requires_auth\": True\n    }\n)\n\nmcp.add_tool(enhanced_tool)\n```\n\nYou can also remove meta information entirely:\n\n```python {6} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Remove meta information from parent tool\nsimplified_tool = Tool.from_tool(\n    analyze_data,\n    name=\"simple_analyzer\", \n    meta=None  # Removes any meta information\n)\n```\n\nIf you don't specify the `meta` parameter, the transformed tool inherits the parent tool's meta information.\n\n### Required Values\n\nIn rare cases where you want to make an optional argument required, you can set `required=True`. This has no effect if the argument was already required.\n\n```python {3} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\ntransform_args = {\n    'user_id': ArgTransform(\n        required=True,\n    )\n}\n```\n\n## Modifying Tool Behavior\n\n<Warning>\n  With great power comes great responsibility. Modifying tool behavior is a very advanced feature.\n</Warning>\n\nIn addition to changing a tool's schema, advanced users can also modify its behavior. This is useful for adding validation logic, or for post-processing the tool's output.\n\nThe `from_tool()` method takes a `transform_fn` parameter, which is an async function that replaces the parent tool's logic and gives you complete control over the tool's execution.\n\n### The Transform Function\n\nThe `transform_fn` is an async function that **completely replaces** the parent tool's logic.\n\nCritically, the transform function's arguments are used to determine the new tool's final schema. Any arguments that are not already present in the parent tool schema OR the `transform_args` will be added to the new tool's schema. Note that when `transform_args` and your function have the same argument name, the `transform_args` metadata will take precedence, if provided.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync def my_custom_logic(user_input: str, max_length: int = 100) -> str:\n    # Your custom logic here - this completely replaces the parent tool\n    return f\"Custom result for: {user_input[:max_length]}\"\n\nTool.from_tool(transform_fn=my_custom_logic)\n```\n\n<Tip>\n  The name / docstring of the `transform_fn` are ignored. Only its arguments are used to determine the final schema.\n</Tip>\n\n### Calling the Parent Tool\n\nMost of the time, you don't want to completely replace the parent tool's behavior. Instead, you want to add validation, modify inputs, or post-process outputs while still leveraging the parent tool's core functionality. For this, FastMCP provides the special `forward()` and `forward_raw()` functions.\n\nBoth `forward()` and `forward_raw()` are async functions that let you call the parent tool from within your `transform_fn`:\n\n* **`forward()`** (recommended): Automatically handles argument mapping based on your `ArgTransform` configurations. Call it with the transformed argument names.\n* **`forward_raw()`**: Bypasses all transformation and calls the parent tool directly with its original argument names. This is rarely needed unless you're doing complex argument manipulation, perhaps without `arg_transforms`.\n\nThe most common transformation pattern is to validate (potentially renamed) arguments before calling the parent tool. Here's an example that validates that `x` and `y` are positive before calling the parent tool:\n\n<Tabs>\n  <Tab title=\"Using forward()\">\n    In the simplest case, your parent tool and your transform function have the same arguments. You can call `forward()` with the same argument names as the parent tool:\n\n    ```python {15} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    from fastmcp import FastMCP\n    from fastmcp.tools import Tool\n    from fastmcp.tools.tool_transform import forward\n\n    mcp = FastMCP()\n\n    @mcp.tool\n    def add(x: int, y: int) -> int:\n        \"\"\"Adds two numbers.\"\"\"\n        return x + y\n\n    async def ensure_positive(x: int, y: int) -> int:\n        if x <= 0 or y <= 0:\n            raise ValueError(\"x and y must be positive\")\n        return await forward(x=x, y=y)\n\n    new_tool = Tool.from_tool(\n        add,\n        transform_fn=ensure_positive,\n    )\n\n    mcp.add_tool(new_tool)\n    ```\n  </Tab>\n\n  <Tab title=\"Using forward() with renamed args\">\n    When your transformed tool has different argument names than the parent tool, you can call `forward()` with the renamed arguments and it will automatically map the arguments to the parent tool's arguments:\n\n    ```python {15, 20-23} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    from fastmcp import FastMCP\n    from fastmcp.tools import Tool\n    from fastmcp.tools.tool_transform import forward\n\n    mcp = FastMCP()\n\n    @mcp.tool\n    def add(x: int, y: int) -> int:\n        \"\"\"Adds two numbers.\"\"\"\n        return x + y\n\n    async def ensure_positive(a: int, b: int) -> int:\n        if a <= 0 or b <= 0:\n            raise ValueError(\"a and b must be positive\")\n        return await forward(a=a, b=b)\n\n    new_tool = Tool.from_tool(\n        add,\n        transform_fn=ensure_positive,\n        transform_args={\n            \"x\": ArgTransform(name=\"a\"),\n            \"y\": ArgTransform(name=\"b\"),\n        }\n    )\n\n    mcp.add_tool(new_tool)\n    ```\n  </Tab>\n\n  <Tab title=\"Using forward_raw()\">\n    Finally, you can use `forward_raw()` to bypass all argument mapping and call the parent tool directly with its original argument names.\n\n    ```python {15, 20-23} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    from fastmcp import FastMCP\n    from fastmcp.tools import Tool\n    from fastmcp.tools.tool_transform import forward\n\n    mcp = FastMCP()\n\n    @mcp.tool\n    def add(x: int, y: int) -> int:\n        \"\"\"Adds two numbers.\"\"\"\n        return x + y\n\n    async def ensure_positive(a: int, b: int) -> int:\n        if a <= 0 or b <= 0:\n            raise ValueError(\"a and b must be positive\")\n        return await forward_raw(x=a, y=b)\n\n    new_tool = Tool.from_tool(\n        add,\n        transform_fn=ensure_positive,\n        transform_args={\n            \"x\": ArgTransform(name=\"a\"),\n            \"y\": ArgTransform(name=\"b\"),\n        }\n    )\n\n    mcp.add_tool(new_tool)\n    ```\n  </Tab>\n</Tabs>\n\n### Passing Arguments with \\*\\*kwargs\n\nIf your `transform_fn` includes `**kwargs` in its signature, it will receive **all arguments from the parent tool after `ArgTransform` configurations have been applied**. This is powerful for creating flexible validation functions that don't require you to add every argument to the function signature.\n\nIn the following example, we wrap a parent tool that accepts two arguments `x` and `y`. These are renamed to `a` and `b` in the transformed tool, and the transform only validates `a`, passing the other argument through as `**kwargs`.\n\n```python {12, 15} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.tools import Tool\nfrom fastmcp.tools.tool_transform import forward, ArgTransform\n\nmcp = FastMCP()\n\n@mcp.tool\ndef add(x: int, y: int) -> int:\n    \"\"\"Adds two numbers.\"\"\"\n    return x + y\n\nasync def ensure_a_positive(a: int, **kwargs) -> int:\n    if a <= 0:\n        raise ValueError(\"a must be positive\")\n    return await forward(a=a, **kwargs)\n\nnew_tool = Tool.from_tool(\n    add,\n    transform_fn=ensure_a_positive,\n    transform_args={\n        \"x\": ArgTransform(name=\"a\"),\n        \"y\": ArgTransform(name=\"b\"),\n    }\n)\n\nmcp.add_tool(new_tool)\n```\n\n<Tip>\n  In the above example, `**kwargs` receives the renamed argument `b`, not the original argument `y`. It is therefore recommended to use with `forward()`, not `forward_raw()`.\n</Tip>\n\n## Modifying MCP Tools with MCPConfig\n\nWhen running MCP Servers under FastMCP with `MCPConfig`, you can also apply a subset of tool transformations\ndirectly in the MCPConfig json file.\n\n```json  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n{\n    \"mcpServers\": {\n        \"weather\": {\n            \"url\": \"https://weather.example.com/mcp\",\n            \"transport\": \"http\",\n            \"tools\": {\n                \"weather_get_forecast\": {\n                    \"name\": \"miami_weather\",\n                    \"description\": \"Get the weather for Miami\",\n                    \"meta\": {\n                        \"category\": \"weather\",\n                        \"location\": \"miami\"\n                    },\n                    \"arguments\": {\n                        \"city\": {\n                            \"name\": \"city\",\n                            \"default\": \"Miami\",\n                            \"hide\": True,\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nThe `tools` section is a dictionary of tool names to tool configurations. Each tool configuration is a\ndictionary of tool properties.\n\nSee the [MCPConfigTransport](/clients/transports#tool-transformation-with-fastmcp-and-mcpconfig) documentation for more details.\n\n## Output Schema Control\n\n<VersionBadge version=\"2.10.0\" />\n\nTransformed tools inherit output schemas from their parent by default, but you can control this behavior:\n\n**Inherit from Parent (Default)**\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nTool.from_tool(parent_tool, name=\"renamed_tool\")\n```\n\nThe transformed tool automatically uses the parent tool's output schema and structured output behavior.\n\n**Custom Output Schema**\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nTool.from_tool(parent_tool, output_schema={\n    \"type\": \"object\", \n    \"properties\": {\"status\": {\"type\": \"string\"}}\n})\n```\n\nProvide your own schema that differs from the parent. The tool must return data matching this schema.\n\n**Remove Output Schema**\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nTool.from_tool(parent_tool, output_schema=None)\n```\n\nRemoves the output schema declaration. Automatic structured content still works for object-like returns (dict, dataclass, Pydantic models) but primitive types won't be structured.\n\n**Full Control with Transform Functions**\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync def custom_output(**kwargs) -> ToolResult:\n    result = await forward(**kwargs)\n    return ToolResult(content=[...], structured_content={...})\n\nTool.from_tool(parent_tool, transform_fn=custom_output)\n```\n\nUse a transform function returning `ToolResult` for complete control over both content blocks and structured outputs.\n\n## Common Patterns\n\nTool transformation is a flexible feature that supports many powerful patterns. Here are a few common use cases to give you ideas.\n\n### Exposing Client Methods as Tools\n\nA powerful use case for tool transformation is exposing methods from existing Python clients (GitHub clients, API clients, database clients, etc.) directly as MCP tools. This pattern eliminates boilerplate wrapper functions and treats tools as annotations around client methods.\n\n**Without Tool Transformation**, you typically create wrapper functions that duplicate annotations:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync def get_repository(\n    owner: Annotated[str, \"The owner of the repository.\"],\n    repo: Annotated[str, \"The name of the repository.\"],\n) -> Repository:\n    \"\"\"Get basic information about a GitHub repository.\"\"\"\n    return await github_client.get_repository(owner=owner, repo=repo)\n```\n\n**With Tool Transformation**, you can wrap the client method directly:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.tools import Tool\nfrom fastmcp.tools.tool_transform import ArgTransform\n\nmcp = FastMCP(\"GitHub Tools\")\n\n# Wrap a client method directly as a tool\nget_repo_tool = Tool.from_tool(\n    tool=Tool.from_function(fn=github_client.get_repository),\n    description=\"Get basic information about a GitHub repository.\",\n    transform_args={\n        \"owner\": ArgTransform(description=\"The owner of the repository.\"),\n        \"repo\": ArgTransform(description=\"The name of the repository.\"),\n    }\n)\n\nmcp.add_tool(get_repo_tool)\n```\n\nThis pattern keeps the implementation in your client and treats the tool as an annotation layer, avoiding duplicate code.\n\n#### Hiding Client-Specific Arguments\n\nClient methods often have internal parameters (debug flags, auth tokens, rate limit settings) that shouldn't be exposed to LLMs. Use `hide=True` with a default value to handle these automatically:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nget_issues_tool = Tool.from_tool(\n    tool=Tool.from_function(fn=github_client.get_issues),\n    description=\"Get issues from a GitHub repository.\",\n    transform_args={\n        \"owner\": ArgTransform(description=\"The owner of the repository.\"),\n        \"repo\": ArgTransform(description=\"The name of the repository.\"),\n        \"limit\": ArgTransform(description=\"Maximum number of issues to return.\"),\n        # Hide internal parameters\n        \"include_debug_info\": ArgTransform(hide=True, default=False),\n        \"error_on_not_found\": ArgTransform(hide=True, default=True),\n    }\n)\n\nmcp.add_tool(get_issues_tool)\n```\n\nThe LLM only sees `owner`, `repo`, and `limit`. Internal parameters are supplied automatically.\n\n#### Reusable Argument Patterns\n\nWhen wrapping multiple client methods, you can define reusable argument transformations. This scales well for larger tool sets and keeps annotations consistent:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.tools import Tool\nfrom fastmcp.tools.tool_transform import ArgTransform\n\nmcp = FastMCP(\"GitHub Tools\")\n\n# Define reusable argument patterns\nOWNER_ARG = ArgTransform(description=\"The repository owner.\")\nREPO_ARG = ArgTransform(description=\"The repository name.\")\nLIMIT_ARG = ArgTransform(description=\"Maximum number of items to return.\")\nHIDE_ERROR = ArgTransform(hide=True, default=True)\n\ndef create_github_tools(client):\n    \"\"\"Create tools from GitHub client methods with shared argument patterns.\"\"\"\n\n    owner_repo_args = {\n        \"owner\": OWNER_ARG,\n        \"repo\": REPO_ARG,\n    }\n\n    error_args = {\n        \"error_on_not_found\": HIDE_ERROR,\n    }\n\n    return [\n        Tool.from_tool(\n            tool=Tool.from_function(fn=client.get_repository),\n            description=\"Get basic information about a GitHub repository.\",\n            transform_args={**owner_repo_args, **error_args}\n        ),\n        Tool.from_tool(\n            tool=Tool.from_function(fn=client.get_issue),\n            description=\"Get a specific issue from a repository.\",\n            transform_args={\n                **owner_repo_args,\n                \"issue_number\": ArgTransform(description=\"The issue number.\"),\n                \"limit_comments\": LIMIT_ARG,\n                **error_args,\n            }\n        ),\n        Tool.from_tool(\n            tool=Tool.from_function(fn=client.get_pull_request),\n            description=\"Get a specific pull request from a repository.\",\n            transform_args={\n                **owner_repo_args,\n                \"pull_request_number\": ArgTransform(description=\"The PR number.\"),\n                \"limit_comments\": LIMIT_ARG,\n                **error_args,\n            }\n        ),\n    ]\n\n# Add all tools to the server\nfor tool in create_github_tools(github_client):\n    mcp.add_tool(tool)\n```\n\nThis pattern provides several benefits:\n\n* **No duplicate implementation**: Logic stays in the client\n* **Consistent annotations**: Reusable argument patterns ensure consistency\n* **Easy maintenance**: Update the client, not wrapper functions\n* **Scalable**: Easily add new tools by wrapping additional client methods\n\n### Adapting Remote or Generated Tools\n\nThis is one of the most common reasons to use tool transformation. Tools from remote MCP servers (via a [proxy](/servers/proxy)) or generated from an [OpenAPI spec](/integrations/openapi) are often too generic for direct use by an LLM. You can use transformation to create a simpler, more intuitive version for your specific needs.\n\n### Chaining Transformations\n\nYou can chain transformations by using an already transformed tool as the parent for a new transformation. This lets you build up complex behaviors in layers, for example, first renaming arguments, and then adding validation logic to the renamed tool.\n\n### Context-Aware Tool Factories\n\nYou can write functions that act as \"factories,\" generating specialized versions of a tool for different contexts. For example, you could create a `get_my_data` tool that is specific to the currently logged-in user by hiding the `user_id` parameter and providing it automatically.",
  "content_length": 27180
}