{
  "title": "Resources & Templates",
  "source_url": "https://gofastmcp.com/servers/resources",
  "content": "Expose data sources and dynamic content generators to your MCP client.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span> \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\nResources represent data or files that an MCP client can read, and resource templates extend this concept by allowing clients to request dynamically generated resources based on parameters passed in the URI.\n\nFastMCP simplifies defining both static and dynamic resources, primarily using the `@mcp.resource` decorator.\n\n## What Are Resources?\n\nResources provide read-only access to data for the LLM or client application. When a client requests a resource URI:\n\n1. FastMCP finds the corresponding resource definition.\n2. If it's dynamic (defined by a function), the function is executed.\n3. The content (text, JSON, binary data) is returned to the client.\n\nThis allows LLMs to access files, database content, configuration, or dynamically generated information relevant to the conversation.\n\n## Resources\n\n### The `@resource` Decorator\n\nThe most common way to define a resource is by decorating a Python function. The decorator requires the resource's unique URI.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport json\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Basic dynamic resource returning a string\n@mcp.resource(\"resource://greeting\")\ndef get_greeting() -> str:\n    \"\"\"Provides a simple greeting message.\"\"\"\n    return \"Hello from FastMCP Resources!\"\n\n# Resource returning JSON data (dict is auto-serialized)\n@mcp.resource(\"data://config\")\ndef get_config() -> dict:\n    \"\"\"Provides application configuration as JSON.\"\"\"\n    return {\n        \"theme\": \"dark\",\n        \"version\": \"1.2.0\",\n        \"features\": [\"tools\", \"resources\"],\n    }\n```\n\n**Key Concepts:**\n\n* **URI:** The first argument to `@resource` is the unique URI (e.g., `\"resource://greeting\"`) clients use to request this data.\n* **Lazy Loading:** The decorated function (`get_greeting`, `get_config`) is only executed when a client specifically requests that resource URI via `resources/read`.\n* **Inferred Metadata:** By default:\n  * Resource Name: Taken from the function name (`get_greeting`).\n  * Resource Description: Taken from the function's docstring.\n\n#### Decorator Arguments\n\nYou can customize the resource's properties using arguments in the `@mcp.resource` decorator:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Example specifying metadata\n@mcp.resource(\n    uri=\"data://app-status\",      # Explicit URI (required)\n    name=\"ApplicationStatus\",     # Custom name\n    description=\"Provides the current status of the application.\", # Custom description\n    mime_type=\"application/json\", # Explicit MIME type\n    tags={\"monitoring\", \"status\"}, # Categorization tags\n    meta={\"version\": \"2.1\", \"team\": \"infrastructure\"}  # Custom metadata\n)\ndef get_application_status() -> dict:\n    \"\"\"Internal function description (ignored if description is provided above).\"\"\"\n    return {\"status\": \"ok\", \"uptime\": 12345, \"version\": mcp.settings.version} # Example usage\n```\n\n<Card icon=\"code\" title=\"@resource Decorator Arguments\">\n  <ParamField body=\"uri\" type=\"str\" required>\n    The unique identifier for the resource\n  </ParamField>\n\n  <ParamField body=\"name\" type=\"str | None\">\n    A human-readable name. If not provided, defaults to function name\n  </ParamField>\n\n  <ParamField body=\"description\" type=\"str | None\">\n    Explanation of the resource. If not provided, defaults to docstring\n  </ParamField>\n\n  <ParamField body=\"mime_type\" type=\"str | None\">\n    Specifies the content type. FastMCP often infers a default like `text/plain` or `application/json`, but explicit is better for non-text types\n  </ParamField>\n\n  <ParamField body=\"tags\" type=\"set[str] | None\">\n    A set of strings used to categorize the resource. These can be used by the server and, in some cases, by clients to filter or group available resources.\n  </ParamField>\n\n  <ParamField body=\"enabled\" type=\"bool\" default=\"True\">\n    A boolean to enable or disable the resource. See [Disabling Resources](#disabling-resources) for more information\n  </ParamField>\n\n  <ParamField body=\"icons\" type=\"list[Icon] | None\">\n    <VersionBadge version=\"2.14.0\" />\n\n    Optional list of icon representations for this resource or template. See [Icons](/servers/icons) for detailed examples\n  </ParamField>\n\n  <ParamField body=\"annotations\" type=\"Annotations | dict | None\">\n    An optional `Annotations` object or dictionary to add additional metadata about the resource.\n\n    <Expandable title=\"Annotations attributes\">\n      <ParamField body=\"readOnlyHint\" type=\"bool | None\">\n        If true, the resource is read-only and does not modify its environment.\n      </ParamField>\n\n      <ParamField body=\"idempotentHint\" type=\"bool | None\">\n        If true, reading the resource repeatedly will have no additional effect on its environment.\n      </ParamField>\n    </Expandable>\n  </ParamField>\n\n  <ParamField body=\"meta\" type=\"dict[str, Any] | None\">\n    <VersionBadge version=\"2.11.0\" />\n\n    Optional meta information about the resource. This data is passed through to the MCP client as the `_meta` field of the client-side resource object and can be used for custom metadata, versioning, or other application-specific purposes.\n  </ParamField>\n</Card>\n\n### Return Values\n\nFastMCP automatically converts your function's return value into the appropriate MCP resource content:\n\n* **`str`**: Sent as `TextResourceContents` (with `mime_type=\"text/plain\"` by default).\n* **`dict`, `list`, `pydantic.BaseModel`**: Automatically serialized to a JSON string and sent as `TextResourceContents` (with `mime_type=\"application/json\"` by default).\n* **`bytes`**: Base64 encoded and sent as `BlobResourceContents`. You should specify an appropriate `mime_type` (e.g., `\"image/png\"`, `\"application/octet-stream\"`).\n* **`None`**: Results in an empty resource content list being returned.\n\n### Disabling Resources\n\n<VersionBadge version=\"2.8.0\" />\n\nYou can control the visibility and availability of resources and templates by enabling or disabling them. Disabled resources will not appear in the list of available resources or templates, and attempting to read a disabled resource will result in an \"Unknown resource\" error.\n\nBy default, all resources are enabled. You can disable a resource upon creation using the `enabled` parameter in the decorator:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.resource(\"data://secret\", enabled=False)\ndef get_secret_data():\n    \"\"\"This resource is currently disabled.\"\"\"\n    return \"Secret data\"\n```\n\nYou can also toggle a resource's state programmatically after it has been created:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.resource(\"data://config\")\ndef get_config(): return {\"version\": 1}\n\n# Disable and re-enable the resource\nget_config.disable()\nget_config.enable()\n```\n\n### Accessing MCP Context\n\n<VersionBadge version=\"2.2.5\" />\n\nResources and resource templates can access additional MCP information and features through the `Context` object. To access it, add a parameter to your resource function with a type annotation of `Context`:\n\n```python {6, 14} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"DataServer\")\n\n@mcp.resource(\"resource://system-status\")\nasync def get_system_status(ctx: Context) -> dict:\n    \"\"\"Provides system status information.\"\"\"\n    return {\n        \"status\": \"operational\",\n        \"request_id\": ctx.request_id\n    }\n\n@mcp.resource(\"resource://{name}/details\")\nasync def get_details(name: str, ctx: Context) -> dict:\n    \"\"\"Get details for a specific name.\"\"\"\n    return {\n        \"name\": name,\n        \"accessed_at\": ctx.request_id\n    }\n```\n\nFor full documentation on the Context object and all its capabilities, see the [Context documentation](/servers/context).\n\n### Async Resources\n\nUse `async def` for resource functions that perform I/O operations (e.g., reading from a database or network) to avoid blocking the server.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport aiofiles\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n@mcp.resource(\"file:///app/data/important_log.txt\", mime_type=\"text/plain\")\nasync def read_important_log() -> str:\n    \"\"\"Reads content from a specific log file asynchronously.\"\"\"\n    try:\n        async with aiofiles.open(\"/app/data/important_log.txt\", mode=\"r\") as f:\n            content = await f.read()\n        return content\n    except FileNotFoundError:\n        return \"Log file not found.\"\n```\n\n### Resource Classes\n\nWhile `@mcp.resource` is ideal for dynamic content, you can directly register pre-defined resources (like static files or simple text) using `mcp.add_resource()` and concrete `Resource` subclasses.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom pathlib import Path\nfrom fastmcp import FastMCP\nfrom fastmcp.resources import FileResource, TextResource, DirectoryResource\n\nmcp = FastMCP(name=\"DataServer\")\n\n# 1. Exposing a static file directly\nreadme_path = Path(\"./README.md\").resolve()\nif readme_path.exists():\n    # Use a file:// URI scheme\n    readme_resource = FileResource(\n        uri=f\"file://{readme_path.as_posix()}\",\n        path=readme_path, # Path to the actual file\n        name=\"README File\",\n        description=\"The project's README.\",\n        mime_type=\"text/markdown\",\n        tags={\"documentation\"}\n    )\n    mcp.add_resource(readme_resource)\n\n# 2. Exposing simple, predefined text\nnotice_resource = TextResource(\n    uri=\"resource://notice\",\n    name=\"Important Notice\",\n    text=\"System maintenance scheduled for Sunday.\",\n    tags={\"notification\"}\n)\nmcp.add_resource(notice_resource)\n\n# 3. Using a custom key different from the URI\nspecial_resource = TextResource(\n    uri=\"resource://common-notice\",\n    name=\"Special Notice\",\n    text=\"This is a special notice with a custom storage key.\",\n)\nmcp.add_resource(special_resource, key=\"resource://custom-key\")\n\n# 4. Exposing a directory listing\ndata_dir_path = Path(\"./app_data\").resolve()\nif data_dir_path.is_dir():\n    data_listing_resource = DirectoryResource(\n        uri=\"resource://data-files\",\n        path=data_dir_path, # Path to the directory\n        name=\"Data Directory Listing\",\n        description=\"Lists files available in the data directory.\",\n        recursive=False # Set to True to list subdirectories\n    )\n    mcp.add_resource(data_listing_resource) # Returns JSON list of files\n```\n\n**Common Resource Classes:**\n\n* `TextResource`: For simple string content.\n* `BinaryResource`: For raw `bytes` content.\n* `FileResource`: Reads content from a local file path. Handles text/binary modes and lazy reading.\n* `HttpResource`: Fetches content from an HTTP(S) URL (requires `httpx`).\n* `DirectoryResource`: Lists files in a local directory (returns JSON).\n* (`FunctionResource`: Internal class used by `@mcp.resource`).\n\nUse these when the content is static or sourced directly from a file/URL, bypassing the need for a dedicated Python function.\n\n#### Custom Resource Keys\n\n<VersionBadge version=\"2.2.0\" />\n\nWhen adding resources directly with `mcp.add_resource()`, you can optionally provide a custom storage key:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Creating a resource with standard URI as the key\nresource = TextResource(uri=\"resource://data\")\nmcp.add_resource(resource)  # Will be stored and accessed using \"resource://data\"\n\n# Creating a resource with a custom key\nspecial_resource = TextResource(uri=\"resource://special-data\")\nmcp.add_resource(special_resource, key=\"internal://data-v2\")  # Will be stored and accessed using \"internal://data-v2\"\n```\n\nNote that this parameter is only available when using `add_resource()` directly and not through the `@resource` decorator, as URIs are provided explicitly when using the decorator.\n\n### Notifications\n\n<VersionBadge version=\"2.9.1\" />\n\nFastMCP automatically sends `notifications/resources/list_changed` notifications to connected clients when resources or templates are added, enabled, or disabled. This allows clients to stay up-to-date with the current resource set without manually polling for changes.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.resource(\"data://example\")\ndef example_resource() -> str:\n    return \"Hello!\"\n\n# These operations trigger notifications:\nmcp.add_resource(example_resource)  # Sends resources/list_changed notification\nexample_resource.disable()          # Sends resources/list_changed notification  \nexample_resource.enable()           # Sends resources/list_changed notification\n```\n\nNotifications are only sent when these operations occur within an active MCP request context (e.g., when called from within a tool or other MCP operation). Operations performed during server initialization do not trigger notifications.\n\nClients can handle these notifications using a [message handler](/clients/messages) to automatically refresh their resource lists or update their interfaces.\n\n### Annotations\n\n<VersionBadge version=\"2.11.0\" />\n\nFastMCP allows you to add specialized metadata to your resources through annotations. These annotations communicate how resources behave to client applications without consuming token context in LLM prompts.\n\nAnnotations serve several purposes in client applications:\n\n* Indicating whether resources are read-only or may have side effects\n* Describing the safety profile of resources (idempotent vs. non-idempotent)\n* Helping clients optimize caching and access patterns\n\nYou can add annotations to a resource using the `annotations` parameter in the `@mcp.resource` decorator:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.resource(\n    \"data://config\",\n    annotations={\n        \"readOnlyHint\": True,\n        \"idempotentHint\": True\n    }\n)\ndef get_config() -> dict:\n    \"\"\"Get application configuration.\"\"\"\n    return {\"version\": \"1.0\", \"debug\": False}\n```\n\nFastMCP supports these standard annotations:\n\n| Annotation       | Type    | Default | Purpose                                                           |\n| :--------------- | :------ | :------ | :---------------------------------------------------------------- |\n| `readOnlyHint`   | boolean | true    | Indicates if the resource only provides data without side effects |\n| `idempotentHint` | boolean | true    | Indicates if repeated reads have the same effect as a single read |\n\nRemember that annotations help make better user experiences but should be treated as advisory hints. They help client applications present appropriate UI elements and optimize access patterns, but won't enforce behavior on their own. Always focus on making your annotations accurately represent what your resource actually does.\n\n## Resource Templates\n\nResource Templates allow clients to request resources whose content depends on parameters embedded in the URI. Define a template using the **same `@mcp.resource` decorator**, but include `{parameter_name}` placeholders in the URI string and add corresponding arguments to your function signature.\n\nResource templates share most configuration options with regular resources (name, description, mime\\_type, tags, annotations), but add the ability to define URI parameters that map to function parameters.\n\nResource templates generate a new resource for each unique set of parameters, which means that resources can be dynamically created on-demand. For example, if the resource template `\"user://profile/{name}\"` is registered, MCP clients could request `\"user://profile/ford\"` or `\"user://profile/marvin\"` to retrieve either of those two user profiles as resources, without having to register each resource individually.\n\n<Tip>\n  Functions with `*args` are not supported as resource templates. However, unlike tools and prompts, resource templates do support `**kwargs` because the URI template defines specific parameter names that will be collected and passed as keyword arguments.\n</Tip>\n\nHere is a complete example that shows how to define two resource templates:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Template URI includes {city} placeholder\n@mcp.resource(\"weather://{city}/current\")\ndef get_weather(city: str) -> dict:\n    \"\"\"Provides weather information for a specific city.\"\"\"\n    # In a real implementation, this would call a weather API\n    # Here we're using simplified logic for example purposes\n    return {\n        \"city\": city.capitalize(),\n        \"temperature\": 22,\n        \"condition\": \"Sunny\",\n        \"unit\": \"celsius\"\n    }\n\n# Template with multiple parameters and annotations\n@mcp.resource(\n    \"repos://{owner}/{repo}/info\",\n    annotations={\n        \"readOnlyHint\": True,\n        \"idempotentHint\": True\n    }\n)\ndef get_repo_info(owner: str, repo: str) -> dict:\n    \"\"\"Retrieves information about a GitHub repository.\"\"\"\n    # In a real implementation, this would call the GitHub API\n    return {\n        \"owner\": owner,\n        \"name\": repo,\n        \"full_name\": f\"{owner}/{repo}\",\n        \"stars\": 120,\n        \"forks\": 48\n    }\n```\n\nWith these two templates defined, clients can request a variety of resources:\n\n* `weather://london/current` → Returns weather for London\n* `weather://paris/current` → Returns weather for Paris\n* `repos://jlowin/fastmcp/info` → Returns info about the jlowin/fastmcp repository\n* `repos://prefecthq/prefect/info` → Returns info about the prefecthq/prefect repository\n\n### RFC 6570 URI Templates\n\nFastMCP implements [RFC 6570 URI Templates](https://datatracker.ietf.org/doc/html/rfc6570) for resource templates, providing a standardized way to define parameterized URIs. This includes support for simple expansion, wildcard path parameters, and form-style query parameters.\n\n#### Wildcard Parameters\n\n<VersionBadge version=\"2.2.4\" />\n\nResource templates support wildcard parameters that can match multiple path segments. While standard parameters (`{param}`) only match a single path segment and don't cross \"/\" boundaries, wildcard parameters (`{param*}`) can capture multiple segments including slashes. Wildcards capture all subsequent path segments *up until* the defined part of the URI template (whether literal or another parameter). This allows you to have multiple wildcard parameters in a single URI template.\n\n```python {15, 23} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n\n# Standard parameter only matches one segment\n@mcp.resource(\"files://{filename}\")\ndef get_file(filename: str) -> str:\n    \"\"\"Retrieves a file by name.\"\"\"\n    # Will only match files://<single-segment>\n    return f\"File content for: {filename}\"\n\n\n# Wildcard parameter can match multiple segments\n@mcp.resource(\"path://{filepath*}\")\ndef get_path_content(filepath: str) -> str:\n    \"\"\"Retrieves content at a specific path.\"\"\"\n    # Can match path://docs/server/resources.mdx\n    return f\"Content at path: {filepath}\"\n\n\n# Mixing standard and wildcard parameters\n@mcp.resource(\"repo://{owner}/{path*}/template.py\")\ndef get_template_file(owner: str, path: str) -> dict:\n    \"\"\"Retrieves a file from a specific repository and path, but\n    only if the resource ends with `template.py`\"\"\"\n    # Can match repo://jlowin/fastmcp/src/resources/template.py\n    return {\n        \"owner\": owner,\n        \"path\": path + \"/template.py\",\n        \"content\": f\"File at {path}/template.py in {owner}'s repository\"\n    }\n```\n\nWildcard parameters are useful when:\n\n* Working with file paths or hierarchical data\n* Creating APIs that need to capture variable-length path segments\n* Building URL-like patterns similar to REST APIs\n\nNote that like regular parameters, each wildcard parameter must still be a named parameter in your function signature, and all required function parameters must appear in the URI template.\n\n#### Query Parameters\n\n<VersionBadge version=\"2.13.0\" />\n\nFastMCP supports RFC 6570 form-style query parameters using the `{?param1,param2}` syntax. Query parameters provide a clean way to pass optional configuration to resources without cluttering the path.\n\nQuery parameters must be optional function parameters (have default values), while path parameters map to required function parameters. This enforces a clear separation: required data goes in the path, optional configuration in query params.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Basic query parameters\n@mcp.resource(\"data://{id}{?format}\")\ndef get_data(id: str, format: str = \"json\") -> str:\n    \"\"\"Retrieve data in specified format.\"\"\"\n    if format == \"xml\":\n        return f\"<data id='{id}' />\"\n    return f'{{\"id\": \"{id}\"}}'\n\n# Multiple query parameters with type coercion\n@mcp.resource(\"api://{endpoint}{?version,limit,offset}\")\ndef call_api(endpoint: str, version: int = 1, limit: int = 10, offset: int = 0) -> dict:\n    \"\"\"Call API endpoint with pagination.\"\"\"\n    return {\n        \"endpoint\": endpoint,\n        \"version\": version,\n        \"limit\": limit,\n        \"offset\": offset,\n        \"results\": fetch_results(endpoint, version, limit, offset)\n    }\n\n# Query parameters with wildcards\n@mcp.resource(\"files://{path*}{?encoding,lines}\")\ndef read_file(path: str, encoding: str = \"utf-8\", lines: int = 100) -> str:\n    \"\"\"Read file with optional encoding and line limit.\"\"\"\n    return read_file_content(path, encoding, lines)\n```\n\n**Example requests:**\n\n* `data://123` → Uses default format `\"json\"`\n* `data://123?format=xml` → Uses format `\"xml\"`\n* `api://users?version=2&limit=50` → `version=2, limit=50, offset=0`\n* `files://src/main.py?encoding=ascii&lines=50` → Custom encoding and line limit\n\nFastMCP automatically coerces query parameter string values to the correct types based on your function's type hints (`int`, `float`, `bool`, `str`).\n\n**Query parameters vs. hidden defaults:**\n\nQuery parameters expose optional configuration to clients. To hide optional parameters from clients entirely (always use defaults), simply omit them from the URI template:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Clients CAN override max_results via query string\n@mcp.resource(\"search://{query}{?max_results}\")\ndef search_configurable(query: str, max_results: int = 10) -> dict:\n    return {\"query\": query, \"limit\": max_results}\n\n# Clients CANNOT override max_results (not in URI template)\n@mcp.resource(\"search://{query}\")\ndef search_fixed(query: str, max_results: int = 10) -> dict:\n    return {\"query\": query, \"limit\": max_results}\n```\n\n### Template Parameter Rules\n\n<VersionBadge version=\"2.2.0\" />\n\nFastMCP enforces these validation rules when creating resource templates:\n\n1. **Required function parameters** (no default values) must appear in the URI path template\n2. **Query parameters** (specified with `{?param}` syntax) must be optional function parameters with default values\n3. **All URI template parameters** (path and query) must exist as function parameters\n\nOptional function parameters (those with default values) can be:\n\n* Included as query parameters (`{?param}`) - clients can override via query string\n* Omitted from URI template - always uses default value, not exposed to clients\n* Used in alternative path templates - enables multiple ways to access the same resource\n\n**Multiple templates for one function:**\n\nCreate multiple resource templates that expose the same function through different URI patterns by manually applying decorators:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DataServer\")\n\n# Define a user lookup function that can be accessed by different identifiers\ndef lookup_user(name: str | None = None, email: str | None = None) -> dict:\n    \"\"\"Look up a user by either name or email.\"\"\"\n    if email:\n        return find_user_by_email(email)  # pseudocode\n    elif name:\n        return find_user_by_name(name)  # pseudocode\n    else:\n        return {\"error\": \"No lookup parameters provided\"}\n\n# Manually apply multiple decorators to the same function\nmcp.resource(\"users://email/{email}\")(lookup_user)\nmcp.resource(\"users://name/{name}\")(lookup_user)\n```\n\nNow an LLM or client can retrieve user information in two different ways:\n\n* `users://email/alice@example.com` → Looks up user by email (with name=None)\n* `users://name/Bob` → Looks up user by name (with email=None)\n\nThis approach allows a single function to be registered with multiple URI patterns while keeping the implementation clean and straightforward.\n\nTemplates provide a powerful way to expose parameterized data access points following REST-like principles.\n\n## Error Handling\n\n<VersionBadge version=\"2.4.1\" />\n\nIf your resource function encounters an error, you can raise a standard Python exception (`ValueError`, `TypeError`, `FileNotFoundError`, custom exceptions, etc.) or a FastMCP `ResourceError`.\n\nBy default, all exceptions (including their details) are logged and converted into an MCP error response to be sent back to the client LLM. This helps the LLM understand failures and react appropriately.\n\nIf you want to mask internal error details for security reasons, you can:\n\n1. Use the `mask_error_details=True` parameter when creating your `FastMCP` instance:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nmcp = FastMCP(name=\"SecureServer\", mask_error_details=True)\n```\n\n2. Or use `ResourceError` to explicitly control what error information is sent to clients:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.exceptions import ResourceError\n\nmcp = FastMCP(name=\"DataServer\")\n\n@mcp.resource(\"resource://safe-error\")\ndef fail_with_details() -> str:\n    \"\"\"This resource provides detailed error information.\"\"\"\n    # ResourceError contents are always sent back to clients,\n    # regardless of mask_error_details setting\n    raise ResourceError(\"Unable to retrieve data: file not found\")\n\n@mcp.resource(\"resource://masked-error\")\ndef fail_with_masked_details() -> str:\n    \"\"\"This resource masks internal error details when mask_error_details=True.\"\"\"\n    # This message would be masked if mask_error_details=True\n    raise ValueError(\"Sensitive internal file path: /etc/secrets.conf\")\n\n@mcp.resource(\"data://{id}\")\ndef get_data_by_id(id: str) -> dict:\n    \"\"\"Template resources also support the same error handling pattern.\"\"\"\n    if id == \"secure\":\n        raise ValueError(\"Cannot access secure data\")\n    elif id == \"missing\":\n        raise ResourceError(\"Data ID 'missing' not found in database\")\n    return {\"id\": id, \"value\": \"data\"}\n```\n\nWhen `mask_error_details=True`, only error messages from `ResourceError` will include details, other exceptions will be converted to a generic message.\n\n## Server Behavior\n\n### Duplicate Resources\n\n<VersionBadge version=\"2.1.0\" />\n\nYou can configure how the FastMCP server handles attempts to register multiple resources or templates with the same URI. Use the `on_duplicate_resources` setting during `FastMCP` initialization.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\n    name=\"ResourceServer\",\n    on_duplicate_resources=\"error\" # Raise error on duplicates\n)\n\n@mcp.resource(\"data://config\")\ndef get_config_v1(): return {\"version\": 1}\n\n# This registration attempt will raise a ValueError because\n# \"data://config\" is already registered and the behavior is \"error\".\n# @mcp.resource(\"data://config\")\n# def get_config_v2(): return {\"version\": 2}\n```\n\nThe duplicate behavior options are:\n\n* `\"warn\"` (default): Logs a warning, and the new resource/template replaces the old one.\n* `\"error\"`: Raises a `ValueError`, preventing the duplicate registration.\n* `\"replace\"`: Silently replaces the existing resource/template with the new one.\n* `\"ignore\"`: Keeps the original resource/template and ignores the new registration attempt.",
  "content_length": 28449
}