{
  "title": "Remote OAuth",
  "source_url": "https://gofastmcp.com/servers/auth/remote-oauth",
  "content": "Integrate your FastMCP server with external identity providers like Descope, WorkOS, Auth0, and corporate SSO systems.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span> \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.11.0\" />\n\nRemote OAuth integration allows your FastMCP server to leverage external identity providers that **support Dynamic Client Registration (DCR)**. With DCR, MCP clients can automatically register themselves with the identity provider and obtain credentials without any manual configuration. This provides enterprise-grade authentication with fully automated flows, making it ideal for production applications with modern identity providers.\n\n<Tip>\n  **When to use RemoteAuthProvider vs OAuth Proxy:**\n\n  * **RemoteAuthProvider**: For providers WITH Dynamic Client Registration (Descope, WorkOS AuthKit, modern OIDC providers)\n  * **OAuth Proxy**: For providers WITHOUT Dynamic Client Registration (GitHub, Google, Azure, AWS, Discord, etc.)\n\n  RemoteAuthProvider requires DCR support for fully automated client registration and authentication.\n</Tip>\n\n## DCR-Enabled Providers\n\nRemoteAuthProvider works with identity providers that support **Dynamic Client Registration (DCR)** - a critical capability that enables automated authentication flows:\n\n| Feature                 | DCR Providers (RemoteAuth)           | Non-DCR Providers (OAuth Proxy)           |\n| ----------------------- | ------------------------------------ | ----------------------------------------- |\n| **Client Registration** | Automatic via API                    | Manual in provider console                |\n| **Credentials**         | Dynamic per client                   | Fixed app credentials                     |\n| **Configuration**       | Zero client config                   | Pre-shared credentials                    |\n| **Examples**            | Descope, WorkOS AuthKit, modern OIDC | GitHub, Google, Azure                     |\n| **FastMCP Class**       | `RemoteAuthProvider`                 | [`OAuthProxy`](/servers/auth/oauth-proxy) |\n\nIf your provider doesn't support DCR (most traditional OAuth providers), you'll need to use [`OAuth Proxy`](/servers/auth/oauth-proxy) instead, which bridges the gap between MCP's DCR expectations and fixed OAuth credentials.\n\n## The Remote OAuth Challenge\n\nTraditional OAuth flows assume human users with web browsers who can interact with login forms, consent screens, and redirects. MCP clients operate differently - they're often automated systems that need to authenticate programmatically without human intervention.\n\nThis creates several unique requirements that standard OAuth implementations don't address well:\n\n**Automatic Discovery**: MCP clients must discover authentication requirements by examining server metadata rather than encountering HTTP redirects. They need to know which identity provider to use and how to reach it before making any authenticated requests.\n\n**Programmatic Registration**: Clients need to register themselves with identity providers automatically. Manual client registration doesn't work when clients might be dynamically created tools or services.\n\n**Seamless Token Management**: Clients must obtain, store, and refresh tokens without user interaction. The authentication flow needs to work in headless environments where no human is available to complete OAuth consent flows.\n\n**Protocol Integration**: The authentication process must integrate cleanly with MCP's JSON-RPC transport layer and error handling mechanisms.\n\nThese requirements mean that your MCP server needs to do more than just validate tokens - it needs to provide discovery metadata that enables MCP clients to understand and navigate your authentication requirements automatically.\n\n## MCP Authentication Discovery\n\nMCP authentication discovery relies on well-known endpoints that clients can examine to understand your authentication requirements. Your server becomes a bridge between MCP clients and your chosen identity provider.\n\nThe core discovery endpoint is `/.well-known/oauth-protected-resource`, which tells clients that your server requires OAuth authentication and identifies the authorization servers you trust. This endpoint contains static metadata that points clients to your identity provider without requiring any dynamic lookups.\n\n```mermaid  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nsequenceDiagram\n    participant Client\n    participant FastMCPServer as FastMCP Server\n    participant ExternalIdP as Identity Provider\n\n    Client->>FastMCPServer: 1. GET /.well-known/oauth-protected-resource\n    FastMCPServer-->>Client: 2. \"Use https://my-idp.com for auth\"\n    \n    note over Client, ExternalIdP: Client goes directly to the IdP\n    Client->>ExternalIdP: 3. Authenticate & get token via DCR\n    ExternalIdP-->>Client: 4. Access token\n    \n    Client->>FastMCPServer: 5. MCP request with Bearer token\n    FastMCPServer->>FastMCPServer: 6. Verify token signature\n    FastMCPServer-->>Client: 7. MCP response\n```\n\nThis flow separates concerns cleanly: your MCP server handles resource protection and token validation, while your identity provider handles user authentication and token issuance. The client coordinates between these systems using standardized OAuth discovery mechanisms.\n\n## FastMCP Remote Authentication\n\n<VersionBadge version=\"2.11.1\" />\n\nFastMCP provides `RemoteAuthProvider` to handle the complexities of remote OAuth integration. This class combines token validation capabilities with the OAuth discovery metadata that MCP clients require.\n\n### RemoteAuthProvider\n\n`RemoteAuthProvider` works by composing a [`TokenVerifier`](/servers/auth/token-verification) with authorization server information. A `TokenVerifier` is another FastMCP authentication class that focuses solely on token validation - signature verification, expiration checking, and claim extraction. The `RemoteAuthProvider` takes that token validation capability and adds the OAuth discovery endpoints that enable MCP clients to automatically find and authenticate with your identity provider.\n\nThis composition pattern means you can use any token validation strategy while maintaining consistent OAuth discovery behavior:\n\n* **JWT tokens**: Use `JWTVerifier` for self-contained tokens\n* **Opaque tokens**: Use `IntrospectionTokenVerifier` for RFC 7662 introspection\n* **Custom validation**: Implement your own `TokenVerifier` subclass\n\nThe separation allows you to change token validation approaches without affecting the client discovery experience.\n\nThe class automatically generates the required OAuth metadata endpoints using the MCP SDK's standardized route creation functions. This ensures compatibility with MCP clients while reducing the implementation complexity for server developers.\n\n### Basic Implementation\n\nMost applications can use `RemoteAuthProvider` directly without subclassing. The implementation requires a `TokenVerifier` instance, a list of trusted authorization servers, and your server's URL for metadata generation.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth import RemoteAuthProvider\nfrom fastmcp.server.auth.providers.jwt import JWTVerifier\nfrom pydantic import AnyHttpUrl\n\n# Configure token validation for your identity provider\ntoken_verifier = JWTVerifier(\n    jwks_uri=\"https://auth.yourcompany.com/.well-known/jwks.json\",\n    issuer=\"https://auth.yourcompany.com\",\n    audience=\"mcp-production-api\"\n)\n\n# Create the remote auth provider\nauth = RemoteAuthProvider(\n    token_verifier=token_verifier,\n    authorization_servers=[AnyHttpUrl(\"https://auth.yourcompany.com\")],\n    base_url=\"https://api.yourcompany.com\",  # Your server base URL\n    # Optional: customize allowed client redirect URIs (defaults to localhost only)\n    allowed_client_redirect_uris=[\"http://localhost:*\", \"http://127.0.0.1:*\"]\n)\n\nmcp = FastMCP(name=\"Company API\", auth=auth)\n```\n\nThis configuration creates a server that accepts tokens issued by `auth.yourcompany.com` and provides the OAuth discovery metadata that MCP clients need. The `JWTVerifier` handles token validation using your identity provider's public keys, while the `RemoteAuthProvider` generates the required OAuth endpoints.\n\nThe `authorization_servers` list tells MCP clients which identity providers you trust. The `base_url` identifies your server in OAuth metadata, enabling proper token audience validation. **Important**: The `base_url` should point to your server base URL - for example, if your MCP server is accessible at `https://api.yourcompany.com/mcp`, use `https://api.yourcompany.com` as the base URL.\n\n### Custom Endpoints\n\nYou can extend `RemoteAuthProvider` to add additional endpoints beyond the standard OAuth protected resource metadata. These don't have to be OAuth-specific - you can add any endpoints your authentication integration requires.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport httpx\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nclass CompanyAuthProvider(RemoteAuthProvider):\n    def __init__(self):\n        token_verifier = JWTVerifier(\n            jwks_uri=\"https://auth.yourcompany.com/.well-known/jwks.json\",\n            issuer=\"https://auth.yourcompany.com\",\n            audience=\"mcp-production-api\"\n        )\n        \n        super().__init__(\n            token_verifier=token_verifier,\n            authorization_servers=[AnyHttpUrl(\"https://auth.yourcompany.com\")],\n            base_url=\"https://api.yourcompany.com\"  # Your server base URL\n        )\n    \n    def get_routes(self) -> list[Route]:\n        \"\"\"Add custom endpoints to the standard protected resource routes.\"\"\"\n        \n        # Get the standard OAuth protected resource routes\n        routes = super().get_routes()\n        \n        # Add authorization server metadata forwarding for client convenience\n        async def authorization_server_metadata(request):\n            async with httpx.AsyncClient() as client:\n                response = await client.get(\n                    \"https://auth.yourcompany.com/.well-known/oauth-authorization-server\"\n                )\n                response.raise_for_status()\n                return JSONResponse(response.json())\n        \n        routes.append(\n            Route(\"/.well-known/oauth-authorization-server\", authorization_server_metadata)\n        )\n        \n        return routes\n\nmcp = FastMCP(name=\"Company API\", auth=CompanyAuthProvider())\n```\n\nThis pattern uses `super().get_routes()` to get the standard protected resource routes, then adds additional endpoints as needed. A common use case is providing authorization server metadata forwarding, which allows MCP clients to discover your identity provider's capabilities through your MCP server rather than contacting the identity provider directly.\n\n## WorkOS AuthKit Integration\n\nWorkOS AuthKit provides an excellent example of remote OAuth integration. The `AuthKitProvider` demonstrates how to implement both token validation and OAuth metadata forwarding in a production-ready package.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth.providers.workos import AuthKitProvider\n\nauth = AuthKitProvider(\n    authkit_domain=\"https://your-project.authkit.app\",\n    base_url=\"https://your-mcp-server.com\"\n)\n\nmcp = FastMCP(name=\"Protected Application\", auth=auth)\n```\n\nThe `AuthKitProvider` automatically configures JWT validation against WorkOS's public keys and provides both protected resource metadata and authorization server metadata forwarding. This implementation handles the complete remote OAuth integration with minimal configuration.\n\nWorkOS's support for Dynamic Client Registration makes it particularly well-suited for MCP applications. Clients can automatically register themselves with your WorkOS project and obtain the credentials needed for authentication without manual intervention.\n\n→ **Complete WorkOS tutorial**: [AuthKit Integration Guide](/integrations/authkit)\n\n## Client Redirect URI Security\n\n<Note>\n  `RemoteAuthProvider` also supports the `allowed_client_redirect_uris` parameter for controlling which redirect URIs are accepted from MCP clients during DCR:\n\n  * `None` (default): Only localhost patterns allowed\n  * Custom list: Specify allowed patterns with wildcard support\n  * Empty list `[]`: Allow all (not recommended)\n\n  This provides defense-in-depth even though DCR providers typically validate redirect URIs themselves.\n</Note>\n\n## Implementation Considerations\n\nRemote OAuth integration requires careful attention to several technical details that affect reliability and security.\n\n**Token Validation Performance**: Your server validates every incoming token by checking signatures against your identity provider's public keys. Consider implementing key caching and rotation handling to minimize latency while maintaining security.\n\n**Error Handling**: Network issues with your identity provider can affect token validation. Implement appropriate timeouts, retry logic, and graceful degradation to maintain service availability during identity provider outages.\n\n**Audience Validation**: Ensure that tokens intended for your server are not accepted by other applications. Proper audience validation prevents token misuse across different services in your ecosystem.\n\n**Scope Management**: Map token scopes to your application's permission model consistently. Consider how scope changes affect existing tokens and plan for smooth permission updates.\n\nThe complexity of these considerations reinforces why external identity providers are recommended over custom OAuth implementations. Established providers handle these technical details with extensive testing and operational experience.",
  "content_length": 14085
}