{
  "title": "Testing your FastMCP Server",
  "source_url": "https://gofastmcp.com/patterns/testing",
  "content": "How to test your FastMCP server.\n\nThe best way to ensure a reliable and maintainable FastMCP Server is to test it! The FastMCP Client combined with Pytest provides a simple and powerful way to test your FastMCP servers.\n\n## Prerequisites\n\nTesting FastMCP servers requires `pytest-asyncio` to handle async test functions and fixtures. Install it as a development dependency:\n\n```bash  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\npip install pytest-asyncio\n```\n\nWe recommend configuring pytest to automatically handle async tests by setting the asyncio mode to `auto` in your `pyproject.toml`:\n\n```toml  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n[tool.pytest.ini_options]\nasyncio_mode = \"auto\"\n```\n\nThis eliminates the need to decorate every async test with `@pytest.mark.asyncio`.\n\n## Testing with Pytest Fixtures\n\nUsing Pytest Fixtures, you can wrap your FastMCP Server in a Client instance that makes interacting with your server fast and easy. This is especially useful when building your own MCP Servers and enables a tight development loop by allowing you to avoid using a separate tool like MCP Inspector during development:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport pytest\nfrom fastmcp.client import Client\nfrom fastmcp.client.transports import FastMCPTransport\n\nfrom my_project.main import mcp\n\n@pytest.fixture\nasync def main_mcp_client():\n    async with Client(transport=mcp) as mcp_client:\n        yield mcp_client\n\nasync def test_list_tools(main_mcp_client: Client[FastMCPTransport]):\n    list_tools = await main_mcp_client.list_tools()\n\n    assert len(list_tools) == 5\n```\n\nWe recommend the [inline-snapshot library](https://github.com/15r10nk/inline-snapshot) for asserting complex data structures coming from your MCP Server. This library allows you to write tests that are easy to read and understand, and are also easy to update when the data structure changes.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom inline_snapshot import snapshot\n\nasync def test_list_tools(main_mcp_client: Client[FastMCPTransport]):\n    list_tools = await main_mcp_client.list_tools()\n\n    assert list_tools == snapshot()\n```\n\nSimply run `pytest --inline-snapshot=fix,create` to fill in the `snapshot()` with actual data.\n\n<Tip>\n  For values that change you can leverage the [dirty-equals](https://github.com/samuelcolvin/dirty-equals) library to perform flexible equality assertions on dynamic or non-deterministic values.\n</Tip>\n\nUsing the pytest `parametrize` decorator, you can easily test your tools with a wide variety of inputs.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport pytest\nfrom my_project.main import mcp\n\nfrom fastmcp.client import Client\nfrom fastmcp.client.transports import FastMCPTransport\n@pytest.fixture\nasync def main_mcp_client():\n    async with Client(mcp) as client:\n        yield client\n\n\n@pytest.mark.parametrize(\n    \"first_number, second_number, expected\",\n    [\n        (1, 2, 3),\n        (2, 3, 5),\n        (3, 4, 7),\n    ],\n)\nasync def test_add(\n    first_number: int,\n    second_number: int,\n    expected: int,\n    main_mcp_client: Client[FastMCPTransport],\n):\n    result = await main_mcp_client.call_tool(\n        name=\"add\", arguments={\"x\": first_number, \"y\": second_number}\n    )\n    assert result.data is not None\n    assert isinstance(result.data, int)\n    assert result.data == expected\n```\n\n<Tip>\n  The [FastMCP Repository contains thousands of tests](https://github.com/jlowin/fastmcp/tree/main/tests) for the FastMCP Client and Server. Everything from connecting to remote MCP servers, to testing tools, resources, and prompts is covered, take a look for inspiration!\n</Tip>",
  "content_length": 3746
}