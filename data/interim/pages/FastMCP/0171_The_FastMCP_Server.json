{
  "title": "The FastMCP Server",
  "source_url": "https://gofastmcp.com/servers/server",
  "content": "The core FastMCP server class for building MCP applications with tools, resources, and prompts.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span> \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\nThe central piece of a FastMCP application is the `FastMCP` server class. This class acts as the main container for your application's tools, resources, and prompts, and manages communication with MCP clients.\n\n## Creating a Server\n\nInstantiating a server is straightforward. You typically provide a name for your server, which helps identify it in client applications or logs.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\n# Create a basic server instance\nmcp = FastMCP(name=\"MyAssistantServer\")\n\n# You can also add instructions for how to interact with the server\nmcp_with_instructions = FastMCP(\n    name=\"HelpfulAssistant\",\n    instructions=\"\"\"\n        This server provides data analysis tools.\n        Call get_average() to analyze numerical data.\n    \"\"\",\n)\n```\n\nThe `FastMCP` constructor accepts several arguments:\n\n<Card icon=\"code\" title=\"FastMCP Constructor Parameters\">\n  <ParamField body=\"name\" type=\"str\" default=\"FastMCP\">\n    A human-readable name for your server\n  </ParamField>\n\n  <ParamField body=\"instructions\" type=\"str | None\">\n    Description of how to interact with this server. These instructions help clients understand the server's purpose and available functionality\n  </ParamField>\n\n  <ParamField body=\"version\" type=\"str | None\">\n    Version string for your server. If not provided, defaults to the FastMCP library version\n  </ParamField>\n\n  <ParamField body=\"website_url\" type=\"str | None\">\n    <VersionBadge version=\"2.14.0\" />\n\n    URL to a website with more information about your server. Displayed in client applications\n  </ParamField>\n\n  <ParamField body=\"icons\" type=\"list[Icon] | None\">\n    <VersionBadge version=\"2.14.0\" />\n\n    List of icon representations for your server. Icons help users visually identify your server in client applications. See [Icons](/servers/icons) for detailed examples\n  </ParamField>\n\n  <ParamField body=\"auth\" type=\"OAuthProvider | TokenVerifier | None\">\n    Authentication provider for securing HTTP-based transports. See [Authentication](/servers/auth/authentication) for configuration options\n  </ParamField>\n\n  <ParamField body=\"lifespan\" type=\"AsyncContextManager | None\">\n    An async context manager function for server startup and shutdown logic\n  </ParamField>\n\n  <ParamField body=\"tools\" type=\"list[Tool | Callable] | None\">\n    A list of tools (or functions to convert to tools) to add to the server. In some cases, providing tools programmatically may be more convenient than using the `@mcp.tool` decorator\n  </ParamField>\n\n  <ParamField body=\"include_tags\" type=\"set[str] | None\">\n    Only expose components with at least one matching tag\n  </ParamField>\n\n  <ParamField body=\"exclude_tags\" type=\"set[str] | None\">\n    Hide components with any matching tag\n  </ParamField>\n\n  <ParamField body=\"on_duplicate_tools\" type=\"Literal[&#x22;error&#x22;, &#x22;warn&#x22;, &#x22;replace&#x22;]\" default=\"error\">\n    How to handle duplicate tool registrations\n  </ParamField>\n\n  <ParamField body=\"on_duplicate_resources\" type=\"Literal[&#x22;error&#x22;, &#x22;warn&#x22;, &#x22;replace&#x22;]\" default=\"warn\">\n    How to handle duplicate resource registrations\n  </ParamField>\n\n  <ParamField body=\"on_duplicate_prompts\" type=\"Literal[&#x22;error&#x22;, &#x22;warn&#x22;, &#x22;replace&#x22;]\" default=\"replace\">\n    How to handle duplicate prompt registrations\n  </ParamField>\n\n  <ParamField body=\"strict_input_validation\" type=\"bool\" default=\"False\">\n    <VersionBadge version=\"2.13.0\" />\n\n    Controls how tool input parameters are validated. When `False` (default), FastMCP uses Pydantic's flexible validation that coerces compatible inputs (e.g., `\"10\"` → `10` for int parameters). When `True`, uses the MCP SDK's JSON Schema validation to validate inputs against the exact schema before passing them to your function, rejecting any type mismatches. The default mode improves compatibility with LLM clients while maintaining type safety. See [Input Validation Modes](/servers/tools#input-validation-modes) for details\n  </ParamField>\n\n  <ParamField body=\"include_fastmcp_meta\" type=\"bool\" default=\"True\">\n    <VersionBadge version=\"2.11.0\" />\n\n    Whether to include FastMCP metadata in component responses. When `True`, component tags and other FastMCP-specific metadata are included in the `_fastmcp` namespace within each component's `meta` field. When `False`, this metadata is omitted, resulting in cleaner integration with external systems. Can be overridden globally via `FASTMCP_INCLUDE_FASTMCP_META` environment variable\n  </ParamField>\n</Card>\n\n## Components\n\nFastMCP servers expose several types of components to the client:\n\n### Tools\n\nTools are functions that the client can call to perform actions or access external systems.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\ndef multiply(a: float, b: float) -> float:\n    \"\"\"Multiplies two numbers together.\"\"\"\n    return a * b\n```\n\nSee [Tools](/servers/tools) for detailed documentation.\n\n### Resources\n\nResources expose data sources that the client can read.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.resource(\"data://config\")\ndef get_config() -> dict:\n    \"\"\"Provides the application configuration.\"\"\"\n    return {\"theme\": \"dark\", \"version\": \"1.0\"}\n```\n\nSee [Resources & Templates](/servers/resources) for detailed documentation.\n\n### Resource Templates\n\nResource templates are parameterized resources that allow the client to request specific data.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.resource(\"users://{user_id}/profile\")\ndef get_user_profile(user_id: int) -> dict:\n    \"\"\"Retrieves a user's profile by ID.\"\"\"\n    # The {user_id} in the URI is extracted and passed to this function\n    return {\"id\": user_id, \"name\": f\"User {user_id}\", \"status\": \"active\"}\n```\n\nSee [Resources & Templates](/servers/resources) for detailed documentation.\n\n### Prompts\n\nPrompts are reusable message templates for guiding the LLM.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.prompt\ndef analyze_data(data_points: list[float]) -> str:\n    \"\"\"Creates a prompt asking for analysis of numerical data.\"\"\"\n    formatted_data = \", \".join(str(point) for point in data_points)\n    return f\"Please analyze these data points: {formatted_data}\"\n```\n\nSee [Prompts](/servers/prompts) for detailed documentation.\n\n## Tag-Based Filtering\n\n<VersionBadge version=\"2.8.0\" />\n\nFastMCP supports tag-based filtering to selectively expose components based on configurable include/exclude tag sets. This is useful for creating different views of your server for different environments or users.\n\nComponents can be tagged when defined using the `tags` parameter:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool(tags={\"public\", \"utility\"})\ndef public_tool() -> str:\n    return \"This tool is public\"\n\n@mcp.tool(tags={\"internal\", \"admin\"})\ndef admin_tool() -> str:\n    return \"This tool is for admins only\"\n```\n\nThe filtering logic works as follows:\n\n* **Include tags**: If specified, only components with at least one matching tag are exposed\n* **Exclude tags**: Components with any matching tag are filtered out\n* **Precedence**: Exclude tags always take priority over include tags\n\n<Tip>\n  To ensure a component is never exposed, you can set `enabled=False` on the component itself. To learn more, see the component-specific documentation.\n</Tip>\n\nYou configure tag-based filtering when creating your server:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Only expose components tagged with \"public\"\nmcp = FastMCP(include_tags={\"public\"})\n\n# Hide components tagged as \"internal\" or \"deprecated\"  \nmcp = FastMCP(exclude_tags={\"internal\", \"deprecated\"})\n\n# Combine both: show admin tools but hide deprecated ones\nmcp = FastMCP(include_tags={\"admin\"}, exclude_tags={\"deprecated\"})\n```\n\nThis filtering applies to all component types (tools, resources, resource templates, and prompts) and affects both listing and access.\n\n## Running the Server\n\nFastMCP servers need a transport mechanism to communicate with clients. You typically start your server by calling the `mcp.run()` method on your `FastMCP` instance, often within an `if __name__ == \"__main__\":` block in your main server script. This pattern ensures compatibility with various MCP clients.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# my_server.py\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"MyServer\")\n\n@mcp.tool\ndef greet(name: str) -> str:\n    \"\"\"Greet a user by name.\"\"\"\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    # This runs the server, defaulting to STDIO transport\n    mcp.run()\n    \n    # To use a different transport, e.g., HTTP:\n    # mcp.run(transport=\"http\", host=\"127.0.0.1\", port=9000)\n```\n\nFastMCP supports several transport options:\n\n* STDIO (default, for local tools)\n* HTTP (recommended for web services, uses Streamable HTTP protocol)\n* SSE (legacy web transport, deprecated)\n\nThe server can also be run using the FastMCP CLI.\n\nFor detailed information on each transport, how to configure them (host, port, paths), and when to use which, please refer to the [**Running Your FastMCP Server**](/deployment/running-server) guide.\n\n## Custom Routes\n\nWhen running your server with HTTP transport, you can add custom web routes alongside your MCP endpoint using the `@custom_route` decorator. This is useful for simple endpoints like health checks that need to be served alongside your MCP server:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\n\nmcp = FastMCP(\"MyServer\")\n\n@mcp.custom_route(\"/health\", methods=[\"GET\"])\nasync def health_check(request: Request) -> PlainTextResponse:\n    return PlainTextResponse(\"OK\")\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"http\")  # Health check at http://localhost:8000/health\n```\n\nCustom routes are served alongside your MCP endpoint and are useful for:\n\n* Health check endpoints for monitoring\n* Simple status or info endpoints\n* Basic webhooks or callbacks\n\nFor more complex web applications, consider [mounting your MCP server into a FastAPI or Starlette app](/deployment/http#integration-with-web-frameworks).\n\n## Composing Servers\n\n<VersionBadge version=\"2.2.0\" />\n\nFastMCP supports composing multiple servers together using `import_server` (static copy) and `mount` (live link). This allows you to organize large applications into modular components or reuse existing servers.\n\nSee the [Server Composition](/servers/composition) guide for full details, best practices, and examples.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Example: Importing a subserver\nfrom fastmcp import FastMCP\nimport asyncio\n\nmain = FastMCP(name=\"Main\")\nsub = FastMCP(name=\"Sub\")\n\n@sub.tool\ndef hello(): \n    return \"hi\"\n\n# Mount directly\nmain.mount(sub, prefix=\"sub\")\n```\n\n## Proxying Servers\n\n<VersionBadge version=\"2.0.0\" />\n\nFastMCP can act as a proxy for any MCP server (local or remote) using `FastMCP.as_proxy`, letting you bridge transports or add a frontend to existing servers. For example, you can expose a remote SSE server locally via stdio, or vice versa.\n\nProxies automatically handle concurrent operations safely by creating fresh sessions for each request when using disconnected clients.\n\nSee the [Proxying Servers](/servers/proxy) guide for details and advanced usage.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Client\n\nbackend = Client(\"http://example.com/mcp/sse\")\nproxy = FastMCP.as_proxy(backend, name=\"ProxyServer\")\n# Now use the proxy like any FastMCP server\n```\n\n## OpenAPI Integration\n\n<VersionBadge version=\"2.0.0\" />\n\nFastMCP can automatically generate servers from OpenAPI specifications or existing FastAPI applications using `FastMCP.from_openapi()` and `FastMCP.from_fastapi()`. This allows you to instantly convert existing APIs into MCP servers without manual tool creation.\n\nSee the [FastAPI Integration](/integrations/fastapi) and [OpenAPI Integration](/integrations/openapi) guides for detailed examples and configuration options.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport httpx\nfrom fastmcp import FastMCP\n\n# From OpenAPI spec\nspec = httpx.get(\"https://api.example.com/openapi.json\").json()\nmcp = FastMCP.from_openapi(openapi_spec=spec, client=httpx.AsyncClient())\n\n# From FastAPI app\nfrom fastapi import FastAPI\napp = FastAPI()\nmcp = FastMCP.from_fastapi(app=app)\n```\n\n## Server Configuration\n\nServers can be configured using a combination of initialization arguments, global settings, and transport-specific settings.\n\n### Server-Specific Configuration\n\nServer-specific settings are passed when creating the `FastMCP` instance and control server behavior:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\n# Configure server-specific settings\nmcp = FastMCP(\n    name=\"ConfiguredServer\",\n    include_tags={\"public\", \"api\"},              # Only expose these tagged components\n    exclude_tags={\"internal\", \"deprecated\"},     # Hide these tagged components\n    on_duplicate_tools=\"error\",                  # Handle duplicate registrations\n    on_duplicate_resources=\"warn\",\n    on_duplicate_prompts=\"replace\",\n    include_fastmcp_meta=False,                  # Disable FastMCP metadata for cleaner integration\n)\n```\n\n### Global Settings\n\nGlobal settings affect all FastMCP servers and can be configured via environment variables (prefixed with `FASTMCP_`) or in a `.env` file:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport fastmcp\n\n# Access global settings\nprint(fastmcp.settings.log_level)        # Default: \"INFO\"\nprint(fastmcp.settings.mask_error_details)  # Default: False\nprint(fastmcp.settings.resource_prefix_format)  # Default: \"path\"\nprint(fastmcp.settings.strict_input_validation)  # Default: False\nprint(fastmcp.settings.include_fastmcp_meta)   # Default: True\n```\n\nCommon global settings include:\n\n* **`log_level`**: Logging level (\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"), set with `FASTMCP_LOG_LEVEL`\n* **`mask_error_details`**: Whether to hide detailed error information from clients, set with `FASTMCP_MASK_ERROR_DETAILS`\n* **`resource_prefix_format`**: How to format resource prefixes (\"path\" or \"protocol\"), set with `FASTMCP_RESOURCE_PREFIX_FORMAT`\n* **`strict_input_validation`**: Controls tool input validation mode (default: False for flexible coercion), set with `FASTMCP_STRICT_INPUT_VALIDATION`. See [Input Validation Modes](/servers/tools#input-validation-modes)\n* **`include_fastmcp_meta`**: Whether to include FastMCP metadata in component responses (default: True), set with `FASTMCP_INCLUDE_FASTMCP_META`\n* **`env_file`**: Path to the environment file to load settings from (default: \".env\"), set with `FASTMCP_ENV_FILE`. Useful when your project uses a `.env` file with syntax incompatible with python-dotenv\n\n### Transport-Specific Configuration\n\nTransport settings are provided when running the server and control network behavior:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Configure transport when running\nmcp.run(\n    transport=\"http\",\n    host=\"0.0.0.0\",           # Bind to all interfaces\n    port=9000,                # Custom port\n    log_level=\"DEBUG\",        # Override global log level\n)\n\n# Or for async usage\nawait mcp.run_async(\n    transport=\"http\", \n    host=\"127.0.0.1\",\n    port=8080,\n)\n```\n\n### Setting Global Configuration\n\nGlobal FastMCP settings can be configured via environment variables (prefixed with `FASTMCP_`):\n\n```bash  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Configure global FastMCP behavior\nexport FASTMCP_LOG_LEVEL=DEBUG\nexport FASTMCP_MASK_ERROR_DETAILS=True\nexport FASTMCP_RESOURCE_PREFIX_FORMAT=protocol\nexport FASTMCP_STRICT_INPUT_VALIDATION=False\nexport FASTMCP_INCLUDE_FASTMCP_META=False\n```\n\n### Custom Tool Serialization\n\n<VersionBadge version=\"2.2.7\" />\n\nBy default, FastMCP serializes tool return values to JSON when they need to be converted to text. You can customize this behavior by providing a `tool_serializer` function when creating your server:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport yaml\nfrom fastmcp import FastMCP\n\n# Define a custom serializer that formats dictionaries as YAML\ndef yaml_serializer(data):\n    return yaml.dump(data, sort_keys=False)\n\n# Create a server with the custom serializer\nmcp = FastMCP(name=\"MyServer\", tool_serializer=yaml_serializer)\n\n@mcp.tool\ndef get_config():\n    \"\"\"Returns configuration in YAML format.\"\"\"\n    return {\"api_key\": \"abc123\", \"debug\": True, \"rate_limit\": 100}\n```\n\nThe serializer function takes any data object and returns a string representation. This is applied to **all non-string return values** from your tools. Tools that already return strings bypass the serializer.\n\nThis customization is useful when you want to:\n\n* Format data in a specific way (like YAML or custom formats)\n* Control specific serialization options (like indentation or sorting)\n* Add metadata or transform data before sending it to clients\n\n<Tip>\n  If the serializer function raises an exception, the tool will fall back to the default JSON serialization to avoid breaking the server.\n</Tip>",
  "content_length": 17922
}