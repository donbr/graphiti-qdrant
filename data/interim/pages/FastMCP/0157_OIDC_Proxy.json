{
  "title": "OIDC Proxy",
  "source_url": "https://gofastmcp.com/servers/auth/oidc-proxy",
  "content": "Bridge OIDC providers to work seamlessly with MCP's authentication flow.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.12.4\" />\n\nThe OIDC proxy enables FastMCP servers to authenticate with OIDC providers that **don't support Dynamic Client Registration (DCR)** out of the box. This includes OAuth providers like: Auth0, Google, Azure, AWS, etc. For providers that do support DCR (like WorkOS AuthKit), use [`RemoteAuthProvider`](/servers/auth/remote-oauth) instead.\n\nThe OIDC proxy is built upon [`OAuthProxy`](/servers/auth/oauth-proxy) so it has all the same functionality under the covers.\n\n## Implementation\n\n### Provider Setup Requirements\n\nBefore using the OIDC proxy, you need to register your application with your OAuth provider:\n\n1. **Register your application** in the provider's developer console (Auth0 Applications, Google Cloud Console, Azure Portal, etc.)\n2. **Configure the redirect URI** as your FastMCP server URL plus your chosen callback path:\n   * Default: `https://your-server.com/auth/callback`\n   * Custom: `https://your-server.com/your/custom/path` (if you set `redirect_path`)\n   * Development: `http://localhost:8000/auth/callback`\n3. **Obtain your credentials**: Client ID and Client Secret\n\n<Warning>\n  The redirect URI you configure with your provider must exactly match your\n  FastMCP server's URL plus the callback path. If you customize `redirect_path`\n  in the OIDC proxy, update your provider's redirect URI accordingly.\n</Warning>\n\n### Basic Setup\n\nHere's how to implement the OIDC proxy with any provider:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth.oidc_proxy import OIDCProxy\n\n# Create the OIDC proxy\nauth = OIDCProxy(\n    # Provider's configuration URL\n    config_url=\"https://provider.com/.well-known/openid-configuration\",\n\n    # Your registered app credentials\n    client_id=\"your-client-id\",\n    client_secret=\"your-client-secret\",\n\n    # Your FastMCP server's public URL\n    base_url=\"https://your-server.com\",\n\n    # Optional: customize the callback path (default is \"/auth/callback\")\n    # redirect_path=\"/custom/callback\",\n)\n\nmcp = FastMCP(name=\"My Server\", auth=auth)\n```\n\n### Configuration Parameters\n\n<Card icon=\"code\" title=\"OIDCProxy Parameters\">\n  <ParamField body=\"config_url\" type=\"str\" required>\n    URL of your OAuth provider's OIDC configuration\n  </ParamField>\n\n  <ParamField body=\"client_id\" type=\"str\" required>\n    Client ID from your registered OAuth application\n  </ParamField>\n\n  <ParamField body=\"client_secret\" type=\"str\" required>\n    Client secret from your registered OAuth application\n  </ParamField>\n\n  <ParamField body=\"base_url\" type=\"AnyHttpUrl | str\" required>\n    Public URL of your FastMCP server (e.g., `https://your-server.com`)\n  </ParamField>\n\n  <ParamField body=\"strict\" type=\"bool | None\">\n    Strict flag for configuration validation. When True, requires all OIDC\n    mandatory fields.\n  </ParamField>\n\n  <ParamField body=\"audience\" type=\"str | None\">\n    Audience parameter for OIDC providers that require it (e.g., Auth0). This is\n    typically your API identifier.\n  </ParamField>\n\n  <ParamField body=\"timeout_seconds\" type=\"int | None\" default=\"10\">\n    HTTP request timeout in seconds for fetching OIDC configuration\n  </ParamField>\n\n  <ParamField body=\"token_verifier\" type=\"TokenVerifier | None\">\n    <VersionBadge version=\"2.13.1\" />\n\n    Custom token verifier for validating tokens. When provided, FastMCP uses your custom verifier instead of creating a default `JWTVerifier`.\n\n    Cannot be used with `algorithm` or `required_scopes` parameters - configure these on your verifier instead. The verifier's `required_scopes` are automatically loaded and advertised.\n  </ParamField>\n\n  <ParamField body=\"algorithm\" type=\"str | None\">\n    JWT algorithm to use for token verification (e.g., \"RS256\"). If not specified,\n    uses the provider's default. Only used when `token_verifier` is not provided.\n  </ParamField>\n\n  <ParamField body=\"required_scopes\" type=\"list[str] | None\">\n    List of OAuth scopes for token validation. These are automatically\n    included in authorization requests. Only used when `token_verifier` is not provided.\n  </ParamField>\n\n  <ParamField body=\"redirect_path\" type=\"str\" default=\"/auth/callback\">\n    Path for OAuth callbacks. Must match the redirect URI configured in your OAuth\n    application\n  </ParamField>\n\n  <ParamField body=\"allowed_client_redirect_uris\" type=\"list[str] | None\">\n    List of allowed redirect URI patterns for MCP clients. Patterns support wildcards (e.g., `\"http://localhost:*\"`, `\"https://*.example.com/*\"`).\n\n    * `None` (default): All redirect URIs allowed (for MCP/DCR compatibility)\n    * Empty list `[]`: No redirect URIs allowed\n    * Custom list: Only matching patterns allowed\n\n    These patterns apply to MCP client loopback redirects, NOT the upstream OAuth app redirect URI.\n  </ParamField>\n\n  <ParamField body=\"token_endpoint_auth_method\" type=\"str | None\">\n    Token endpoint authentication method for the upstream OAuth server. Controls how the proxy authenticates when exchanging authorization codes and refresh tokens with the upstream provider.\n\n    * `\"client_secret_basic\"`: Send credentials in Authorization header (most common)\n    * `\"client_secret_post\"`: Send credentials in request body (required by some providers)\n    * `\"none\"`: No authentication (for public clients)\n    * `None` (default): Uses authlib's default (typically `\"client_secret_basic\"`)\n\n    Set this if your provider requires a specific authentication method and the default doesn't work.\n  </ParamField>\n\n  <ParamField body=\"jwt_signing_key\" type=\"str | bytes | None\">\n    <VersionBadge version=\"2.13.0\" />\n\n    Secret used to sign FastMCP JWT tokens issued to clients. Accepts any string or bytes - will be derived into a proper 32-byte cryptographic key using HKDF.\n\n    **Default behavior (`None`):**\n\n    * **Mac/Windows**: Auto-managed via system keyring. Keys are generated once and persisted, surviving server restarts with zero configuration. Keys are automatically derived from server attributes, so this approach, while convenient, is **only** suitable for development and local testing. For production, you must provide an explicit secret.\n    * **Linux**: Ephemeral (random salt at startup). Tokens become invalid on server restart, triggering client re-authentication.\n\n    **For production:**\n    Provide an explicit secret (e.g., from environment variable) to use a fixed key instead of the auto-generated one.\n  </ParamField>\n\n  <ParamField body=\"client_storage\" type=\"AsyncKeyValue | None\">\n    <VersionBadge version=\"2.13.0\" />\n\n    Storage backend for persisting OAuth client registrations and upstream tokens.\n\n    **Default behavior:**\n\n    * **Mac/Windows**: Encrypted DiskStore in your platform's data directory (derived from `platformdirs`)\n    * **Linux**: MemoryStore (ephemeral - clients lost on restart)\n\n    By default on Mac/Windows, clients are automatically persisted to encrypted disk storage, allowing them to survive server restarts as long as the filesystem remains accessible. This means MCP clients only need to register once and can reconnect seamlessly. On Linux where keyring isn't available, ephemeral storage is used to match the ephemeral key strategy.\n\n    For production deployments with multiple servers or cloud deployments, use a network-accessible storage backend rather than local disk storage. **Wrap your storage in `FernetEncryptionWrapper` to encrypt sensitive OAuth tokens at rest.** See [Storage Backends](/servers/storage-backends) for available options.\n\n    Testing with in-memory storage (unencrypted):\n\n    ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    from key_value.aio.stores.memory import MemoryStore\n\n    # Use in-memory storage for testing (clients lost on restart)\n    auth = OIDCProxy(..., client_storage=MemoryStore())\n    ```\n\n    Production with encrypted Redis storage:\n\n    ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    from key_value.aio.stores.redis import RedisStore\n    from key_value.aio.wrappers.encryption import FernetEncryptionWrapper\n    from cryptography.fernet import Fernet\n    import os\n\n    auth = OIDCProxy(\n        ...,\n        jwt_signing_key=os.environ[\"JWT_SIGNING_KEY\"],\n        client_storage=FernetEncryptionWrapper(\n            key_value=RedisStore(host=\"redis.example.com\", port=6379),\n            fernet=Fernet(os.environ[\"STORAGE_ENCRYPTION_KEY\"])\n        )\n    )\n    ```\n  </ParamField>\n\n  <ParamField body=\"require_authorization_consent\" type=\"bool\" default=\"True\">\n    Whether to require user consent before authorizing MCP clients. When enabled (default), users see a consent screen that displays which client is requesting access. See [OAuthProxy documentation](/servers/auth/oauth-proxy#confused-deputy-attacks) for details on confused deputy attack protection.\n  </ParamField>\n\n  <ParamField body=\"consent_csp_policy\" type=\"str | None\" default=\"None\">\n    Content Security Policy for the consent page.\n\n    * `None` (default): Uses the built-in CSP policy with appropriate directives for form submission\n    * Empty string `\"\"`: Disables CSP entirely (no meta tag rendered)\n    * Custom string: Uses the provided value as the CSP policy\n\n    This is useful for organizations that have their own CSP policies and need to override or disable FastMCP's built-in CSP directives.\n  </ParamField>\n</Card>\n\n### Using Built-in Providers\n\nFastMCP includes pre-configured OIDC providers for common services:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.auth.providers.auth0 import Auth0Provider\n\nauth = Auth0Provider(\n    config_url=\"https://.../.well-known/openid-configuration\",\n    client_id=\"your-auth0-client-id\",\n    client_secret=\"your-auth0-client-secret\",\n    audience=\"https://...\",\n    base_url=\"https://localhost:8000\"\n)\n\nmcp = FastMCP(name=\"My Server\", auth=auth)\n```\n\nAvailable providers include `Auth0Provider` at present.\n\n### Scope Configuration\n\nOAuth scopes are configured with `required_scopes` to automatically request the permissions your application needs.\n\nDynamic clients created by the proxy will automatically include these scopes in their authorization requests.\n\n## Environment Configuration\n\n<VersionBadge version=\"2.13.0\" />\n\nFor production deployments, configure the OIDC proxy through environment variables instead of hardcoding credentials:\n\n```bash  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Specify the provider implementation\nexport FASTMCP_SERVER_AUTH=fastmcp.server.auth.providers.auth0.Auth0Provider\n\n# Provider-specific credentials\nexport FASTMCP_SERVER_AUTH_AUTH0_CONFIG_URL=https://.../.well-known/openid-configuration\nexport FASTMCP_SERVER_AUTH_AUTH0_CLIENT_ID=tv2ObNgaZAWWhhycr7Bz1LU2mxlnsmsB\nexport FASTMCP_SERVER_AUTH_AUTH0_CLIENT_SECRET=vPYqbjemq...\nexport FASTMCP_SERVER_AUTH_AUTH0_AUDIENCE=https://...\nexport FASTMCP_SERVER_AUTH_AUTH0_BASE_URL=https://localhost:8000\n```\n\nWith environment configuration, your server code simplifies to:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\n# Authentication automatically configured from environment\nmcp = FastMCP(name=\"My Server\")\n\n@mcp.tool\ndef protected_tool(data: str) -> str:\n    \"\"\"This tool is now protected by OAuth.\"\"\"\n    return f\"Processed: {data}\"\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"http\", port=8000)\n```",
  "content_length": 11835
}