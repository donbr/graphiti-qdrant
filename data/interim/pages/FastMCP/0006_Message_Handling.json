{
  "title": "Message Handling",
  "source_url": "https://gofastmcp.com/clients/messages",
  "content": "Handle MCP messages, requests, and notifications with custom message handlers.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.9.1\" />\n\nMCP clients can receive various types of messages from servers, including requests that need responses and notifications that don't. The message handler provides a unified way to process all these messages.\n\n## Function-Based Handler\n\nThe simplest way to handle messages is with a function that receives all messages:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import Client\n\nasync def message_handler(message):\n    \"\"\"Handle all MCP messages from the server.\"\"\"\n    if hasattr(message, 'root'):\n        method = message.root.method\n        print(f\"Received: {method}\")\n        \n        # Handle specific notifications\n        if method == \"notifications/tools/list_changed\":\n            print(\"Tools have changed - might want to refresh tool cache\")\n        elif method == \"notifications/resources/list_changed\":\n            print(\"Resources have changed\")\n\nclient = Client(\n    \"my_mcp_server.py\",\n    message_handler=message_handler,\n)\n```\n\n## Message Handler Class\n\nFor fine-grained targeting, FastMCP provides a `MessageHandler` class you can subclass to take advantage of specific hooks:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import Client\nfrom fastmcp.client.messages import MessageHandler\nimport mcp.types\n\nclass MyMessageHandler(MessageHandler):\n    async def on_tool_list_changed(\n        self, notification: mcp.types.ToolListChangedNotification\n    ) -> None:\n        \"\"\"Handle tool list changes specifically.\"\"\"\n        print(\"Tool list changed - refreshing available tools\")\n\nclient = Client(\n    \"my_mcp_server.py\",\n    message_handler=MyMessageHandler(),\n)\n```\n\n### Available Handler Methods\n\nAll handler methods receive a single argument - the specific message type:\n\n<Card icon=\"code\" title=\"Message Handler Methods\">\n  <ResponseField name=\"on_message(message)\" type=\"Any MCP message\">\n    Called for ALL messages (requests and notifications)\n  </ResponseField>\n\n  <ResponseField name=\"on_request(request)\" type=\"mcp.types.ClientRequest\">\n    Called for requests that expect responses\n  </ResponseField>\n\n  <ResponseField name=\"on_notification(notification)\" type=\"mcp.types.ServerNotification\">\n    Called for notifications (fire-and-forget)\n  </ResponseField>\n\n  <ResponseField name=\"on_tool_list_changed(notification)\" type=\"mcp.types.ToolListChangedNotification\">\n    Called when the server's tool list changes\n  </ResponseField>\n\n  <ResponseField name=\"on_resource_list_changed(notification)\" type=\"mcp.types.ResourceListChangedNotification\">\n    Called when the server's resource list changes\n  </ResponseField>\n\n  <ResponseField name=\"on_prompt_list_changed(notification)\" type=\"mcp.types.PromptListChangedNotification\">\n    Called when the server's prompt list changes\n  </ResponseField>\n\n  <ResponseField name=\"on_progress(notification)\" type=\"mcp.types.ProgressNotification\">\n    Called for progress updates during long-running operations\n  </ResponseField>\n\n  <ResponseField name=\"on_logging_message(notification)\" type=\"mcp.types.LoggingMessageNotification\">\n    Called for log messages from the server\n  </ResponseField>\n</Card>\n\n## Example: Handling Tool Changes\n\nHere's a practical example of handling tool list changes:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.client.messages import MessageHandler\nimport mcp.types\n\nclass ToolCacheHandler(MessageHandler):\n    def __init__(self):\n        self.cached_tools = []\n    \n    async def on_tool_list_changed(\n        self, notification: mcp.types.ToolListChangedNotification\n    ) -> None:\n        \"\"\"Clear tool cache when tools change.\"\"\"\n        print(\"Tools changed - clearing cache\")\n        self.cached_tools = []  # Force refresh on next access\n\nclient = Client(\"server.py\", message_handler=ToolCacheHandler())\n```\n\n## Handling Requests\n\nWhile the message handler receives server-initiated requests, for most use cases you should use the dedicated callback parameters instead:\n\n* **Sampling requests**: Use [`sampling_handler`](/clients/sampling)\n* **Progress requests**: Use [`progress_handler`](/clients/progress)\n* **Log requests**: Use [`log_handler`](/clients/logging)\n\nThe message handler is primarily for monitoring and handling notifications rather than responding to requests.",
  "content_length": 4744
}