{
  "title": "Decorating Methods",
  "source_url": "https://gofastmcp.com/patterns/decorating-methods",
  "content": "Properly use instance methods, class methods, and static methods with FastMCP decorators.\n\nFastMCP's decorator system is designed to work with functions, but you may see unexpected behavior if you try to decorate an instance or class method. This guide explains the correct approach for using methods with all FastMCP decorators (`@tool`, `@resource`, and `@prompt`).\n\n## Why Are Methods Hard?\n\nWhen you apply a FastMCP decorator like `@tool`, `@resource`, or `@prompt` to a method, the decorator captures the function at decoration time. For instance methods and class methods, this poses a challenge because:\n\n1. For instance methods: The decorator gets the unbound method before any instance exists\n2. For class methods: The decorator gets the function before it's bound to the class\n\nThis means directly decorating these methods doesn't work as expected. In practice, the LLM would see parameters like `self` or `cls` that it cannot provide values for.\n\nAdditionally, **FastMCP decorators return objects (Tool, Resource, or Prompt instances) rather than the original function**. This means that when you decorate a method directly, the method becomes the returned object and is no longer callable by your code:\n\n<Warning>\n  **Don't do this!**\n\n  The method will no longer be callable from Python, and the tool won't be callable by LLMs.\n\n  ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n\n  from fastmcp import FastMCP\n  mcp = FastMCP()\n\n  class MyClass:\n      @mcp.tool\n      def my_method(self, x: int) -> int:\n          return x * 2\n\n  obj = MyClass()\n  obj.my_method(5)  # Fails - my_method is a Tool, not a function\n  ```\n</Warning>\n\nThis is another important reason to register methods functionally after defining the class.\n\n## Recommended Patterns\n\n### Instance Methods\n\n<Warning>\n  **Don't do this!**\n\n  ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  class MyClass:\n      @mcp.tool  # This won't work correctly\n      def add(self, x, y):\n          return x + y\n  ```\n</Warning>\n\nWhen the decorator is applied this way, it captures the unbound method. When the LLM later tries to use this component, it will see `self` as a required parameter, but it won't know what to provide for it, causing errors or unexpected behavior.\n\n<Check>\n  **Do this instead**:\n\n  ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  class MyClass:\n      def add(self, x, y):\n          return x + y\n\n  # Create an instance first, then register the bound methods\n  obj = MyClass()\n  mcp.tool(obj.add)\n\n  # Now you can call it without 'self' showing up as a parameter\n  await mcp._mcp_call_tool('add', {'x': 1, 'y': 2})  # Returns 3\n  ```\n</Check>\n\nThis approach works because:\n\n1. You first create an instance of the class (`obj`)\n2. When you access the method through the instance (`obj.add`), Python creates a bound method where `self` is already set to that instance\n3. When you register this bound method, the system sees a callable that only expects the appropriate parameters, not `self`\n\n### Class Methods\n\nThe behavior of decorating class methods depends on the order of decorators:\n\n<Warning>\n  **Don't do this** (decorator order matters):\n\n  ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  class MyClass:\n      @classmethod\n      @mcp.tool  # This won't work but won't raise an error\n      def from_string_v1(cls, s):\n          return cls(s)\n      \n      @mcp.tool\n      @classmethod  # This will raise a helpful ValueError\n      def from_string_v2(cls, s):\n          return cls(s)\n  ```\n</Warning>\n\n* If `@classmethod` comes first, then `@mcp.tool`: No error is raised, but it won't work correctly\n* If `@mcp.tool` comes first, then `@classmethod`: FastMCP will detect this and raise a helpful `ValueError` with guidance\n\n<Check>\n  **Do this instead**:\n\n  ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  class MyClass:\n      @classmethod\n      def from_string(cls, s):\n          return cls(s)\n\n  # Register the class method after the class is defined\n  mcp.tool(MyClass.from_string)\n  ```\n</Check>\n\nThis works because:\n\n1. The `@classmethod` decorator is applied properly during class definition\n2. When you access `MyClass.from_string`, Python provides a special method object that automatically binds the class to the `cls` parameter\n3. When registered, only the appropriate parameters are exposed to the LLM, hiding the implementation detail of the `cls` parameter\n\n### Static Methods\n\nStatic methods \"work\" with FastMCP decorators, but this is not recommended because the FastMCP decorator will not return a callable method. Therefore, you should register static methods the same way as other methods.\n\n<Warning>\n  **This is not recommended, though it will work.**\n\n  ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  class MyClass:\n      @mcp.tool\n      @staticmethod\n      def utility(x, y):\n          return x + y\n  ```\n</Warning>\n\nThis works because `@staticmethod` converts the method to a regular function, which the FastMCP decorator can then properly process. However, this is not recommended because the FastMCP decorator will not return a callable staticmethod. Therefore, you should register static methods the same way as other methods.\n\n<Check>\n  **Prefer this pattern:**\n\n  ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  class MyClass:\n      @staticmethod\n      def utility(x, y):\n          return x + y\n\n  # This also works\n  mcp.tool(MyClass.utility)\n  ```\n</Check>\n\n## Additional Patterns\n\n### Creating Components at Class Initialization\n\nYou can automatically register instance methods when creating an object:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\nclass ComponentProvider:\n    def __init__(self, mcp_instance):\n        # Register methods\n        mcp_instance.tool(self.tool_method)\n        mcp_instance.resource(\"resource://data\")(self.resource_method)\n    \n    def tool_method(self, x):\n        return x * 2\n    \n    def resource_method(self):\n        return \"Resource data\"\n\n# The methods are automatically registered when creating the instance\nprovider = ComponentProvider(mcp)\n```\n\nThis pattern is useful when:\n\n* You want to encapsulate registration logic within the class itself\n* You have multiple related components that should be registered together\n* You want to ensure that methods are always properly registered when creating an instance\n\nThe class automatically registers its methods during initialization, ensuring they're properly bound to the instance before registration.\n\n## Summary\n\nThe current behavior of FastMCP decorators with methods is:\n\n* **Static methods**: Can be decorated directly and work perfectly with all FastMCP decorators\n* **Class methods**: Cannot be decorated directly and will raise a helpful `ValueError` with guidance\n* **Instance methods**: Should be registered after creating an instance using the decorator calls\n\nFor class and instance methods, you should register them after creating the instance or class to ensure proper method binding. This ensures that the methods are properly bound before being registered.\n\nUnderstanding these patterns allows you to effectively organize your components into classes while maintaining proper method binding, giving you the benefits of object-oriented design without sacrificing the simplicity of FastMCP's decorator system.",
  "content_length": 7782
}