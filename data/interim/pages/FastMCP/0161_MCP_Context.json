{
  "title": "MCP Context",
  "source_url": "https://gofastmcp.com/servers/context",
  "content": "Access MCP capabilities like logging, progress, and resources within your MCP objects.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\nWhen defining FastMCP [tools](/servers/tools), [resources](/servers/resources), resource templates, or [prompts](/servers/prompts), your functions might need to interact with the underlying MCP session or access advanced server capabilities. FastMCP provides the `Context` object for this purpose.\n\n## What Is Context?\n\nThe `Context` object provides a clean interface to access MCP features within your functions, including:\n\n* **Logging**: Send debug, info, warning, and error messages back to the client\n* **Progress Reporting**: Update the client on the progress of long-running operations\n* **Resource Access**: List and read data from resources registered with the server\n* **Prompt Access**: List and retrieve prompts registered with the server\n* **LLM Sampling**: Request the client's LLM to generate text based on provided messages\n* **User Elicitation**: Request structured input from users during tool execution\n* **State Management**: Store and share data between middleware and the handler within a single request\n* **Request Information**: Access metadata about the current request\n* **Server Access**: When needed, access the underlying FastMCP server instance\n\n## Accessing the Context\n\n### Via Dependency Injection\n\nTo use the context object within any of your functions, simply add a parameter to your function signature and type-hint it as `Context`. FastMCP will automatically inject the context instance when your function is called.\n\n**Key Points:**\n\n* The parameter name (e.g., `ctx`, `context`) doesn't matter, only the type hint `Context` is important.\n* The context parameter can be placed anywhere in your function's signature; it will not be exposed to MCP clients as a valid parameter.\n* The context is optional - functions that don't need it can omit the parameter entirely.\n* Context methods are async, so your function usually needs to be async as well.\n* The type hint can be a union (`Context | None`) or use `Annotated[]` and it will still work properly.\n* **Each MCP request receives a new context object.** Context is scoped to a single request; state or data set in one request will not be available in subsequent requests.\n* Context is only available during a request; attempting to use context methods outside a request will raise errors. If you need to debug or call your context methods outside of a request, you can type your variable as `Context | None=None` to avoid missing argument errors.\n\n#### Tools\n\n```python {1, 6} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"Context Demo\")\n\n@mcp.tool\nasync def process_file(file_uri: str, ctx: Context) -> str:\n    \"\"\"Processes a file, using context for logging and resource access.\"\"\"\n    # Context is available as the ctx parameter\n    return \"Processed file\"\n```\n\n#### Resources and Templates\n\n<VersionBadge version=\"2.2.5\" />\n\n```python {1, 6, 12} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"Context Demo\")\n\n@mcp.resource(\"resource://user-data\")\nasync def get_user_data(ctx: Context) -> dict:\n    \"\"\"Fetch personalized user data based on the request context.\"\"\"\n    # Context is available as the ctx parameter\n    return {\"user_id\": \"example\"}\n\n@mcp.resource(\"resource://users/{user_id}/profile\")\nasync def get_user_profile(user_id: str, ctx: Context) -> dict:\n    \"\"\"Fetch user profile with context-aware logging.\"\"\"\n    # Context is available as the ctx parameter\n    return {\"id\": user_id}\n```\n\n#### Prompts\n\n<VersionBadge version=\"2.2.5\" />\n\n```python {1, 6} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"Context Demo\")\n\n@mcp.prompt\nasync def data_analysis_request(dataset: str, ctx: Context) -> str:\n    \"\"\"Generate a request to analyze data with contextual information.\"\"\"\n    # Context is available as the ctx parameter\n    return f\"Please analyze the following dataset: {dataset}\"\n```\n\n### Via Runtime Dependency Function\n\n<VersionBadge version=\"2.2.11\" />\n\nWhile the simplest way to access context is through function parameter injection as shown above, there are cases where you need to access the context in code that may not be easy to modify to accept a context parameter, or that is nested deeper within your function calls.\n\nFastMCP provides dependency functions that allow you to retrieve the active context from anywhere within a server request's execution flow:\n\n```python {2,9} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.dependencies import get_context\n\nmcp = FastMCP(name=\"Dependency Demo\")\n\n# Utility function that needs context but doesn't receive it as a parameter\nasync def process_data(data: list[float]) -> dict:\n    # Get the active context - only works when called within a request\n    ctx = get_context()    \n    await ctx.info(f\"Processing {len(data)} data points\")\n    \n@mcp.tool\nasync def analyze_dataset(dataset_name: str) -> dict:\n    # Call utility function that uses context internally\n    data = load_data(dataset_name)\n    await process_data(data)\n```\n\n**Important Notes:**\n\n* The `get_context` function should only be used within the context of a server request. Calling it outside of a request will raise a `RuntimeError`.\n* The `get_context` function is server-only and should not be used in client code.\n\n## Context Capabilities\n\nFastMCP provides several advanced capabilities through the context object. Each capability has dedicated documentation with comprehensive examples and best practices:\n\n### Logging\n\nSend debug, info, warning, and error messages back to the MCP client for visibility into function execution.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nawait ctx.debug(\"Starting analysis\")\nawait ctx.info(f\"Processing {len(data)} items\") \nawait ctx.warning(\"Deprecated parameter used\")\nawait ctx.error(\"Processing failed\")\n```\n\nSee [Server Logging](/servers/logging) for complete documentation and examples.\n\n### Client Elicitation\n\n<VersionBadge version=\"2.10.0\" />\n\nRequest structured input from clients during tool execution, enabling interactive workflows and progressive disclosure. This is a new feature in the 6/18/2025 MCP spec.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nresult = await ctx.elicit(\"Enter your name:\", response_type=str)\nif result.action == \"accept\":\n    name = result.data\n```\n\nSee [User Elicitation](/servers/elicitation) for detailed examples and supported response types.\n\n### LLM Sampling\n\n<VersionBadge version=\"2.0.0\" />\n\nRequest the client's LLM to generate text based on provided messages, useful for leveraging AI capabilities within your tools.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nresponse = await ctx.sample(\"Analyze this data\", temperature=0.7)\n```\n\nSee [LLM Sampling](/servers/sampling) for comprehensive usage and advanced techniques.\n\n### Progress Reporting\n\nUpdate clients on the progress of long-running operations, enabling progress indicators and better user experience.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nawait ctx.report_progress(progress=50, total=100)  # 50% complete\n```\n\nSee [Progress Reporting](/servers/progress) for detailed patterns and examples.\n\n### Resource Access\n\nList and read data from resources registered with your FastMCP server, allowing access to files, configuration, or dynamic content.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# List available resources\nresources = await ctx.list_resources()\n\n# Read a specific resource\ncontent_list = await ctx.read_resource(\"resource://config\")\ncontent = content_list[0].content\n```\n\n**Method signatures:**\n\n* **`ctx.list_resources() -> list[MCPResource]`**: <VersionBadge version=\"2.13.0\" /> Returns list of all available resources\n* **`ctx.read_resource(uri: str | AnyUrl) -> list[ReadResourceContents]`**: Returns a list of resource content parts\n\n### Prompt Access\n\n<VersionBadge version=\"2.13.0\" />\n\nList and retrieve prompts registered with your FastMCP server, allowing tools and middleware to discover and use available prompts programmatically.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# List available prompts\nprompts = await ctx.list_prompts()\n\n# Get a specific prompt with arguments\nresult = await ctx.get_prompt(\"analyze_data\", {\"dataset\": \"users\"})\nmessages = result.messages\n```\n\n**Method signatures:**\n\n* **`ctx.list_prompts() -> list[MCPPrompt]`**: Returns list of all available prompts\n* **`ctx.get_prompt(name: str, arguments: dict[str, Any] | None = None) -> GetPromptResult`**: Get a specific prompt with optional arguments\n\n### State Management\n\n<VersionBadge version=\"2.11.0\" />\n\nStore and share data between middleware and handlers within a single MCP request. Each MCP request (such as calling a tool, reading a resource, listing tools, or listing resources) receives its own context object with isolated state. Context state is particularly useful for passing information from [middleware](/servers/middleware) to your handlers.\n\nTo store a value in the context state, use `ctx.set_state(key, value)`. To retrieve a value, use `ctx.get_state(key)`.\n\n<Warning>\n  Context state is scoped to a single MCP request. Each operation (tool call, resource read, list operation, etc.) receives a new context object. State set during one request will not be available in subsequent requests. For persistent data storage across requests, use external storage mechanisms like databases, files, or in-memory caches.\n</Warning>\n\nThis simplified example shows how to use MCP middleware to store user info in the context state, and how to access that state in a tool:\n\n```python {7-8, 16-17} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.middleware import Middleware, MiddlewareContext\n\nclass UserAuthMiddleware(Middleware):\n    async def on_call_tool(self, context: MiddlewareContext, call_next):\n\n        # Middleware stores user info in context state\n        context.fastmcp_context.set_state(\"user_id\", \"user_123\")\n        context.fastmcp_context.set_state(\"permissions\", [\"read\", \"write\"])\n\n        return await call_next(context)\n\n@mcp.tool\nasync def secure_operation(data: str, ctx: Context) -> str:\n    \"\"\"Tool can access state set by middleware.\"\"\"\n\n    user_id = ctx.get_state(\"user_id\")  # \"user_123\"\n    permissions = ctx.get_state(\"permissions\")  # [\"read\", \"write\"]\n    \n    if \"write\" not in permissions:\n        return \"Access denied\"\n    \n    return f\"Processing {data} for user {user_id}\"\n```\n\n**Method signatures:**\n\n* **`ctx.set_state(key: str, value: Any) -> None`**: Store a value in the context state\n* **`ctx.get_state(key: str) -> Any`**: Retrieve a value from the context state (returns None if not found)\n\n**State Inheritance:**\nWhen a new context is created (nested contexts), it inherits a copy of its parent's state. This ensures that:\n\n* State set on a child context never affects the parent context\n* State set on a parent context after the child context is initialized is not propagated to the child context\n\nThis makes state management predictable and prevents unexpected side effects between nested operations.\n\n### Change Notifications\n\n<VersionBadge version=\"2.9.1\" />\n\nFastMCP automatically sends list change notifications when components (such as tools, resources, or prompts) are added, removed, enabled, or disabled. In rare cases where you need to manually trigger these notifications, you can use the context methods:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def custom_tool_management(ctx: Context) -> str:\n    \"\"\"Example of manual notification after custom tool changes.\"\"\"\n    # After making custom changes to tools\n    await ctx.send_tool_list_changed()\n    await ctx.send_resource_list_changed()\n    await ctx.send_prompt_list_changed()\n    return \"Notifications sent\"\n```\n\nThese methods are primarily used internally by FastMCP's automatic notification system and most users will not need to invoke them directly.\n\n### FastMCP Server\n\nTo access the underlying FastMCP server instance, you can use the `ctx.fastmcp` property:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def my_tool(ctx: Context) -> None:\n    # Access the FastMCP server instance\n    server_name = ctx.fastmcp.name\n    ...\n```\n\n### MCP Request\n\nAccess metadata about the current request and client.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def request_info(ctx: Context) -> dict:\n    \"\"\"Return information about the current request.\"\"\"\n    return {\n        \"request_id\": ctx.request_id,\n        \"client_id\": ctx.client_id or \"Unknown client\"\n    }\n```\n\n**Available Properties:**\n\n* **`ctx.request_id -> str`**: Get the unique ID for the current MCP request\n* **`ctx.client_id -> str | None`**: Get the ID of the client making the request, if provided during initialization\n* **`ctx.session_id -> str | None`**: Get the MCP session ID for session-based data sharing (HTTP transports only)\n\n#### Request Context Availability\n\n<VersionBadge version=\"2.13.1\" />\n\nThe `ctx.request_context` property provides access to the underlying MCP request context, but returns `None` when the MCP session has not been established yet. This typically occurs:\n\n* During middleware execution in the `on_request` hook before the MCP handshake completes\n* During the initialization phase of client connections\n\nThe MCP request context is distinct from the HTTP request. For HTTP transports, HTTP request data may be available even when the MCP session is not yet established.\n\nTo safely access the request context in situations where it may not be available:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Context\nfrom fastmcp.server.dependencies import get_http_request\n\nmcp = FastMCP(name=\"Session Aware Demo\")\n\n@mcp.tool\nasync def session_info(ctx: Context) -> dict:\n    \"\"\"Return session information when available.\"\"\"\n\n    # Check if MCP session is available\n    if ctx.request_context:\n        # MCP session available - can access MCP-specific attributes\n        return {\n            \"session_id\": ctx.session_id,\n            \"request_id\": ctx.request_id,\n            \"has_meta\": ctx.request_context.meta is not None\n        }\n    else:\n        # MCP session not available - use HTTP helpers for request data (if using HTTP transport)\n        request = get_http_request()\n        return {\n            \"message\": \"MCP session not available\",\n            \"user_agent\": request.headers.get(\"user-agent\", \"Unknown\")\n        }\n```\n\nFor HTTP request access that works regardless of MCP session availability (when using HTTP transports), use the [HTTP request helpers](#http-requests) like `get_http_request()` and `get_http_headers()`.\n\n#### Client Metadata\n\n<VersionBadge version=\"2.13.1\" />\n\nClients can send contextual information with their requests using the `meta` parameter. This metadata is accessible through `ctx.request_context.meta` and is available for all MCP operations (tools, resources, prompts).\n\nThe `meta` field is `None` when clients don't provide metadata. When provided, metadata is accessible via attribute access (e.g., `meta.user_id`) rather than dictionary access. The structure of metadata is determined by the client making the request.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\ndef send_email(to: str, subject: str, body: str, ctx: Context) -> str:\n    \"\"\"Send an email, logging metadata about the request.\"\"\"\n\n    # Access client-provided metadata\n    meta = ctx.request_context.meta\n\n    if meta:\n        # Meta is accessed as an object with attribute access\n        user_id = meta.user_id if hasattr(meta, 'user_id') else None\n        trace_id = meta.trace_id if hasattr(meta, 'trace_id') else None\n\n        # Use metadata for logging, observability, etc.\n        if trace_id:\n            log_with_trace(f\"Sending email for user {user_id}\", trace_id)\n\n    # Send the email...\n    return f\"Email sent to {to}\"\n```\n\n<Warning>\n  The MCP request is part of the low-level MCP SDK and intended for advanced use cases. Most users will not need to use it directly.\n</Warning>\n\n## Runtime Dependencies\n\n### HTTP Requests\n\n<VersionBadge version=\"2.2.11\" />\n\nThe recommended way to access the current HTTP request is through the `get_http_request()` dependency function:\n\n```python {2, 3, 11} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.dependencies import get_http_request\nfrom starlette.requests import Request\n\nmcp = FastMCP(name=\"HTTP Request Demo\")\n\n@mcp.tool\nasync def user_agent_info() -> dict:\n    \"\"\"Return information about the user agent.\"\"\"\n    # Get the HTTP request\n    request: Request = get_http_request()\n    \n    # Access request data\n    user_agent = request.headers.get(\"user-agent\", \"Unknown\")\n    client_ip = request.client.host if request.client else \"Unknown\"\n    \n    return {\n        \"user_agent\": user_agent,\n        \"client_ip\": client_ip,\n        \"path\": request.url.path,\n    }\n```\n\nThis approach works anywhere within a request's execution flow, not just within your MCP function. It's useful when:\n\n1. You need access to HTTP information in helper functions\n2. You're calling nested functions that need HTTP request data\n3. You're working with middleware or other request processing code\n\n### HTTP Headers\n\n<VersionBadge version=\"2.2.11\" />\n\nIf you only need request headers and want to avoid potential errors, you can use the `get_http_headers()` helper:\n\n```python {2, 10} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.dependencies import get_http_headers\n\nmcp = FastMCP(name=\"Headers Demo\")\n\n@mcp.tool\nasync def safe_header_info() -> dict:\n    \"\"\"Safely get header information without raising errors.\"\"\"\n    # Get headers (returns empty dict if no request context)\n    headers = get_http_headers()\n    \n    # Get authorization header\n    auth_header = headers.get(\"authorization\", \"\")\n    is_bearer = auth_header.startswith(\"Bearer \")\n    \n    return {\n        \"user_agent\": headers.get(\"user-agent\", \"Unknown\"),\n        \"content_type\": headers.get(\"content-type\", \"Unknown\"),\n        \"has_auth\": bool(auth_header),\n        \"auth_type\": \"Bearer\" if is_bearer else \"Other\" if auth_header else \"None\",\n        \"headers_count\": len(headers)\n    }\n```\n\nBy default, `get_http_headers()` excludes problematic headers like `host` and `content-length`. To include all headers, use `get_http_headers(include_all=True)`.\n\n### Access Tokens\n\n<VersionBadge version=\"2.11.0\" />\n\nWhen using authentication with your FastMCP server, you can access the authenticated user's access token information using the `get_access_token()` dependency function:\n\n```python {2, 10} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.dependencies import get_access_token, AccessToken\n\nmcp = FastMCP(name=\"Auth Token Demo\")\n\n@mcp.tool\nasync def get_user_info() -> dict:\n    \"\"\"Get information about the authenticated user.\"\"\"\n    # Get the access token (None if not authenticated)\n    token: AccessToken | None = get_access_token()\n    \n    if token is None:\n        return {\"authenticated\": False}\n    \n    return {\n        \"authenticated\": True,\n        \"client_id\": token.client_id,\n        \"scopes\": token.scopes,\n        \"expires_at\": token.expires_at,\n        \"token_claims\": token.claims,  # JWT claims or custom token data\n    }\n```\n\nThis is particularly useful when you need to:\n\n1. **Access user identification** - Get the `client_id` or subject from token claims\n2. **Check permissions** - Verify scopes or custom claims before performing operations\n3. **Multi-tenant applications** - Extract tenant information from token claims\n4. **Audit logging** - Track which user performed which actions\n\n#### Working with Token Claims\n\nThe `claims` field contains all the data from the original token (JWT claims for JWT tokens, or custom data for other token types):\n\n```python {2, 3, 9, 12, 15} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.dependencies import get_access_token\n\nmcp = FastMCP(name=\"Multi-tenant Demo\")\n\n@mcp.tool\nasync def get_tenant_data(resource_id: str) -> dict:\n    \"\"\"Get tenant-specific data using token claims.\"\"\"\n    token: AccessToken | None = get_access_token()\n    \n    # Extract tenant ID from token claims\n    tenant_id = token.claims.get(\"tenant_id\") if token else None\n    \n    # Extract user ID from standard JWT subject claim\n    user_id = token.claims.get(\"sub\") if token else None\n    \n    # Use tenant and user info to authorize and filter data\n    if not tenant_id:\n        raise ValueError(\"No tenant information in token\")\n    \n    return {\n        \"resource_id\": resource_id,\n        \"tenant_id\": tenant_id,\n        \"user_id\": user_id,\n        \"data\": f\"Tenant-specific data for {tenant_id}\",\n    }\n```",
  "content_length": 21627
}