{
  "title": "Running Your Server",
  "source_url": "https://gofastmcp.com/deployment/running-server",
  "content": "Learn how to run your FastMCP server locally for development and testing\n\nFastMCP servers can be run in different ways depending on your needs. This guide focuses on running servers locally for development and testing. For production deployment to a URL, see the [HTTP Deployment](/deployment/http) guide.\n\n## The `run()` Method\n\nEvery FastMCP server needs to be started to accept connections. The simplest way to run a server is by calling the `run()` method on your FastMCP instance. This method starts the server and blocks until it's stopped, handling all the connection management for you.\n\n<Tip>\n  For maximum compatibility, it's best practice to place the `run()` call within an `if __name__ == \"__main__\":` block. This ensures the server starts only when the script is executed directly, not when imported as a module.\n</Tip>\n\n```python {9-10} my_server.py theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"MyServer\")\n\n@mcp.tool\ndef hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\nYou can now run this MCP server by executing `python my_server.py`.\n\n## Transport Protocols\n\nMCP servers communicate with clients through different transport protocols. Think of transports as the \"language\" your server speaks to communicate with clients. FastMCP supports three main transport protocols, each designed for specific use cases and deployment scenarios.\n\nThe choice of transport determines how clients connect to your server, what network capabilities are available, and how many clients can connect simultaneously. Understanding these transports helps you choose the right approach for your application.\n\n### STDIO Transport (Default)\n\nSTDIO (Standard Input/Output) is the default transport for FastMCP servers. When you call `run()` without arguments, your server uses STDIO transport. This transport communicates through standard input and output streams, making it perfect for command-line tools and desktop applications like Claude Desktop.\n\nWith STDIO transport, the client spawns a new server process for each session and manages its lifecycle. The server reads MCP messages from stdin and writes responses to stdout. This is why STDIO servers don't stay running - they're started on-demand by the client.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"MyServer\")\n\n@mcp.tool\ndef hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    mcp.run()  # Uses STDIO transport by default\n```\n\nSTDIO is ideal for:\n\n* Local development and testing\n* Claude Desktop integration\n* Command-line tools\n* Single-user applications\n\n### HTTP Transport (Streamable)\n\nHTTP transport turns your MCP server into a web service accessible via a URL. This transport uses the Streamable HTTP protocol, which allows clients to connect over the network. Unlike STDIO where each client gets its own process, an HTTP server can handle multiple clients simultaneously.\n\nThe Streamable HTTP protocol provides full bidirectional communication between client and server, supporting all MCP operations including streaming responses. This makes it the recommended choice for network-based deployments.\n\nTo use HTTP transport, specify it in the `run()` method along with networking options:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"MyServer\")\n\n@mcp.tool\ndef hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    # Start an HTTP server on port 8000\n    mcp.run(transport=\"http\", host=\"127.0.0.1\", port=8000)\n```\n\nYour server is now accessible at `http://localhost:8000/mcp`. This URL is the MCP endpoint that clients will connect to. HTTP transport enables:\n\n* Network accessibility\n* Multiple concurrent clients\n* Integration with web infrastructure\n* Remote deployment capabilities\n\nFor production HTTP deployment with authentication and advanced configuration, see the [HTTP Deployment](/deployment/http) guide.\n\n### SSE Transport (Legacy)\n\nServer-Sent Events (SSE) transport was the original HTTP-based transport for MCP. While still supported for backward compatibility, it has limitations compared to the newer Streamable HTTP transport. SSE only supports server-to-client streaming, making it less efficient for bidirectional communication.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nif __name__ == \"__main__\":\n    # SSE transport - use HTTP instead for new projects\n    mcp.run(transport=\"sse\", host=\"127.0.0.1\", port=8000)\n```\n\nWe recommend using HTTP transport instead of SSE for all new projects. SSE remains available only for compatibility with older clients that haven't upgraded to Streamable HTTP.\n\n### Choosing the Right Transport\n\nEach transport serves different needs. STDIO is perfect when you need simple, local execution - it's what Claude Desktop and most command-line tools expect. HTTP transport is essential when you need network access, want to serve multiple clients, or plan to deploy your server remotely. SSE exists only for backward compatibility and shouldn't be used in new projects.\n\nConsider your deployment scenario: Are you building a tool for local use? STDIO is your best choice. Need a centralized service that multiple clients can access? HTTP transport is the way to go.\n\n## The FastMCP CLI\n\nFastMCP provides a powerful command-line interface for running servers without modifying the source code. The CLI can automatically find and run your server with different transports, manage dependencies, and handle development workflows:\n\n```bash  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfastmcp run server.py\n```\n\nThe CLI automatically finds a FastMCP instance in your file (named `mcp`, `server`, or `app`) and runs it with the specified options. This is particularly useful for testing different transports or configurations without changing your code.\n\n### Dependency Management\n\nThe CLI integrates with `uv` to manage Python environments and dependencies:\n\n```bash  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Run with a specific Python version\nfastmcp run server.py --python 3.11\n\n# Run with additional packages\nfastmcp run server.py --with pandas --with numpy\n\n# Run with dependencies from a requirements file\nfastmcp run server.py --with-requirements requirements.txt\n\n# Combine multiple options\nfastmcp run server.py --python 3.10 --with httpx --transport http\n\n# Run within a specific project directory\nfastmcp run server.py --project /path/to/project\n```\n\n<Note>\n  When using `--python`, `--with`, `--project`, or `--with-requirements`, the server runs via `uv run` subprocess instead of using your local environment.\n</Note>\n\n### Passing Arguments to Servers\n\nWhen servers accept command line arguments (using argparse, click, or other libraries), you can pass them after `--`:\n\n```bash  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfastmcp run config_server.py -- --config config.json\nfastmcp run database_server.py -- --database-path /tmp/db.sqlite --debug\n```\n\nThis is useful for servers that need configuration files, database paths, API keys, or other runtime options.\n\nFor more CLI features including development mode with the MCP Inspector, see the [CLI documentation](/patterns/cli).\n\n### Async Usage\n\nFastMCP servers are built on async Python, but the framework provides both synchronous and asynchronous APIs to fit your application's needs. The `run()` method we've been using is actually a synchronous wrapper around the async server implementation.\n\nFor applications that are already running in an async context, FastMCP provides the `run_async()` method:\n\n```python {10-12} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nimport asyncio\n\nmcp = FastMCP(name=\"MyServer\")\n\n@mcp.tool\ndef hello(name: str) -> str:\n    return f\"Hello, {name}!\"\n\nasync def main():\n    # Use run_async() in async contexts\n    await mcp.run_async(transport=\"http\", port=8000)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n<Warning>\n  The `run()` method cannot be called from inside an async function because it creates its own async event loop internally. If you attempt to call `run()` from inside an async function, you'll get an error about the event loop already running.\n\n  Always use `run_async()` inside async functions and `run()` in synchronous contexts.\n</Warning>\n\nBoth `run()` and `run_async()` accept the same transport arguments, so all the examples above apply to both methods.\n\n## Custom Routes\n\nWhen using HTTP transport, you might want to add custom web endpoints alongside your MCP server. This is useful for health checks, status pages, or simple APIs. FastMCP lets you add custom routes using the `@custom_route` decorator:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\n\nmcp = FastMCP(\"MyServer\")\n\n@mcp.custom_route(\"/health\", methods=[\"GET\"])\nasync def health_check(request: Request) -> PlainTextResponse:\n    return PlainTextResponse(\"OK\")\n\n@mcp.tool\ndef process(data: str) -> str:\n    return f\"Processed: {data}\"\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"http\")  # Health check at http://localhost:8000/health\n```\n\nCustom routes are served by the same web server as your MCP endpoint. They're available at the root of your domain while the MCP endpoint is at `/mcp/`. For more complex web applications, consider [mounting your MCP server into a FastAPI or Starlette app](/deployment/http#integration-with-web-frameworks).\n\n## Alternative Initialization Patterns\n\nThe `if __name__ == \"__main__\"` pattern works well for standalone scripts, but some deployment scenarios require different approaches. FastMCP handles these cases automatically.\n\n### CLI-Only Servers\n\nWhen using the FastMCP CLI, you don't need the `if __name__` block at all. The CLI will find your FastMCP instance and run it:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# server.py\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\"MyServer\")  # CLI looks for 'mcp', 'server', or 'app'\n\n@mcp.tool\ndef process(data: str) -> str:\n    return f\"Processed: {data}\"\n\n# No if __name__ block needed - CLI will find and run 'mcp'\n```\n\n### ASGI Applications\n\nFor ASGI deployment (running with Uvicorn or similar), you'll want to create an ASGI application object. This approach is common in production deployments where you need more control over the server configuration:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# app.py\nfrom fastmcp import FastMCP\n\ndef create_app():\n    mcp = FastMCP(\"MyServer\")\n    \n    @mcp.tool\n    def process(data: str) -> str:\n        return f\"Processed: {data}\"\n    \n    return mcp.http_app()\n\napp = create_app()  # Uvicorn will use this\n```\n\nSee the [HTTP Deployment](/deployment/http) guide for more ASGI deployment patterns.",
  "content_length": 11098
}