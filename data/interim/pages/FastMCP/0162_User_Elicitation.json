{
  "title": "User Elicitation",
  "source_url": "https://gofastmcp.com/servers/elicitation",
  "content": "Request structured input from users during tool execution through the MCP context.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.10.0\" />\n\nUser elicitation allows MCP servers to request structured input from users during tool execution. Instead of requiring all inputs upfront, tools can interactively ask for missing parameters, clarification, or additional context as needed.\n\n<Tip>\n  Most of the examples in this document assume you have a FastMCP server instance named `mcp` and show how to use the `ctx.elicit` method to request user input from an `@mcp.tool`-decorated function.\n</Tip>\n\n## What is Elicitation?\n\nElicitation enables tools to pause execution and request specific information from users. This is particularly useful for:\n\n* **Missing parameters**: Ask for required information not provided initially\n* **Clarification requests**: Get user confirmation or choices for ambiguous scenarios\n* **Progressive disclosure**: Collect complex information step-by-step\n* **Dynamic workflows**: Adapt tool behavior based on user responses\n\nFor example, a file management tool might ask \"Which directory should I create?\" or a data analysis tool might request \"What date range should I analyze?\"\n\n### Basic Usage\n\nUse the `ctx.elicit()` method within any tool function to request user input:\n\n```python {14-17} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Context\nfrom dataclasses import dataclass\n\nmcp = FastMCP(\"Elicitation Server\")\n\n@dataclass\nclass UserInfo:\n    name: str\n    age: int\n\n@mcp.tool\nasync def collect_user_info(ctx: Context) -> str:\n    \"\"\"Collect user information through interactive prompts.\"\"\"\n    result = await ctx.elicit(\n        message=\"Please provide your information\",\n        response_type=UserInfo\n    )\n    \n    if result.action == \"accept\":\n        user = result.data\n        return f\"Hello {user.name}, you are {user.age} years old\"\n    elif result.action == \"decline\":\n        return \"Information not provided\"\n    else:  # cancel\n        return \"Operation cancelled\"\n```\n\n## Method Signature\n\n<Card icon=\"code\" title=\"Context Elicitation Method\">\n  <ResponseField name=\"ctx.elicit\" type=\"async method\">\n    <Expandable title=\"Parameters\">\n      <ResponseField name=\"message\" type=\"str\">\n        The prompt message to display to the user\n      </ResponseField>\n\n      <ResponseField name=\"response_type\" type=\"type\" default=\"None\">\n        The Python type defining the expected response structure (dataclass, primitive type, etc.) Note that elicitation responses are subject to a restricted subset of JSON Schema types. See [Supported Response Types](#supported-response-types) for more details.\n      </ResponseField>\n    </Expandable>\n\n    <Expandable title=\"Response\">\n      <ResponseField name=\"ElicitationResult\" type=\"object\">\n        Result object containing the user's response\n\n        <Expandable title=\"properties\">\n          <ResponseField name=\"action\" type=\"Literal['accept', 'decline', 'cancel']\">\n            How the user responded to the request\n          </ResponseField>\n\n          <ResponseField name=\"data\" type=\"response_type | None\">\n            The user's input data (only present when action is \"accept\")\n          </ResponseField>\n        </Expandable>\n      </ResponseField>\n    </Expandable>\n  </ResponseField>\n</Card>\n\n## Elicitation Actions\n\nThe elicitation result contains an `action` field indicating how the user responded:\n\n* **`accept`**: User provided valid input - data is available in the `data` field\n* **`decline`**: User chose not to provide the requested information and the data field is `None`\n* **`cancel`**: User cancelled the entire operation and the data field is `None`\n\n```python {5, 7} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def my_tool(ctx: Context) -> str:\n    result = await ctx.elicit(\"Choose an action\")\n\n    if result.action == \"accept\":\n        return \"Accepted!\"\n    elif result.action == \"decline\":\n        return \"Declined!\"\n    else:\n        return \"Cancelled!\"\n```\n\nFastMCP also provides typed result classes for pattern matching on the `action` field:\n\n```python {1-5, 12, 14, 16} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.elicitation import (\n    AcceptedElicitation, \n    DeclinedElicitation, \n    CancelledElicitation,\n)\n\n@mcp.tool\nasync def pattern_example(ctx: Context) -> str:\n    result = await ctx.elicit(\"Enter your name:\", response_type=str)\n    \n    match result:\n        case AcceptedElicitation(data=name):\n            return f\"Hello {name}!\"\n        case DeclinedElicitation():\n            return \"No name provided\"\n        case CancelledElicitation():\n            return \"Operation cancelled\"\n```\n\n## Response Types\n\nThe server must send a schema to the client indicating the type of data it expects in response to the elicitation request. If the request is `accept`-ed, the client must send a response that matches the schema.\n\nThe MCP spec only supports a limited subset of JSON Schema types for elicitation responses. Specifically, it only supports JSON  **objects** with **primitive** properties including `string`, `number` (or `integer`), `boolean` and `enum` fields.\n\nFastMCP makes it easy to request a broader range of types, including scalars (e.g. `str`) or no response at all, by automatically wrapping them in MCP-compatible object schemas.\n\n### Scalar Types\n\nYou can request simple scalar data types for basic input, such as a string, integer, or boolean.\n\nWhen you request a scalar type, FastMCP automatically wraps it in an object schema for MCP spec compatibility. Clients will see a corresponding schema requesting a single \"value\" field of the requested type. Once clients respond, the provided object is \"unwrapped\" and the scalar value is returned to your tool function as the `data` field of the `ElicitationResult` object.\n\nAs a developer, this means you do not have to worry about creating or accessing a structured object when you only need a scalar value.\n\n<CodeGroup>\n  ```python {4} title=\"Request a string\" theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  @mcp.tool\n  async def get_user_name(ctx: Context) -> str:\n      \"\"\"Get the user's name.\"\"\"\n      result = await ctx.elicit(\"What's your name?\", response_type=str)\n      \n      if result.action == \"accept\":\n          return f\"Hello, {result.data}!\"\n      return \"No name provided\"\n  ```\n\n  ```python {4} title=\"Request an integer\" theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  @mcp.tool\n  async def pick_a_number(ctx: Context) -> str:\n      \"\"\"Pick a number.\"\"\"\n      result = await ctx.elicit(\"Pick a number!\", response_type=int)\n      \n      if result.action == \"accept\":\n          return f\"You picked {result.data}\"\n      return \"No number provided\"\n  ```\n\n  ```python {4} title=\"Request a boolean\" theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  @mcp.tool\n  async def pick_a_boolean(ctx: Context) -> str:\n      \"\"\"Pick a boolean.\"\"\"\n      result = await ctx.elicit(\"True or false?\", response_type=bool)\n      \n      if result.action == \"accept\":\n          return f\"You picked {result.data}\"\n      return \"No boolean provided\"\n  ```\n</CodeGroup>\n\n### No Response\n\nSometimes, the goal of an elicitation is to simply get a user to approve or reject an action. In this case, you can pass `None` as the response type to indicate that no response is expected. In order to comply with the MCP spec, the client will see a schema requesting an empty object in response. In this case, the `data` field of the `ElicitationResult` object will be `None` when the user accepts the elicitation.\n\n```python {4} title=\"No response\" theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def approve_action(ctx: Context) -> str:\n    \"\"\"Approve an action.\"\"\"\n    result = await ctx.elicit(\"Approve this action?\", response_type=None)\n\n    if result.action == \"accept\":\n        return do_action()\n    else:\n        raise ValueError(\"Action rejected\")\n```\n\n### Constrained Options\n\nOften you'll want to constrain the user's response to a specific set of values. You can do this by using a `Literal` type or a Python enum as the response type, or by passing a list of strings to the `response_type` parameter as a convenient shortcut.\n\n<CodeGroup>\n  ```python {6} title=\"Using a list of strings\" theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  @mcp.tool\n  async def set_priority(ctx: Context) -> str:\n      \"\"\"Set task priority level.\"\"\"\n      result = await ctx.elicit(\n          \"What priority level?\", \n          response_type=[\"low\", \"medium\", \"high\"],\n      )\n      \n      if result.action == \"accept\":\n          return f\"Priority set to: {result.data}\"\n  ```\n\n  ```python {1, 8} title=\"Using a Literal type\" theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from typing import Literal\n\n  @mcp.tool\n  async def set_priority(ctx: Context) -> str:\n      \"\"\"Set task priority level.\"\"\"\n      result = await ctx.elicit(\n          \"What priority level?\", \n          response_type=Literal[\"low\", \"medium\", \"high\"]\n      )\n      \n      if result.action == \"accept\":\n          return f\"Priority set to: {result.data}\"\n      return \"No priority set\"\n  ```\n\n  ```python {1, 11} title=\"Using a Python enum\" theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from enum import Enum\n\n  class Priority(Enum):\n      LOW = \"low\"\n      MEDIUM = \"medium\"\n      HIGH = \"high\"   \n\n  @mcp.tool\n  async def set_priority(ctx: Context) -> str:\n      \"\"\"Set task priority level.\"\"\"\n      result = await ctx.elicit(\"What priority level?\", response_type=Priority)\n      \n      if result.action == \"accept\":\n          return f\"Priority set to: {result.data.value}\"\n      return \"No priority set\"\n  ```\n</CodeGroup>\n\n### Structured Responses\n\nYou can request structured data with multiple fields by using a dataclass, typed dict, or Pydantic model as the response type. Note that the MCP spec only supports shallow objects with scalar (string, number, boolean) or enum properties.\n\n```python {1, 16, 20} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom dataclasses import dataclass\nfrom typing import Literal\n\n@dataclass\nclass TaskDetails:\n    title: str\n    description: str\n    priority: Literal[\"low\", \"medium\", \"high\"]\n    due_date: str\n\n@mcp.tool\nasync def create_task(ctx: Context) -> str:\n    \"\"\"Create a new task with user-provided details.\"\"\"\n    result = await ctx.elicit(\n        \"Please provide task details\",\n        response_type=TaskDetails\n    )\n    \n    if result.action == \"accept\":\n        task = result.data\n        return f\"Created task: {task.title} (Priority: {task.priority})\"\n    return \"Task creation cancelled\"\n```\n\n## Multi-Turn Elicitation\n\nTools can make multiple elicitation calls to gather information progressively:\n\n```python {6, 11, 16-19} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def plan_meeting(ctx: Context) -> str:\n    \"\"\"Plan a meeting by gathering details step by step.\"\"\"\n    \n    # Get meeting title\n    title_result = await ctx.elicit(\"What's the meeting title?\", response_type=str)\n    if title_result.action != \"accept\":\n        return \"Meeting planning cancelled\"\n    \n    # Get duration\n    duration_result = await ctx.elicit(\"Duration in minutes?\", response_type=int)\n    if duration_result.action != \"accept\":\n        return \"Meeting planning cancelled\"\n    \n    # Get priority\n    priority_result = await ctx.elicit(\n        \"Is this urgent?\", \n        response_type=Literal[\"yes\", \"no\"]\n    )\n    if priority_result.action != \"accept\":\n        return \"Meeting planning cancelled\"\n    \n    urgent = priority_result.data == \"yes\"\n    return f\"Meeting '{title_result.data}' planned for {duration_result.data} minutes (Urgent: {urgent})\"\n```\n\n## Client Requirements\n\nElicitation requires the client to implement an elicitation handler. See [Client Elicitation](/clients/elicitation) for details on how clients can handle these requests.\n\nIf a client doesn't support elicitation, calls to `ctx.elicit()` will raise an error indicating that elicitation is not supported.",
  "content_length": 12455
}