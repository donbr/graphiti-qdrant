{
  "title": "Client Logging",
  "source_url": "https://gofastmcp.com/servers/logging",
  "content": "Send log messages back to MCP clients through the context.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<Tip>\n  This documentation covers **MCP client logging** - sending messages from your server to MCP clients. For standard server-side logging (e.g., writing to files, console), use `fastmcp.utilities.logging.get_logger()` or Python's built-in `logging` module.\n</Tip>\n\nServer logging allows MCP tools to send debug, info, warning, and error messages back to the client. This provides visibility into function execution and helps with debugging during development and operation.\n\n## Why Use Server Logging?\n\nServer logging is essential for:\n\n* **Debugging**: Send detailed execution information to help diagnose issues\n* **Progress visibility**: Keep users informed about what the tool is doing\n* **Error reporting**: Communicate problems and their context to clients\n* **Audit trails**: Create records of tool execution for compliance or analysis\n\nUnlike standard Python logging, MCP server logging sends messages directly to the client, making them visible in the client's interface or logs.\n\n### Basic Usage\n\nUse the context logging methods within any tool function:\n\n```python {8-9, 13, 17, 21} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(\"LoggingDemo\")\n\n@mcp.tool\nasync def analyze_data(data: list[float], ctx: Context) -> dict:\n    \"\"\"Analyze numerical data with comprehensive logging.\"\"\"\n    await ctx.debug(\"Starting analysis of numerical data\")\n    await ctx.info(f\"Analyzing {len(data)} data points\")\n    \n    try:\n        if not data:\n            await ctx.warning(\"Empty data list provided\")\n            return {\"error\": \"Empty data list\"}\n        \n        result = sum(data) / len(data)\n        await ctx.info(f\"Analysis complete, average: {result}\")\n        return {\"average\": result, \"count\": len(data)}\n        \n    except Exception as e:\n        await ctx.error(f\"Analysis failed: {str(e)}\")\n        raise\n```\n\n## Structured Logging with `extra`\n\nAll logging methods (`debug`, `info`, `warning`, `error`, `log`) now accept an `extra` parameter, which is a dictionary of arbitrary data. This allows you to send structured data to the client, which is useful for creating rich, queryable logs.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def process_transaction(transaction_id: str, amount: float, ctx: Context):\n    await ctx.info(\n        f\"Processing transaction {transaction_id}\",\n        extra={\n            \"transaction_id\": transaction_id,\n            \"amount\": amount,\n            \"currency\": \"USD\"\n        }\n    )\n    # ... processing logic ...\n```\n\n## Server Logs\n\nClient Logging in the form of `ctx.log()` and its convenience methods (`debug`, `info`, `warning`, `error`) are meant for sending messages to the MCP clients. Messages sent to clients are also logged to the server's log at `DEBUG` level. Enable debug logging on the server or enable debug logging on the `fastmcp.server.context.to_client` logger to see these messages in the server's log.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport logging\n\nfrom fastmcp.utilities.logging import get_logger\n\nto_client_logger = get_logger(name=\"fastmcp.server.context.to_client\")\nto_client_logger.setLevel(level=logging.DEBUG)\n```\n\n## Logging Methods\n\n<Card icon=\"code\" title=\"Context Logging Methods\">\n  <ResponseField name=\"ctx.debug\" type=\"async method\">\n    Send debug-level messages for detailed execution information\n\n    <Expandable title=\"parameters\">\n      <ResponseField name=\"message\" type=\"str\">\n        The debug message to send to the client\n      </ResponseField>\n\n      <ResponseField name=\"extra\" type=\"dict | None\" default=\"None\">\n        Optional dictionary for structured logging data\n      </ResponseField>\n    </Expandable>\n  </ResponseField>\n\n  <ResponseField name=\"ctx.info\" type=\"async method\">\n    Send informational messages about normal execution\n\n    <Expandable title=\"parameters\">\n      <ResponseField name=\"message\" type=\"str\">\n        The information message to send to the client\n      </ResponseField>\n\n      <ResponseField name=\"extra\" type=\"dict | None\" default=\"None\">\n        Optional dictionary for structured logging data\n      </ResponseField>\n    </Expandable>\n  </ResponseField>\n\n  <ResponseField name=\"ctx.warning\" type=\"async method\">\n    Send warning messages for potential issues that didn't prevent execution\n\n    <Expandable title=\"parameters\">\n      <ResponseField name=\"message\" type=\"str\">\n        The warning message to send to the client\n      </ResponseField>\n\n      <ResponseField name=\"extra\" type=\"dict | None\" default=\"None\">\n        Optional dictionary for structured logging data\n      </ResponseField>\n    </Expandable>\n  </ResponseField>\n\n  <ResponseField name=\"ctx.error\" type=\"async method\">\n    Send error messages for problems that occurred during execution\n\n    <Expandable title=\"parameters\">\n      <ResponseField name=\"message\" type=\"str\">\n        The error message to send to the client\n      </ResponseField>\n\n      <ResponseField name=\"extra\" type=\"dict | None\" default=\"None\">\n        Optional dictionary for structured logging data\n      </ResponseField>\n    </Expandable>\n  </ResponseField>\n\n  <ResponseField name=\"ctx.log\" type=\"async method\">\n    Generic logging method with custom level and logger name\n\n    <Expandable title=\"parameters\">\n      <ResponseField name=\"level\" type=\"Literal['debug', 'info', 'warning', 'error']\">\n        The log level for the message\n      </ResponseField>\n\n      <ResponseField name=\"message\" type=\"str\">\n        The message to send to the client\n      </ResponseField>\n\n      <ResponseField name=\"logger_name\" type=\"str | None\" default=\"None\">\n        Optional custom logger name for categorizing messages\n      </ResponseField>\n\n      <ResponseField name=\"extra\" type=\"dict | None\" default=\"None\">\n        Optional dictionary for structured logging data\n      </ResponseField>\n    </Expandable>\n  </ResponseField>\n</Card>\n\n## Log Levels\n\n### Debug\n\nUse for detailed information that's typically only useful when diagnosing problems:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def process_file(file_path: str, ctx: Context) -> str:\n    \"\"\"Process a file with detailed debug logging.\"\"\"\n    await ctx.debug(f\"Starting to process file: {file_path}\")\n    await ctx.debug(\"Checking file permissions\")\n    \n    # File processing logic\n    await ctx.debug(\"File processing completed successfully\")\n    return \"File processed\"\n```\n\n### Info\n\nUse for general information about normal program execution:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def backup_database(ctx: Context) -> str:\n    \"\"\"Backup database with progress information.\"\"\"\n    await ctx.info(\"Starting database backup\")\n    await ctx.info(\"Connecting to database\")\n    await ctx.info(\"Backup completed successfully\")\n    return \"Database backed up\"\n```\n\n### Warning\n\nUse for potentially harmful situations that don't prevent execution:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def validate_config(config: dict, ctx: Context) -> dict:\n    \"\"\"Validate configuration with warnings for deprecated options.\"\"\"\n    if \"old_api_key\" in config:\n        await ctx.warning(\n            \"Using deprecated 'old_api_key' field. Please use 'api_key' instead\",\n            extra={\"deprecated_field\": \"old_api_key\"}\n        )\n    \n    if config.get(\"timeout\", 30) > 300:\n        await ctx.warning(\n            \"Timeout value is very high (>5 minutes), this may cause issues\",\n            extra={\"timeout_value\": config.get(\"timeout\")}\n        )\n    \n    return {\"status\": \"valid\", \"warnings\": \"see logs\"}\n```\n\n### Error\n\nUse for error events that might still allow the application to continue:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def batch_process(items: list[str], ctx: Context) -> dict:\n    \"\"\"Process multiple items, logging errors for failed items.\"\"\"\n    successful = 0\n    failed = 0\n    \n    for item in items:\n        try:\n            # Process item\n            successful += 1\n        except Exception as e:\n            await ctx.error(\n                f\"Failed to process item '{item}': {str(e)}\",\n                extra={\"failed_item\": item}\n            )\n            failed += 1\n    \n    return {\"successful\": successful, \"failed\": failed}\n```\n\n## Client Handling\n\nLog messages are sent to the client through the MCP protocol. How clients handle these messages depends on their implementation:\n\n* **Development clients**: May display logs in real-time for debugging\n* **Production clients**: May store logs for later analysis or display to users\n* **Integration clients**: May forward logs to external logging systems\n\nSee [Client Logging](/clients/logging) for details on how clients can handle server log messages.",
  "content_length": 9280
}