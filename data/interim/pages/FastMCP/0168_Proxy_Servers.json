{
  "title": "Proxy Servers",
  "source_url": "https://gofastmcp.com/servers/proxy",
  "content": "Use FastMCP to act as an intermediary or change transport for other MCP servers.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span> \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.0.0\" />\n\nFastMCP provides a powerful proxying capability that allows one FastMCP server instance to act as a frontend for another MCP server (which could be remote, running on a different transport, or even another FastMCP instance). This is achieved using the `FastMCP.as_proxy()` class method.\n\n## What is Proxying?\n\nProxying means setting up a FastMCP server that doesn't implement its own tools or resources directly. Instead, when it receives a request (like `tools/call` or `resources/read`), it forwards that request to a *backend* MCP server, receives the response, and then relays that response back to the original client.\n\n```mermaid  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nsequenceDiagram\n    participant ClientApp as Your Client (e.g., Claude Desktop)\n    participant FastMCPProxy as FastMCP Proxy Server\n    participant BackendServer as Backend MCP Server (e.g., remote SSE)\n\n    ClientApp->>FastMCPProxy: MCP Request (e.g. stdio)\n    Note over FastMCPProxy, BackendServer: Proxy forwards the request\n    FastMCPProxy->>BackendServer: MCP Request (e.g. sse)\n    BackendServer-->>FastMCPProxy: MCP Response (e.g. sse)\n    Note over ClientApp, FastMCPProxy: Proxy relays the response\n    FastMCPProxy-->>ClientApp: MCP Response (e.g. stdio)\n```\n\n### Key Benefits\n\n<VersionBadge version=\"2.10.3\" />\n\n* **Session Isolation**: Each request gets its own isolated session, ensuring safe concurrent operations\n* **Transport Bridging**: Expose servers running on one transport via a different transport\n* **Advanced MCP Features**: Automatic forwarding of sampling, elicitation, logging, and progress\n* **Security**: Acts as a controlled gateway to backend servers\n* **Simplicity**: Single endpoint even if backend location or transport changes\n\n### Performance Considerations\n\nWhen using proxy servers, especially those connecting to HTTP-based backend servers, be aware that latency can be significant. Operations like `list_tools()` may take hundreds of milliseconds compared to 1-2ms for local tools. When mounting proxy servers, this latency affects all operations on the parent server, not just interactions with the proxied tools.\n\nIf low latency is a requirement for your use-case, consider using [`import_server()`](/servers/composition#importing-static-composition) to copy tools at startup rather than proxying them at runtime.\n\n## Quick Start\n\n<VersionBadge version=\"2.10.3\" />\n\nThe recommended way to create a proxy is using `ProxyClient`, which provides full MCP feature support with automatic session isolation:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.proxy import ProxyClient\n\n# Create a proxy with full MCP feature support\nproxy = FastMCP.as_proxy(\n    ProxyClient(\"backend_server.py\"),\n    name=\"MyProxy\"\n)\n\n# Run the proxy (e.g., via stdio for Claude Desktop)\nif __name__ == \"__main__\":\n    proxy.run()\n```\n\nThis single setup gives you:\n\n* Safe concurrent request handling\n* Automatic forwarding of advanced MCP features (sampling, elicitation, etc.)\n* Session isolation to prevent context mixing\n* Full compatibility with all MCP clients\n\nYou can also pass a FastMCP [client transport](/clients/transports) (or parameter that can be inferred to a transport) to `as_proxy()`. This will automatically create a `ProxyClient` instance for you.\n\nFinally, you can pass a regular FastMCP `Client` instance to `as_proxy()`. This will work for many use cases, but may break if advanced MCP features like sampling or elicitation are invoked by the server.\n\n## Session Isolation & Concurrency\n\n<VersionBadge version=\"2.10.3\" />\n\nFastMCP proxies provide session isolation to ensure safe concurrent operations. The session strategy depends on how the proxy is configured:\n\n### Fresh Sessions\n\nWhen you pass a disconnected client (which is the normal case), each request gets its own isolated backend session:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.proxy import ProxyClient\n\n# Each request creates a fresh backend session (recommended)\nproxy = FastMCP.as_proxy(ProxyClient(\"backend_server.py\"))\n\n# Multiple clients can use this proxy simultaneously without interference:\n# - Client A calls a tool -> gets isolated backend session\n# - Client B calls a tool -> gets different isolated backend session  \n# - No context mixing between requests\n```\n\n### Session Reuse with Connected Clients\n\nWhen you pass an already-connected client, the proxy will reuse that session for all requests:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import Client\n\n# Create and connect a client\nasync with Client(\"backend_server.py\") as connected_client:\n    # This proxy will reuse the connected session for all requests\n    proxy = FastMCP.as_proxy(connected_client)\n    \n    # ⚠️ Warning: All requests share the same backend session\n    # This may cause context mixing in concurrent scenarios\n```\n\n**Important**: Using shared sessions with concurrent requests from multiple clients may lead to context mixing and race conditions. This approach should only be used in single-threaded scenarios or when you have explicit synchronization.\n\n## Transport Bridging\n\nA common use case is bridging transports - exposing a server running on one transport via a different transport. For example, making a remote SSE server available locally via stdio:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.proxy import ProxyClient\n\n# Bridge remote SSE server to local stdio\nremote_proxy = FastMCP.as_proxy(\n    ProxyClient(\"http://example.com/mcp/sse\"),\n    name=\"Remote-to-Local Bridge\"\n)\n\n# Run locally via stdio for Claude Desktop\nif __name__ == \"__main__\":\n    remote_proxy.run()  # Defaults to stdio transport\n```\n\nOr expose a local server via HTTP for remote access:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Bridge local server to HTTP\nlocal_proxy = FastMCP.as_proxy(\n    ProxyClient(\"local_server.py\"),\n    name=\"Local-to-HTTP Bridge\"\n)\n\n# Run via HTTP for remote clients\nif __name__ == \"__main__\":\n    local_proxy.run(transport=\"http\", host=\"0.0.0.0\", port=8080)\n```\n\n## Advanced MCP Features\n\n<VersionBadge version=\"2.10.3\" />\n\n`ProxyClient` automatically forwards advanced MCP protocol features between the backend server and clients connected to the proxy, ensuring full MCP compatibility.\n\n### Supported Features\n\n* **Roots**: Forwards filesystem root access requests to the client\n* **Sampling**: Forwards LLM completion requests from backend to client\n* **Elicitation**: Forwards user input requests to the client\n* **Logging**: Forwards log messages from backend through to client\n* **Progress**: Forwards progress notifications during long operations\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.proxy import ProxyClient\n\n# ProxyClient automatically handles all these features\nbackend = ProxyClient(\"advanced_backend.py\")\nproxy = FastMCP.as_proxy(backend)\n\n# When the backend server:\n# - Requests LLM sampling -> forwarded to your client\n# - Logs messages -> appear in your client\n# - Reports progress -> shown in your client\n# - Needs user input -> prompts your client\n```\n\n### Customizing Feature Support\n\nYou can selectively disable forwarding by passing `None` for specific handlers:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Disable sampling but keep other features\nbackend = ProxyClient(\n    \"backend_server.py\",\n    sampling_handler=None,  # Disable LLM sampling forwarding\n    log_handler=None        # Disable log forwarding\n)\n```\n\nWhen you use a transport string directly with `FastMCP.as_proxy()`, it automatically creates a `ProxyClient` internally to ensure full feature support.\n\n## Configuration-Based Proxies\n\n<VersionBadge version=\"2.4.0\" />\n\nYou can create a proxy directly from a configuration dictionary that follows the MCPConfig schema. This is useful for quickly setting up proxies to remote servers without manually configuring each connection detail.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\n# Create a proxy directly from a config dictionary\nconfig = {\n    \"mcpServers\": {\n        \"default\": {  # For single server configs, 'default' is commonly used\n            \"url\": \"https://example.com/mcp\",\n            \"transport\": \"http\"\n        }\n    }\n}\n\n# Create a proxy to the configured server (auto-creates ProxyClient)\nproxy = FastMCP.as_proxy(config, name=\"Config-Based Proxy\")\n\n# Run the proxy with stdio transport for local access\nif __name__ == \"__main__\":\n    proxy.run()\n```\n\n<Note>\n  The MCPConfig format follows an emerging standard for MCP server configuration and may evolve as the specification matures. While FastMCP aims to maintain compatibility with future versions, be aware that field names or structure might change.\n</Note>\n\n### Multi-Server Configurations\n\nYou can create a proxy to multiple servers by specifying multiple entries in the config. They are automatically mounted with their config names as prefixes:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Multi-server configuration\nconfig = {\n    \"mcpServers\": {\n        \"weather\": {\n            \"url\": \"https://weather-api.example.com/mcp\",\n            \"transport\": \"http\"\n        },\n        \"calendar\": {\n            \"url\": \"https://calendar-api.example.com/mcp\",\n            \"transport\": \"http\"\n        }\n    }\n}\n\n# Create a unified proxy to multiple servers\ncomposite_proxy = FastMCP.as_proxy(config, name=\"Composite Proxy\")\n\n# Tools, resources, prompts, and templates are accessible with prefixes:\n# - Tools: weather_get_forecast, calendar_add_event\n# - Prompts: weather_daily_summary, calendar_quick_add\n# - Resources: weather://weather/icons/sunny, calendar://calendar/events/today\n# - Templates: weather://weather/locations/{id}, calendar://calendar/events/{date}\n```\n\n## Component Prefixing\n\nWhen proxying one or more servers, component names are prefixed the same way as with mounting and importing:\n\n* Tools: `{prefix}_{tool_name}`\n* Prompts: `{prefix}_{prompt_name}`\n* Resources: `protocol://{prefix}/path/to/resource` (default path format)\n* Resource templates: `protocol://{prefix}/...` and template names are also prefixed\n\nThese rules apply uniformly whether you:\n\n* Mount a proxy on another server\n* Create a multi-server proxy from an `MCPConfig`\n* Use `FastMCP.as_proxy()` directly\n\nFor resource URI prefix formats (path vs legacy protocol style) and configuration options, see Server Composition → Resource Prefix Formats.\n\n## Mirrored Components\n\n<VersionBadge version=\"2.10.5\" />\n\nWhen you access tools, resources, or prompts from a proxy server, they are \"mirrored\" from the remote server. Mirrored components cannot be modified directly since they reflect the state of the remote server. For example, you can not simply \"disable\" a mirrored component.\n\nHowever, you can create a copy of a mirrored component and store it as a new locally-defined component. Local components always take precedence over mirrored ones because the proxy server will check its own registry before it attempts to engage the remote server.\n\nTherefore, to enable or disable a proxy tool, resource, or prompt, you should first create a local copy and add it to your own server. Here's an example of how to do that for a tool:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Create your own server\nmy_server = FastMCP(\"MyServer\")\n\n# Get a proxy server\nproxy = FastMCP.as_proxy(\"backend_server.py\")\n\n# Get mirrored components from proxy\nmirrored_tool = await proxy.get_tool(\"useful_tool\")\n\n# Create a local copy that you can modify\nlocal_tool = mirrored_tool.copy()\n\n# Add the local copy to your server\nmy_server.add_tool(local_tool)\n\n# Now you can disable YOUR copy\nlocal_tool.disable()\n```\n\n## `FastMCPProxy` Class\n\nInternally, `FastMCP.as_proxy()` uses the `FastMCPProxy` class. You generally don't need to interact with this class directly, but it's available if needed for advanced scenarios.\n\n### Direct Usage\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.proxy import FastMCPProxy, ProxyClient\n\n# Provide a client factory for explicit session control\ndef create_client():\n    return ProxyClient(\"backend_server.py\")\n\nproxy = FastMCPProxy(client_factory=create_client)\n```\n\n### Parameters\n\n* **`client`**: **\\[DEPRECATED]** A `Client` instance. Use `client_factory` instead for explicit session management.\n* **`client_factory`**: A callable that returns a `Client` instance when called. This gives you full control over session creation and reuse strategies.\n\n### Explicit Session Management\n\n`FastMCPProxy` requires explicit session management - no automatic detection is performed. You must choose your session strategy:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Share session across all requests (be careful with concurrency)\nshared_client = ProxyClient(\"backend_server.py\")\ndef shared_session_factory():\n    return shared_client\n\nproxy = FastMCPProxy(client_factory=shared_session_factory)\n\n# Create fresh sessions per request (recommended)\ndef fresh_session_factory():\n    return ProxyClient(\"backend_server.py\")\n\nproxy = FastMCPProxy(client_factory=fresh_session_factory)\n```\n\nFor automatic session strategy selection, use the convenience method `FastMCP.as_proxy()` instead.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Custom factory with specific configuration\ndef custom_client_factory():\n    client = ProxyClient(\"backend_server.py\")\n    # Add any custom configuration here\n    return client\n\nproxy = FastMCPProxy(client_factory=custom_client_factory)\n```",
  "content_length": 14294
}