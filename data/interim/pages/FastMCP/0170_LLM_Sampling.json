{
  "title": "LLM Sampling",
  "source_url": "https://gofastmcp.com/servers/sampling",
  "content": "Request LLM text generation from the client or a configured provider through the MCP context.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.0.0\" />\n\nLLM sampling allows MCP tools to request LLM text generation based on provided messages. By default, sampling requests are sent to the client's LLM, but you can also configure a fallback handler or always use a specific LLM provider. This is useful when tools need to leverage LLM capabilities to process data, generate responses, or perform text-based analysis.\n\n## Why Use LLM Sampling?\n\nLLM sampling enables tools to:\n\n* **Leverage AI capabilities**: Use the client's LLM for text generation and analysis\n* **Offload complex reasoning**: Let the LLM handle tasks requiring natural language understanding\n* **Generate dynamic content**: Create responses, summaries, or transformations based on data\n* **Maintain context**: Use the same LLM instance that the user is already interacting with\n\n### Basic Usage\n\nUse `ctx.sample()` to request text generation from the client's LLM:\n\n```python {14} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(\"SamplingDemo\")\n\n@mcp.tool\nasync def analyze_sentiment(text: str, ctx: Context) -> dict:\n    \"\"\"Analyze the sentiment of text using the client's LLM.\"\"\"\n    prompt = f\"\"\"Analyze the sentiment of the following text as positive, negative, or neutral. \n    Just output a single word - 'positive', 'negative', or 'neutral'.\n    \n    Text to analyze: {text}\"\"\"\n    \n    # Request LLM analysis\n    response = await ctx.sample(prompt)\n    \n    # Process the LLM's response\n    sentiment = response.text.strip().lower()\n    \n    # Map to standard sentiment values\n    if \"positive\" in sentiment:\n        sentiment = \"positive\"\n    elif \"negative\" in sentiment:\n        sentiment = \"negative\"\n    else:\n        sentiment = \"neutral\"\n    \n    return {\"text\": text, \"sentiment\": sentiment}\n```\n\n## Method Signature\n\n<Card icon=\"code\" title=\"Context Sampling Method\">\n  <ResponseField name=\"ctx.sample\" type=\"async method\">\n    Request text generation from the client's LLM\n\n    <Expandable title=\"Parameters\">\n      <ResponseField name=\"messages\" type=\"str | list[str | SamplingMessage]\">\n        A string or list of strings/message objects to send to the LLM\n      </ResponseField>\n\n      <ResponseField name=\"system_prompt\" type=\"str | None\" default=\"None\">\n        Optional system prompt to guide the LLM's behavior\n      </ResponseField>\n\n      <ResponseField name=\"temperature\" type=\"float | None\" default=\"None\">\n        Optional sampling temperature (controls randomness, typically 0.0-1.0)\n      </ResponseField>\n\n      <ResponseField name=\"max_tokens\" type=\"int | None\" default=\"512\">\n        Optional maximum number of tokens to generate\n      </ResponseField>\n\n      <ResponseField name=\"model_preferences\" type=\"ModelPreferences | str | list[str] | None\" default=\"None\">\n        Optional model selection preferences (e.g., model hint string, list of hints, or ModelPreferences object)\n      </ResponseField>\n    </Expandable>\n\n    <Expandable title=\"Response\">\n      <ResponseField name=\"response\" type=\"TextContent | ImageContent\">\n        The LLM's response content (typically TextContent with a .text attribute)\n      </ResponseField>\n    </Expandable>\n  </ResponseField>\n</Card>\n\n## Simple Text Generation\n\n### Basic Prompting\n\nGenerate text with simple string prompts:\n\n```python {6} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def generate_summary(content: str, ctx: Context) -> str:\n    \"\"\"Generate a summary of the provided content.\"\"\"\n    prompt = f\"Please provide a concise summary of the following content:\\n\\n{content}\"\n    \n    response = await ctx.sample(prompt)\n    return response.text\n```\n\n### System Prompt\n\nUse system prompts to guide the LLM's behavior:\n\n````python {4-9} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def generate_code_example(concept: str, ctx: Context) -> str:\n    \"\"\"Generate a Python code example for a given concept.\"\"\"\n    response = await ctx.sample(\n        messages=f\"Write a simple Python code example demonstrating '{concept}'.\",\n        system_prompt=\"You are an expert Python programmer. Provide concise, working code examples without explanations.\",\n        temperature=0.7,\n        max_tokens=300\n    )\n    \n    code_example = response.text\n    return f\"```python\\n{code_example}\\n```\"\n````\n\n### Model Preferences\n\nSpecify model preferences for different use cases:\n\n```python {4-8, 17-22} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\nasync def creative_writing(topic: str, ctx: Context) -> str:\n    \"\"\"Generate creative content using a specific model.\"\"\"\n    response = await ctx.sample(\n        messages=f\"Write a creative short story about {topic}\",\n        model_preferences=\"claude-3-sonnet\",  # Prefer a specific model\n        include_context=\"thisServer\",  # Use the server's context\n        temperature=0.9,  # High creativity\n        max_tokens=1000\n    )\n    \n    return response.text\n\n@mcp.tool\nasync def technical_analysis(data: str, ctx: Context) -> str:\n    \"\"\"Perform technical analysis with a reasoning-focused model.\"\"\"\n    response = await ctx.sample(\n        messages=f\"Analyze this technical data and provide insights: {data}\",\n        model_preferences=[\"claude-3-opus\", \"gpt-4\"],  # Prefer reasoning models\n        temperature=0.2,  # Low randomness for consistency\n        max_tokens=800\n    )\n    \n    return response.text\n```\n\n### Complex Message Structures\n\nUse structured messages for more complex interactions:\n\n```python {1, 6-10} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.client.sampling import SamplingMessage\n\n@mcp.tool\nasync def multi_turn_analysis(user_query: str, context_data: str, ctx: Context) -> str:\n    \"\"\"Perform analysis using multi-turn conversation structure.\"\"\"\n    messages = [\n        SamplingMessage(role=\"user\", content=f\"I have this data: {context_data}\"),\n        SamplingMessage(role=\"assistant\", content=\"I can see your data. What would you like me to analyze?\"),\n        SamplingMessage(role=\"user\", content=user_query)\n    ]\n    \n    response = await ctx.sample(\n        messages=messages,\n        system_prompt=\"You are a data analyst. Provide detailed insights based on the conversation context.\",\n        temperature=0.3\n    )\n    \n    return response.text\n```\n\n## Sampling Fallback Handler\n\nClient support for sampling is optional. If the client does not support sampling, the server will report an error indicating that the client does not support sampling.\n\nHowever, you can provide a `sampling_handler` to the FastMCP server, which sends sampling requests directly to an LLM provider instead of routing through the client. The `sampling_handler_behavior` parameter controls when this handler is used:\n\n* **`\"fallback\"`** (default): Uses the handler only when the client doesn't support sampling. Requests go to the client first, falling back to the handler if needed.\n* **`\"always\"`**: Always uses the handler, bypassing the client entirely. Useful when you want full control over the LLM used for sampling.\n\nSampling handlers can be implemented using any LLM provider, but a sample implementation for OpenAI is provided as a Contrib module. Sampling lacks the full capabilities of typical LLM completions. For this reason, the OpenAI sampling handler, pointed at a third-party provider's OpenAI-compatible API, is often sufficient to implement a sampling handler.\n\n### Fallback Mode (Default)\n\nUses the handler only when the client doesn't support sampling:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport asyncio\nimport os\n\nfrom mcp.types import ContentBlock\nfrom openai import OpenAI\n\nfrom fastmcp import FastMCP\nfrom fastmcp.experimental.sampling.handlers.openai import OpenAISamplingHandler\nfrom fastmcp.server.context import Context\n\n\nasync def async_main():\n    server = FastMCP(\n        name=\"OpenAI Sampling Fallback Example\",\n        sampling_handler=OpenAISamplingHandler(\n            default_model=\"gpt-4o-mini\",\n            client=OpenAI(\n                api_key=os.getenv(\"API_KEY\"),\n                base_url=os.getenv(\"BASE_URL\"),\n            ),\n        ),\n        sampling_handler_behavior=\"fallback\",  # Default - only use when client doesn't support sampling\n    )\n\n    @server.tool\n    async def test_sample_fallback(ctx: Context) -> ContentBlock:\n        # Will use client's LLM if available, otherwise falls back to the handler\n        return await ctx.sample(\n            messages=[\"hello world!\"],\n        )\n\n    await server.run_http_async()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(async_main())\n```\n\n### Always Mode\n\nAlways uses the handler, bypassing the client:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nserver = FastMCP(\n    name=\"Server-Controlled Sampling\",\n    sampling_handler=OpenAISamplingHandler(\n        default_model=\"gpt-4o-mini\",\n        client=OpenAI(api_key=os.getenv(\"API_KEY\")),\n    ),\n    sampling_handler_behavior=\"always\",  # Always use the handler, never the client\n)\n\n@server.tool\nasync def analyze_data(data: str, ctx: Context) -> str:\n    # Will ALWAYS use the server's configured LLM, not the client's\n    result = await ctx.sample(\n        messages=f\"Analyze this data: {data}\",\n        system_prompt=\"You are a data analyst.\",\n    )\n    return result.text\n```\n\n## Client Requirements\n\nBy default, LLM sampling requires client support:\n\n* Clients must implement sampling handlers to process requests (see [Client Sampling](/clients/sampling))\n* If the client doesn't support sampling and no fallback handler is configured, `ctx.sample()` will raise an error\n* Configure a `sampling_handler` with `sampling_handler_behavior=\"fallback\"` to automatically handle clients that don't support sampling\n* Use `sampling_handler_behavior=\"always\"` to completely bypass the client and control which LLM is used",
  "content_length": 10316
}