{
  "title": "Tools",
  "source_url": "https://gofastmcp.com/servers/tools",
  "content": "Expose functions as executable capabilities for your MCP client.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span> \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\nTools are the core building blocks that allow your LLM to interact with external systems, execute code, and access data that isn't in its training data. In FastMCP, tools are Python functions exposed to LLMs through the MCP protocol.\n\nTools in FastMCP transform regular Python functions into capabilities that LLMs can invoke during conversations. When an LLM decides to use a tool:\n\n1. It sends a request with parameters based on the tool's schema.\n2. FastMCP validates these parameters against your function's signature.\n3. Your function executes with the validated inputs.\n4. The result is returned to the LLM, which can use it in its response.\n\nThis allows LLMs to perform tasks like querying databases, calling APIs, making calculations, or accessing files—extending their capabilities beyond what's in their training data.\n\n## The `@tool` Decorator\n\nCreating a tool is as simple as decorating a Python function with `@mcp.tool`:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"CalculatorServer\")\n\n@mcp.tool\ndef add(a: int, b: int) -> int:\n    \"\"\"Adds two integer numbers together.\"\"\"\n    return a + b\n```\n\nWhen this tool is registered, FastMCP automatically:\n\n* Uses the function name (`add`) as the tool name.\n* Uses the function's docstring (`Adds two integer numbers...`) as the tool description.\n* Generates an input schema based on the function's parameters and type annotations.\n* Handles parameter validation and error reporting.\n\nThe way you define your Python function dictates how the tool appears and behaves for the LLM client.\n\n<Tip>\n  Functions with `*args` or `**kwargs` are not supported as tools. This restriction exists because FastMCP needs to generate a complete parameter schema for the MCP protocol, which isn't possible with variable argument lists.\n</Tip>\n\n### Decorator Arguments\n\nWhile FastMCP infers the name and description from your function, you can override these and add additional metadata using arguments to the `@mcp.tool` decorator:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool(\n    name=\"find_products\",           # Custom tool name for the LLM\n    description=\"Search the product catalog with optional category filtering.\", # Custom description\n    tags={\"catalog\", \"search\"},      # Optional tags for organization/filtering\n    meta={\"version\": \"1.2\", \"author\": \"product-team\"}  # Custom metadata\n)\ndef search_products_implementation(query: str, category: str | None = None) -> list[dict]:\n    \"\"\"Internal function description (ignored if description is provided above).\"\"\"\n    # Implementation...\n    print(f\"Searching for '{query}' in category '{category}'\")\n    return [{\"id\": 2, \"name\": \"Another Product\"}]\n```\n\n<Card icon=\"code\" title=\"@tool Decorator Arguments\">\n  <ParamField body=\"name\" type=\"str | None\">\n    Sets the explicit tool name exposed via MCP. If not provided, uses the function name\n  </ParamField>\n\n  <ParamField body=\"description\" type=\"str | None\">\n    Provides the description exposed via MCP. If set, the function's docstring is ignored for this purpose\n  </ParamField>\n\n  <ParamField body=\"tags\" type=\"set[str] | None\">\n    A set of strings used to categorize the tool. These can be used by the server and, in some cases, by clients to filter or group available tools.\n  </ParamField>\n\n  <ParamField body=\"enabled\" type=\"bool\" default=\"True\">\n    A boolean to enable or disable the tool. See [Disabling Tools](#disabling-tools) for more information\n  </ParamField>\n\n  <ParamField body=\"icons\" type=\"list[Icon] | None\">\n    <VersionBadge version=\"2.14.0\" />\n\n    Optional list of icon representations for this tool. See [Icons](/servers/icons) for detailed examples\n  </ParamField>\n\n  <ParamField body=\"exclude_args\" type=\"list[str] | None\">\n    A list of argument names to exclude from the tool schema shown to the LLM. See [Excluding Arguments](#excluding-arguments) for more information\n  </ParamField>\n\n  <ParamField body=\"annotations\" type=\"ToolAnnotations | dict | None\">\n    An optional `ToolAnnotations` object or dictionary to add additional metadata about the tool.\n\n    <Expandable title=\"ToolAnnotations attributes\">\n      <ParamField body=\"title\" type=\"str | None\">\n        A human-readable title for the tool.\n      </ParamField>\n\n      <ParamField body=\"readOnlyHint\" type=\"bool | None\">\n        If true, the tool does not modify its environment.\n      </ParamField>\n\n      <ParamField body=\"destructiveHint\" type=\"bool | None\">\n        If true, the tool may perform destructive updates to its environment.\n      </ParamField>\n\n      <ParamField body=\"idempotentHint\" type=\"bool | None\">\n        If true, calling the tool repeatedly with the same arguments will have no additional effect on the its environment.\n      </ParamField>\n\n      <ParamField body=\"openWorldHint\" type=\"bool | None\">\n        If true, this tool may interact with an \"open world\" of external entities. If false, the tool's domain of interaction is closed.\n      </ParamField>\n    </Expandable>\n  </ParamField>\n\n  <ParamField body=\"meta\" type=\"dict[str, Any] | None\">\n    <VersionBadge version=\"2.11.0\" />\n\n    Optional meta information about the tool. This data is passed through to the MCP client as the `_meta` field of the client-side tool object and can be used for custom metadata, versioning, or other application-specific purposes.\n  </ParamField>\n</Card>\n\n### Async Support\n\nFastMCP is an async-first framework that seamlessly supports both asynchronous (`async def`) and synchronous (`def`) functions as tools. Async tools are preferred for I/O-bound operations to keep your server responsive.\n\nWhile synchronous tools work seamlessly in FastMCP, they can block the event loop during execution. For CPU-intensive or potentially blocking synchronous operations, consider alternative strategies. One approach is to use `anyio` (which FastMCP already uses internally) to wrap them as async functions, for example:\n\n```python {1, 13} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport anyio\nfrom fastmcp import FastMCP\n\nmcp = FastMCP()\n\ndef cpu_intensive_task(data: str) -> str:\n    # Some heavy computation that could block the event loop\n    return processed_data\n\n@mcp.tool\nasync def wrapped_cpu_task(data: str) -> str:\n    \"\"\"CPU-intensive task wrapped to prevent blocking.\"\"\"\n    return await anyio.to_thread.run_sync(cpu_intensive_task, data)\n```\n\nAlternative approaches include using `asyncio.get_event_loop().run_in_executor()` or other threading techniques to manage blocking operations without impacting server responsiveness. For example, here's a recipe for using the `asyncer` library (not included in FastMCP) to create a decorator that wraps synchronous functions, courtesy of [@hsheth2](https://github.com/jlowin/fastmcp/issues/864#issuecomment-3103678258):\n\n<CodeGroup>\n  ```python Decorator Recipe theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  import asyncer\n  import functools\n  from typing import Callable, ParamSpec, TypeVar, Awaitable\n\n  _P = ParamSpec(\"_P\")\n  _R = TypeVar(\"_R\")\n\n  def make_async_background(fn: Callable[_P, _R]) -> Callable[_P, Awaitable[_R]]:\n      @functools.wraps(fn)\n      async def wrapper(*args: _P.args, **kwargs: _P.kwargs) -> _R:\n          return await asyncer.asyncify(fn)(*args, **kwargs)\n\n      return wrapper\n  ```\n\n  ```python Using the Decorator {6} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  @mcp.tool()\n  @make_async_background\n  def my_tool() -> None:\n      time.sleep(5)\n  ```\n</CodeGroup>\n\n## Arguments\n\nBy default, FastMCP converts Python functions into MCP tools by inspecting the function's signature and type annotations. This allows you to use standard Python type annotations for your tools. In general, the framework strives to \"just work\": idiomatic Python behaviors like parameter defaults and type annotations are automatically translated into MCP schemas. However, there are a number of ways to customize the behavior of your tools.\n\n### Type Annotations\n\nMCP tools have typed arguments, and FastMCP uses type annotations to determine those types. Therefore, you should use standard Python type annotations for tool arguments:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\ndef analyze_text(\n    text: str,\n    max_tokens: int = 100,\n    language: str | None = None\n) -> dict:\n    \"\"\"Analyze the provided text.\"\"\"\n    # Implementation...\n```\n\nFastMCP supports a wide range of type annotations, including all Pydantic types:\n\n| Type Annotation   | Example                                   | Description                                                  |\n| :---------------- | :---------------------------------------- | :----------------------------------------------------------- |\n| Basic types       | `int`, `float`, `str`, `bool`             | Simple scalar values                                         |\n| Binary data       | `bytes`                                   | Binary content (raw strings, not auto-decoded base64)        |\n| Date and Time     | `datetime`, `date`, `timedelta`           | Date and time objects (ISO format strings)                   |\n| Collection types  | `list[str]`, `dict[str, int]`, `set[int]` | Collections of items                                         |\n| Optional types    | `float \\| None`, `Optional[float]`        | Parameters that may be null/omitted                          |\n| Union types       | `str \\| int`, `Union[str, int]`           | Parameters accepting multiple types                          |\n| Constrained types | `Literal[\"A\", \"B\"]`, `Enum`               | Parameters with specific allowed values                      |\n| Paths             | `Path`                                    | File system paths (auto-converted from strings)              |\n| UUIDs             | `UUID`                                    | Universally unique identifiers (auto-converted from strings) |\n| Pydantic models   | `UserData`                                | Complex structured data with validation                      |\n\nFastMCP supports all types that Pydantic supports as fields, including all Pydantic custom types. A few FastMCP-specific behaviors to note:\n\n**Binary Data**: `bytes` parameters accept raw strings without automatic base64 decoding. For base64 data, use `str` and decode manually with `base64.b64decode()`.\n\n**Enums**: Clients send enum values (`\"red\"`), not names (`\"RED\"`). Your function receives the Enum member (`Color.RED`).\n\n**Paths and UUIDs**: String inputs are automatically converted to `Path` and `UUID` objects.\n\n**Pydantic Models**: Must be provided as JSON objects (dicts), not stringified JSON. Even with flexible validation, `{\"user\": {\"name\": \"Alice\"}}` works, but `{\"user\": '{\"name\": \"Alice\"}'}` does not.\n\n### Optional Arguments\n\nFastMCP follows Python's standard function parameter conventions. Parameters without default values are required, while those with default values are optional.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\ndef search_products(\n    query: str,                   # Required - no default value\n    max_results: int = 10,        # Optional - has default value\n    sort_by: str = \"relevance\",   # Optional - has default value\n    category: str | None = None   # Optional - can be None\n) -> list[dict]:\n    \"\"\"Search the product catalog.\"\"\"\n    # Implementation...\n```\n\nIn this example, the LLM must provide a `query` parameter, while `max_results`, `sort_by`, and `category` will use their default values if not explicitly provided.\n\n### Validation Modes\n\n<VersionBadge version=\"2.13.0\" />\n\nBy default, FastMCP uses Pydantic's flexible validation that coerces compatible inputs to match your type annotations. This improves compatibility with LLM clients that may send string representations of values (like `\"10\"` for an integer parameter).\n\nIf you need stricter validation that rejects any type mismatches, you can enable strict input validation. Strict mode uses the MCP SDK's built-in JSON Schema validation to validate inputs against the exact schema before passing them to your function:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Enable strict validation for this server\nmcp = FastMCP(\"StrictServer\", strict_input_validation=True)\n\n@mcp.tool\ndef add_numbers(a: int, b: int) -> int:\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\n# With strict_input_validation=True, sending {\"a\": \"10\", \"b\": \"20\"} will fail\n# With strict_input_validation=False (default), it will be coerced to integers\n```\n\n**Validation Behavior Comparison:**\n\n| Input Type                                                | strict\\_input\\_validation=False (default) | strict\\_input\\_validation=True |\n| :-------------------------------------------------------- | :---------------------------------------- | :----------------------------- |\n| String integers (`\"10\"` for `int`)                        | ✅ Coerced to integer                      | ❌ Validation error             |\n| String floats (`\"3.14\"` for `float`)                      | ✅ Coerced to float                        | ❌ Validation error             |\n| String booleans (`\"true\"` for `bool`)                     | ✅ Coerced to boolean                      | ❌ Validation error             |\n| Lists with string elements (`[\"1\", \"2\"]` for `list[int]`) | ✅ Elements coerced                        | ❌ Validation error             |\n| Pydantic model fields with type mismatches                | ✅ Fields coerced                          | ❌ Validation error             |\n| Invalid values (`\"abc\"` for `int`)                        | ❌ Validation error                        | ❌ Validation error             |\n\n<Note>\n  **Note on Pydantic Models:** Even with `strict_input_validation=False`, Pydantic model parameters must be provided as JSON objects (dicts), not as stringified JSON. For example, `{\"user\": {\"name\": \"Alice\"}}` works, but `{\"user\": '{\"name\": \"Alice\"}'}` does not.\n</Note>\n\nThe default flexible validation mode is recommended for most use cases as it handles common LLM client behaviors gracefully while still providing strong type safety through Pydantic's validation.\n\n### Parameter Metadata\n\nYou can provide additional metadata about parameters in several ways:\n\n#### Simple String Descriptions\n\n<VersionBadge version=\"2.11.0\" />\n\nFor basic parameter descriptions, you can use a convenient shorthand with `Annotated`:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom typing import Annotated\n\n@mcp.tool\ndef process_image(\n    image_url: Annotated[str, \"URL of the image to process\"],\n    resize: Annotated[bool, \"Whether to resize the image\"] = False,\n    width: Annotated[int, \"Target width in pixels\"] = 800,\n    format: Annotated[str, \"Output image format\"] = \"jpeg\"\n) -> dict:\n    \"\"\"Process an image with optional resizing.\"\"\"\n    # Implementation...\n```\n\nThis shorthand syntax is equivalent to using `Field(description=...)` but more concise for simple descriptions.\n\n<Tip>\n  This shorthand syntax is only applied to `Annotated` types with a single string description.\n</Tip>\n\n#### Advanced Metadata with Field\n\nFor validation constraints and advanced metadata, use Pydantic's `Field` class with `Annotated`:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom typing import Annotated\nfrom pydantic import Field\n\n@mcp.tool\ndef process_image(\n    image_url: Annotated[str, Field(description=\"URL of the image to process\")],\n    resize: Annotated[bool, Field(description=\"Whether to resize the image\")] = False,\n    width: Annotated[int, Field(description=\"Target width in pixels\", ge=1, le=2000)] = 800,\n    format: Annotated[\n        Literal[\"jpeg\", \"png\", \"webp\"], \n        Field(description=\"Output image format\")\n    ] = \"jpeg\"\n) -> dict:\n    \"\"\"Process an image with optional resizing.\"\"\"\n    # Implementation...\n```\n\nYou can also use the Field as a default value, though the Annotated approach is preferred:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\ndef search_database(\n    query: str = Field(description=\"Search query string\"),\n    limit: int = Field(10, description=\"Maximum number of results\", ge=1, le=100)\n) -> list:\n    \"\"\"Search the database with the provided query.\"\"\"\n    # Implementation...\n```\n\nField provides several validation and documentation features:\n\n* `description`: Human-readable explanation of the parameter (shown to LLMs)\n* `ge`/`gt`/`le`/`lt`: Greater/less than (or equal) constraints\n* `min_length`/`max_length`: String or collection length constraints\n* `pattern`: Regex pattern for string validation\n* `default`: Default value if parameter is omitted\n\n### Excluding Arguments\n\n<VersionBadge version=\"2.6.0\" />\n\nYou can exclude certain arguments from the tool schema shown to the LLM. This is useful for arguments that are injected at runtime (such as `state`, `user_id`, or credentials) and should not be exposed to the LLM or client. Only arguments with default values can be excluded; attempting to exclude a required argument will raise an error.\n\n**Note:** `exclude_args` will be deprecated in FastMCP 2.14 in favor of dependency injection with `Depends()` for better lifecycle management and more explicit dependency handling. `exclude_args` will continue to work until then.\n\nExample with `exclude_args`:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool(\n    name=\"get_user_details\",\n    exclude_args=[\"user_id\"]\n)\ndef get_user_details(user_id: str = None) -> str:\n    # user_id will be injected by the server, not provided by the LLM\n    ...\n```\n\nWith this configuration, `user_id` will not appear in the tool's parameter schema, but can still be set by the server or framework at runtime.\n\nFor more complex tool transformations, see [Transforming Tools](/patterns/tool-transformation).\n\n## Return Values\n\nFastMCP tools can return data in two complementary formats: **traditional content blocks** (like text and images) and **structured outputs** (machine-readable JSON). When you add return type annotations, FastMCP automatically generates **output schemas** to validate the structured data and enables clients to deserialize results back to Python objects.\n\nUnderstanding how these three concepts work together:\n\n* **Return Values**: What your Python function returns (determines both content blocks and structured data)\n* **Structured Outputs**: JSON data sent alongside traditional content for machine processing\n* **Output Schemas**: JSON Schema declarations that describe and validate the structured output format\n\nThe following sections explain each concept in detail.\n\n### Content Blocks\n\nFastMCP automatically converts tool return values into appropriate MCP content blocks:\n\n* **`str`**: Sent as `TextContent`\n* **`bytes`**: Base64 encoded and sent as `BlobResourceContents` (within an `EmbeddedResource`)\n* **`fastmcp.utilities.types.Image`**: Sent as `ImageContent`\n* **`fastmcp.utilities.types.Audio`**: Sent as `AudioContent`\n* **`fastmcp.utilities.types.File`**: Sent as base64-encoded `EmbeddedResource`\n* **MCP SDK content blocks**: Sent as-is\n* **A list of any of the above**: Converts each item according to the above rules\n* **`None`**: Results in an empty response\n\n#### Media Helper Classes\n\nFastMCP provides helper classes for returning images, audio, and files. When you return one of these classes, either directly or as part of a list, FastMCP automatically converts it to the appropriate MCP content block. For example, if you return a `fastmcp.utilities.types.Image` object, FastMCP will convert it to an MCP `ImageContent` block with the correct MIME type and base64 encoding.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.utilities.types import Image, Audio, File\n\n@mcp.tool\ndef get_chart() -> Image:\n    \"\"\"Generate a chart image.\"\"\"\n    return Image(path=\"chart.png\")\n\n@mcp.tool\ndef get_multiple_charts() -> list[Image]:\n    \"\"\"Return multiple charts.\"\"\"\n    return [Image(path=\"chart1.png\"), Image(path=\"chart2.png\")]\n```\n\n<Tip>\n  Helper classes are only automatically converted to MCP content blocks when returned **directly** or as part of a **list**. For more complex containers like dicts, you can manually convert them to MCP types:\n\n  ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  # ✅ Automatic conversion\n  return Image(path=\"chart.png\")\n  return [Image(path=\"chart1.png\"), \"text content\"]\n\n  # ❌ Will not be automatically converted\n  return {\"image\": Image(path=\"chart.png\")}\n\n  # ✅ Manual conversion for nested use\n  return {\"image\": Image(path=\"chart.png\").to_image_content()}\n  ```\n</Tip>\n\nEach helper class accepts either `path=` or `data=` (mutually exclusive):\n\n* **`path`**: File path (string or Path object) - MIME type detected from extension\n* **`data`**: Raw bytes - requires `format=` parameter for MIME type\n* **`format`**: Optional format override (e.g., \"png\", \"wav\", \"pdf\")\n* **`name`**: Optional name for `File` when using `data=`\n* **`annotations`**: Optional MCP annotations for the content\n\n### Structured Output\n\n<VersionBadge version=\"2.10.0\" />\n\nThe 6/18/2025 MCP spec update [introduced](https://modelcontextprotocol.io/specification/2025-06-18/server/tools#structured-content) structured content, which is a new way to return data from tools. Structured content is a JSON object that is sent alongside traditional content. FastMCP automatically creates structured outputs alongside traditional content when your tool returns data that has a JSON object representation. This provides machine-readable JSON data that clients can deserialize back to Python objects.\n\n**Automatic Structured Content Rules:**\n\n* **Object-like results** (`dict`, Pydantic models, dataclasses) → Always become structured content (even without output schema)\n* **Non-object results** (`int`, `str`, `list`) → Only become structured content if there's an output schema to validate/serialize them\n* **All results** → Always become traditional content blocks for backward compatibility\n\n<Note>\n  This automatic behavior enables clients to receive machine-readable data alongside human-readable content without requiring explicit output schemas for object-like returns.\n</Note>\n\n#### Dictionaries and Objects\n\nWhen your tool returns a dictionary, dataclass, or Pydantic model, FastMCP automatically creates structured content from it. The structured content contains the actual object data, making it easy for clients to deserialize back to native objects.\n\n<CodeGroup>\n  ```python Tool Definition theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  @mcp.tool\n  def get_user_data(user_id: str) -> dict:\n      \"\"\"Get user data.\"\"\"\n      return {\"name\": \"Alice\", \"age\": 30, \"active\": True}\n  ```\n\n  ```json MCP Result theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"{\\n  \\\"name\\\": \\\"Alice\\\",\\n  \\\"age\\\": 30,\\n  \\\"active\\\": true\\n}\"\n      }\n    ],\n    \"structuredContent\": {\n      \"name\": \"Alice\",\n      \"age\": 30,\n      \"active\": true\n    }\n  }\n  ```\n</CodeGroup>\n\n#### Primitives and Collections\n\nWhen your tool returns a primitive type (int, str, bool) or a collection (list, set), FastMCP needs a return type annotation to generate structured content. The annotation tells FastMCP how to validate and serialize the result.\n\nWithout a type annotation, the tool only produces `content`:\n\n<CodeGroup>\n  ```python Tool Definition theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  @mcp.tool\n  def calculate_sum(a: int, b: int):\n      \"\"\"Calculate sum without return annotation.\"\"\"\n      return a + b  # Returns 8\n  ```\n\n  ```json MCP Result theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"8\"\n      }\n    ]\n  }\n  ```\n</CodeGroup>\n\nWhen you add a return annotation, such as `-> int`, FastMCP generates `structuredContent` by wrapping the primitive value in a `{\"result\": ...}` object, since JSON schemas require object-type roots for structured output:\n\n<CodeGroup>\n  ```python Tool Definition theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  @mcp.tool\n  def calculate_sum(a: int, b: int) -> int:\n      \"\"\"Calculate sum with return annotation.\"\"\"\n      return a + b  # Returns 8\n  ```\n\n  ```json MCP Result theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"8\"\n      }\n    ],\n    \"structuredContent\": {\n      \"result\": 8\n    }\n  }\n  ```\n</CodeGroup>\n\n#### Typed Models\n\nReturn type annotations work with any type that can be converted to a JSON schema. Dataclasses and Pydantic models are particularly useful because FastMCP extracts their field definitions to create detailed schemas.\n\n<CodeGroup>\n  ```python Tool Definition theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  from dataclasses import dataclass\n  from fastmcp import FastMCP\n\n  mcp = FastMCP()\n\n  @dataclass\n  class Person:\n      name: str\n      age: int\n      email: str\n\n  @mcp.tool\n  def get_user_profile(user_id: str) -> Person:\n      \"\"\"Get a user's profile information.\"\"\"\n      return Person(\n          name=\"Alice\",\n          age=30,\n          email=\"alice@example.com\",\n      )\n  ```\n\n  ```json Generated Output Schema theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  {\n    \"properties\": {\n      \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n      \"age\": {\"title\": \"Age\", \"type\": \"integer\"},\n      \"email\": {\"title\": \"Email\", \"type\": \"string\"}\n    },\n    \"required\": [\"name\", \"age\", \"email\"],\n    \"title\": \"Person\",\n    \"type\": \"object\"\n  }\n  ```\n\n  ```json MCP Result theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30, \\\"email\\\": \\\"alice@example.com\\\"}\"\n      }\n    ],\n    \"structuredContent\": {\n      \"name\": \"Alice\",\n      \"age\": 30,\n      \"email\": \"alice@example.com\"\n    }\n  }\n  ```\n</CodeGroup>\n\nThe `Person` dataclass becomes an output schema (second tab) that describes the expected format. When executed, clients receive the result (third tab) with both `content` and `structuredContent` fields.\n\n### Output Schemas\n\n<VersionBadge version=\"2.10.0\" />\n\nThe 6/18/2025 MCP spec update [introduced](https://modelcontextprotocol.io/specification/2025-06-18/server/tools#output-schema) output schemas, which are a new way to describe the expected output format of a tool. When an output schema is provided, the tool *must* return structured output that matches the schema.\n\nWhen you add return type annotations to your functions, FastMCP automatically generates JSON schemas that describe the expected output format. These schemas help MCP clients understand and validate the structured data they receive.\n\n#### Primitive Type Wrapping\n\nFor primitive return types (like `int`, `str`, `bool`), FastMCP automatically wraps the result under a `\"result\"` key to create valid structured output:\n\n<CodeGroup>\n  ```python Primitive Return Type theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  @mcp.tool\n  def calculate_sum(a: int, b: int) -> int:\n      \"\"\"Add two numbers together.\"\"\"\n      return a + b\n  ```\n\n  ```json Generated Schema (Wrapped) theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  {\n    \"type\": \"object\",\n    \"properties\": {\n      \"result\": {\"type\": \"integer\"}\n    },\n    \"x-fastmcp-wrap-result\": true\n  }\n  ```\n\n  ```json Structured Output theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n  {\n    \"result\": 8\n  }\n  ```\n</CodeGroup>\n\n#### Manual Schema Control\n\nYou can override the automatically generated schema by providing a custom `output_schema`:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool(output_schema={\n    \"type\": \"object\", \n    \"properties\": {\n        \"data\": {\"type\": \"string\"},\n        \"metadata\": {\"type\": \"object\"}\n    }\n})\ndef custom_schema_tool() -> dict:\n    \"\"\"Tool with custom output schema.\"\"\"\n    return {\"data\": \"Hello\", \"metadata\": {\"version\": \"1.0\"}}\n```\n\nSchema generation works for most common types including basic types, collections, union types, Pydantic models, TypedDict structures, and dataclasses.\n\n<Warning>\n  **Important Constraints**:\n\n  * Output schemas must be object types (`\"type\": \"object\"`)\n  * If you provide an output schema, your tool **must** return structured output that matches it\n  * However, you can provide structured output without an output schema (using `ToolResult`)\n</Warning>\n\n### ToolResult and Metadata\n\nFor complete control over tool responses, return a `ToolResult` object. This gives you explicit control over all aspects of the tool's output: traditional content, structured data, and metadata.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.tools.tool import ToolResult\nfrom mcp.types import TextContent\n\n@mcp.tool\ndef advanced_tool() -> ToolResult:\n    \"\"\"Tool with full control over output.\"\"\"\n    return ToolResult(\n        content=[TextContent(type=\"text\", text=\"Human-readable summary\")],\n        structured_content={\"data\": \"value\", \"count\": 42},\n        meta={\"execution_time_ms\": 145}\n    )\n```\n\n`ToolResult` accepts three fields:\n\n**`content`** - The traditional MCP content blocks that clients display to users. Can be a string (automatically converted to `TextContent`), a list of MCP content blocks, or any serializable value (converted to JSON string). At least one of `content` or `structured_content` must be provided.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Simple string\nToolResult(content=\"Hello, world!\")\n\n# List of content blocks\nToolResult(content=[\n    TextContent(type=\"text\", text=\"Result: 42\"),\n    ImageContent(type=\"image\", data=\"base64...\", mimeType=\"image/png\")\n])\n```\n\n**`structured_content`** - A dictionary containing structured data that matches your tool's output schema. This enables clients to programmatically process the results. If you provide `structured_content`, it must be a dictionary or `None`. If only `structured_content` is provided, it will also be used as `content` (converted to JSON string).\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nToolResult(\n    content=\"Found 3 users\",\n    structured_content={\"users\": [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]}\n)\n```\n\n**`meta`**\n\n<VersionBadge version=\"2.13.1\" />\n\nRuntime metadata about the tool execution. Use this for performance metrics, debugging information, or any client-specific data that doesn't belong in the content or structured output.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nToolResult(\n    content=\"Analysis complete\",\n    structured_content={\"result\": \"positive\"},\n    meta={\n        \"execution_time_ms\": 145,\n        \"model_version\": \"2.1\",\n        \"confidence\": 0.95\n    }\n)\n```\n\n<Note>\n  The `meta` field in `ToolResult` is for runtime metadata about tool execution (e.g., execution time, performance metrics). This is separate from the `meta` parameter in `@mcp.tool(meta={...})`, which provides static metadata about the tool definition itself.\n</Note>\n\nWhen returning `ToolResult`, you have full control - FastMCP won't automatically wrap or transform your data. `ToolResult` can be returned with or without an output schema.\n\n## Error Handling\n\n<VersionBadge version=\"2.4.1\" />\n\nIf your tool encounters an error, you can raise a standard Python exception (`ValueError`, `TypeError`, `FileNotFoundError`, custom exceptions, etc.) or a FastMCP `ToolError`.\n\nBy default, all exceptions (including their details) are logged and converted into an MCP error response to be sent back to the client LLM. This helps the LLM understand failures and react appropriately.\n\nIf you want to mask internal error details for security reasons, you can:\n\n1. Use the `mask_error_details=True` parameter when creating your `FastMCP` instance:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nmcp = FastMCP(name=\"SecureServer\", mask_error_details=True)\n```\n\n2. Or use `ToolError` to explicitly control what error information is sent to clients:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.exceptions import ToolError\n\n@mcp.tool\ndef divide(a: float, b: float) -> float:\n    \"\"\"Divide a by b.\"\"\"\n\n    if b == 0:\n        # Error messages from ToolError are always sent to clients,\n        # regardless of mask_error_details setting\n        raise ToolError(\"Division by zero is not allowed.\")\n    \n    # If mask_error_details=True, this message would be masked\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both arguments must be numbers.\")\n        \n    return a / b\n```\n\nWhen `mask_error_details=True`, only error messages from `ToolError` will include details, other exceptions will be converted to a generic message.\n\n## Disabling Tools\n\n<VersionBadge version=\"2.8.0\" />\n\nYou can control the visibility and availability of tools by enabling or disabling them. This is useful for feature flagging, maintenance, or dynamically changing the toolset available to a client. Disabled tools will not appear in the list of available tools returned by `list_tools`, and attempting to call a disabled tool will result in an \"Unknown tool\" error, just as if the tool did not exist.\n\nBy default, all tools are enabled. You can disable a tool upon creation using the `enabled` parameter in the decorator:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool(enabled=False)\ndef maintenance_tool():\n    \"\"\"This tool is currently under maintenance.\"\"\"\n    return \"This tool is disabled.\"\n```\n\nYou can also toggle a tool's state programmatically after it has been created:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\ndef dynamic_tool():\n    return \"I am a dynamic tool.\"\n\n# Disable and re-enable the tool\ndynamic_tool.disable()\ndynamic_tool.enable()\n```\n\n## MCP Annotations\n\n<VersionBadge version=\"2.2.7\" />\n\nFastMCP allows you to add specialized metadata to your tools through annotations. These annotations communicate how tools behave to client applications without consuming token context in LLM prompts.\n\nAnnotations serve several purposes in client applications:\n\n* Adding user-friendly titles for display purposes\n* Indicating whether tools modify data or systems\n* Describing the safety profile of tools (destructive vs. non-destructive)\n* Signaling if tools interact with external systems\n\nYou can add annotations to a tool using the `annotations` parameter in the `@mcp.tool` decorator:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool(\n    annotations={\n        \"title\": \"Calculate Sum\",\n        \"readOnlyHint\": True,\n        \"openWorldHint\": False\n    }\n)\ndef calculate_sum(a: float, b: float) -> float:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n```\n\nFastMCP supports these standard annotations:\n\n| Annotation        | Type    | Default | Purpose                                                                     |\n| :---------------- | :------ | :------ | :-------------------------------------------------------------------------- |\n| `title`           | string  | -       | Display name for user interfaces                                            |\n| `readOnlyHint`    | boolean | false   | Indicates if the tool only reads without making changes                     |\n| `destructiveHint` | boolean | true    | For non-readonly tools, signals if changes are destructive                  |\n| `idempotentHint`  | boolean | false   | Indicates if repeated identical calls have the same effect as a single call |\n| `openWorldHint`   | boolean | true    | Specifies if the tool interacts with external systems                       |\n\nRemember that annotations help make better user experiences but should be treated as advisory hints. They help client applications present appropriate UI elements and safety controls, but won't enforce security boundaries on their own. Always focus on making your annotations accurately represent what your tool actually does.\n\n## Notifications\n\n<VersionBadge version=\"2.9.1\" />\n\nFastMCP automatically sends `notifications/tools/list_changed` notifications to connected clients when tools are added, removed, enabled, or disabled. This allows clients to stay up-to-date with the current tool set without manually polling for changes.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n@mcp.tool\ndef example_tool() -> str:\n    return \"Hello!\"\n\n# These operations trigger notifications:\nmcp.add_tool(example_tool)     # Sends tools/list_changed notification\nexample_tool.disable()         # Sends tools/list_changed notification  \nexample_tool.enable()          # Sends tools/list_changed notification\nmcp.remove_tool(\"example_tool\") # Sends tools/list_changed notification\n```\n\nNotifications are only sent when these operations occur within an active MCP request context (e.g., when called from within a tool or other MCP operation). Operations performed during server initialization do not trigger notifications.\n\nClients can handle these notifications using a [message handler](/clients/messages) to automatically refresh their tool lists or update their interfaces.\n\n## Accessing the MCP Context\n\nTools can access MCP features like logging, reading resources, or reporting progress through the `Context` object. To use it, add a parameter to your tool function with the type hint `Context`.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP, Context\n\nmcp = FastMCP(name=\"ContextDemo\")\n\n@mcp.tool\nasync def process_data(data_uri: str, ctx: Context) -> dict:\n    \"\"\"Process data from a resource with progress reporting.\"\"\"\n    await ctx.info(f\"Processing data from {data_uri}\")\n    \n    # Read a resource\n    resource = await ctx.read_resource(data_uri)\n    data = resource[0].content if resource else \"\"\n    \n    # Report progress\n    await ctx.report_progress(progress=50, total=100)\n    \n    # Example request to the client's LLM for help\n    summary = await ctx.sample(f\"Summarize this in 10 words: {data[:200]}\")\n    \n    await ctx.report_progress(progress=100, total=100)\n    return {\n        \"length\": len(data),\n        \"summary\": summary.text\n    }\n```\n\nThe Context object provides access to:\n\n* **Logging**: `ctx.debug()`, `ctx.info()`, `ctx.warning()`, `ctx.error()`\n* **Progress Reporting**: `ctx.report_progress(progress, total)`\n* **Resource Access**: `ctx.read_resource(uri)`\n* **LLM Sampling**: `ctx.sample(...)`\n* **Request Information**: `ctx.request_id`, `ctx.client_id`\n\nFor full documentation on the Context object and all its capabilities, see the [Context documentation](/servers/context).\n\n## Server Behavior\n\n### Duplicate Tools\n\n<VersionBadge version=\"2.1.0\" />\n\nYou can control how the FastMCP server behaves if you try to register multiple tools with the same name. This is configured using the `on_duplicate_tools` argument when creating the `FastMCP` instance.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(\n    name=\"StrictServer\",\n    # Configure behavior for duplicate tool names\n    on_duplicate_tools=\"error\"\n)\n\n@mcp.tool\ndef my_tool(): return \"Version 1\"\n\n# This will now raise a ValueError because 'my_tool' already exists\n# and on_duplicate_tools is set to \"error\".\n# @mcp.tool\n# def my_tool(): return \"Version 2\"\n```\n\nThe duplicate behavior options are:\n\n* `\"warn\"` (default): Logs a warning and the new tool replaces the old one.\n* `\"error\"`: Raises a `ValueError`, preventing the duplicate registration.\n* `\"replace\"`: Silently replaces the existing tool with the new one.\n* `\"ignore\"`: Keeps the original tool and ignores the new registration attempt.\n\n### Removing Tools\n\n<VersionBadge version=\"2.3.4\" />\n\nYou can dynamically remove tools from a server using the `remove_tool` method:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\nmcp = FastMCP(name=\"DynamicToolServer\")\n\n@mcp.tool\ndef calculate_sum(a: int, b: int) -> int:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n\nmcp.remove_tool(\"calculate_sum\")\n```",
  "content_length": 40891
}