{
  "title": "oauth_proxy",
  "source_url": "https://gofastmcp.com/python-sdk/fastmcp-server-auth-oauth_proxy",
  "content": "# `fastmcp.server.auth.oauth_proxy`\n\nOAuth Proxy Provider for FastMCP.\n\nThis provider acts as a transparent proxy to an upstream OAuth Authorization Server,\nhandling Dynamic Client Registration locally while forwarding all other OAuth flows.\nThis enables authentication with upstream providers that don't support DCR or have\nrestricted client registration policies.\n\nKey features:\n\n* Proxies authorization and token endpoints to upstream server\n* Implements local Dynamic Client Registration with fixed upstream credentials\n* Validates tokens using upstream JWKS\n* Maintains minimal local state for bookkeeping\n* Enhanced logging with request correlation\n\nThis implementation is based on the OAuth 2.1 specification and is designed for\nproduction use with enterprise identity providers.\n\n## Functions\n\n### `create_consent_html` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L236\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\ncreate_consent_html(client_id: str, redirect_uri: str, scopes: list[str], txn_id: str, csrf_token: str, client_name: str | None = None, title: str = 'Application Access Request', server_name: str | None = None, server_icon_url: str | None = None, server_website_url: str | None = None, client_website_url: str | None = None) -> str\n```\n\nCreate a styled HTML consent page for OAuth authorization requests.\n\n## Classes\n\n### `OAuthTransaction` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L108\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nOAuth transaction state for consent flow.\n\nStored server-side to track active authorization flows with client context.\nIncludes CSRF tokens for consent protection per MCP security best practices.\n\n### `ClientCode` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L129\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nClient authorization code with PKCE and upstream tokens.\n\nStored server-side after upstream IdP callback. Contains the upstream\ntokens bound to the client's PKCE challenge for secure token exchange.\n\n### `UpstreamTokenSet` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L147\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nStored upstream OAuth tokens from identity provider.\n\nThese tokens are obtained from the upstream provider (Google, GitHub, etc.)\nand stored in plaintext within this model. Encryption is handled transparently\nat the storage layer via FernetEncryptionWrapper. Tokens are never exposed to MCP clients.\n\n### `JTIMapping` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L169\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nMaps FastMCP token JTI to upstream token ID.\n\nThis allows stateless JWT validation while still being able to look up\nthe corresponding upstream token when tools need to access upstream APIs.\n\n### `ProxyDCRClient` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L181\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nClient for DCR proxy with configurable redirect URI validation.\n\nThis special client class is critical for the OAuth proxy to work correctly\nwith Dynamic Client Registration (DCR). Here's why it exists:\n\n## Problem:\n\nWhen MCP clients use OAuth, they dynamically register with random localhost\nports (e.g., [http://localhost:55454/callback](http://localhost:55454/callback)). The OAuth proxy needs to:\n\n1. Accept these dynamic redirect URIs from clients based on configured patterns\n2. Use its own fixed redirect URI with the upstream provider (Google, GitHub, etc.)\n3. Forward the authorization code back to the client's dynamic URI\n\n## Solution:\n\nThis class validates redirect URIs against configurable patterns,\nwhile the proxy internally uses its own fixed redirect URI with the upstream\nprovider. This allows the flow to work even when clients reconnect with\ndifferent ports or when tokens are cached.\n\nWithout proper validation, clients could get \"Redirect URI not registered\" errors\nwhen trying to authenticate with cached tokens, or security vulnerabilities could\narise from accepting arbitrary redirect URIs.\n\n**Methods:**\n\n#### `validate_redirect_uri` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L210\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nvalidate_redirect_uri(self, redirect_uri: AnyUrl | None) -> AnyUrl\n```\n\nValidate redirect URI against allowed patterns.\n\nSince we're acting as a proxy and clients register dynamically,\nwe validate their redirect URIs against configurable patterns.\nThis is essential for cached token scenarios where the client may\nreconnect with a different port.\n\n### `TokenHandler` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L383\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nTokenHandler that returns OAuth 2.1 compliant error responses.\n\nThe MCP SDK always returns HTTP 400 for all client authentication issues.\nHowever, OAuth 2.1 Section 5.3 and the MCP specification require that\ninvalid or expired tokens MUST receive a HTTP 401 response.\n\nThis handler extends the base MCP SDK TokenHandler to transform client\nauthentication failures into OAuth 2.1 compliant responses:\n\n* Changes 'unauthorized\\_client' to 'invalid\\_client' error code\n* Returns HTTP 401 status code instead of 400 for client auth failures\n\nPer OAuth 2.1 Section 5.3: \"The authorization server MAY return an HTTP 401\n(Unauthorized) status code to indicate which HTTP authentication schemes\nare supported.\"\n\nPer MCP spec: \"Invalid or expired tokens MUST receive a HTTP 401 response.\"\n\n**Methods:**\n\n#### `response` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L402\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nresponse(self, obj: TokenSuccessResponse | TokenErrorResponse)\n```\n\nOverride response method to provide OAuth 2.1 compliant error handling.\n\n### `OAuthProxy` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L432\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nOAuth provider that presents a DCR-compliant interface while proxying to non-DCR IDPs.\n\n## Purpose\n\nMCP clients expect OAuth providers to support Dynamic Client Registration (DCR),\nwhere clients can register themselves dynamically and receive unique credentials.\nMost enterprise IDPs (Google, GitHub, Azure AD, etc.) don't support DCR and require\npre-registered OAuth applications with fixed credentials.\n\nThis proxy bridges that gap by:\n\n* Presenting a full DCR-compliant OAuth interface to MCP clients\n* Translating DCR registration requests to use pre-configured upstream credentials\n* Proxying all OAuth flows to the upstream IDP with appropriate translations\n* Managing the state and security requirements of both protocols\n\n## Architecture Overview\n\nThe proxy maintains a single OAuth app registration with the upstream provider\nwhile allowing unlimited MCP clients to register and authenticate dynamically.\nIt implements the complete OAuth 2.1 + DCR specification for clients while\ntranslating to whatever OAuth variant the upstream provider requires.\n\n## Key Translation Challenges Solved\n\n1. Dynamic Client Registration:\n   * MCP clients expect to register dynamically and get unique credentials\n   * Upstream IDPs require pre-registered apps with fixed credentials\n   * Solution: Accept DCR requests, return shared upstream credentials\n\n2. Dynamic Redirect URIs:\n   * MCP clients use random localhost ports that change between sessions\n   * Upstream IDPs require fixed, pre-registered redirect URIs\n   * Solution: Use proxy's fixed callback URL with upstream, forward to client's dynamic URI\n\n3. Authorization Code Mapping:\n   * Upstream returns codes for the proxy's redirect URI\n   * Clients expect codes for their own redirect URIs\n   * Solution: Exchange upstream code server-side, issue new code to client\n\n4. State Parameter Collision:\n   * Both client and proxy need to maintain state through the flow\n   * Only one state parameter available in OAuth\n   * Solution: Use transaction ID as state with upstream, preserve client's state\n\n5. Token Management:\n   * Clients may expect different token formats/claims than upstream provides\n   * Need to track tokens for revocation and refresh\n   * Solution: Store token relationships, forward upstream tokens transparently\n\n## OAuth Flow Implementation\n\n1. Client Registration (DCR):\n   * Accept any client registration request\n   * Store ProxyDCRClient that accepts dynamic redirect URIs\n\n2. Authorization:\n   * Store transaction mapping client details to proxy flow\n   * Redirect to upstream with proxy's fixed redirect URI\n   * Use transaction ID as state parameter with upstream\n\n3. Upstream Callback:\n   * Exchange upstream authorization code for tokens (server-side)\n   * Generate new authorization code bound to client's PKCE challenge\n   * Redirect to client's original dynamic redirect URI\n\n4. Token Exchange:\n   * Validate client's code and PKCE verifier\n   * Return previously obtained upstream tokens\n   * Clean up one-time use authorization code\n\n5. Token Refresh:\n   * Forward refresh requests to upstream using authlib\n   * Handle token rotation if upstream issues new refresh token\n   * Update local token mappings\n\n## State Management\n\nThe proxy maintains minimal but crucial state:\n\n* \\_oauth\\_transactions: Active authorization flows with client context\n* \\_client\\_codes: Authorization codes with PKCE challenges and upstream tokens\n* \\_access\\_tokens, \\_refresh\\_tokens: Token storage for revocation\n* Token relationship mappings for cleanup and rotation\n\n## Security Considerations\n\n* PKCE enforced end-to-end (client to proxy, proxy to upstream)\n* Authorization codes are single-use with short expiry\n* Transaction IDs are cryptographically random\n* All state is cleaned up after use to prevent replay\n* Token validation delegates to upstream provider\n\n## Provider Compatibility\n\nWorks with any OAuth 2.0 provider that supports:\n\n* Authorization code flow\n* Fixed redirect URI (configured in provider's app settings)\n* Standard token endpoint\n\nHandles provider-specific requirements:\n\n* Google: Ensures minimum scope requirements\n* GitHub: Compatible with OAuth Apps and GitHub Apps\n* Azure AD: Handles tenant-specific endpoints\n* Generic: Works with any spec-compliant provider\n\n**Methods:**\n\n#### `get_client` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L813\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nget_client(self, client_id: str) -> OAuthClientInformationFull | None\n```\n\nGet client information by ID. This is generally the random ID\nprovided to the DCR client during registration, not the upstream client ID.\n\nFor unregistered clients, returns None (which will raise an error in the SDK).\n\n#### `register_client` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L829\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nregister_client(self, client_info: OAuthClientInformationFull) -> None\n```\n\nRegister a client locally\n\nWhen a client registers, we create a ProxyDCRClient that is more\nforgiving about validating redirect URIs, since the DCR client's\nredirect URI will likely be localhost or unknown to the proxied IDP. The\nproxied IDP only knows about this server's fixed redirect URI.\n\n#### `authorize` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L876\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nauthorize(self, client: OAuthClientInformationFull, params: AuthorizationParams) -> str\n```\n\nStart OAuth transaction and route through consent interstitial.\n\nFlow:\n\n1. Store transaction with client details and PKCE (if forwarding)\n2. Return local /consent URL; browser visits consent first\n3. Consent handler redirects to upstream IdP if approved/already approved\n\nIf consent is disabled (require\\_authorization\\_consent=False), skip the consent screen\nand redirect directly to the upstream IdP.\n\n#### `load_authorization_code` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L951\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nload_authorization_code(self, client: OAuthClientInformationFull, authorization_code: str) -> AuthorizationCode | None\n```\n\nLoad authorization code for validation.\n\nLook up our client code and return authorization code object\nwith PKCE challenge for validation.\n\n#### `exchange_authorization_code` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L994\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nexchange_authorization_code(self, client: OAuthClientInformationFull, authorization_code: AuthorizationCode) -> OAuthToken\n```\n\nExchange authorization code for FastMCP-issued tokens.\n\nImplements the token factory pattern:\n\n1. Retrieves upstream tokens from stored authorization code\n2. Extracts user identity from upstream token\n3. Encrypts and stores upstream tokens\n4. Issues FastMCP-signed JWT tokens\n5. Returns FastMCP tokens (NOT upstream tokens)\n\nPKCE validation is handled by the MCP framework before this method is called.\n\n#### `load_refresh_token` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L1159\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nload_refresh_token(self, client: OAuthClientInformationFull, refresh_token: str) -> RefreshToken | None\n```\n\nLoad refresh token from local storage.\n\n#### `exchange_refresh_token` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L1167\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nexchange_refresh_token(self, client: OAuthClientInformationFull, refresh_token: RefreshToken, scopes: list[str]) -> OAuthToken\n```\n\nExchange FastMCP refresh token for new FastMCP access token.\n\nImplements two-tier refresh:\n\n1. Verify FastMCP refresh token\n2. Look up upstream token via JTI mapping\n3. Refresh upstream token with upstream provider\n4. Update stored upstream token\n5. Issue new FastMCP access token\n6. Keep same FastMCP refresh token (unless upstream rotates)\n\n#### `load_access_token` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L1368\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nload_access_token(self, token: str) -> AccessToken | None\n```\n\nValidate FastMCP JWT by swapping for upstream token.\n\nThis implements the token swap pattern:\n\n1. Verify FastMCP JWT signature (proves it's our token)\n2. Look up upstream token via JTI mapping\n3. Decrypt upstream token\n4. Validate upstream token with provider (GitHub API, JWT validation, etc.)\n5. Return upstream validation result\n\nThe FastMCP JWT is a reference token - all authorization data comes\nfrom validating the upstream token via the TokenVerifier.\n\n#### `revoke_token` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L1424\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nrevoke_token(self, token: AccessToken | RefreshToken) -> None\n```\n\nRevoke token locally and with upstream server if supported.\n\nRemoves tokens from local storage and attempts to revoke them with\nthe upstream server if a revocation endpoint is configured.\n\n#### `get_routes` <sup><a href=\"https://github.com/jlowin/fastmcp/blob/main/src/fastmcp/server/auth/oauth_proxy.py#L1468\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nget_routes(self, mcp_path: str | None = None) -> list[Route]\n```\n\nGet OAuth routes with custom handlers for better error UX.\n\nThis method creates standard OAuth routes and replaces:\n\n* /authorize endpoint: Enhanced error responses for unregistered clients\n* /token endpoint: OAuth 2.1 compliant error codes\n\n**Args:**\n\n* `mcp_path`: The path where the MCP endpoint is mounted (e.g., \"/mcp\")\n  This is used to advertise the resource URL in metadata.",
  "content_length": 17749
}