{
  "title": "Tool Operations",
  "source_url": "https://gofastmcp.com/clients/tools",
  "content": "Discover and execute server-side tools with the FastMCP client.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span> \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.0.0\" />\n\nTools are executable functions exposed by MCP servers. The FastMCP client provides methods to discover available tools and execute them with arguments.\n\n## Discovering Tools\n\nUse `list_tools()` to retrieve all tools available on the server:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    tools = await client.list_tools()\n    # tools -> list[mcp.types.Tool]\n    \n    for tool in tools:\n        print(f\"Tool: {tool.name}\")\n        print(f\"Description: {tool.description}\")\n        if tool.inputSchema:\n            print(f\"Parameters: {tool.inputSchema}\")\n        # Access tags and other metadata\n        if hasattr(tool, 'meta') and tool.meta:\n            fastmcp_meta = tool.meta.get('_fastmcp', {})\n            print(f\"Tags: {fastmcp_meta.get('tags', [])}\")\n```\n\n### Filtering by Tags\n\n<VersionBadge version=\"2.11.0\" />\n\nYou can use the `meta` field to filter tools based on their tags:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    tools = await client.list_tools()\n    \n    # Filter tools by tag\n    analysis_tools = [\n        tool for tool in tools \n        if hasattr(tool, 'meta') and tool.meta and\n           tool.meta.get('_fastmcp', {}) and\n           'analysis' in tool.meta.get('_fastmcp', {}).get('tags', [])\n    ]\n    \n    print(f\"Found {len(analysis_tools)} analysis tools\")\n```\n\n<Note>\n  The `meta` field is part of the standard MCP specification. FastMCP servers include tags and other metadata within a `_fastmcp` namespace (e.g., `meta._fastmcp.tags`) to avoid conflicts with user-defined metadata. This behavior can be controlled with the server's `include_fastmcp_meta` setting - when disabled, the `_fastmcp` namespace won't be included. Other MCP server implementations may not provide this metadata structure.\n</Note>\n\n## Executing Tools\n\n### Basic Execution\n\nExecute a tool using `call_tool()` with the tool name and arguments:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    # Simple tool call\n    result = await client.call_tool(\"add\", {\"a\": 5, \"b\": 3})\n    # result -> CallToolResult with structured and unstructured data\n    \n    # Access structured data (automatically deserialized)\n    print(result.data)  # 8 (int) or {\"result\": 8} for primitive types\n    \n    # Access traditional content blocks  \n    print(result.content[0].text)  # \"8\" (TextContent)\n```\n\n### Advanced Execution Options\n\nThe `call_tool()` method supports additional parameters for timeout control and progress monitoring:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    # With timeout (aborts if execution takes longer than 2 seconds)\n    result = await client.call_tool(\n        \"long_running_task\", \n        {\"param\": \"value\"}, \n        timeout=2.0\n    )\n    \n    # With progress handler (to track execution progress)\n    result = await client.call_tool(\n        \"long_running_task\",\n        {\"param\": \"value\"},\n        progress_handler=my_progress_handler\n    )\n```\n\n**Parameters:**\n\n* `name`: The tool name (string)\n* `arguments`: Dictionary of arguments to pass to the tool (optional)\n* `timeout`: Maximum execution time in seconds (optional, overrides client-level timeout)\n* `progress_handler`: Progress callback function (optional, overrides client-level handler)\n* `meta`: Dictionary of metadata to send with the request (optional, see below)\n\n## Sending Metadata\n\n<VersionBadge version=\"2.13.1\" />\n\nThe `meta` parameter sends ancillary information alongside tool calls. This can be used for various purposes like observability, debugging, client identification, or any context the server may need beyond the tool's primary arguments.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    result = await client.call_tool(\n        name=\"send_email\",\n        arguments={\n            \"to\": \"user@example.com\",\n            \"subject\": \"Hello\",\n            \"body\": \"Welcome!\"\n        },\n        meta={\n            \"trace_id\": \"abc-123\",\n            \"request_source\": \"mobile_app\"\n        }\n    )\n```\n\nThe structure and usage of `meta` is determined by your application. See [Client Metadata](/servers/context#client-metadata) in the server documentation to learn how to access this data in your tool implementations.\n\n## Handling Results\n\n<VersionBadge version=\"2.10.0\" />\n\nTool execution returns a `CallToolResult` object with both structured and traditional content. FastMCP's standout feature is the `.data` property, which doesn't just provide raw JSON but actually hydrates complete Python objects including complex types like datetimes, UUIDs, and custom classes.\n\n### CallToolResult Properties\n\n<Card icon=\"code\" title=\"CallToolResult Properties\">\n  <ResponseField name=\".data\" type=\"Any\">\n    **FastMCP exclusive**: Fully hydrated Python objects with complex type support (datetimes, UUIDs, custom classes). Goes beyond JSON to provide complete object reconstruction from output schemas.\n  </ResponseField>\n\n  <ResponseField name=\".content\" type=\"list[mcp.types.ContentBlock]\">\n    Standard MCP content blocks (`TextContent`, `ImageContent`, `AudioContent`, etc.) available from all MCP servers.\n  </ResponseField>\n\n  <ResponseField name=\".structured_content\" type=\"dict[str, Any] | None\">\n    Standard MCP structured JSON data as sent by the server, available from all MCP servers that support structured outputs.\n  </ResponseField>\n\n  <ResponseField name=\".is_error\" type=\"bool\">\n    Boolean indicating if the tool execution failed.\n  </ResponseField>\n</Card>\n\n### Structured Data Access\n\nFastMCP's `.data` property provides fully hydrated Python objects, not just JSON dictionaries. This includes complex type reconstruction:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom datetime import datetime\nfrom uuid import UUID\n\nasync with client:\n    result = await client.call_tool(\"get_weather\", {\"city\": \"London\"})\n    \n    # FastMCP reconstructs complete Python objects from the server's output schema\n    weather = result.data  # Server-defined WeatherReport object\n    print(f\"Temperature: {weather.temperature}°C at {weather.timestamp}\")\n    print(f\"Station: {weather.station_id}\")\n    print(f\"Humidity: {weather.humidity}%\")\n    \n    # The timestamp is a real datetime object, not a string!\n    assert isinstance(weather.timestamp, datetime)\n    assert isinstance(weather.station_id, UUID)\n    \n    # Compare with raw structured JSON (standard MCP)\n    print(f\"Raw JSON: {result.structured_content}\")\n    # {\"temperature\": 20, \"timestamp\": \"2024-01-15T14:30:00Z\", \"station_id\": \"123e4567-...\"}\n    \n    # Traditional content blocks (standard MCP)  \n    print(f\"Text content: {result.content[0].text}\")\n```\n\n### Fallback Behavior\n\nFor tools without output schemas or when deserialization fails, `.data` will be `None`:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    result = await client.call_tool(\"legacy_tool\", {\"param\": \"value\"})\n    \n    if result.data is not None:\n        # Structured output available and successfully deserialized\n        print(f\"Structured: {result.data}\")\n    else:\n        # No structured output or deserialization failed - use content blocks\n        for content in result.content:\n            if hasattr(content, 'text'):\n                print(f\"Text result: {content.text}\")\n            elif hasattr(content, 'data'):\n                print(f\"Binary data: {len(content.data)} bytes\")\n```\n\n### Primitive Type Unwrapping\n\n<Tip>\n  FastMCP servers automatically wrap non-object results (like `int`, `str`, `bool`) in a `{\"result\": value}` structure to create valid structured outputs. FastMCP clients understand this convention and automatically unwrap the value in `.data` for convenience, so you get the original primitive value instead of a wrapper object.\n</Tip>\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    result = await client.call_tool(\"calculate_sum\", {\"a\": 5, \"b\": 3})\n    \n    # FastMCP client automatically unwraps for convenience\n    print(result.data)  # 8 (int) - the original value\n    \n    # Raw structured content shows the server-side wrapping\n    print(result.structured_content)  # {\"result\": 8}\n    \n    # Other MCP clients would need to manually access [\"result\"]\n    # value = result.structured_content[\"result\"]  # Not needed with FastMCP!\n```\n\n## Error Handling\n\n### Exception-Based Error Handling\n\nBy default, `call_tool()` raises a `ToolError` if the tool execution fails:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.exceptions import ToolError\n\nasync with client:\n    try:\n        result = await client.call_tool(\"potentially_failing_tool\", {\"param\": \"value\"})\n        print(\"Tool succeeded:\", result.data)\n    except ToolError as e:\n        print(f\"Tool failed: {e}\")\n```\n\n### Manual Error Checking\n\nYou can disable automatic error raising and manually check the result:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    result = await client.call_tool(\n        \"potentially_failing_tool\", \n        {\"param\": \"value\"}, \n        raise_on_error=False\n    )\n    \n    if result.is_error:\n        print(f\"Tool failed: {result.content[0].text}\")\n    else:\n        print(f\"Tool succeeded: {result.data}\")\n```\n\n### Raw MCP Protocol Access\n\nFor complete control, use `call_tool_mcp()` which returns the raw MCP protocol object:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    result = await client.call_tool_mcp(\"potentially_failing_tool\", {\"param\": \"value\"})\n    # result -> mcp.types.CallToolResult\n    \n    if result.isError:\n        print(f\"Tool failed: {result.content}\")\n    else:\n        print(f\"Tool succeeded: {result.content}\")\n        # Note: No automatic deserialization with call_tool_mcp()\n```\n\n## Argument Handling\n\nArguments are passed as a dictionary to the tool:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    # Simple arguments\n    result = await client.call_tool(\"greet\", {\"name\": \"World\"})\n    \n    # Complex arguments\n    result = await client.call_tool(\"process_data\", {\n        \"config\": {\"format\": \"json\", \"validate\": True},\n        \"items\": [1, 2, 3, 4, 5],\n        \"metadata\": {\"source\": \"api\", \"version\": \"1.0\"}\n    })\n```\n\n<Tip>\n  For multi-server clients, tool names are automatically prefixed with the server name (e.g., `weather_get_forecast` for a tool named `get_forecast` on the `weather` server).\n</Tip>",
  "content_length": 11067
}