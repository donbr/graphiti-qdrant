{
  "title": "FastAPI ðŸ¤ FastMCP",
  "source_url": "https://gofastmcp.com/integrations/fastapi",
  "content": "Integrate FastMCP with FastAPI applications\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<Tip>\n  **New in 2.11**: FastMCP is introducing a next-generation OpenAPI parser. The new parser has greatly improved performance and compatibility, and is also easier to maintain. To enable it, set the environment variable `FASTMCP_EXPERIMENTAL_ENABLE_NEW_OPENAPI_PARSER=true`.\n\n  The new parser is largely API-compatible with the existing implementation and will become the default in a future version. We encourage all users to test it and report any issues before it becomes the default.\n</Tip>\n\nFastMCP provides two powerful ways to integrate with FastAPI applications:\n\n1. **[Generate an MCP server FROM your FastAPI app](#generating-an-mcp-server)** - Convert existing API endpoints into MCP tools\n2. **[Mount an MCP server INTO your FastAPI app](#mounting-an-mcp-server)** - Add MCP functionality to your web application\n\n<Tip>\n  Generating MCP servers from OpenAPI is a great way to get started with FastMCP, but in practice LLMs achieve **significantly better performance** with well-designed and curated MCP servers than with auto-converted OpenAPI servers. This is especially true for complex APIs with many endpoints and parameters.\n\n  We recommend using the FastAPI integration for bootstrapping and prototyping, not for mirroring your API to LLM clients. See the post [Stop Converting Your REST APIs to MCP](https://www.jlowin.dev/blog/stop-converting-rest-apis-to-mcp) for more details.\n</Tip>\n\n<Note>\n  FastMCP does *not* include FastAPI as a dependency; you must install it separately to use this integration.\n</Note>\n\n## Example FastAPI Application\n\nThroughout this guide, we'll use this e-commerce API as our example (click the `Copy` button to copy it for use with other code blocks):\n\n```python [expandable] theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Copy this FastAPI server into other code blocks in this guide\n\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\n# Models\nclass Product(BaseModel):\n    name: str\n    price: float\n    category: str\n    description: str | None = None\n\nclass ProductResponse(BaseModel):\n    id: int\n    name: str\n    price: float\n    category: str\n    description: str | None = None\n\n# Create FastAPI app\napp = FastAPI(title=\"E-commerce API\", version=\"1.0.0\")\n\n# In-memory database\nproducts_db = {\n    1: ProductResponse(\n        id=1, name=\"Laptop\", price=999.99, category=\"Electronics\"\n    ),\n    2: ProductResponse(\n        id=2, name=\"Mouse\", price=29.99, category=\"Electronics\"\n    ),\n    3: ProductResponse(\n        id=3, name=\"Desk Chair\", price=299.99, category=\"Furniture\"\n    ),\n}\nnext_id = 4\n\n@app.get(\"/products\", response_model=list[ProductResponse])\ndef list_products(\n    category: str | None = None,\n    max_price: float | None = None,\n) -> list[ProductResponse]:\n    \"\"\"List all products with optional filtering.\"\"\"\n    products = list(products_db.values())\n    if category:\n        products = [p for p in products if p.category == category]\n    if max_price:\n        products = [p for p in products if p.price <= max_price]\n    return products\n\n@app.get(\"/products/{product_id}\", response_model=ProductResponse)\ndef get_product(product_id: int):\n    \"\"\"Get a specific product by ID.\"\"\"\n    if product_id not in products_db:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    return products_db[product_id]\n\n@app.post(\"/products\", response_model=ProductResponse)\ndef create_product(product: Product):\n    \"\"\"Create a new product.\"\"\"\n    global next_id\n    product_response = ProductResponse(id=next_id, **product.model_dump())\n    products_db[next_id] = product_response\n    next_id += 1\n    return product_response\n\n@app.put(\"/products/{product_id}\", response_model=ProductResponse)\ndef update_product(product_id: int, product: Product):\n    \"\"\"Update an existing product.\"\"\"\n    if product_id not in products_db:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    products_db[product_id] = ProductResponse(\n        id=product_id,\n        **product.model_dump(),\n    )\n    return products_db[product_id]\n\n@app.delete(\"/products/{product_id}\")\ndef delete_product(product_id: int):\n    \"\"\"Delete a product.\"\"\"\n    if product_id not in products_db:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    del products_db[product_id]\n    return {\"message\": \"Product deleted\"}\n```\n\n<Tip>\n  All subsequent code examples in this guide assume you have the above FastAPI application code already defined. Each example builds upon this base application, `app`.\n</Tip>\n\n## Generating an MCP Server\n\n<VersionBadge version=\"2.0.0\" />\n\nOne of the most common ways to bootstrap an MCP server is to generate it from an existing FastAPI application. FastMCP will expose your FastAPI endpoints as MCP components (tools, by default) in order to expose your API to LLM clients.\n\n### Basic Conversion\n\nConvert the FastAPI app to an MCP server with a single line:\n\n```python {5} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Assumes the FastAPI app from above is already defined\nfrom fastmcp import FastMCP\n\n# Convert to MCP server\nmcp = FastMCP.from_fastapi(app=app)\n\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\n### Adding Components\n\nYour converted MCP server is a full FastMCP instance, meaning you can add new tools, resources, and other components to it just like you would with any other FastMCP instance.\n\n```python {8-11} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Assumes the FastAPI app from above is already defined\nfrom fastmcp import FastMCP\n\n# Convert to MCP server\nmcp = FastMCP.from_fastapi(app=app)\n\n# Add a new tool\n@mcp.tool\ndef get_product(product_id: int) -> ProductResponse:\n    \"\"\"Get a product by ID.\"\"\"\n    return products_db[product_id]\n\n# Run the MCP server\nif __name__ == \"__main__\":\n    mcp.run()\n```\n\n### Interacting with the MCP Server\n\nOnce you've converted your FastAPI app to an MCP server, you can interact with it using the FastMCP client to test functionality before deploying it to an LLM-based application.\n\n```python {3, } theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Assumes the FastAPI app from above is already defined\nfrom fastmcp import FastMCP\nfrom fastmcp.client import Client\nimport asyncio\n\n# Convert to MCP server\nmcp = FastMCP.from_fastapi(app=app)\n\nasync def demo():\n    async with Client(mcp) as client:\n        # List available tools\n        tools = await client.list_tools()\n        print(f\"Available tools: {[t.name for t in tools]}\")\n        \n        # Create a product\n        result = await client.call_tool(\n            \"create_product_products_post\",\n            {\n                \"name\": \"Wireless Keyboard\",\n                \"price\": 79.99,\n                \"category\": \"Electronics\",\n                \"description\": \"Bluetooth mechanical keyboard\"\n            }\n        )\n        print(f\"Created product: {result.data}\")\n        \n        # List electronics under $100\n        result = await client.call_tool(\n            \"list_products_products_get\",\n            {\"category\": \"Electronics\", \"max_price\": 100}\n        )\n        print(f\"Affordable electronics: {result.data}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(demo())\n```\n\n### Custom Route Mapping\n\nBecause FastMCP's FastAPI integration is based on its [OpenAPI integration](/integrations/openapi), you can customize how endpoints are converted to MCP components in exactly the same way. For example, here we use a `RouteMap` to map all GET requests to MCP resources, and all POST/PUT/DELETE requests to MCP tools:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Assumes the FastAPI app from above is already defined\nfrom fastmcp import FastMCP\nfrom fastmcp.server.openapi import RouteMap, MCPType\n\n# If using experimental parser, import from experimental module:\n# from fastmcp.experimental.server.openapi import RouteMap, MCPType\n\n# Custom mapping rules\nmcp = FastMCP.from_fastapi(\n    app=app,\n    route_maps=[\n        # GET with path params â†’ ResourceTemplates\n        RouteMap(\n            methods=[\"GET\"], \n            pattern=r\".*\\{.*\\}.*\", \n            mcp_type=MCPType.RESOURCE_TEMPLATE\n        ),\n        # Other GETs â†’ Resources\n        RouteMap(\n            methods=[\"GET\"], \n            pattern=r\".*\", \n            mcp_type=MCPType.RESOURCE\n        ),\n        # POST/PUT/DELETE â†’ Tools (default)\n    ],\n)\n\n# Now:\n# - GET /products â†’ Resource\n# - GET /products/{id} â†’ ResourceTemplate\n# - POST/PUT/DELETE â†’ Tools\n```\n\n<Tip>\n  To learn more about customizing the conversion process, see the [OpenAPI Integration guide](/integrations/openapi).\n</Tip>\n\n### Authentication and Headers\n\nYou can configure headers and other client options via the `httpx_client_kwargs` parameter. For example, to add authentication to your FastAPI app, you can pass a `headers` dictionary to the `httpx_client_kwargs` parameter:\n\n```python {27-31} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Assumes the FastAPI app from above is already defined\nfrom fastmcp import FastMCP\n\n# Add authentication to your FastAPI app\nfrom fastapi import Depends, Header\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\n\nsecurity = HTTPBearer()\n\ndef verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    if credentials.credentials != \"secret-token\":\n        raise HTTPException(status_code=401, detail=\"Invalid authentication\")\n    return credentials.credentials\n\n# Add a protected endpoint\n@app.get(\"/admin/stats\", dependencies=[Depends(verify_token)])\ndef get_admin_stats():\n    return {\n        \"total_products\": len(products_db),\n        \"categories\": list(set(p.category for p in products_db.values()))\n    }\n\n# Create MCP server with authentication headers\nmcp = FastMCP.from_fastapi(\n    app=app,\n    httpx_client_kwargs={\n        \"headers\": {\n            \"Authorization\": \"Bearer secret-token\",\n        }\n    }\n)\n```\n\n## Mounting an MCP Server\n\n<VersionBadge version=\"2.3.1\" />\n\nIn addition to generating servers, FastMCP can facilitate adding MCP servers to your existing FastAPI application. You can do this by mounting the MCP ASGI application.\n\n### Basic Mounting\n\nTo mount an MCP server, you can use the `http_app` method on your FastMCP instance. This will return an ASGI application that can be mounted to your FastAPI application.\n\n```python {23-30} theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastapi import FastAPI\n\n# Create MCP server\nmcp = FastMCP(\"Analytics Tools\")\n\n@mcp.tool\ndef analyze_pricing(category: str) -> dict:\n    \"\"\"Analyze pricing for a category.\"\"\"\n    products = [p for p in products_db.values() if p.category == category]\n    if not products:\n        return {\"error\": f\"No products in {category}\"}\n    \n    prices = [p.price for p in products]\n    return {\n        \"category\": category,\n        \"avg_price\": round(sum(prices) / len(prices), 2),\n        \"min\": min(prices),\n        \"max\": max(prices),\n    }\n\n# Create ASGI app from MCP server\nmcp_app = mcp.http_app(path='/mcp')\n\n# Key: Pass lifespan to FastAPI\napp = FastAPI(title=\"E-commerce API\", lifespan=mcp_app.lifespan)\n\n# Mount the MCP server\napp.mount(\"/analytics\", mcp_app)\n\n# Now: API at /products/*, MCP at /analytics/mcp/\n```\n\n## Offering an LLM-Friendly API\n\nA common pattern is to generate an MCP server from your FastAPI app and serve both interfaces from the same application. This provides an LLM-optimized interface alongside your regular API:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Assumes the FastAPI app from above is already defined\nfrom fastmcp import FastMCP\nfrom fastapi import FastAPI\n\n# 1. Generate MCP server from your API\nmcp = FastMCP.from_fastapi(app=app, name=\"E-commerce MCP\")\n\n# 2. Create the MCP's ASGI app\nmcp_app = mcp.http_app(path='/mcp')\n\n# 3. Create a new FastAPI app that combines both sets of routes\ncombined_app = FastAPI(\n    title=\"E-commerce API with MCP\",\n    routes=[\n        *mcp_app.routes,  # MCP routes\n        *app.routes,      # Original API routes\n    ],\n    lifespan=mcp_app.lifespan,\n)\n\n# Now you have:\n# - Regular API: http://localhost:8000/products\n# - LLM-friendly MCP: http://localhost:8000/mcp\n# Both served from the same FastAPI application!\n```\n\nThis approach lets you maintain a single codebase while offering both traditional REST endpoints and MCP-compatible endpoints for LLM clients.\n\n## Key Considerations\n\n### Operation IDs\n\nFastAPI operation IDs become MCP component names. Always specify meaningful operation IDs:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Good - explicit operation_id\n@app.get(\"/users/{user_id}\", operation_id=\"get_user_by_id\")\ndef get_user(user_id: int):\n    return {\"id\": user_id}\n\n# Less ideal - auto-generated name\n@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    return {\"id\": user_id}\n```\n\n### Lifespan Management\n\nWhen mounting MCP servers, always pass the lifespan context:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Correct - lifespan passed\nmcp_app = mcp.http_app(path='/mcp')\napp = FastAPI(lifespan=mcp_app.lifespan)\napp.mount(\"/mcp\", mcp_app)\n\n# Incorrect - missing lifespan\napp = FastAPI()\napp.mount(\"/mcp\", mcp.http_app())  # Session manager won't initialize\n```\n\nIf you're mounting an authenticated MCP server under a path prefix, see [Mounting Authenticated Servers](/deployment/http#mounting-authenticated-servers) for important OAuth routing considerations.\n\n### CORS Middleware\n\nIf your FastAPI app uses `CORSMiddleware` and you're mounting an OAuth-protected FastMCP server, avoid adding application-wide CORS middleware. FastMCP and the MCP SDK already handle CORS for OAuth routes, and layering CORS middleware can cause conflicts (such as 404 errors on `.well-known` routes or OPTIONS requests).\n\nIf you need CORS on your own FastAPI routes, use the sub-app pattern: mount your API and FastMCP as separate apps, each with their own middleware, rather than adding top-level `CORSMiddleware` to the combined application.\n\n### Combining Lifespans\n\nIf your FastAPI app already has a lifespan (for database connections, startup tasks, etc.), you can't simply replace it with the MCP lifespan. Instead, you need to create a new lifespan function that manages both contexts. This ensures that both your app's initialization logic and the MCP server's session manager run properly:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom fastmcp import FastMCP\n\n# Your existing lifespan\n@asynccontextmanager\nasync def app_lifespan(app: FastAPI):\n    # Startup\n    print(\"Starting up the app...\")\n    # Initialize database, cache, etc.\n    yield\n    # Shutdown\n    print(\"Shutting down the app...\")\n\n# Create MCP server\nmcp = FastMCP(\"Tools\")\nmcp_app = mcp.http_app(path='/mcp')\n\n# Combine both lifespans\n@asynccontextmanager\nasync def combined_lifespan(app: FastAPI):\n    # Run both lifespans\n    async with app_lifespan(app):\n        async with mcp_app.lifespan(app):\n            yield\n\n# Use the combined lifespan\napp = FastAPI(lifespan=combined_lifespan)\napp.mount(\"/mcp\", mcp_app)\n```\n\nThis pattern ensures both your app's initialization logic and the MCP server's session manager are properly managed. The key is using nested `async with` statements - the inner context (MCP) will be initialized after the outer context (your app), and cleaned up before it. This maintains the correct initialization and cleanup order for all your resources.\n\n### Performance Tips\n\n1. **Use in-memory transport for testing** - Pass MCP servers directly to clients\n2. **Design purpose-built MCP tools** - Better than auto-converting complex APIs\n3. **Keep tool parameters simple** - LLMs perform better with focused interfaces\n\nFor more details on configuration options, see the [OpenAPI Integration guide](/integrations/openapi).",
  "content_length": 16336
}