{
  "title": "The FastMCP Client",
  "source_url": "https://gofastmcp.com/clients/client",
  "content": "Programmatic client for interacting with MCP servers through a well-typed, Pythonic interface.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span> \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.0.0\" />\n\nThe central piece of MCP client applications is the `fastmcp.Client` class. This class provides a **programmatic interface** for interacting with any Model Context Protocol (MCP) server, handling protocol details and connection management automatically.\n\nThe FastMCP Client is designed for deterministic, controlled interactions rather than autonomous behavior, making it ideal for:\n\n* **Testing MCP servers** during development\n* **Building deterministic applications** that need reliable MCP interactions\n* **Creating the foundation for agentic or LLM-based clients** with structured, type-safe operations\n\nAll client operations require using the `async with` context manager for proper connection lifecycle management.\n\n<Note>\n  This is not an agentic client - it requires explicit function calls and provides direct control over all MCP operations. Use it as a building block for higher-level systems.\n</Note>\n\n## Creating a Client\n\nCreating a client is straightforward. You provide a server source and the client automatically infers the appropriate transport mechanism.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport asyncio\nfrom fastmcp import Client, FastMCP\n\n# In-memory server (ideal for testing)\nserver = FastMCP(\"TestServer\")\nclient = Client(server)\n\n# HTTP server\nclient = Client(\"https://example.com/mcp\")\n\n# Local Python script\nclient = Client(\"my_mcp_server.py\")\n\nasync def main():\n    async with client:\n        # Basic server interaction\n        await client.ping()\n        \n        # List available operations\n        tools = await client.list_tools()\n        resources = await client.list_resources()\n        prompts = await client.list_prompts()\n        \n        # Execute operations\n        result = await client.call_tool(\"example_tool\", {\"param\": \"value\"})\n        print(result)\n\nasyncio.run(main())\n```\n\n## Client-Transport Architecture\n\nThe FastMCP Client separates concerns between protocol and connection:\n\n* **`Client`**: Handles MCP protocol operations (tools, resources, prompts) and manages callbacks\n* **`Transport`**: Establishes and maintains the connection (WebSockets, HTTP, Stdio, in-memory)\n\n### Transport Inference\n\nThe client automatically infers the appropriate transport based on the input:\n\n1. **`FastMCP` instance** → In-memory transport (perfect for testing)\n2. **File path ending in `.py`** → Python Stdio transport\n3. **File path ending in `.js`** → Node.js Stdio transport\n4. **URL starting with `http://` or `https://`** → HTTP transport\n5. **`MCPConfig` dictionary** → Multi-server client\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import Client, FastMCP\n\n# Examples of transport inference\nclient_memory = Client(FastMCP(\"TestServer\"))\nclient_script = Client(\"./server.py\") \nclient_http = Client(\"https://api.example.com/mcp\")\n```\n\n<Tip>\n  For testing and development, always prefer the in-memory transport by passing a `FastMCP` server directly to the client. This eliminates network complexity and separate processes.\n</Tip>\n\n## Configuration-Based Clients\n\n<VersionBadge version=\"2.4.0\" />\n\nCreate clients from MCP configuration dictionaries, which can include multiple servers. While there is no official standard for MCP configuration format, FastMCP follows established conventions used by tools like Claude Desktop.\n\n### Configuration Format\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nconfig = {\n    \"mcpServers\": {\n        \"server_name\": {\n            # Remote HTTP/SSE server\n            \"transport\": \"http\",  # or \"sse\" \n            \"url\": \"https://api.example.com/mcp\",\n            \"headers\": {\"Authorization\": \"Bearer token\"},\n            \"auth\": \"oauth\"  # or bearer token string\n        },\n        \"local_server\": {\n            # Local stdio server\n            \"transport\": \"stdio\",\n            \"command\": \"python\",\n            \"args\": [\"./server.py\", \"--verbose\"],\n            \"env\": {\"DEBUG\": \"true\"},\n            \"cwd\": \"/path/to/server\",\n        }\n    }\n}\n```\n\n### Multi-Server Example\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nconfig = {\n    \"mcpServers\": {\n        \"weather\": {\"url\": \"https://weather-api.example.com/mcp\"},\n        \"assistant\": {\"command\": \"python\", \"args\": [\"./assistant_server.py\"]}\n    }\n}\n\nclient = Client(config)\n\nasync with client:\n    # Tools are prefixed with server names\n    weather_data = await client.call_tool(\"weather_get_forecast\", {\"city\": \"London\"})\n    response = await client.call_tool(\"assistant_answer_question\", {\"question\": \"What's the capital of France?\"})\n    \n    # Resources use prefixed URIs\n    icons = await client.read_resource(\"weather://weather/icons/sunny\")\n    templates = await client.read_resource(\"resource://assistant/templates/list\")\n```\n\n## Connection Lifecycle\n\nThe client operates asynchronously and uses context managers for connection management:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync def example():\n    client = Client(\"my_mcp_server.py\")\n    \n    # Connection established here\n    async with client:\n        print(f\"Connected: {client.is_connected()}\")\n        \n        # Make multiple calls within the same session\n        tools = await client.list_tools()\n        result = await client.call_tool(\"greet\", {\"name\": \"World\"})\n        \n    # Connection closed automatically here\n    print(f\"Connected: {client.is_connected()}\")\n```\n\n## Operations\n\nFastMCP clients can interact with several types of server components:\n\n### Tools\n\nTools are server-side functions that the client can execute with arguments.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    # List available tools\n    tools = await client.list_tools()\n    \n    # Execute a tool\n    result = await client.call_tool(\"multiply\", {\"a\": 5, \"b\": 3})\n    print(result.data)  # 15\n```\n\nSee [Tools](/clients/tools) for detailed documentation.\n\n### Resources\n\nResources are data sources that the client can read, either static or templated.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    # List available resources\n    resources = await client.list_resources()\n    \n    # Read a resource\n    content = await client.read_resource(\"file:///config/settings.json\")\n    print(content[0].text)\n```\n\nSee [Resources](/clients/resources) for detailed documentation.\n\n### Prompts\n\nPrompts are reusable message templates that can accept arguments.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    # List available prompts\n    prompts = await client.list_prompts()\n    \n    # Get a rendered prompt\n    messages = await client.get_prompt(\"analyze_data\", {\"data\": [1, 2, 3]})\n    print(messages.messages)\n```\n\nSee [Prompts](/clients/prompts) for detailed documentation.\n\n### Server Connectivity\n\nUse `ping()` to verify the server is reachable:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nasync with client:\n    await client.ping()\n    print(\"Server is reachable\")\n```\n\n### Initialization and Server Information\n\nWhen you enter the client context manager, the client automatically performs an MCP initialization handshake with the server. This handshake exchanges capabilities, server metadata, and instructions. The result is available through the `initialize_result` property.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import Client, FastMCP\n\nmcp = FastMCP(name=\"MyServer\", instructions=\"Use the greet tool to say hello!\")\n\n@mcp.tool\ndef greet(name: str) -> str:\n    \"\"\"Greet a user by name.\"\"\"\n    return f\"Hello, {name}!\"\n\nasync with Client(mcp) as client:\n    # Initialization already happened automatically\n    print(f\"Server: {client.initialize_result.serverInfo.name}\")\n    print(f\"Version: {client.initialize_result.serverInfo.version}\")\n    print(f\"Instructions: {client.initialize_result.instructions}\")\n    print(f\"Capabilities: {client.initialize_result.capabilities.tools}\")\n```\n\n#### Manual Initialization Control\n\nIn advanced scenarios, you might want precise control over when initialization happens. For example, you may need custom error handling, want to defer initialization until after other setup, or need to measure initialization timing separately.\n\nDisable automatic initialization and call `initialize()` manually:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import Client\n\n# Disable automatic initialization\nclient = Client(\"my_mcp_server.py\", auto_initialize=False)\n\nasync with client:\n    # Connection established, but not initialized yet\n    print(f\"Connected: {client.is_connected()}\")\n    print(f\"Initialized: {client.initialize_result is not None}\")  # False\n\n    # Initialize manually with custom timeout\n    result = await client.initialize(timeout=10.0)\n    print(f\"Server: {result.serverInfo.name}\")\n\n    # Now ready for operations\n    tools = await client.list_tools()\n```\n\nThe `initialize()` method is idempotent - calling it multiple times returns the cached result from the first successful call.\n\n## Client Configuration\n\nClients can be configured with additional handlers and settings for specialized use cases.\n\n### Callback Handlers\n\nThe client supports several callback handlers for advanced server interactions:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import Client\nfrom fastmcp.client.logging import LogMessage\n\nasync def log_handler(message: LogMessage):\n    print(f\"Server log: {message.data}\")\n\nasync def progress_handler(progress: float, total: float | None, message: str | None):\n    print(f\"Progress: {progress}/{total} - {message}\")\n\nasync def sampling_handler(messages, params, context):\n    # Integrate with your LLM service here\n    return \"Generated response\"\n\nclient = Client(\n    \"my_mcp_server.py\",\n    log_handler=log_handler,\n    progress_handler=progress_handler,\n    sampling_handler=sampling_handler,\n    timeout=30.0\n)\n```\n\nThe `Client` constructor accepts several configuration options:\n\n* `transport`: Transport instance or source for automatic inference\n* `log_handler`: Handle server log messages\n* `progress_handler`: Monitor long-running operations\n* `sampling_handler`: Respond to server LLM requests\n* `roots`: Provide local context to servers\n* `timeout`: Default timeout for requests (in seconds)\n\n### Transport Configuration\n\nFor detailed transport configuration (headers, authentication, environment variables), see the [Transports](/clients/transports) documentation.\n\n## Next Steps\n\nExplore the detailed documentation for each operation type:\n\n### Core Operations\n\n* **[Tools](/clients/tools)** - Execute server-side functions and handle results\n* **[Resources](/clients/resources)** - Access static and templated resources\n* **[Prompts](/clients/prompts)** - Work with message templates and argument serialization\n\n### Advanced Features\n\n* **[Logging](/clients/logging)** - Handle server log messages\n* **[Progress](/clients/progress)** - Monitor long-running operations\n* **[Sampling](/clients/sampling)** - Respond to server LLM requests\n* **[Roots](/clients/roots)** - Provide local context to servers\n\n### Connection Details\n\n* **[Transports](/clients/transports)** - Configure connection methods and parameters\n* **[Authentication](/clients/auth/oauth)** - Set up OAuth and bearer token authentication\n\n<Tip>\n  The FastMCP Client is designed as a foundational tool. Use it directly for deterministic operations, or build higher-level agentic systems on top of its reliable, type-safe interface.\n</Tip>",
  "content_length": 12091
}