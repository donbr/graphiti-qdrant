{
  "title": "User Elicitation",
  "source_url": "https://gofastmcp.com/clients/elicitation",
  "content": "Handle server-initiated user input requests with structured schemas.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.10.0\" />\n\n## What is Elicitation?\n\nElicitation allows MCP servers to request structured input from users during tool execution. Instead of requiring all inputs upfront, servers can interactively ask users for information as needed - like prompting for missing parameters, requesting clarification, or gathering additional context.\n\nFor example, a file management tool might ask \"Which directory should I create?\" or a data analysis tool might request \"What date range should I analyze?\"\n\n## How FastMCP Makes Elicitation Easy\n\nFastMCP's client provides a helpful abstraction layer that:\n\n* **Converts JSON schemas to Python types**: The raw MCP protocol uses JSON schemas, but FastMCP automatically converts these to Python dataclasses\n* **Provides structured constructors**: Instead of manually building dictionaries that match the schema, you get dataclass constructors that ensure correct structure\n* **Handles type conversion**: FastMCP takes care of converting between JSON representations and Python objects\n* **Runtime introspection**: You can inspect the generated dataclass fields to understand the expected structure\n\nWhen you implement an elicitation handler, FastMCP gives you a dataclass type that matches the server's schema, making it easy to create properly structured responses without having to manually parse JSON schemas.\n\n## Elicitation Handler\n\nProvide an `elicitation_handler` function when creating the client. FastMCP automatically converts the server's JSON schema into a Python dataclass type, making it easy to construct the response:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import Client\nfrom fastmcp.client.elicitation import ElicitResult\n\nasync def elicitation_handler(message: str, response_type: type, params, context):\n    # Present the message to the user and collect input\n    user_input = input(f\"{message}: \")\n    \n    # Create response using the provided dataclass type\n    # FastMCP converted the JSON schema to this Python type for you\n    response_data = response_type(value=user_input)\n    \n    # You can return data directly - FastMCP will implicitly accept the elicitation\n    return response_data\n    \n    # Or explicitly return an ElicitResult for more control\n    # return ElicitResult(action=\"accept\", content=response_data)\n\nclient = Client(\n    \"my_mcp_server.py\",\n    elicitation_handler=elicitation_handler,\n)\n```\n\n### Handler Parameters\n\nThe elicitation handler receives four parameters:\n\n<Card icon=\"code\" title=\"Elicitation Handler Parameters\">\n  <ResponseField name=\"message\" type=\"str\">\n    The prompt message to display to the user\n  </ResponseField>\n\n  <ResponseField name=\"response_type\" type=\"type\">\n    A Python dataclass type that FastMCP created from the server's JSON schema. Use this to construct your response with proper typing and IDE support. If the server requests an empty object (indicating no response), this will be `None`.\n  </ResponseField>\n\n  <ResponseField name=\"params\" type=\"ElicitRequestParams\">\n    The original MCP elicitation request parameters, including the raw JSON schema in `params.requestedSchema` if you need it\n  </ResponseField>\n\n  <ResponseField name=\"context\" type=\"RequestContext\">\n    Request context containing metadata about the elicitation request\n  </ResponseField>\n</Card>\n\n### Response Actions\n\nThe handler can return data directly (which implicitly accepts the elicitation) or an `ElicitResult` object for more control over the response action:\n\n<Card icon=\"code\" title=\"ElicitResult Structure\">\n  <ResponseField name=\"action\" type=\"Literal['accept', 'decline', 'cancel']\">\n    How the user responded to the elicitation request\n  </ResponseField>\n\n  <ResponseField name=\"content\" type=\"dataclass instance | dict | None\">\n    The user's input data (required for \"accept\", omitted for \"decline\"/\"cancel\")\n  </ResponseField>\n</Card>\n\n**Action Types:**\n\n* **`accept`**: User provided valid input - include their data in the `content` field\n* **`decline`**: User chose not to provide the requested information - omit `content`\n* **`cancel`**: User cancelled the entire operation - omit `content`\n\n## Basic Example\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import Client\nfrom fastmcp.client.elicitation import ElicitResult\n\nasync def basic_elicitation_handler(message: str, response_type: type, params, context):\n    print(f\"Server asks: {message}\")\n    \n    # Simple text input for demonstration\n    user_response = input(\"Your response: \")\n    \n    if not user_response:\n        # For non-acceptance, use ElicitResult explicitly\n        return ElicitResult(action=\"decline\")\n    \n    # Use the response_type dataclass to create a properly structured response\n    # FastMCP handles the conversion from JSON schema to Python type\n    # Return data directly - FastMCP will implicitly accept the elicitation\n    return response_type(value=user_response)\n\nclient = Client(\n    \"my_mcp_server.py\", \n    elicitation_handler=basic_elicitation_handler\n)\n```",
  "content_length": 5461
}