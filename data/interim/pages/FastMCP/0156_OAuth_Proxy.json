{
  "title": "OAuth Proxy",
  "source_url": "https://gofastmcp.com/servers/auth/oauth-proxy",
  "content": "Bridge traditional OAuth providers to work seamlessly with MCP's authentication flow.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span> \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.12.0\" />\n\nThe OAuth proxy enables FastMCP servers to authenticate with OAuth providers that **don't support Dynamic Client Registration (DCR)**. This includes virtually all traditional OAuth providers: GitHub, Google, Azure, AWS, Discord, Facebook, and most enterprise identity systems. For providers that do support DCR (like Descope and WorkOS AuthKit), use [`RemoteAuthProvider`](/servers/auth/remote-oauth) instead.\n\nMCP clients expect to register automatically and obtain credentials on the fly, but traditional providers require manual app registration through their developer consoles. The OAuth proxy bridges this gap by presenting a DCR-compliant interface to MCP clients while using your pre-registered credentials with the upstream provider. When a client attempts to register, the proxy returns your fixed credentials. When a client initiates authorization, the proxy handles the complexity of callback forwarding—storing the client's dynamic callback URL, using its own fixed callback with the provider, then forwarding back to the client after token exchange.\n\nThis approach enables any MCP client (whether using random localhost ports or fixed URLs like Claude.ai) to authenticate with any traditional OAuth provider, all while maintaining full OAuth 2.1 and PKCE security.\n\n<Note>\n  For providers that support OIDC discovery (Auth0, Google with OIDC\n  configuration, Azure AD), consider using [`OIDC\n    Proxy`](/servers/auth/oidc-proxy) for automatic configuration. OIDC Proxy\n  extends the OAuth proxy to automatically discover endpoints from the provider's\n  `/.well-known/openid-configuration` URL, simplifying setup.\n</Note>\n\n## Implementation\n\n### Provider Setup Requirements\n\nBefore using the OAuth proxy, you need to register your application with your OAuth provider:\n\n1. **Register your application** in the provider's developer console (GitHub Settings, Google Cloud Console, Azure Portal, etc.)\n2. **Configure the redirect URI** as your FastMCP server URL plus your chosen callback path:\n   * Default: `https://your-server.com/auth/callback`\n   * Custom: `https://your-server.com/your/custom/path` (if you set `redirect_path`)\n   * Development: `http://localhost:8000/auth/callback`\n3. **Obtain your credentials**: Client ID and Client Secret\n4. **Note the OAuth endpoints**: Authorization URL and Token URL (usually found in the provider's OAuth documentation)\n\n<Warning>\n  The redirect URI you configure with your provider must exactly match your\n  FastMCP server's URL plus the callback path. If you customize `redirect_path`\n  in the OAuth proxy, update your provider's redirect URI accordingly.\n</Warning>\n\n### Basic Setup\n\nHere's how to implement the OAuth proxy with any provider:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nfrom fastmcp.server.auth import OAuthProxy\nfrom fastmcp.server.auth.providers.jwt import JWTVerifier\n\n# Configure token verification for your provider\n# See the Token Verification guide for provider-specific setups\ntoken_verifier = JWTVerifier(\n    jwks_uri=\"https://your-provider.com/.well-known/jwks.json\",\n    issuer=\"https://your-provider.com\",\n    audience=\"your-app-id\"\n)\n\n# Create the OAuth proxy\nauth = OAuthProxy(\n    # Provider's OAuth endpoints (from their documentation)\n    upstream_authorization_endpoint=\"https://provider.com/oauth/authorize\",\n    upstream_token_endpoint=\"https://provider.com/oauth/token\",\n\n    # Your registered app credentials\n    upstream_client_id=\"your-client-id\",\n    upstream_client_secret=\"your-client-secret\",\n\n    # Token validation (see Token Verification guide)\n    token_verifier=token_verifier,\n\n    # Your FastMCP server's public URL\n    base_url=\"https://your-server.com\",\n\n    # Optional: customize the callback path (default is \"/auth/callback\")\n    # redirect_path=\"/custom/callback\",\n)\n\nmcp = FastMCP(name=\"My Server\", auth=auth)\n```\n\n### Configuration Parameters\n\n<Card icon=\"code\" title=\"OAuthProxy Parameters\">\n  <ParamField body=\"upstream_authorization_endpoint\" type=\"str\" required>\n    URL of your OAuth provider's authorization endpoint (e.g., `https://github.com/login/oauth/authorize`)\n  </ParamField>\n\n  <ParamField body=\"upstream_token_endpoint\" type=\"str\" required>\n    URL of your OAuth provider's token endpoint (e.g.,\n    `https://github.com/login/oauth/access_token`)\n  </ParamField>\n\n  <ParamField body=\"upstream_client_id\" type=\"str\" required>\n    Client ID from your registered OAuth application\n  </ParamField>\n\n  <ParamField body=\"upstream_client_secret\" type=\"str\" required>\n    Client secret from your registered OAuth application\n  </ParamField>\n\n  <ParamField body=\"token_verifier\" type=\"TokenVerifier\" required>\n    A [`TokenVerifier`](/servers/auth/token-verification) instance to validate the\n    provider's tokens\n  </ParamField>\n\n  <ParamField body=\"base_url\" type=\"AnyHttpUrl | str\" required>\n    Public URL where OAuth endpoints will be accessible, **including any mount path** (e.g., `https://your-server.com/api`).\n\n    This URL is used to construct OAuth callback URLs and operational endpoints. When mounting under a path prefix, include that prefix in `base_url`. Use `issuer_url` separately to specify where auth server metadata is located (typically at root level).\n  </ParamField>\n\n  <ParamField body=\"redirect_path\" type=\"str\" default=\"/auth/callback\">\n    Path for OAuth callbacks. Must match the redirect URI configured in your OAuth\n    application\n  </ParamField>\n\n  <ParamField body=\"upstream_revocation_endpoint\" type=\"str | None\">\n    Optional URL of provider's token revocation endpoint\n  </ParamField>\n\n  <ParamField body=\"issuer_url\" type=\"AnyHttpUrl | str | None\">\n    Issuer URL for OAuth authorization server metadata (defaults to `base_url`).\n\n    When mounting your MCP server under a path prefix (e.g., `/api`), set this to your root-level URL to avoid 404 logs during OAuth discovery. MCP clients try path-scoped discovery first per RFC 8414, which will fail if your auth server metadata is at the root level.\n\n    **Example with mounting:**\n\n    ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    auth = GitHubProvider(\n        base_url=\"http://localhost:8000/api\",  # OAuth endpoints under /api\n        issuer_url=\"http://localhost:8000\"     # Auth server metadata at root\n    )\n    ```\n\n    Without `issuer_url`, clients will attempt `/.well-known/oauth-authorization-server/api` (404) before falling back to `/.well-known/oauth-authorization-server` (success). Setting `issuer_url` to the root eliminates the 404 attempt.\n\n    **When to use:**\n\n    * **Default (`None`)**: Use `base_url` as issuer - simple deployments at root path\n    * **Root-level URL**: Mounting under a path prefix - avoids 404 logs\n\n    See the [HTTP Deployment guide](/deployment/http#mounting-authenticated-servers) for complete mounting examples.\n  </ParamField>\n\n  <ParamField body=\"service_documentation_url\" type=\"AnyHttpUrl | str | None\">\n    Optional URL to your service documentation\n  </ParamField>\n\n  <ParamField body=\"forward_pkce\" type=\"bool\" default=\"True\">\n    Whether to forward PKCE (Proof Key for Code Exchange) to the upstream OAuth\n    provider. When enabled and the client uses PKCE, the proxy generates its own\n    PKCE parameters to send upstream while separately validating the client's\n    PKCE. This ensures end-to-end PKCE security at both layers (client-to-proxy\n    and proxy-to-upstream). - `True` (default): Forward PKCE for providers that\n    support it (Google, Azure, AWS, GitHub, etc.) - `False`: Disable only if upstream\n    provider doesn't support PKCE\n  </ParamField>\n\n  <ParamField body=\"token_endpoint_auth_method\" type=\"str | None\">\n    Token endpoint authentication method for the upstream OAuth server. Controls\n    how the proxy authenticates when exchanging authorization codes and refresh\n    tokens with the upstream provider. - `\"client_secret_basic\"`: Send credentials\n    in Authorization header (most common) - `\"client_secret_post\"`: Send\n    credentials in request body (required by some providers) - `\"none\"`: No\n    authentication (for public clients) - `None` (default): Uses authlib's default\n    (typically `\"client_secret_basic\"`) Set this if your provider requires a\n    specific authentication method and the default doesn't work.\n  </ParamField>\n\n  <ParamField body=\"allowed_client_redirect_uris\" type=\"list[str] | None\">\n    List of allowed redirect URI patterns for MCP clients. Patterns support\n    wildcards (e.g., `\"http://localhost:*\"`, `\"https://*.example.com/*\"`). -\n    `None` (default): All redirect URIs allowed (for MCP/DCR compatibility) -\n    Empty list `[]`: No redirect URIs allowed - Custom list: Only matching\n    patterns allowed These patterns apply to MCP client loopback redirects, NOT\n    the upstream OAuth app redirect URI.\n  </ParamField>\n\n  <ParamField body=\"valid_scopes\" type=\"list[str] | None\">\n    List of all possible valid scopes for the OAuth provider. These are advertised\n    to clients through the `/.well-known` endpoints. Defaults to `required_scopes`\n    from your TokenVerifier if not specified.\n  </ParamField>\n\n  <ParamField body=\"extra_authorize_params\" type=\"dict[str, str] | None\">\n    Additional parameters to forward to the upstream authorization endpoint. Useful for provider-specific parameters that aren't part of the standard OAuth2 flow.\n\n    For example, Auth0 requires an `audience` parameter to issue JWT tokens:\n\n    ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    extra_authorize_params={\"audience\": \"https://api.example.com\"}\n    ```\n\n    These parameters are added to every authorization request sent to the upstream provider.\n  </ParamField>\n\n  <ParamField body=\"extra_token_params\" type=\"dict[str, str] | None\">\n    Additional parameters to forward to the upstream token endpoint during code exchange and token refresh. Useful for provider-specific requirements during token operations.\n\n    For example, some providers require additional context during token exchange:\n\n    ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    extra_token_params={\"audience\": \"https://api.example.com\"}\n    ```\n\n    These parameters are included in all token requests to the upstream provider.\n  </ParamField>\n\n  <ParamField body=\"client_storage\" type=\"AsyncKeyValue | None\">\n    <VersionBadge version=\"2.13.0\" />\n\n    Storage backend for persisting OAuth client registrations and upstream tokens.\n\n    **Default behavior:**\n    By default, clients are automatically persisted to an encrypted disk store, allowing them to survive server restarts as long as the filesystem remains accessible. This means MCP clients only need to register once and can reconnect seamlessly. The disk store is encrypted using a key derived from the JWT Signing Key (which is derived from the upstream client secret by default). For client registrations to survive upstream client secret rotation, you should provide a JWT Signing Key or your own client\\_storage.\n\n    For production deployments with multiple servers or cloud deployments, see [Storage Backends](/servers/storage-backends) for available options.\n\n    <Warning>\n      **When providing custom storage**, wrap it in `FernetEncryptionWrapper` to encrypt sensitive OAuth tokens at rest:\n\n      ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n      from key_value.aio.stores.redis import RedisStore\n      from key_value.aio.wrappers.encryption import FernetEncryptionWrapper\n      from cryptography.fernet import Fernet\n      import os\n\n      auth = OAuthProxy(\n          ...,\n          jwt_signing_key=os.environ[\"JWT_SIGNING_KEY\"],\n          client_storage=FernetEncryptionWrapper(\n              key_value=RedisStore(host=\"redis.example.com\", port=6379),\n              fernet=Fernet(os.environ[\"STORAGE_ENCRYPTION_KEY\"])\n          )\n      )\n      ```\n\n      Without encryption, upstream OAuth tokens are stored in plaintext.\n    </Warning>\n\n    Testing with in-memory storage (unencrypted):\n\n    ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    from key_value.aio.stores.memory import MemoryStore\n\n    # Use in-memory storage for testing (clients lost on restart)\n    auth = OAuthProxy(..., client_storage=MemoryStore())\n    ```\n  </ParamField>\n\n  <ParamField body=\"jwt_signing_key\" type=\"str | bytes | None\">\n    <VersionBadge version=\"2.13.0\" />\n\n    Secret used to sign FastMCP JWT tokens issued to clients. Accepts any string or bytes - will be derived into a proper 32-byte cryptographic key using HKDF.\n\n    **Default behavior (`None`):**\n    Derives a 32-byte key using PBKDF2 from the upstream client secret.\n\n    **For production:**\n    Provide an explicit secret (e.g., from environment variable) to use a fixed key instead of the key derived from the upstream client secret. This allows you to manage keys securely in cloud environments, allows keys to work across multiple instances, and allows you to rotate keys without losing client registrations.\n\n    ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    import os\n\n    auth = OAuthProxy(\n        ...,\n        jwt_signing_key=os.environ[\"JWT_SIGNING_KEY\"],  # Any sufficiently complex string!\n        client_storage=RedisStore(...)  # Persistent storage\n    )\n    ```\n\n    See [HTTP Deployment - OAuth Token Security](/deployment/http#oauth-token-security) for complete production setup.\n  </ParamField>\n\n  <ParamField body=\"require_authorization_consent\" type=\"bool\" default=\"True\">\n    Whether to require user consent before authorizing MCP clients. When enabled (default), users see a consent screen that displays which client is requesting access, preventing [confused deputy attacks](https://modelcontextprotocol.io/specification/2025-06-18/basic/security_best_practices#confused-deputy-problem) by ensuring users explicitly approve new clients.\n\n    **Default behavior (True):**\n    Users see a consent screen on first authorization. Consent choices are remembered via signed cookies, so users only need to approve each client once. This protects against malicious clients impersonating the user.\n\n    **Disabling consent (False):**\n    Authorization proceeds directly to the upstream provider without user confirmation. Only use this for local development or testing environments where the security trade-off is acceptable.\n\n    ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    # Development/testing only - skip consent screen\n    auth = OAuthProxy(\n        ...,\n        require_authorization_consent=False  # ⚠️ Security warning: only for local/testing\n    )\n    ```\n\n    <Warning>\n      Disabling consent removes an important security layer. Only disable for local development or testing environments where you fully control all connecting clients.\n    </Warning>\n  </ParamField>\n\n  <ParamField body=\"consent_csp_policy\" type=\"str | None\" default=\"None\">\n    Content Security Policy for the consent page.\n\n    * `None` (default): Uses the built-in CSP policy with appropriate directives for form submission\n    * Empty string `\"\"`: Disables CSP entirely (no meta tag rendered)\n    * Custom string: Uses the provided value as the CSP policy\n\n    This is useful for organizations that have their own CSP policies and need to override or disable FastMCP's built-in CSP directives.\n\n    ```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n    # Disable CSP entirely (let org CSP policies apply)\n    auth = OAuthProxy(..., consent_csp_policy=\"\")\n\n    # Use custom CSP policy\n    auth = OAuthProxy(..., consent_csp_policy=\"default-src 'self'; style-src 'unsafe-inline'\")\n    ```\n  </ParamField>\n</Card>\n\n### Using Built-in Providers\n\nFastMCP includes pre-configured providers for common services:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp.server.auth.providers.github import GitHubProvider\n\nauth = GitHubProvider(\n    client_id=\"your-github-app-id\",\n    client_secret=\"your-github-app-secret\",\n    base_url=\"https://your-server.com\"\n)\n\nmcp = FastMCP(name=\"My Server\", auth=auth)\n```\n\nAvailable providers include `GitHubProvider`, `GoogleProvider`, and others. These handle token verification automatically.\n\n### Token Verification\n\nThe OAuth proxy requires a compatible `TokenVerifier` to validate tokens from your provider. Different providers use different token formats:\n\n* **JWT tokens** (Google, Azure): Use `JWTVerifier` with the provider's JWKS endpoint\n* **Opaque tokens with RFC 7662 introspection** (Auth0, Okta, WorkOS): Use `IntrospectionTokenVerifier`\n* **Opaque tokens (provider-specific)** (GitHub, Discord): Use provider-specific verifiers like `GitHubTokenVerifier`\n\nSee the [Token Verification guide](/servers/auth/token-verification) for detailed setup instructions for your provider.\n\n### Scope Configuration\n\nOAuth scopes control what permissions your application requests from users. They're configured through your `TokenVerifier` (required for the OAuth proxy to validate tokens from your provider). Set `required_scopes` to automatically request the permissions your application needs:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nJWTVerifier(..., required_scopes = [\"read:user\", \"write:data\"])\n```\n\nDynamic clients created by the proxy will automatically include these scopes in their authorization requests. See the [Token Verification](#token-verification) section below for detailed setup.\n\n### Custom Parameters\n\nSome OAuth providers require additional parameters beyond the standard OAuth2 flow. Use `extra_authorize_params` and `extra_token_params` to pass provider-specific requirements. For example, Auth0 requires an `audience` parameter to issue JWT tokens instead of opaque tokens:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nauth = OAuthProxy(\n    upstream_authorization_endpoint=\"https://your-domain.auth0.com/authorize\",\n    upstream_token_endpoint=\"https://your-domain.auth0.com/oauth/token\",\n    upstream_client_id=\"your-auth0-client-id\",\n    upstream_client_secret=\"your-auth0-client-secret\",\n\n    # Auth0-specific audience parameter\n    extra_authorize_params={\"audience\": \"https://your-api-identifier.com\"},\n    extra_token_params={\"audience\": \"https://your-api-identifier.com\"},\n\n    token_verifier=JWTVerifier(\n        jwks_uri=\"https://your-domain.auth0.com/.well-known/jwks.json\",\n        issuer=\"https://your-domain.auth0.com/\",\n        audience=\"https://your-api-identifier.com\"\n    ),\n    base_url=\"https://your-server.com\"\n)\n```\n\nThe proxy also automatically forwards RFC 8707 `resource` parameters from MCP clients to upstream providers that support them.\n\n## OAuth Flow\n\n```mermaid  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nsequenceDiagram\n    participant Client as MCP Client<br/>(localhost:random)\n    participant User as User\n    participant Proxy as FastMCP OAuth Proxy<br/>(server:8000)\n    participant Provider as OAuth Provider<br/>(GitHub, etc.)\n\n    Note over Client, Proxy: Dynamic Registration (Local)\n    Client->>Proxy: 1. POST /register<br/>redirect_uri: localhost:54321/callback\n    Proxy-->>Client: 2. Returns fixed upstream credentials\n\n    Note over Client, User: Authorization with User Consent\n    Client->>Proxy: 3. GET /authorize<br/>redirect_uri=localhost:54321/callback<br/>code_challenge=CLIENT_CHALLENGE\n    Note over Proxy: Store transaction with client PKCE<br/>Generate proxy PKCE pair\n    Proxy->>User: 4. Show consent page<br/>(client details, redirect URI, scopes)\n    User->>Proxy: 5. Approve/deny consent\n    Proxy->>Provider: 6. Redirect to provider<br/>redirect_uri=server:8000/auth/callback<br/>code_challenge=PROXY_CHALLENGE\n\n    Note over Provider, Proxy: Provider Callback\n    Provider->>Proxy: 7. GET /auth/callback<br/>with authorization code\n    Proxy->>Provider: 8. Exchange code for tokens<br/>code_verifier=PROXY_VERIFIER\n    Provider-->>Proxy: 9. Access & refresh tokens\n\n    Note over Proxy, Client: Client Callback Forwarding\n    Proxy->>Client: 10. Redirect to localhost:54321/callback<br/>with new authorization code\n\n    Note over Client, Proxy: Token Exchange\n    Client->>Proxy: 11. POST /token with code<br/>code_verifier=CLIENT_VERIFIER\n    Proxy-->>Client: 12. Returns stored provider tokens\n```\n\nThe flow diagram above illustrates the complete OAuth proxy pattern. Let's understand each phase:\n\n### Registration Phase\n\nWhen an MCP client calls `/register` with its dynamic callback URL, the proxy responds with your pre-configured upstream credentials. The client stores these credentials believing it has registered a new app. Meanwhile, the proxy records the client's callback URL for later use.\n\n### Authorization Phase\n\nThe client initiates OAuth by redirecting to the proxy's `/authorize` endpoint. The proxy:\n\n1. Stores the client's transaction with its PKCE challenge\n2. Generates its own PKCE parameters for upstream security\n3. Shows the user a consent page with the client's details, redirect URI, and requested scopes\n4. If the user approves (or the client was previously approved), redirects to the upstream provider using the fixed callback URL\n\nThis dual-PKCE approach maintains end-to-end security at both the client-to-proxy and proxy-to-provider layers. The consent step protects against confused deputy attacks by ensuring you explicitly approve each client before it can complete authorization.\n\n### Callback Phase\n\nAfter user authorization, the provider redirects back to the proxy's fixed callback URL. The proxy:\n\n1. Exchanges the authorization code for tokens with the provider\n2. Stores these tokens temporarily\n3. Generates a new authorization code for the client\n4. Redirects to the client's original dynamic callback URL\n\n### Token Exchange Phase\n\nFinally, the client exchanges its authorization code with the proxy to receive the provider's tokens. The proxy validates the client's PKCE verifier before returning the stored tokens.\n\nThis entire flow is transparent to the MCP client—it experiences a standard OAuth flow with dynamic registration, unaware that a proxy is managing the complexity behind the scenes.\n\n### Token Architecture\n\nThe OAuth proxy implements a **token factory pattern**: instead of directly forwarding tokens from the upstream OAuth provider, it issues its own JWT tokens to MCP clients. This maintains proper OAuth 2.0 token audience boundaries and enables better security controls.\n\n**How it works:**\n\nWhen an MCP client completes authorization, the proxy:\n\n1. **Receives upstream tokens** from the OAuth provider (GitHub, Google, etc.)\n2. **Encrypts and stores** these tokens using Fernet encryption (AES-128-CBC + HMAC-SHA256)\n3. **Issues FastMCP JWT tokens** to the client, signed with HS256\n\nThe FastMCP JWT contains minimal claims: issuer, audience, client ID, scopes, expiration, and a unique token identifier (JTI). The JTI acts as a reference linking to the encrypted upstream token.\n\n**Token validation:**\n\nWhen a client makes an MCP request with its FastMCP token:\n\n1. **FastMCP validates the JWT** signature, expiration, issuer, and audience\n2. **Looks up the upstream token** using the JTI from the validated JWT\n3. **Decrypts and validates** the upstream token with the provider\n\nThis two-tier validation ensures that FastMCP tokens can only be used with this server (via audience validation) while maintaining full upstream token security.\n\n**Token expiry alignment:**\n\nFastMCP token lifetimes match the upstream token lifetimes. When the upstream token expires, the FastMCP token also expires, maintaining consistent security boundaries.\n\n**Refresh tokens:**\n\nThe proxy issues its own refresh tokens that map to upstream refresh tokens. When a client uses a FastMCP refresh token, the proxy refreshes the upstream token and issues a new FastMCP access token.\n\n### PKCE Forwarding\n\nThe OAuth proxy automatically handles PKCE (Proof Key for Code Exchange) when working with providers that support or require it. The proxy generates its own PKCE parameters to send upstream while separately validating the client's PKCE, ensuring end-to-end security at both layers.\n\nThis is enabled by default via the `forward_pkce` parameter and works seamlessly with providers like Google, Azure AD, and GitHub. Only disable it for legacy providers that don't support PKCE:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Disable PKCE forwarding only if upstream doesn't support it\nauth = OAuthProxy(\n    ...,\n    forward_pkce=False  # Default is True\n)\n```\n\n### Redirect URI Validation\n\nWhile the OAuth proxy accepts all redirect URIs by default (for DCR compatibility), you can restrict which clients can connect by specifying allowed patterns:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Allow only localhost clients (common for development)\nauth = OAuthProxy(\n    # ... other parameters ...\n    allowed_client_redirect_uris=[\n        \"http://localhost:*\",\n        \"http://127.0.0.1:*\"\n    ]\n)\n\n# Allow specific known clients\nauth = OAuthProxy(\n    # ... other parameters ...\n    allowed_client_redirect_uris=[\n        \"http://localhost:*\",\n        \"https://claude.ai/api/mcp/auth_callback\",\n        \"https://*.mycompany.com/auth/*\"  # Wildcard patterns supported\n    ]\n)\n```\n\nCheck your server logs for \"Client registered with redirect\\_uri\" messages to identify what URLs your clients use.\n\n## Security\n\n### Key and Storage Management\n\n<VersionBadge version=\"2.13.0\" />\n\nThe OAuth proxy requires cryptographic keys for JWT signing and storage encryption, plus persistent storage to maintain valid tokens across server restarts.\n\n**Default behavior (appropriate for development only):**\n\n* **Mac/Windows**: FastMCP automatically generates keys and stores them in your system keyring. Storage defaults to disk. Tokens survive server restarts. This is **only** suitable for development and local testing.\n* **Linux**: Keys are ephemeral (random salt at startup). Storage defaults to memory. Tokens become invalid on server restart.\n\n**For production:**\nConfigure the following parameters together: provide a unique `jwt_signing_key` (for signing FastMCP JWTs), and a shared `client_storage` backend (for storing tokens). Both are required for production deployments. Use a network-accessible storage backend like Redis or DynamoDB rather than local disk storage. **Wrap your storage in `FernetEncryptionWrapper` to encrypt sensitive OAuth tokens at rest** (see the `client_storage` parameter documentation above for examples). The keys accept any secret string and derive proper cryptographic keys using HKDF. See [OAuth Token Security](/deployment/http#oauth-token-security) and [Storage Backends](/servers/storage-backends) for complete production setup.\n\n### Confused Deputy Attacks\n\n<VersionBadge version=\"2.13.0\" />\n\nA confused deputy attack allows a malicious client to steal your authorization by tricking you into granting it access under your identity.\n\nThe OAuth proxy works by bridging DCR clients to traditional auth providers, which means that multiple MCP clients connect through a single upstream OAuth application. An attacker can exploit this shared application by registering a malicious client with their own redirect URI, then sending you an authorization link. When you click it, your browser goes through the OAuth flow—but since you may have already authorized this OAuth app before, the provider might auto-approve the request. The authorization code then gets sent to the attacker's redirect URI instead of a legitimate client, giving them access under your credentials.\n\n#### Mitigation\n\nFastMCP's OAuth proxy requires you to explicitly consent whenever any new or unrecognized client attempts to connect to your server. Before any authorization happens, you see a consent page showing the client's details, redirect URI, and requested scopes. This gives you the opportunity to review and deny suspicious requests. Once you approve a client, it's remembered so you don't see the consent page again for that client. The consent mechanism is implemented with CSRF tokens and cryptographically signed cookies to prevent tampering.\n\n<img src=\"https://mintcdn.com/fastmcp/zqDxYvizCdG8znhy/assets/images/oauth-proxy-consent-screen.png?fit=max&auto=format&n=zqDxYvizCdG8znhy&q=85&s=bab90dc9a4b9b71fdc95814347a9c757\" alt=\"\" data-og-width=\"2504\" width=\"2504\" data-og-height=\"1762\" height=\"1762\" data-path=\"assets/images/oauth-proxy-consent-screen.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/fastmcp/zqDxYvizCdG8znhy/assets/images/oauth-proxy-consent-screen.png?w=280&fit=max&auto=format&n=zqDxYvizCdG8znhy&q=85&s=9b53721ebcbed550bde0bd413fe99a75 280w, https://mintcdn.com/fastmcp/zqDxYvizCdG8znhy/assets/images/oauth-proxy-consent-screen.png?w=560&fit=max&auto=format&n=zqDxYvizCdG8znhy&q=85&s=11020ece6d18127feda01d8474bc6318 560w, https://mintcdn.com/fastmcp/zqDxYvizCdG8znhy/assets/images/oauth-proxy-consent-screen.png?w=840&fit=max&auto=format&n=zqDxYvizCdG8znhy&q=85&s=a250e4d019952264fae440b1295c7fed 840w, https://mintcdn.com/fastmcp/zqDxYvizCdG8znhy/assets/images/oauth-proxy-consent-screen.png?w=1100&fit=max&auto=format&n=zqDxYvizCdG8znhy&q=85&s=ccfb379186d02166f860acc1d8938c3d 1100w, https://mintcdn.com/fastmcp/zqDxYvizCdG8znhy/assets/images/oauth-proxy-consent-screen.png?w=1650&fit=max&auto=format&n=zqDxYvizCdG8znhy&q=85&s=fda19052fdf7339e643beea02d0d727c 1650w, https://mintcdn.com/fastmcp/zqDxYvizCdG8znhy/assets/images/oauth-proxy-consent-screen.png?w=2500&fit=max&auto=format&n=zqDxYvizCdG8znhy&q=85&s=30d780aa2a3437dd8fdd2e87ff579377 2500w\" />\n\nThe consent page automatically displays your server's name, icon, and website URL, if available. These visual identifiers help users confirm they're authorizing the correct server.\n\n**Learn more:**\n\n* [MCP Security Best Practices](https://modelcontextprotocol.io/specification/2025-06-18/basic/security_best_practices#confused-deputy-problem) - Official specification guidance\n* [Confused Deputy Attacks Explained](https://den.dev/blog/mcp-confused-deputy-api-management/) - Detailed walkthrough by Den Delimarsky\n\n## Environment Configuration\n\n<VersionBadge version=\"2.12.1\" />\n\nFor production deployments, configure the OAuth proxy through environment variables instead of hardcoding credentials:\n\n```bash  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Specify the provider implementation\nexport FASTMCP_SERVER_AUTH=fastmcp.server.auth.providers.github.GitHubProvider\n\n# Provider-specific credentials\nexport FASTMCP_SERVER_AUTH_GITHUB_CLIENT_ID=\"Ov23li...\"\nexport FASTMCP_SERVER_AUTH_GITHUB_CLIENT_SECRET=\"abc123...\"\nexport FASTMCP_SERVER_AUTH_GITHUB_BASE_URL=\"https://your-production-server.com\"\n```\n\nWith environment configuration, your server code simplifies to:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\n# Authentication automatically configured from environment\nmcp = FastMCP(name=\"My Server\")\n\n@mcp.tool\ndef protected_tool(data: str) -> str:\n    \"\"\"This tool is now protected by OAuth.\"\"\"\n    return f\"Processed: {data}\"\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"http\", port=8000)\n```",
  "content_length": 31676
}