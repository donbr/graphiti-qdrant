{
  "title": "Server Composition",
  "source_url": "https://gofastmcp.com/servers/composition",
  "content": "Combine multiple FastMCP servers into a single, larger application using mounting and importing.\n\nexport const VersionBadge = ({version}) => {\n  return <code className=\"version-badge-container\">\n            <p className=\"version-badge\">\n                <span className=\"version-badge-label\">New in version:</span>Â \n                <code className=\"version-badge-version\">{version}</code>\n            </p>\n        </code>;\n};\n\n<VersionBadge version=\"2.2.0\" />\n\nAs your MCP applications grow, you might want to organize your tools, resources, and prompts into logical modules or reuse existing server components. FastMCP supports composition through two methods:\n\n* **`import_server`**: For a one-time copy of components with prefixing (static composition).\n* **`mount`**: For creating a live link where the main server delegates requests to the subserver (dynamic composition).\n\n## Why Compose Servers?\n\n* **Modularity**: Break down large applications into smaller, focused servers (e.g., a `WeatherServer`, a `DatabaseServer`, a `CalendarServer`).\n* **Reusability**: Create common utility servers (e.g., a `TextProcessingServer`) and mount them wherever needed.\n* **Teamwork**: Different teams can work on separate FastMCP servers that are later combined.\n* **Organization**: Keep related functionality grouped together logically.\n\n### Importing vs Mounting\n\nThe choice of importing or mounting depends on your use case and requirements.\n\n| Feature              | Importing                                                  | Mounting                                    |\n| -------------------- | ---------------------------------------------------------- | ------------------------------------------- |\n| **Method**           | `FastMCP.import_server(server, prefix=None)`               | `FastMCP.mount(server, prefix=None)`        |\n| **Composition Type** | One-time copy (static)                                     | Live link (dynamic)                         |\n| **Updates**          | Changes to subserver NOT reflected                         | Changes to subserver immediately reflected  |\n| **Performance**      | Fast - no runtime delegation                               | Slower - affected by slowest mounted server |\n| **Prefix**           | Optional - omit for original names                         | Optional - omit for original names          |\n| **Best For**         | Bundling finalized components, performance-critical setups | Modular runtime composition                 |\n\n### Proxy Servers\n\nFastMCP supports [MCP proxying](/servers/proxy), which allows you to mirror a local or remote server in a local FastMCP instance. Proxies are fully compatible with both importing and mounting.\n\n<VersionBadge version=\"2.4.0\" />\n\nYou can also create proxies from configuration dictionaries that follow the MCPConfig schema, which is useful for quickly connecting to one or more remote servers. See the [Proxy Servers documentation](/servers/proxy#configuration-based-proxies) for details on configuration-based proxying. Note that MCPConfig follows an emerging standard and its format may evolve over time.\n\nPrefixing rules for tools, prompts, resources, and templates are identical across importing, mounting, and proxies.\n\n## Importing (Static Composition)\n\nThe `import_server()` method copies all components (tools, resources, templates, prompts) from one `FastMCP` instance (the *subserver*) into another (the *main server*). An optional `prefix` can be provided to avoid naming conflicts. If no prefix is provided, components are imported without modification. When multiple servers are imported with the same prefix (or no prefix), the most recently imported server's components take precedence.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\nimport asyncio\n\n# Define subservers\nweather_mcp = FastMCP(name=\"WeatherService\")\n\n@weather_mcp.tool\ndef get_forecast(city: str) -> dict:\n    \"\"\"Get weather forecast.\"\"\"\n    return {\"city\": city, \"forecast\": \"Sunny\"}\n\n@weather_mcp.resource(\"data://cities/supported\")\ndef list_supported_cities() -> list[str]:\n    \"\"\"List cities with weather support.\"\"\"\n    return [\"London\", \"Paris\", \"Tokyo\"]\n\n# Define main server\nmain_mcp = FastMCP(name=\"MainApp\")\n\n# Import subserver\nasync def setup():\n    await main_mcp.import_server(weather_mcp, prefix=\"weather\")\n\n# Result: main_mcp now contains prefixed components:\n# - Tool: \"weather_get_forecast\"\n# - Resource: \"data://weather/cities/supported\" \n\nif __name__ == \"__main__\":\n    asyncio.run(setup())\n    main_mcp.run()\n```\n\n### How Importing Works\n\nWhen you call `await main_mcp.import_server(subserver, prefix={whatever})`:\n\n1. **Tools**: All tools from `subserver` are added to `main_mcp` with names prefixed using `{prefix}_`.\n   * `subserver.tool(name=\"my_tool\")` becomes `main_mcp.tool(name=\"{prefix}_my_tool\")`.\n2. **Resources**: All resources are added with both URIs and names prefixed.\n   * URI: `subserver.resource(uri=\"data://info\")` becomes `main_mcp.resource(uri=\"data://{prefix}/info\")`.\n   * Name: `resource.name` becomes `\"{prefix}_{resource.name}\"`.\n3. **Resource Templates**: Templates are prefixed similarly to resources.\n   * URI: `subserver.resource(uri=\"data://{id}\")` becomes `main_mcp.resource(uri=\"data://{prefix}/{id}\")`.\n   * Name: `template.name` becomes `\"{prefix}_{template.name}\"`.\n4. **Prompts**: All prompts are added with names prefixed using `{prefix}_`.\n   * `subserver.prompt(name=\"my_prompt\")` becomes `main_mcp.prompt(name=\"{prefix}_my_prompt\")`.\n\nNote that `import_server` performs a **one-time copy** of components. Changes made to the `subserver` *after* importing **will not** be reflected in `main_mcp`. The `subserver`'s `lifespan` context is also **not** executed by the main server.\n\n<Tip>\n  The `prefix` parameter is optional. If omitted, components are imported without modification.\n</Tip>\n\n#### Importing Without Prefixes\n\n<VersionBadge version=\"2.9.0\" />\n\nYou can also import servers without specifying a prefix, which copies components using their original names:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n\nfrom fastmcp import FastMCP\nimport asyncio\n\n# Define subservers\nweather_mcp = FastMCP(name=\"WeatherService\")\n\n@weather_mcp.tool\ndef get_forecast(city: str) -> dict:\n    \"\"\"Get weather forecast.\"\"\"\n    return {\"city\": city, \"forecast\": \"Sunny\"}\n\n@weather_mcp.resource(\"data://cities/supported\")\ndef list_supported_cities() -> list[str]:\n    \"\"\"List cities with weather support.\"\"\"\n    return [\"London\", \"Paris\", \"Tokyo\"]\n\n# Define main server\nmain_mcp = FastMCP(name=\"MainApp\")\n\n# Import subserver\nasync def setup():\n    # Import without prefix - components keep original names\n    await main_mcp.import_server(weather_mcp)\n\n# Result: main_mcp now contains:\n# - Tool: \"get_forecast\" (original name preserved)\n# - Resource: \"data://cities/supported\" (original URI preserved)\n\nif __name__ == \"__main__\":\n    asyncio.run(setup())\n    main_mcp.run()\n```\n\n#### Conflict Resolution\n\n<VersionBadge version=\"2.9.0\" />\n\nWhen importing multiple servers with the same prefix, or no prefix, components from the **most recently imported** server take precedence.\n\n## Mounting (Live Linking)\n\nThe `mount()` method creates a **live link** between the `main_mcp` server and the `subserver`. Instead of copying components, requests for components matching the optional `prefix` are **delegated** to the `subserver` at runtime. If no prefix is provided, the subserver's components are accessible without prefixing. When multiple servers are mounted with the same prefix (or no prefix), the most recently mounted server takes precedence for conflicting component names.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport asyncio\nfrom fastmcp import FastMCP, Client\n\n# Define subserver\ndynamic_mcp = FastMCP(name=\"DynamicService\")\n\n@dynamic_mcp.tool\ndef initial_tool():\n    \"\"\"Initial tool demonstration.\"\"\"\n    return \"Initial Tool Exists\"\n\n# Mount subserver (synchronous operation)\nmain_mcp = FastMCP(name=\"MainAppLive\")\nmain_mcp.mount(dynamic_mcp, prefix=\"dynamic\")\n\n# Add a tool AFTER mounting - it will be accessible through main_mcp\n@dynamic_mcp.tool\ndef added_later():\n    \"\"\"Tool added after mounting.\"\"\"\n    return \"Tool Added Dynamically!\"\n\n# Testing access to mounted tools\nasync def test_dynamic_mount():\n    tools = await main_mcp.get_tools()\n    print(\"Available tools:\", list(tools.keys()))\n    # Shows: ['dynamic_initial_tool', 'dynamic_added_later']\n    \n    async with Client(main_mcp) as client:\n        result = await client.call_tool(\"dynamic_added_later\")\n        print(\"Result:\", result.data)\n        # Shows: \"Tool Added Dynamically!\"\n\nif __name__ == \"__main__\":\n    asyncio.run(test_dynamic_mount())\n```\n\n### How Mounting Works\n\nWhen mounting is configured:\n\n1. **Live Link**: The parent server establishes a connection to the mounted server.\n2. **Dynamic Updates**: Changes to the mounted server are immediately reflected when accessed through the parent.\n3. **Prefixed Access**: The parent server uses prefixes to route requests to the mounted server.\n4. **Delegation**: Requests for components matching the prefix are delegated to the mounted server at runtime.\n\nThe same prefixing rules apply as with `import_server` for naming tools, resources, templates, and prompts. This includes prefixing both the URIs/keys and the names of resources and templates for better identification in multi-server configurations.\n\n<Tip>\n  The `prefix` parameter is optional. If omitted, components are mounted without modification.\n</Tip>\n\n#### Performance Considerations\n\nDue to the \"live link\", operations like `list_tools()` on the parent server will be impacted by the speed of the slowest mounted server. In particular, HTTP-based mounted servers can introduce significant latency (300-400ms vs 1-2ms for local tools), and this slowdown affects the whole server, not just interactions with the HTTP-proxied tools. If performance is important, importing tools via [`import_server()`](#importing-static-composition) may be a more appropriate solution as it copies components once at startup rather than delegating requests at runtime.\n\n#### Mounting Without Prefixes\n\n<VersionBadge version=\"2.9.0\" />\n\nYou can also mount servers without specifying a prefix, which makes components accessible without prefixing. This works identically to [importing without prefixes](#importing-without-prefixes), including [conflict resolution](#conflict-resolution).\n\n### Direct vs. Proxy Mounting\n\n<VersionBadge version=\"2.2.7\" />\n\nFastMCP supports two mounting modes:\n\n1. **Direct Mounting** (default): The parent server directly accesses the mounted server's objects in memory.\n   * No client lifecycle events occur on the mounted server\n   * The mounted server's lifespan context is not executed\n   * Communication is handled through direct method calls\n2. **Proxy Mounting**: The parent server treats the mounted server as a separate entity and communicates with it through a client interface.\n   * Full client lifecycle events occur on the mounted server\n   * The mounted server's lifespan is executed when a client connects\n   * Communication happens via an in-memory Client transport\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Direct mounting (default when no custom lifespan)\nmain_mcp.mount(api_server, prefix=\"api\")\n\n# Proxy mounting (preserves full client lifecycle)\nmain_mcp.mount(api_server, prefix=\"api\", as_proxy=True)\n\n# Mounting without a prefix (components accessible without prefixing)\nmain_mcp.mount(api_server)\n```\n\nFastMCP automatically uses proxy mounting when the mounted server has a custom lifespan, but you can override this behavior with the `as_proxy` parameter.\n\n#### Interaction with Proxy Servers\n\nWhen using `FastMCP.as_proxy()` to create a proxy server, mounting that server will always use proxy mounting:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\n# Create a proxy for a remote server\nremote_proxy = FastMCP.as_proxy(Client(\"http://example.com/mcp\"))\n\n# Mount the proxy (always uses proxy mounting)\nmain_server.mount(remote_proxy, prefix=\"remote\")\n```\n\n## Tag Filtering with Composition\n\n<VersionBadge version=\"2.9.0\" />\n\nWhen using `include_tags` or `exclude_tags` on a parent server, these filters apply **recursively** to all components, including those from mounted or imported servers. This allows you to control which components are exposed at the parent level, regardless of how your application is composed.\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport asyncio\nfrom fastmcp import FastMCP, Client\n\n# Create a subserver with tools tagged for different environments\napi_server = FastMCP(name=\"APIServer\")\n\n@api_server.tool(tags={\"production\"})\ndef prod_endpoint() -> str:\n    \"\"\"Production-ready endpoint.\"\"\"\n    return \"Production data\"\n\n@api_server.tool(tags={\"development\"})\ndef dev_endpoint() -> str:\n    \"\"\"Development-only endpoint.\"\"\"\n    return \"Debug data\"\n\n# Mount the subserver with production tag filtering at parent level\nprod_app = FastMCP(name=\"ProductionApp\", include_tags={\"production\"})\nprod_app.mount(api_server, prefix=\"api\")\n\n# Test the filtering\nasync def test_filtering():\n    async with Client(prod_app) as client:\n        tools = await client.list_tools()\n        print(\"Available tools:\", [t.name for t in tools])\n        # Shows: ['api_prod_endpoint']\n        # The 'api_dev_endpoint' is filtered out\n\n        # Calling the filtered tool raises an error\n        try:\n            await client.call_tool(\"api_dev_endpoint\")\n        except Exception as e:\n            print(f\"Filtered tool not accessible: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(test_filtering())\n```\n\n### How Recursive Filtering Works\n\nTag filters apply in the following order:\n\n1. **Child Server Filters**: Each mounted/imported server first applies its own `include_tags`/`exclude_tags` to its components.\n2. **Parent Server Filters**: The parent server then applies its own `include_tags`/`exclude_tags` to all components, including those from child servers.\n\nThis ensures that parent server tag policies act as a global policy for everything the parent server exposes, no matter how your application is composed.\n\n<Note>\n  This filtering applies to both **listing** (e.g., `list_tools()`) and **execution** (e.g., `call_tool()`). Filtered components are neither visible nor executable through the parent server.\n</Note>\n\n## Resource Prefix Formats\n\n<VersionBadge version=\"2.4.0\" />\n\nWhen mounting or importing servers, resource URIs are usually prefixed to avoid naming conflicts. FastMCP supports two different formats for resource prefixes:\n\n### Path Format (Default)\n\nIn path format, prefixes are added to the path component of the URI:\n\n```\nresource://prefix/path/to/resource\n```\n\nThis is the default format since FastMCP 2.4. This format is recommended because it avoids issues with URI protocol restrictions (like underscores not being allowed in protocol names).\n\n### Protocol Format (Legacy)\n\nIn protocol format, prefixes are added as part of the protocol:\n\n```\nprefix+resource://path/to/resource\n```\n\nThis was the default format in FastMCP before 2.4. While still supported, it's not recommended for new code as it can cause problems with prefix names that aren't valid in URI protocols.\n\n### Configuring the Prefix Format\n\nYou can configure the prefix format globally in code:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nimport fastmcp\nfastmcp.settings.resource_prefix_format = \"protocol\" \n```\n\nOr via environment variable:\n\n```bash  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nFASTMCP_RESOURCE_PREFIX_FORMAT=protocol\n```\n\nOr per-server:\n\n```python  theme={\"theme\":{\"light\":\"snazzy-light\",\"dark\":\"dark-plus\"}}\nfrom fastmcp import FastMCP\n\n# Create a server that uses legacy protocol format\nserver = FastMCP(\"LegacyServer\", resource_prefix_format=\"protocol\")\n\n# Create a server that uses new path format\nserver = FastMCP(\"NewServer\", resource_prefix_format=\"path\")\n```\n\nWhen mounting or importing servers, the prefix format of the parent server is used.\n\n<Note>\n  When mounting servers, custom HTTP routes defined with `@server.custom_route()` are also forwarded to the parent server, making them accessible through the parent's HTTP application.\n</Note>",
  "content_length": 16400
}