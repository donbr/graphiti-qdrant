{
  "title": "`pydantic_ai.agent`",
  "source_url": null,
  "content": "### Agent\n\nBases: `AbstractAgent[AgentDepsT, OutputDataT]`\n\nClass for defining \"agents\" - a way to have a specific type of \"conversation\" with an LLM.\n\nAgents are generic in the dependency type they take AgentDepsT and the output type they return, OutputDataT.\n\nBy default, if neither generic parameter is customised, agents have type `Agent[None, str]`.\n\nMinimal usage example:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\nresult = agent.run_sync('What is the capital of France?')\nprint(result.output)\n#> The capital of France is Paris.\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n````python\n@dataclasses.dataclass(init=False)\nclass Agent(AbstractAgent[AgentDepsT, OutputDataT]):\n    \"\"\"Class for defining \"agents\" - a way to have a specific type of \"conversation\" with an LLM.\n\n    Agents are generic in the dependency type they take [`AgentDepsT`][pydantic_ai.tools.AgentDepsT]\n    and the output type they return, [`OutputDataT`][pydantic_ai.output.OutputDataT].\n\n    By default, if neither generic parameter is customised, agents have type `Agent[None, str]`.\n\n    Minimal usage example:\n\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n    result = agent.run_sync('What is the capital of France?')\n    print(result.output)\n    #> The capital of France is Paris.\n    ```\n    \"\"\"\n\n    _model: models.Model | models.KnownModelName | str | None\n\n    _name: str | None\n    end_strategy: EndStrategy\n    \"\"\"Strategy for handling tool calls when a final result is found.\"\"\"\n\n    model_settings: ModelSettings | None\n    \"\"\"Optional model request settings to use for this agents's runs, by default.\n\n    Note, if `model_settings` is provided by `run`, `run_sync`, or `run_stream`, those settings will\n    be merged with this value, with the runtime argument taking priority.\n    \"\"\"\n\n    _output_type: OutputSpec[OutputDataT]\n\n    instrument: InstrumentationSettings | bool | None\n    \"\"\"Options to automatically instrument with OpenTelemetry.\"\"\"\n\n    _instrument_default: ClassVar[InstrumentationSettings | bool] = False\n\n    _deps_type: type[AgentDepsT] = dataclasses.field(repr=False)\n    _output_schema: _output.OutputSchema[OutputDataT] = dataclasses.field(repr=False)\n    _output_validators: list[_output.OutputValidator[AgentDepsT, OutputDataT]] = dataclasses.field(repr=False)\n    _instructions: list[str | _system_prompt.SystemPromptFunc[AgentDepsT]] = dataclasses.field(repr=False)\n    _system_prompts: tuple[str, ...] = dataclasses.field(repr=False)\n    _system_prompt_functions: list[_system_prompt.SystemPromptRunner[AgentDepsT]] = dataclasses.field(repr=False)\n    _system_prompt_dynamic_functions: dict[str, _system_prompt.SystemPromptRunner[AgentDepsT]] = dataclasses.field(\n        repr=False\n    )\n    _function_toolset: FunctionToolset[AgentDepsT] = dataclasses.field(repr=False)\n    _output_toolset: OutputToolset[AgentDepsT] | None = dataclasses.field(repr=False)\n    _user_toolsets: list[AbstractToolset[AgentDepsT]] = dataclasses.field(repr=False)\n    _prepare_tools: ToolsPrepareFunc[AgentDepsT] | None = dataclasses.field(repr=False)\n    _prepare_output_tools: ToolsPrepareFunc[AgentDepsT] | None = dataclasses.field(repr=False)\n    _max_result_retries: int = dataclasses.field(repr=False)\n    _max_tool_retries: int = dataclasses.field(repr=False)\n    _validation_context: Any | Callable[[RunContext[AgentDepsT]], Any] = dataclasses.field(repr=False)\n\n    _event_stream_handler: EventStreamHandler[AgentDepsT] | None = dataclasses.field(repr=False)\n\n    _enter_lock: Lock = dataclasses.field(repr=False)\n    _entered_count: int = dataclasses.field(repr=False)\n    _exit_stack: AsyncExitStack | None = dataclasses.field(repr=False)\n\n    @overload\n    def __init__(\n        self,\n        model: models.Model | models.KnownModelName | str | None = None,\n        *,\n        output_type: OutputSpec[OutputDataT] = str,\n        instructions: Instructions[AgentDepsT] = None,\n        system_prompt: str | Sequence[str] = (),\n        deps_type: type[AgentDepsT] = NoneType,\n        name: str | None = None,\n        model_settings: ModelSettings | None = None,\n        retries: int = 1,\n        validation_context: Any | Callable[[RunContext[AgentDepsT]], Any] = None,\n        output_retries: int | None = None,\n        tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] = (),\n        builtin_tools: Sequence[AbstractBuiltinTool] = (),\n        prepare_tools: ToolsPrepareFunc[AgentDepsT] | None = None,\n        prepare_output_tools: ToolsPrepareFunc[AgentDepsT] | None = None,\n        toolsets: Sequence[AbstractToolset[AgentDepsT] | ToolsetFunc[AgentDepsT]] | None = None,\n        defer_model_check: bool = False,\n        end_strategy: EndStrategy = 'early',\n        instrument: InstrumentationSettings | bool | None = None,\n        history_processors: Sequence[HistoryProcessor[AgentDepsT]] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> None: ...\n\n    @overload\n    @deprecated('`mcp_servers` is deprecated, use `toolsets` instead.')\n    def __init__(\n        self,\n        model: models.Model | models.KnownModelName | str | None = None,\n        *,\n        output_type: OutputSpec[OutputDataT] = str,\n        instructions: Instructions[AgentDepsT] = None,\n        system_prompt: str | Sequence[str] = (),\n        deps_type: type[AgentDepsT] = NoneType,\n        name: str | None = None,\n        model_settings: ModelSettings | None = None,\n        retries: int = 1,\n        validation_context: Any | Callable[[RunContext[AgentDepsT]], Any] = None,\n        output_retries: int | None = None,\n        tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] = (),\n        builtin_tools: Sequence[AbstractBuiltinTool] = (),\n        prepare_tools: ToolsPrepareFunc[AgentDepsT] | None = None,\n        prepare_output_tools: ToolsPrepareFunc[AgentDepsT] | None = None,\n        mcp_servers: Sequence[MCPServer] = (),\n        defer_model_check: bool = False,\n        end_strategy: EndStrategy = 'early',\n        instrument: InstrumentationSettings | bool | None = None,\n        history_processors: Sequence[HistoryProcessor[AgentDepsT]] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        model: models.Model | models.KnownModelName | str | None = None,\n        *,\n        output_type: OutputSpec[OutputDataT] = str,\n        instructions: Instructions[AgentDepsT] = None,\n        system_prompt: str | Sequence[str] = (),\n        deps_type: type[AgentDepsT] = NoneType,\n        name: str | None = None,\n        model_settings: ModelSettings | None = None,\n        retries: int = 1,\n        validation_context: Any | Callable[[RunContext[AgentDepsT]], Any] = None,\n        output_retries: int | None = None,\n        tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] = (),\n        builtin_tools: Sequence[AbstractBuiltinTool] = (),\n        prepare_tools: ToolsPrepareFunc[AgentDepsT] | None = None,\n        prepare_output_tools: ToolsPrepareFunc[AgentDepsT] | None = None,\n        toolsets: Sequence[AbstractToolset[AgentDepsT] | ToolsetFunc[AgentDepsT]] | None = None,\n        defer_model_check: bool = False,\n        end_strategy: EndStrategy = 'early',\n        instrument: InstrumentationSettings | bool | None = None,\n        history_processors: Sequence[HistoryProcessor[AgentDepsT]] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n        **_deprecated_kwargs: Any,\n    ):\n        \"\"\"Create an agent.\n\n        Args:\n            model: The default model to use for this agent, if not provided,\n                you must provide the model when calling it. We allow `str` here since the actual list of allowed models changes frequently.\n            output_type: The type of the output data, used to validate the data returned by the model,\n                defaults to `str`.\n            instructions: Instructions to use for this agent, you can also register instructions via a function with\n                [`instructions`][pydantic_ai.Agent.instructions] or pass additional, temporary, instructions when executing a run.\n            system_prompt: Static system prompts to use for this agent, you can also register system\n                prompts via a function with [`system_prompt`][pydantic_ai.Agent.system_prompt].\n            deps_type: The type used for dependency injection, this parameter exists solely to allow you to fully\n                parameterize the agent, and therefore get the best out of static type checking.\n                If you're not using deps, but want type checking to pass, you can set `deps=None` to satisfy Pyright\n                or add a type hint `: Agent[None, <return type>]`.\n            name: The name of the agent, used for logging. If `None`, we try to infer the agent name from the call frame\n                when the agent is first run.\n            model_settings: Optional model request settings to use for this agent's runs, by default.\n            retries: The default number of retries to allow for tool calls and output validation, before raising an error.\n                For model request retries, see the [HTTP Request Retries](../retries.md) documentation.\n            validation_context: Pydantic [validation context](https://docs.pydantic.dev/latest/concepts/validators/#validation-context) used to validate tool arguments and outputs.\n            output_retries: The maximum number of retries to allow for output validation, defaults to `retries`.\n            tools: Tools to register with the agent, you can also register tools via the decorators\n                [`@agent.tool`][pydantic_ai.Agent.tool] and [`@agent.tool_plain`][pydantic_ai.Agent.tool_plain].\n            builtin_tools: The builtin tools that the agent will use. This depends on the model, as some models may not\n                support certain tools. If the model doesn't support the builtin tools, an error will be raised.\n            prepare_tools: Custom function to prepare the tool definition of all tools for each step, except output tools.\n                This is useful if you want to customize the definition of multiple tools or you want to register\n                a subset of tools for a given step. See [`ToolsPrepareFunc`][pydantic_ai.tools.ToolsPrepareFunc]\n            prepare_output_tools: Custom function to prepare the tool definition of all output tools for each step.\n                This is useful if you want to customize the definition of multiple output tools or you want to register\n                a subset of output tools for a given step. See [`ToolsPrepareFunc`][pydantic_ai.tools.ToolsPrepareFunc]\n            toolsets: Toolsets to register with the agent, including MCP servers and functions which take a run context\n                and return a toolset. See [`ToolsetFunc`][pydantic_ai.toolsets.ToolsetFunc] for more information.\n            defer_model_check: by default, if you provide a [named][pydantic_ai.models.KnownModelName] model,\n                it's evaluated to create a [`Model`][pydantic_ai.models.Model] instance immediately,\n                which checks for the necessary environment variables. Set this to `false`\n                to defer the evaluation until the first run. Useful if you want to\n                [override the model][pydantic_ai.Agent.override] for testing.\n            end_strategy: Strategy for handling tool calls that are requested alongside a final result.\n                See [`EndStrategy`][pydantic_ai.agent.EndStrategy] for more information.\n            instrument: Set to True to automatically instrument with OpenTelemetry,\n                which will use Logfire if it's configured.\n                Set to an instance of [`InstrumentationSettings`][pydantic_ai.agent.InstrumentationSettings] to customize.\n                If this isn't set, then the last value set by\n                [`Agent.instrument_all()`][pydantic_ai.Agent.instrument_all]\n                will be used, which defaults to False.\n                See the [Debugging and Monitoring guide](https://ai.pydantic.dev/logfire/) for more info.\n            history_processors: Optional list of callables to process the message history before sending it to the model.\n                Each processor takes a list of messages and returns a modified list of messages.\n                Processors can be sync or async and are applied in sequence.\n            event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools.\n        \"\"\"\n        if model is None or defer_model_check:\n            self._model = model\n        else:\n            self._model = models.infer_model(model)\n\n        self._name = name\n        self.end_strategy = end_strategy\n        self.model_settings = model_settings\n\n        self._output_type = output_type\n        self.instrument = instrument\n        self._deps_type = deps_type\n\n        if mcp_servers := _deprecated_kwargs.pop('mcp_servers', None):\n            if toolsets is not None:  # pragma: no cover\n                raise TypeError('`mcp_servers` and `toolsets` cannot be set at the same time.')\n            warnings.warn('`mcp_servers` is deprecated, use `toolsets` instead', DeprecationWarning)\n            toolsets = mcp_servers\n\n        _utils.validate_empty_kwargs(_deprecated_kwargs)\n\n        self._output_schema = _output.OutputSchema[OutputDataT].build(output_type)\n        self._output_validators = []\n\n        self._instructions = self._normalize_instructions(instructions)\n\n        self._system_prompts = (system_prompt,) if isinstance(system_prompt, str) else tuple(system_prompt)\n        self._system_prompt_functions = []\n        self._system_prompt_dynamic_functions = {}\n\n        self._max_result_retries = output_retries if output_retries is not None else retries\n        self._max_tool_retries = retries\n\n        self._validation_context = validation_context\n\n        self._builtin_tools = builtin_tools\n\n        self._prepare_tools = prepare_tools\n        self._prepare_output_tools = prepare_output_tools\n\n        self._output_toolset = self._output_schema.toolset\n        if self._output_toolset:\n            self._output_toolset.max_retries = self._max_result_retries\n\n        self._function_toolset = _AgentFunctionToolset(\n            tools, max_retries=self._max_tool_retries, output_schema=self._output_schema\n        )\n        self._dynamic_toolsets = [\n            DynamicToolset[AgentDepsT](toolset_func=toolset)\n            for toolset in toolsets or []\n            if not isinstance(toolset, AbstractToolset)\n        ]\n        self._user_toolsets = [toolset for toolset in toolsets or [] if isinstance(toolset, AbstractToolset)]\n\n        self.history_processors = history_processors or []\n\n        self._event_stream_handler = event_stream_handler\n\n        self._override_name: ContextVar[_utils.Option[str]] = ContextVar('_override_name', default=None)\n        self._override_deps: ContextVar[_utils.Option[AgentDepsT]] = ContextVar('_override_deps', default=None)\n        self._override_model: ContextVar[_utils.Option[models.Model]] = ContextVar('_override_model', default=None)\n        self._override_toolsets: ContextVar[_utils.Option[Sequence[AbstractToolset[AgentDepsT]]]] = ContextVar(\n            '_override_toolsets', default=None\n        )\n        self._override_tools: ContextVar[\n            _utils.Option[Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]]]\n        ] = ContextVar('_override_tools', default=None)\n        self._override_instructions: ContextVar[\n            _utils.Option[list[str | _system_prompt.SystemPromptFunc[AgentDepsT]]]\n        ] = ContextVar('_override_instructions', default=None)\n\n        self._enter_lock = Lock()\n        self._entered_count = 0\n        self._exit_stack = None\n\n    @staticmethod\n    def instrument_all(instrument: InstrumentationSettings | bool = True) -> None:\n        \"\"\"Set the instrumentation options for all agents where `instrument` is not set.\"\"\"\n        Agent._instrument_default = instrument\n\n    @property\n    def model(self) -> models.Model | models.KnownModelName | str | None:\n        \"\"\"The default model configured for this agent.\"\"\"\n        return self._model\n\n    @model.setter\n    def model(self, value: models.Model | models.KnownModelName | str | None) -> None:\n        \"\"\"Set the default model configured for this agent.\n\n        We allow `str` here since the actual list of allowed models changes frequently.\n        \"\"\"\n        self._model = value\n\n    @property\n    def name(self) -> str | None:\n        \"\"\"The name of the agent, used for logging.\n\n        If `None`, we try to infer the agent name from the call frame when the agent is first run.\n        \"\"\"\n        name_ = self._override_name.get()\n        return name_.value if name_ else self._name\n\n    @name.setter\n    def name(self, value: str | None) -> None:\n        \"\"\"Set the name of the agent, used for logging.\"\"\"\n        self._name = value\n\n    @property\n    def deps_type(self) -> type:\n        \"\"\"The type of dependencies used by the agent.\"\"\"\n        return self._deps_type\n\n    @property\n    def output_type(self) -> OutputSpec[OutputDataT]:\n        \"\"\"The type of data output by agent runs, used to validate the data returned by the model, defaults to `str`.\"\"\"\n        return self._output_type\n\n    @property\n    def event_stream_handler(self) -> EventStreamHandler[AgentDepsT] | None:\n        \"\"\"Optional handler for events from the model's streaming response and the agent's execution of tools.\"\"\"\n        return self._event_stream_handler\n\n    def __repr__(self) -> str:\n        return f'{type(self).__name__}(model={self.model!r}, name={self.name!r}, end_strategy={self.end_strategy!r}, model_settings={self.model_settings!r}, output_type={self.output_type!r}, instrument={self.instrument!r})'\n\n    @overload\n    def iter(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AbstractAsyncContextManager[AgentRun[AgentDepsT, OutputDataT]]: ...\n\n    @overload\n    def iter(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT],\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AbstractAsyncContextManager[AgentRun[AgentDepsT, RunOutputDataT]]: ...\n\n    @asynccontextmanager\n    async def iter(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[Any] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AsyncIterator[AgentRun[AgentDepsT, Any]]:\n        \"\"\"A contextmanager which can be used to iterate over the agent graph's nodes as they are executed.\n\n        This method builds an internal agent graph (using system prompts, tools and output schemas) and then returns an\n        `AgentRun` object. The `AgentRun` can be used to async-iterate over the nodes of the graph as they are\n        executed. This is the API to use if you want to consume the outputs coming from each LLM model response, or the\n        stream of events coming from the execution of tools.\n\n        The `AgentRun` also provides methods to access the full message history, new messages, and usage statistics,\n        and the final result of the run once it has completed.\n\n        For more details, see the documentation of `AgentRun`.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o')\n\n        async def main():\n            nodes = []\n            async with agent.iter('What is the capital of France?') as agent_run:\n                async for node in agent_run:\n                    nodes.append(node)\n            print(nodes)\n            '''\n            [\n                UserPromptNode(\n                    user_prompt='What is the capital of France?',\n                    instructions_functions=[],\n                    system_prompts=(),\n                    system_prompt_functions=[],\n                    system_prompt_dynamic_functions={},\n                ),\n                ModelRequestNode(\n                    request=ModelRequest(\n                        parts=[\n                            UserPromptPart(\n                                content='What is the capital of France?',\n                                timestamp=datetime.datetime(...),\n                            )\n                        ],\n                        run_id='...',\n                    )\n                ),\n                CallToolsNode(\n                    model_response=ModelResponse(\n                        parts=[TextPart(content='The capital of France is Paris.')],\n                        usage=RequestUsage(input_tokens=56, output_tokens=7),\n                        model_name='gpt-4o',\n                        timestamp=datetime.datetime(...),\n                        run_id='...',\n                    )\n                ),\n                End(data=FinalResult(output='The capital of France is Paris.')),\n            ]\n            '''\n            print(agent_run.result.output)\n            #> The capital of France is Paris.\n        ```\n\n        Args:\n            user_prompt: User input to start/continue the conversation.\n            output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n                output validators since output validators would expect an argument that matches the agent's output type.\n            message_history: History of the conversation so far.\n            deferred_tool_results: Optional results for deferred tool calls in the message history.\n            model: Optional model to use for this run, required if `model` was not set when creating the agent.\n            instructions: Optional additional instructions to use for this run.\n            deps: Optional dependencies to use for this run.\n            model_settings: Optional settings to use for this model's request.\n            usage_limits: Optional limits on model request count or token usage.\n            usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n            infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n            toolsets: Optional additional toolsets for this run.\n            builtin_tools: Optional additional builtin tools for this run.\n\n        Returns:\n            The result of the run.\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n\n        model_used = self._get_model(model)\n        del model\n\n        deps = self._get_deps(deps)\n        output_schema = self._prepare_output_schema(output_type)\n\n        output_type_ = output_type or self.output_type\n\n        # We consider it a user error if a user tries to restrict the result type while having an output validator that\n        # may change the result type from the restricted type to something else. Therefore, we consider the following\n        # typecast reasonable, even though it is possible to violate it with otherwise-type-checked code.\n        output_validators = self._output_validators\n\n        output_toolset = self._output_toolset\n        if output_schema != self._output_schema or output_validators:\n            output_toolset = output_schema.toolset\n            if output_toolset:\n                output_toolset.max_retries = self._max_result_retries\n                output_toolset.output_validators = output_validators\n        toolset = self._get_toolset(output_toolset=output_toolset, additional_toolsets=toolsets)\n        tool_manager = ToolManager[AgentDepsT](toolset)\n\n        # Build the graph\n        graph = _agent_graph.build_agent_graph(self.name, self._deps_type, output_type_)\n\n        # Build the initial state\n        usage = usage or _usage.RunUsage()\n        state = _agent_graph.GraphAgentState(\n            message_history=list(message_history) if message_history else [],\n            usage=usage,\n            retries=0,\n            run_step=0,\n        )\n\n        # Merge model settings in order of precedence: run > agent > model\n        merged_settings = merge_model_settings(model_used.settings, self.model_settings)\n        model_settings = merge_model_settings(merged_settings, model_settings)\n        usage_limits = usage_limits or _usage.UsageLimits()\n\n        instructions_literal, instructions_functions = self._get_instructions(additional_instructions=instructions)\n\n        async def get_instructions(run_context: RunContext[AgentDepsT]) -> str | None:\n            parts = [\n                instructions_literal,\n                *[await func.run(run_context) for func in instructions_functions],\n            ]\n\n            parts = [p for p in parts if p]\n            if not parts:\n                return None\n            return '\\n\\n'.join(parts).strip()\n\n        if isinstance(model_used, InstrumentedModel):\n            instrumentation_settings = model_used.instrumentation_settings\n            tracer = model_used.instrumentation_settings.tracer\n        else:\n            instrumentation_settings = None\n            tracer = NoOpTracer()\n\n        graph_deps = _agent_graph.GraphAgentDeps[AgentDepsT, OutputDataT](\n            user_deps=deps,\n            prompt=user_prompt,\n            new_message_index=len(message_history) if message_history else 0,\n            model=model_used,\n            model_settings=model_settings,\n            usage_limits=usage_limits,\n            max_result_retries=self._max_result_retries,\n            end_strategy=self.end_strategy,\n            output_schema=output_schema,\n            output_validators=output_validators,\n            validation_context=self._validation_context,\n            history_processors=self.history_processors,\n            builtin_tools=[*self._builtin_tools, *(builtin_tools or [])],\n            tool_manager=tool_manager,\n            tracer=tracer,\n            get_instructions=get_instructions,\n            instrumentation_settings=instrumentation_settings,\n        )\n\n        user_prompt_node = _agent_graph.UserPromptNode[AgentDepsT](\n            user_prompt=user_prompt,\n            deferred_tool_results=deferred_tool_results,\n            instructions=instructions_literal,\n            instructions_functions=instructions_functions,\n            system_prompts=self._system_prompts,\n            system_prompt_functions=self._system_prompt_functions,\n            system_prompt_dynamic_functions=self._system_prompt_dynamic_functions,\n        )\n\n        agent_name = self.name or 'agent'\n        instrumentation_names = InstrumentationNames.for_version(\n            instrumentation_settings.version if instrumentation_settings else DEFAULT_INSTRUMENTATION_VERSION\n        )\n\n        run_span = tracer.start_span(\n            instrumentation_names.get_agent_run_span_name(agent_name),\n            attributes={\n                'model_name': model_used.model_name if model_used else 'no-model',\n                'agent_name': agent_name,\n                'gen_ai.agent.name': agent_name,\n                'logfire.msg': f'{agent_name} run',\n            },\n        )\n\n        try:\n            async with graph.iter(\n                inputs=user_prompt_node,\n                state=state,\n                deps=graph_deps,\n                span=use_span(run_span) if run_span.is_recording() else None,\n                infer_name=False,\n            ) as graph_run:\n                async with toolset:\n                    agent_run = AgentRun(graph_run)\n                    yield agent_run\n                    if (final_result := agent_run.result) is not None and run_span.is_recording():\n                        if instrumentation_settings and instrumentation_settings.include_content:\n                            run_span.set_attribute(\n                                'final_result',\n                                (\n                                    final_result.output\n                                    if isinstance(final_result.output, str)\n                                    else json.dumps(InstrumentedModel.serialize_any(final_result.output))\n                                ),\n                            )\n        finally:\n            try:\n                if instrumentation_settings and run_span.is_recording():\n                    run_span.set_attributes(\n                        self._run_span_end_attributes(\n                            instrumentation_settings, usage, state.message_history, graph_deps.new_message_index\n                        )\n                    )\n            finally:\n                run_span.end()\n\n    def _run_span_end_attributes(\n        self,\n        settings: InstrumentationSettings,\n        usage: _usage.RunUsage,\n        message_history: list[_messages.ModelMessage],\n        new_message_index: int,\n    ):\n        if settings.version == 1:\n            attrs = {\n                'all_messages_events': json.dumps(\n                    [InstrumentedModel.event_to_dict(e) for e in settings.messages_to_otel_events(message_history)]\n                )\n            }\n        else:\n            # Store the last instructions here for convenience\n            last_instructions = InstrumentedModel._get_instructions(message_history)  # pyright: ignore[reportPrivateUsage]\n            attrs: dict[str, Any] = {\n                'pydantic_ai.all_messages': json.dumps(settings.messages_to_otel_messages(list(message_history))),\n                **settings.system_instructions_attributes(last_instructions),\n            }\n\n            # If this agent run was provided with existing history, store an attribute indicating the point at which the\n            # new messages begin.\n            if new_message_index > 0:\n                attrs['pydantic_ai.new_message_index'] = new_message_index\n\n            # If the instructions for this agent run were not always the same, store an attribute that indicates that.\n            # This can signal to an observability UI that different steps in the agent run had different instructions.\n            # Note: We purposely only look at \"new\" messages because they are the only ones produced by this agent run.\n            if any(\n                (\n                    isinstance(m, _messages.ModelRequest)\n                    and m.instructions is not None\n                    and m.instructions != last_instructions\n                )\n                for m in message_history[new_message_index:]\n            ):\n                attrs['pydantic_ai.variable_instructions'] = True\n\n        return {\n            **usage.opentelemetry_attributes(),\n            **attrs,\n            'logfire.json_schema': json.dumps(\n                {\n                    'type': 'object',\n                    'properties': {\n                        **{k: {'type': 'array'} if isinstance(v, str) else {} for k, v in attrs.items()},\n                        'final_result': {'type': 'object'},\n                    },\n                }\n            ),\n        }\n\n    @contextmanager\n    def override(\n        self,\n        *,\n        name: str | _utils.Unset = _utils.UNSET,\n        deps: AgentDepsT | _utils.Unset = _utils.UNSET,\n        model: models.Model | models.KnownModelName | str | _utils.Unset = _utils.UNSET,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | _utils.Unset = _utils.UNSET,\n        tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] | _utils.Unset = _utils.UNSET,\n        instructions: Instructions[AgentDepsT] | _utils.Unset = _utils.UNSET,\n    ) -> Iterator[None]:\n        \"\"\"Context manager to temporarily override agent name, dependencies, model, toolsets, tools, or instructions.\n\n        This is particularly useful when testing.\n        You can find an example of this [here](../testing.md#overriding-model-via-pytest-fixtures).\n\n        Args:\n            name: The name to use instead of the name passed to the agent constructor and agent run.\n            deps: The dependencies to use instead of the dependencies passed to the agent run.\n            model: The model to use instead of the model passed to the agent run.\n            toolsets: The toolsets to use instead of the toolsets passed to the agent constructor and agent run.\n            tools: The tools to use instead of the tools registered with the agent.\n            instructions: The instructions to use instead of the instructions registered with the agent.\n        \"\"\"\n        if _utils.is_set(name):\n            name_token = self._override_name.set(_utils.Some(name))\n        else:\n            name_token = None\n\n        if _utils.is_set(deps):\n            deps_token = self._override_deps.set(_utils.Some(deps))\n        else:\n            deps_token = None\n\n        if _utils.is_set(model):\n            model_token = self._override_model.set(_utils.Some(models.infer_model(model)))\n        else:\n            model_token = None\n\n        if _utils.is_set(toolsets):\n            toolsets_token = self._override_toolsets.set(_utils.Some(toolsets))\n        else:\n            toolsets_token = None\n\n        if _utils.is_set(tools):\n            tools_token = self._override_tools.set(_utils.Some(tools))\n        else:\n            tools_token = None\n\n        if _utils.is_set(instructions):\n            normalized_instructions = self._normalize_instructions(instructions)\n            instructions_token = self._override_instructions.set(_utils.Some(normalized_instructions))\n        else:\n            instructions_token = None\n\n        try:\n            yield\n        finally:\n            if name_token is not None:\n                self._override_name.reset(name_token)\n            if deps_token is not None:\n                self._override_deps.reset(deps_token)\n            if model_token is not None:\n                self._override_model.reset(model_token)\n            if toolsets_token is not None:\n                self._override_toolsets.reset(toolsets_token)\n            if tools_token is not None:\n                self._override_tools.reset(tools_token)\n            if instructions_token is not None:\n                self._override_instructions.reset(instructions_token)\n\n    @overload\n    def instructions(\n        self, func: Callable[[RunContext[AgentDepsT]], str], /\n    ) -> Callable[[RunContext[AgentDepsT]], str]: ...\n\n    @overload\n    def instructions(\n        self, func: Callable[[RunContext[AgentDepsT]], Awaitable[str]], /\n    ) -> Callable[[RunContext[AgentDepsT]], Awaitable[str]]: ...\n\n    @overload\n    def instructions(self, func: Callable[[], str], /) -> Callable[[], str]: ...\n\n    @overload\n    def instructions(self, func: Callable[[], Awaitable[str]], /) -> Callable[[], Awaitable[str]]: ...\n\n    @overload\n    def instructions(\n        self, /\n    ) -> Callable[[_system_prompt.SystemPromptFunc[AgentDepsT]], _system_prompt.SystemPromptFunc[AgentDepsT]]: ...\n\n    def instructions(\n        self,\n        func: _system_prompt.SystemPromptFunc[AgentDepsT] | None = None,\n        /,\n    ) -> (\n        Callable[[_system_prompt.SystemPromptFunc[AgentDepsT]], _system_prompt.SystemPromptFunc[AgentDepsT]]\n        | _system_prompt.SystemPromptFunc[AgentDepsT]\n    ):\n        \"\"\"Decorator to register an instructions function.\n\n        Optionally takes [`RunContext`][pydantic_ai.tools.RunContext] as its only argument.\n        Can decorate a sync or async functions.\n\n        The decorator can be used bare (`agent.instructions`).\n\n        Overloads for every possible signature of `instructions` are included so the decorator doesn't obscure\n        the type of the function.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent, RunContext\n\n        agent = Agent('test', deps_type=str)\n\n        @agent.instructions\n        def simple_instructions() -> str:\n            return 'foobar'\n\n        @agent.instructions\n        async def async_instructions(ctx: RunContext[str]) -> str:\n            return f'{ctx.deps} is the best'\n        ```\n        \"\"\"\n        if func is None:\n\n            def decorator(\n                func_: _system_prompt.SystemPromptFunc[AgentDepsT],\n            ) -> _system_prompt.SystemPromptFunc[AgentDepsT]:\n                self._instructions.append(func_)\n                return func_\n\n            return decorator\n        else:\n            self._instructions.append(func)\n            return func\n\n    @overload\n    def system_prompt(\n        self, func: Callable[[RunContext[AgentDepsT]], str], /\n    ) -> Callable[[RunContext[AgentDepsT]], str]: ...\n\n    @overload\n    def system_prompt(\n        self, func: Callable[[RunContext[AgentDepsT]], Awaitable[str]], /\n    ) -> Callable[[RunContext[AgentDepsT]], Awaitable[str]]: ...\n\n    @overload\n    def system_prompt(self, func: Callable[[], str], /) -> Callable[[], str]: ...\n\n    @overload\n    def system_prompt(self, func: Callable[[], Awaitable[str]], /) -> Callable[[], Awaitable[str]]: ...\n\n    @overload\n    def system_prompt(\n        self, /, *, dynamic: bool = False\n    ) -> Callable[[_system_prompt.SystemPromptFunc[AgentDepsT]], _system_prompt.SystemPromptFunc[AgentDepsT]]: ...\n\n    def system_prompt(\n        self,\n        func: _system_prompt.SystemPromptFunc[AgentDepsT] | None = None,\n        /,\n        *,\n        dynamic: bool = False,\n    ) -> (\n        Callable[[_system_prompt.SystemPromptFunc[AgentDepsT]], _system_prompt.SystemPromptFunc[AgentDepsT]]\n        | _system_prompt.SystemPromptFunc[AgentDepsT]\n    ):\n        \"\"\"Decorator to register a system prompt function.\n\n        Optionally takes [`RunContext`][pydantic_ai.tools.RunContext] as its only argument.\n        Can decorate a sync or async functions.\n\n        The decorator can be used either bare (`agent.system_prompt`) or as a function call\n        (`agent.system_prompt(...)`), see the examples below.\n\n        Overloads for every possible signature of `system_prompt` are included so the decorator doesn't obscure\n        the type of the function, see `tests/typed_agent.py` for tests.\n\n        Args:\n            func: The function to decorate\n            dynamic: If True, the system prompt will be reevaluated even when `messages_history` is provided,\n                see [`SystemPromptPart.dynamic_ref`][pydantic_ai.messages.SystemPromptPart.dynamic_ref]\n\n        Example:\n        ```python\n        from pydantic_ai import Agent, RunContext\n\n        agent = Agent('test', deps_type=str)\n\n        @agent.system_prompt\n        def simple_system_prompt() -> str:\n            return 'foobar'\n\n        @agent.system_prompt(dynamic=True)\n        async def async_system_prompt(ctx: RunContext[str]) -> str:\n            return f'{ctx.deps} is the best'\n        ```\n        \"\"\"\n        if func is None:\n\n            def decorator(\n                func_: _system_prompt.SystemPromptFunc[AgentDepsT],\n            ) -> _system_prompt.SystemPromptFunc[AgentDepsT]:\n                runner = _system_prompt.SystemPromptRunner[AgentDepsT](func_, dynamic=dynamic)\n                self._system_prompt_functions.append(runner)\n                if dynamic:  # pragma: lax no cover\n                    self._system_prompt_dynamic_functions[func_.__qualname__] = runner\n                return func_\n\n            return decorator\n        else:\n            assert not dynamic, \"dynamic can't be True in this case\"\n            self._system_prompt_functions.append(_system_prompt.SystemPromptRunner[AgentDepsT](func, dynamic=dynamic))\n            return func\n\n    @overload\n    def output_validator(\n        self, func: Callable[[RunContext[AgentDepsT], OutputDataT], OutputDataT], /\n    ) -> Callable[[RunContext[AgentDepsT], OutputDataT], OutputDataT]: ...\n\n    @overload\n    def output_validator(\n        self, func: Callable[[RunContext[AgentDepsT], OutputDataT], Awaitable[OutputDataT]], /\n    ) -> Callable[[RunContext[AgentDepsT], OutputDataT], Awaitable[OutputDataT]]: ...\n\n    @overload\n    def output_validator(\n        self, func: Callable[[OutputDataT], OutputDataT], /\n    ) -> Callable[[OutputDataT], OutputDataT]: ...\n\n    @overload\n    def output_validator(\n        self, func: Callable[[OutputDataT], Awaitable[OutputDataT]], /\n    ) -> Callable[[OutputDataT], Awaitable[OutputDataT]]: ...\n\n    def output_validator(\n        self, func: _output.OutputValidatorFunc[AgentDepsT, OutputDataT], /\n    ) -> _output.OutputValidatorFunc[AgentDepsT, OutputDataT]:\n        \"\"\"Decorator to register an output validator function.\n\n        Optionally takes [`RunContext`][pydantic_ai.tools.RunContext] as its first argument.\n        Can decorate a sync or async functions.\n\n        Overloads for every possible signature of `output_validator` are included so the decorator doesn't obscure\n        the type of the function, see `tests/typed_agent.py` for tests.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent, ModelRetry, RunContext\n\n        agent = Agent('test', deps_type=str)\n\n        @agent.output_validator\n        def output_validator_simple(data: str) -> str:\n            if 'wrong' in data:\n                raise ModelRetry('wrong response')\n            return data\n\n        @agent.output_validator\n        async def output_validator_deps(ctx: RunContext[str], data: str) -> str:\n            if ctx.deps in data:\n                raise ModelRetry('wrong response')\n            return data\n\n        result = agent.run_sync('foobar', deps='spam')\n        print(result.output)\n        #> success (no tool calls)\n        ```\n        \"\"\"\n        self._output_validators.append(_output.OutputValidator[AgentDepsT, Any](func))\n        return func\n\n    @overload\n    def tool(self, func: ToolFuncContext[AgentDepsT, ToolParams], /) -> ToolFuncContext[AgentDepsT, ToolParams]: ...\n\n    @overload\n    def tool(\n        self,\n        /,\n        *,\n        name: str | None = None,\n        description: str | None = None,\n        retries: int | None = None,\n        prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n        docstring_format: DocstringFormat = 'auto',\n        require_parameter_descriptions: bool = False,\n        schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n        strict: bool | None = None,\n        sequential: bool = False,\n        requires_approval: bool = False,\n        metadata: dict[str, Any] | None = None,\n    ) -> Callable[[ToolFuncContext[AgentDepsT, ToolParams]], ToolFuncContext[AgentDepsT, ToolParams]]: ...\n\n    def tool(\n        self,\n        func: ToolFuncContext[AgentDepsT, ToolParams] | None = None,\n        /,\n        *,\n        name: str | None = None,\n        description: str | None = None,\n        retries: int | None = None,\n        prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n        docstring_format: DocstringFormat = 'auto',\n        require_parameter_descriptions: bool = False,\n        schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n        strict: bool | None = None,\n        sequential: bool = False,\n        requires_approval: bool = False,\n        metadata: dict[str, Any] | None = None,\n    ) -> Any:\n        \"\"\"Decorator to register a tool function which takes [`RunContext`][pydantic_ai.tools.RunContext] as its first argument.\n\n        Can decorate a sync or async functions.\n\n        The docstring is inspected to extract both the tool description and description of each parameter,\n        [learn more](../tools.md#function-tools-and-schema).\n\n        We can't add overloads for every possible signature of tool, since the return type is a recursive union\n        so the signature of functions decorated with `@agent.tool` is obscured.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent, RunContext\n\n        agent = Agent('test', deps_type=int)\n\n        @agent.tool\n        def foobar(ctx: RunContext[int], x: int) -> int:\n            return ctx.deps + x\n\n        @agent.tool(retries=2)\n        async def spam(ctx: RunContext[str], y: float) -> float:\n            return ctx.deps + y\n\n        result = agent.run_sync('foobar', deps=1)\n        print(result.output)\n        #> {\"foobar\":1,\"spam\":1.0}\n        ```\n\n        Args:\n            func: The tool function to register.\n            name: The name of the tool, defaults to the function name.\n            description: The description of the tool, defaults to the function docstring.\n            retries: The number of retries to allow for this tool, defaults to the agent's default retries,\n                which defaults to 1.\n            prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n                tool from a given step. This is useful if you want to customise a tool at call time,\n                or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n            docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n                Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.\n            require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.\n            schema_generator: The JSON schema generator class to use for this tool. Defaults to `GenerateToolJsonSchema`.\n            strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n                See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n            sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n            requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n                See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n            metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n        \"\"\"\n\n        def tool_decorator(\n            func_: ToolFuncContext[AgentDepsT, ToolParams],\n        ) -> ToolFuncContext[AgentDepsT, ToolParams]:\n            # noinspection PyTypeChecker\n            self._function_toolset.add_function(\n                func_,\n                takes_ctx=True,\n                name=name,\n                description=description,\n                retries=retries,\n                prepare=prepare,\n                docstring_format=docstring_format,\n                require_parameter_descriptions=require_parameter_descriptions,\n                schema_generator=schema_generator,\n                strict=strict,\n                sequential=sequential,\n                requires_approval=requires_approval,\n                metadata=metadata,\n            )\n            return func_\n\n        return tool_decorator if func is None else tool_decorator(func)\n\n    @overload\n    def tool_plain(self, func: ToolFuncPlain[ToolParams], /) -> ToolFuncPlain[ToolParams]: ...\n\n    @overload\n    def tool_plain(\n        self,\n        /,\n        *,\n        name: str | None = None,\n        description: str | None = None,\n        retries: int | None = None,\n        prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n        docstring_format: DocstringFormat = 'auto',\n        require_parameter_descriptions: bool = False,\n        schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n        strict: bool | None = None,\n        sequential: bool = False,\n        requires_approval: bool = False,\n        metadata: dict[str, Any] | None = None,\n    ) -> Callable[[ToolFuncPlain[ToolParams]], ToolFuncPlain[ToolParams]]: ...\n\n    def tool_plain(\n        self,\n        func: ToolFuncPlain[ToolParams] | None = None,\n        /,\n        *,\n        name: str | None = None,\n        description: str | None = None,\n        retries: int | None = None,\n        prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n        docstring_format: DocstringFormat = 'auto',\n        require_parameter_descriptions: bool = False,\n        schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n        strict: bool | None = None,\n        sequential: bool = False,\n        requires_approval: bool = False,\n        metadata: dict[str, Any] | None = None,\n    ) -> Any:\n        \"\"\"Decorator to register a tool function which DOES NOT take `RunContext` as an argument.\n\n        Can decorate a sync or async functions.\n\n        The docstring is inspected to extract both the tool description and description of each parameter,\n        [learn more](../tools.md#function-tools-and-schema).\n\n        We can't add overloads for every possible signature of tool, since the return type is a recursive union\n        so the signature of functions decorated with `@agent.tool` is obscured.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent, RunContext\n\n        agent = Agent('test')\n\n        @agent.tool\n        def foobar(ctx: RunContext[int]) -> int:\n            return 123\n\n        @agent.tool(retries=2)\n        async def spam(ctx: RunContext[str]) -> float:\n            return 3.14\n\n        result = agent.run_sync('foobar', deps=1)\n        print(result.output)\n        #> {\"foobar\":123,\"spam\":3.14}\n        ```\n\n        Args:\n            func: The tool function to register.\n            name: The name of the tool, defaults to the function name.\n            description: The description of the tool, defaults to the function docstring.\n            retries: The number of retries to allow for this tool, defaults to the agent's default retries,\n                which defaults to 1.\n            prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n                tool from a given step. This is useful if you want to customise a tool at call time,\n                or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n            docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n                Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.\n            require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.\n            schema_generator: The JSON schema generator class to use for this tool. Defaults to `GenerateToolJsonSchema`.\n            strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n                See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n            sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n            requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n                See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n            metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n        \"\"\"\n\n        def tool_decorator(func_: ToolFuncPlain[ToolParams]) -> ToolFuncPlain[ToolParams]:\n            # noinspection PyTypeChecker\n            self._function_toolset.add_function(\n                func_,\n                takes_ctx=False,\n                name=name,\n                description=description,\n                retries=retries,\n                prepare=prepare,\n                docstring_format=docstring_format,\n                require_parameter_descriptions=require_parameter_descriptions,\n                schema_generator=schema_generator,\n                strict=strict,\n                sequential=sequential,\n                requires_approval=requires_approval,\n                metadata=metadata,\n            )\n            return func_\n\n        return tool_decorator if func is None else tool_decorator(func)\n\n    @overload\n    def toolset(self, func: ToolsetFunc[AgentDepsT], /) -> ToolsetFunc[AgentDepsT]: ...\n\n    @overload\n    def toolset(\n        self,\n        /,\n        *,\n        per_run_step: bool = True,\n    ) -> Callable[[ToolsetFunc[AgentDepsT]], ToolsetFunc[AgentDepsT]]: ...\n\n    def toolset(\n        self,\n        func: ToolsetFunc[AgentDepsT] | None = None,\n        /,\n        *,\n        per_run_step: bool = True,\n    ) -> Any:\n        \"\"\"Decorator to register a toolset function which takes [`RunContext`][pydantic_ai.tools.RunContext] as its only argument.\n\n        Can decorate a sync or async functions.\n\n        The decorator can be used bare (`agent.toolset`).\n\n        Example:\n        ```python\n        from pydantic_ai import AbstractToolset, Agent, FunctionToolset, RunContext\n\n        agent = Agent('test', deps_type=str)\n\n        @agent.toolset\n        async def simple_toolset(ctx: RunContext[str]) -> AbstractToolset[str]:\n            return FunctionToolset()\n        ```\n\n        Args:\n            func: The toolset function to register.\n            per_run_step: Whether to re-evaluate the toolset for each run step. Defaults to True.\n        \"\"\"\n\n        def toolset_decorator(func_: ToolsetFunc[AgentDepsT]) -> ToolsetFunc[AgentDepsT]:\n            self._dynamic_toolsets.append(DynamicToolset(func_, per_run_step=per_run_step))\n            return func_\n\n        return toolset_decorator if func is None else toolset_decorator(func)\n\n    def _get_model(self, model: models.Model | models.KnownModelName | str | None) -> models.Model:\n        \"\"\"Create a model configured for this agent.\n\n        Args:\n            model: model to use for this run, required if `model` was not set when creating the agent.\n\n        Returns:\n            The model used\n        \"\"\"\n        model_: models.Model\n        if some_model := self._override_model.get():\n            # we don't want `override()` to cover up errors from the model not being defined, hence this check\n            if model is None and self.model is None:\n                raise exceptions.UserError(\n                    '`model` must either be set on the agent or included when calling it. '\n                    '(Even when `override(model=...)` is customizing the model that will actually be called)'\n                )\n            model_ = some_model.value\n        elif model is not None:\n            model_ = models.infer_model(model)\n        elif self.model is not None:\n            # noinspection PyTypeChecker\n            model_ = self.model = models.infer_model(self.model)\n        else:\n            raise exceptions.UserError('`model` must either be set on the agent or included when calling it.')\n\n        instrument = self.instrument\n        if instrument is None:\n            instrument = self._instrument_default\n\n        return instrument_model(model_, instrument)\n\n    def _get_deps(self: Agent[T, OutputDataT], deps: T) -> T:\n        \"\"\"Get deps for a run.\n\n        If we've overridden deps via `_override_deps`, use that, otherwise use the deps passed to the call.\n\n        We could do runtime type checking of deps against `self._deps_type`, but that's a slippery slope.\n        \"\"\"\n        if some_deps := self._override_deps.get():\n            return some_deps.value\n        else:\n            return deps\n\n    def _normalize_instructions(\n        self,\n        instructions: Instructions[AgentDepsT],\n    ) -> list[str | _system_prompt.SystemPromptFunc[AgentDepsT]]:\n        if instructions is None:\n            return []\n        if isinstance(instructions, str) or callable(instructions):\n            return [instructions]\n        return list(instructions)\n\n    def _get_instructions(\n        self,\n        additional_instructions: Instructions[AgentDepsT] = None,\n    ) -> tuple[str | None, list[_system_prompt.SystemPromptRunner[AgentDepsT]]]:\n        override_instructions = self._override_instructions.get()\n        if override_instructions:\n            instructions = override_instructions.value\n        else:\n            instructions = self._instructions.copy()\n            if additional_instructions is not None:\n                instructions.extend(self._normalize_instructions(additional_instructions))\n\n        literal_parts: list[str] = []\n        functions: list[_system_prompt.SystemPromptRunner[AgentDepsT]] = []\n\n        for instruction in instructions:\n            if isinstance(instruction, str):\n                literal_parts.append(instruction)\n            else:\n                functions.append(_system_prompt.SystemPromptRunner[AgentDepsT](instruction))\n\n        literal = '\\n'.join(literal_parts).strip() or None\n        return literal, functions\n\n    def _get_toolset(\n        self,\n        output_toolset: AbstractToolset[AgentDepsT] | None | _utils.Unset = _utils.UNSET,\n        additional_toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    ) -> AbstractToolset[AgentDepsT]:\n        \"\"\"Get the complete toolset.\n\n        Args:\n            output_toolset: The output toolset to use instead of the one built at agent construction time.\n            additional_toolsets: Additional toolsets to add, unless toolsets have been overridden.\n        \"\"\"\n        toolsets = self.toolsets\n        # Don't add additional toolsets if the toolsets have been overridden\n        if additional_toolsets and self._override_toolsets.get() is None:\n            toolsets = [*toolsets, *additional_toolsets]\n\n        toolset = CombinedToolset(toolsets)\n\n        # Copy the dynamic toolsets to ensure each run has its own instances\n        def copy_dynamic_toolsets(toolset: AbstractToolset[AgentDepsT]) -> AbstractToolset[AgentDepsT]:\n            if isinstance(toolset, DynamicToolset):\n                return dataclasses.replace(toolset)\n            else:\n                return toolset\n\n        toolset = toolset.visit_and_replace(copy_dynamic_toolsets)\n\n        if self._prepare_tools:\n            toolset = PreparedToolset(toolset, self._prepare_tools)\n\n        output_toolset = output_toolset if _utils.is_set(output_toolset) else self._output_toolset\n        if output_toolset is not None:\n            if self._prepare_output_tools:\n                output_toolset = PreparedToolset(output_toolset, self._prepare_output_tools)\n            toolset = CombinedToolset([output_toolset, toolset])\n\n        return toolset\n\n    @property\n    def toolsets(self) -> Sequence[AbstractToolset[AgentDepsT]]:\n        \"\"\"All toolsets registered on the agent, including a function toolset holding tools that were registered on the agent directly.\n\n        Output tools are not included.\n        \"\"\"\n        toolsets: list[AbstractToolset[AgentDepsT]] = []\n\n        if some_tools := self._override_tools.get():\n            function_toolset = _AgentFunctionToolset(\n                some_tools.value, max_retries=self._max_tool_retries, output_schema=self._output_schema\n            )\n        else:\n            function_toolset = self._function_toolset\n        toolsets.append(function_toolset)\n\n        if some_user_toolsets := self._override_toolsets.get():\n            user_toolsets = some_user_toolsets.value\n        else:\n            user_toolsets = [*self._user_toolsets, *self._dynamic_toolsets]\n        toolsets.extend(user_toolsets)\n\n        return toolsets\n\n    @overload\n    def _prepare_output_schema(self, output_type: None) -> _output.OutputSchema[OutputDataT]: ...\n\n    @overload\n    def _prepare_output_schema(\n        self, output_type: OutputSpec[RunOutputDataT]\n    ) -> _output.OutputSchema[RunOutputDataT]: ...\n\n    def _prepare_output_schema(self, output_type: OutputSpec[Any] | None) -> _output.OutputSchema[Any]:\n        if output_type is not None:\n            if self._output_validators:\n                raise exceptions.UserError('Cannot set a custom run `output_type` when the agent has output validators')\n            schema = _output.OutputSchema.build(output_type)\n        else:\n            schema = self._output_schema\n\n        return schema\n\n    async def __aenter__(self) -> Self:\n        \"\"\"Enter the agent context.\n\n        This will start all [`MCPServerStdio`s][pydantic_ai.mcp.MCPServerStdio] registered as `toolsets` so they are ready to be used.\n\n        This is a no-op if the agent has already been entered.\n        \"\"\"\n        async with self._enter_lock:\n            if self._entered_count == 0:\n                async with AsyncExitStack() as exit_stack:\n                    toolset = self._get_toolset()\n                    await exit_stack.enter_async_context(toolset)\n\n                    self._exit_stack = exit_stack.pop_all()\n            self._entered_count += 1\n        return self\n\n    async def __aexit__(self, *args: Any) -> bool | None:\n        async with self._enter_lock:\n            self._entered_count -= 1\n            if self._entered_count == 0 and self._exit_stack is not None:\n                await self._exit_stack.aclose()\n                self._exit_stack = None\n\n    def set_mcp_sampling_model(self, model: models.Model | models.KnownModelName | str | None = None) -> None:\n        \"\"\"Set the sampling model on all MCP servers registered with the agent.\n\n        If no sampling model is provided, the agent's model will be used.\n        \"\"\"\n        try:\n            sampling_model = models.infer_model(model) if model else self._get_model(None)\n        except exceptions.UserError as e:\n            raise exceptions.UserError('No sampling model provided and no model set on the agent.') from e\n\n        from ..mcp import MCPServer\n\n        def _set_sampling_model(toolset: AbstractToolset[AgentDepsT]) -> None:\n            if isinstance(toolset, MCPServer):\n                toolset.sampling_model = sampling_model\n\n        self._get_toolset().apply(_set_sampling_model)\n\n    @asynccontextmanager\n    @deprecated(\n        '`run_mcp_servers` is deprecated, use `async with agent:` instead. If you need to set a sampling model on all MCP servers, use `agent.set_mcp_sampling_model()`.'\n    )\n    async def run_mcp_servers(\n        self, model: models.Model | models.KnownModelName | str | None = None\n    ) -> AsyncIterator[None]:\n        \"\"\"Run [`MCPServerStdio`s][pydantic_ai.mcp.MCPServerStdio] so they can be used by the agent.\n\n        Deprecated: use [`async with agent`][pydantic_ai.agent.Agent.__aenter__] instead.\n        If you need to set a sampling model on all MCP servers, use [`agent.set_mcp_sampling_model()`][pydantic_ai.agent.Agent.set_mcp_sampling_model].\n\n        Returns: a context manager to start and shutdown the servers.\n        \"\"\"\n        try:\n            self.set_mcp_sampling_model(model)\n        except exceptions.UserError:\n            if model is not None:\n                raise\n\n        async with self:\n            yield\n\n````\n\n#### __init__\n\n```python\n__init__(\n    model: Model | KnownModelName | str | None = None,\n    *,\n    output_type: OutputSpec[OutputDataT] = str,\n    instructions: Instructions[AgentDepsT] = None,\n    system_prompt: str | Sequence[str] = (),\n    deps_type: type[AgentDepsT] = NoneType,\n    name: str | None = None,\n    model_settings: ModelSettings | None = None,\n    retries: int = 1,\n    validation_context: (\n        Any | Callable[[RunContext[AgentDepsT]], Any]\n    ) = None,\n    output_retries: int | None = None,\n    tools: Sequence[\n        Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]\n    ] = (),\n    builtin_tools: Sequence[AbstractBuiltinTool] = (),\n    prepare_tools: (\n        ToolsPrepareFunc[AgentDepsT] | None\n    ) = None,\n    prepare_output_tools: (\n        ToolsPrepareFunc[AgentDepsT] | None\n    ) = None,\n    toolsets: (\n        Sequence[\n            AbstractToolset[AgentDepsT]\n            | ToolsetFunc[AgentDepsT]\n        ]\n        | None\n    ) = None,\n    defer_model_check: bool = False,\n    end_strategy: EndStrategy = \"early\",\n    instrument: (\n        InstrumentationSettings | bool | None\n    ) = None,\n    history_processors: (\n        Sequence[HistoryProcessor[AgentDepsT]] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> None\n\n```\n\n```python\n__init__(\n    model: Model | KnownModelName | str | None = None,\n    *,\n    output_type: OutputSpec[OutputDataT] = str,\n    instructions: Instructions[AgentDepsT] = None,\n    system_prompt: str | Sequence[str] = (),\n    deps_type: type[AgentDepsT] = NoneType,\n    name: str | None = None,\n    model_settings: ModelSettings | None = None,\n    retries: int = 1,\n    validation_context: (\n        Any | Callable[[RunContext[AgentDepsT]], Any]\n    ) = None,\n    output_retries: int | None = None,\n    tools: Sequence[\n        Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]\n    ] = (),\n    builtin_tools: Sequence[AbstractBuiltinTool] = (),\n    prepare_tools: (\n        ToolsPrepareFunc[AgentDepsT] | None\n    ) = None,\n    prepare_output_tools: (\n        ToolsPrepareFunc[AgentDepsT] | None\n    ) = None,\n    mcp_servers: Sequence[MCPServer] = (),\n    defer_model_check: bool = False,\n    end_strategy: EndStrategy = \"early\",\n    instrument: (\n        InstrumentationSettings | bool | None\n    ) = None,\n    history_processors: (\n        Sequence[HistoryProcessor[AgentDepsT]] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> None\n\n```\n\n```python\n__init__(\n    model: Model | KnownModelName | str | None = None,\n    *,\n    output_type: OutputSpec[OutputDataT] = str,\n    instructions: Instructions[AgentDepsT] = None,\n    system_prompt: str | Sequence[str] = (),\n    deps_type: type[AgentDepsT] = NoneType,\n    name: str | None = None,\n    model_settings: ModelSettings | None = None,\n    retries: int = 1,\n    validation_context: (\n        Any | Callable[[RunContext[AgentDepsT]], Any]\n    ) = None,\n    output_retries: int | None = None,\n    tools: Sequence[\n        Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]\n    ] = (),\n    builtin_tools: Sequence[AbstractBuiltinTool] = (),\n    prepare_tools: (\n        ToolsPrepareFunc[AgentDepsT] | None\n    ) = None,\n    prepare_output_tools: (\n        ToolsPrepareFunc[AgentDepsT] | None\n    ) = None,\n    toolsets: (\n        Sequence[\n            AbstractToolset[AgentDepsT]\n            | ToolsetFunc[AgentDepsT]\n        ]\n        | None\n    ) = None,\n    defer_model_check: bool = False,\n    end_strategy: EndStrategy = \"early\",\n    instrument: (\n        InstrumentationSettings | bool | None\n    ) = None,\n    history_processors: (\n        Sequence[HistoryProcessor[AgentDepsT]] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None,\n    **_deprecated_kwargs: Any\n)\n\n```\n\nCreate an agent.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `model` | `Model | KnownModelName | str | None` | The default model to use for this agent, if not provided, you must provide the model when calling it. We allow str here since the actual list of allowed models changes frequently. | `None` | | `output_type` | `OutputSpec[OutputDataT]` | The type of the output data, used to validate the data returned by the model, defaults to str. | `str` | | `instructions` | `Instructions[AgentDepsT]` | Instructions to use for this agent, you can also register instructions via a function with instructions or pass additional, temporary, instructions when executing a run. | `None` | | `system_prompt` | `str | Sequence[str]` | Static system prompts to use for this agent, you can also register system prompts via a function with system_prompt. | `()` | | `deps_type` | `type[AgentDepsT]` | The type used for dependency injection, this parameter exists solely to allow you to fully parameterize the agent, and therefore get the best out of static type checking. If you're not using deps, but want type checking to pass, you can set deps=None to satisfy Pyright or add a type hint : Agent\\[None, <return type>\\]. | `NoneType` | | `name` | `str | None` | The name of the agent, used for logging. If None, we try to infer the agent name from the call frame when the agent is first run. | `None` | | `model_settings` | `ModelSettings | None` | Optional model request settings to use for this agent's runs, by default. | `None` | | `retries` | `int` | The default number of retries to allow for tool calls and output validation, before raising an error. For model request retries, see the HTTP Request Retries documentation. | `1` | | `validation_context` | `Any | Callable[[RunContext[AgentDepsT]], Any]` | Pydantic validation context used to validate tool arguments and outputs. | `None` | | `output_retries` | `int | None` | The maximum number of retries to allow for output validation, defaults to retries. | `None` | | `tools` | `Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]]` | Tools to register with the agent, you can also register tools via the decorators @agent.tool and @agent.tool_plain. | `()` | | `builtin_tools` | `Sequence[AbstractBuiltinTool]` | The builtin tools that the agent will use. This depends on the model, as some models may not support certain tools. If the model doesn't support the builtin tools, an error will be raised. | `()` | | `prepare_tools` | `ToolsPrepareFunc[AgentDepsT] | None` | Custom function to prepare the tool definition of all tools for each step, except output tools. This is useful if you want to customize the definition of multiple tools or you want to register a subset of tools for a given step. See ToolsPrepareFunc | `None` | | `prepare_output_tools` | `ToolsPrepareFunc[AgentDepsT] | None` | Custom function to prepare the tool definition of all output tools for each step. This is useful if you want to customize the definition of multiple output tools or you want to register a subset of output tools for a given step. See ToolsPrepareFunc | `None` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT] | ToolsetFunc[AgentDepsT]] | None` | Toolsets to register with the agent, including MCP servers and functions which take a run context and return a toolset. See ToolsetFunc for more information. | `None` | | `defer_model_check` | `bool` | by default, if you provide a named model, it's evaluated to create a Model instance immediately, which checks for the necessary environment variables. Set this to false to defer the evaluation until the first run. Useful if you want to override the model for testing. | `False` | | `end_strategy` | `EndStrategy` | Strategy for handling tool calls that are requested alongside a final result. See EndStrategy for more information. | `'early'` | | `instrument` | `InstrumentationSettings | bool | None` | Set to True to automatically instrument with OpenTelemetry, which will use Logfire if it's configured. Set to an instance of InstrumentationSettings to customize. If this isn't set, then the last value set by Agent.instrument_all() will be used, which defaults to False. See the Debugging and Monitoring guide for more info. | `None` | | `history_processors` | `Sequence[HistoryProcessor[AgentDepsT]] | None` | Optional list of callables to process the message history before sending it to the model. Each processor takes a list of messages and returns a modified list of messages. Processors can be sync or async and are applied in sequence. | `None` | | `event_stream_handler` | `EventStreamHandler[AgentDepsT] | None` | Optional handler for events from the model's streaming response and the agent's execution of tools. | `None` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n```python\ndef __init__(\n    self,\n    model: models.Model | models.KnownModelName | str | None = None,\n    *,\n    output_type: OutputSpec[OutputDataT] = str,\n    instructions: Instructions[AgentDepsT] = None,\n    system_prompt: str | Sequence[str] = (),\n    deps_type: type[AgentDepsT] = NoneType,\n    name: str | None = None,\n    model_settings: ModelSettings | None = None,\n    retries: int = 1,\n    validation_context: Any | Callable[[RunContext[AgentDepsT]], Any] = None,\n    output_retries: int | None = None,\n    tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] = (),\n    builtin_tools: Sequence[AbstractBuiltinTool] = (),\n    prepare_tools: ToolsPrepareFunc[AgentDepsT] | None = None,\n    prepare_output_tools: ToolsPrepareFunc[AgentDepsT] | None = None,\n    toolsets: Sequence[AbstractToolset[AgentDepsT] | ToolsetFunc[AgentDepsT]] | None = None,\n    defer_model_check: bool = False,\n    end_strategy: EndStrategy = 'early',\n    instrument: InstrumentationSettings | bool | None = None,\n    history_processors: Sequence[HistoryProcessor[AgentDepsT]] | None = None,\n    event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    **_deprecated_kwargs: Any,\n):\n    \"\"\"Create an agent.\n\n    Args:\n        model: The default model to use for this agent, if not provided,\n            you must provide the model when calling it. We allow `str` here since the actual list of allowed models changes frequently.\n        output_type: The type of the output data, used to validate the data returned by the model,\n            defaults to `str`.\n        instructions: Instructions to use for this agent, you can also register instructions via a function with\n            [`instructions`][pydantic_ai.Agent.instructions] or pass additional, temporary, instructions when executing a run.\n        system_prompt: Static system prompts to use for this agent, you can also register system\n            prompts via a function with [`system_prompt`][pydantic_ai.Agent.system_prompt].\n        deps_type: The type used for dependency injection, this parameter exists solely to allow you to fully\n            parameterize the agent, and therefore get the best out of static type checking.\n            If you're not using deps, but want type checking to pass, you can set `deps=None` to satisfy Pyright\n            or add a type hint `: Agent[None, <return type>]`.\n        name: The name of the agent, used for logging. If `None`, we try to infer the agent name from the call frame\n            when the agent is first run.\n        model_settings: Optional model request settings to use for this agent's runs, by default.\n        retries: The default number of retries to allow for tool calls and output validation, before raising an error.\n            For model request retries, see the [HTTP Request Retries](../retries.md) documentation.\n        validation_context: Pydantic [validation context](https://docs.pydantic.dev/latest/concepts/validators/#validation-context) used to validate tool arguments and outputs.\n        output_retries: The maximum number of retries to allow for output validation, defaults to `retries`.\n        tools: Tools to register with the agent, you can also register tools via the decorators\n            [`@agent.tool`][pydantic_ai.Agent.tool] and [`@agent.tool_plain`][pydantic_ai.Agent.tool_plain].\n        builtin_tools: The builtin tools that the agent will use. This depends on the model, as some models may not\n            support certain tools. If the model doesn't support the builtin tools, an error will be raised.\n        prepare_tools: Custom function to prepare the tool definition of all tools for each step, except output tools.\n            This is useful if you want to customize the definition of multiple tools or you want to register\n            a subset of tools for a given step. See [`ToolsPrepareFunc`][pydantic_ai.tools.ToolsPrepareFunc]\n        prepare_output_tools: Custom function to prepare the tool definition of all output tools for each step.\n            This is useful if you want to customize the definition of multiple output tools or you want to register\n            a subset of output tools for a given step. See [`ToolsPrepareFunc`][pydantic_ai.tools.ToolsPrepareFunc]\n        toolsets: Toolsets to register with the agent, including MCP servers and functions which take a run context\n            and return a toolset. See [`ToolsetFunc`][pydantic_ai.toolsets.ToolsetFunc] for more information.\n        defer_model_check: by default, if you provide a [named][pydantic_ai.models.KnownModelName] model,\n            it's evaluated to create a [`Model`][pydantic_ai.models.Model] instance immediately,\n            which checks for the necessary environment variables. Set this to `false`\n            to defer the evaluation until the first run. Useful if you want to\n            [override the model][pydantic_ai.Agent.override] for testing.\n        end_strategy: Strategy for handling tool calls that are requested alongside a final result.\n            See [`EndStrategy`][pydantic_ai.agent.EndStrategy] for more information.\n        instrument: Set to True to automatically instrument with OpenTelemetry,\n            which will use Logfire if it's configured.\n            Set to an instance of [`InstrumentationSettings`][pydantic_ai.agent.InstrumentationSettings] to customize.\n            If this isn't set, then the last value set by\n            [`Agent.instrument_all()`][pydantic_ai.Agent.instrument_all]\n            will be used, which defaults to False.\n            See the [Debugging and Monitoring guide](https://ai.pydantic.dev/logfire/) for more info.\n        history_processors: Optional list of callables to process the message history before sending it to the model.\n            Each processor takes a list of messages and returns a modified list of messages.\n            Processors can be sync or async and are applied in sequence.\n        event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools.\n    \"\"\"\n    if model is None or defer_model_check:\n        self._model = model\n    else:\n        self._model = models.infer_model(model)\n\n    self._name = name\n    self.end_strategy = end_strategy\n    self.model_settings = model_settings\n\n    self._output_type = output_type\n    self.instrument = instrument\n    self._deps_type = deps_type\n\n    if mcp_servers := _deprecated_kwargs.pop('mcp_servers', None):\n        if toolsets is not None:  # pragma: no cover\n            raise TypeError('`mcp_servers` and `toolsets` cannot be set at the same time.')\n        warnings.warn('`mcp_servers` is deprecated, use `toolsets` instead', DeprecationWarning)\n        toolsets = mcp_servers\n\n    _utils.validate_empty_kwargs(_deprecated_kwargs)\n\n    self._output_schema = _output.OutputSchema[OutputDataT].build(output_type)\n    self._output_validators = []\n\n    self._instructions = self._normalize_instructions(instructions)\n\n    self._system_prompts = (system_prompt,) if isinstance(system_prompt, str) else tuple(system_prompt)\n    self._system_prompt_functions = []\n    self._system_prompt_dynamic_functions = {}\n\n    self._max_result_retries = output_retries if output_retries is not None else retries\n    self._max_tool_retries = retries\n\n    self._validation_context = validation_context\n\n    self._builtin_tools = builtin_tools\n\n    self._prepare_tools = prepare_tools\n    self._prepare_output_tools = prepare_output_tools\n\n    self._output_toolset = self._output_schema.toolset\n    if self._output_toolset:\n        self._output_toolset.max_retries = self._max_result_retries\n\n    self._function_toolset = _AgentFunctionToolset(\n        tools, max_retries=self._max_tool_retries, output_schema=self._output_schema\n    )\n    self._dynamic_toolsets = [\n        DynamicToolset[AgentDepsT](toolset_func=toolset)\n        for toolset in toolsets or []\n        if not isinstance(toolset, AbstractToolset)\n    ]\n    self._user_toolsets = [toolset for toolset in toolsets or [] if isinstance(toolset, AbstractToolset)]\n\n    self.history_processors = history_processors or []\n\n    self._event_stream_handler = event_stream_handler\n\n    self._override_name: ContextVar[_utils.Option[str]] = ContextVar('_override_name', default=None)\n    self._override_deps: ContextVar[_utils.Option[AgentDepsT]] = ContextVar('_override_deps', default=None)\n    self._override_model: ContextVar[_utils.Option[models.Model]] = ContextVar('_override_model', default=None)\n    self._override_toolsets: ContextVar[_utils.Option[Sequence[AbstractToolset[AgentDepsT]]]] = ContextVar(\n        '_override_toolsets', default=None\n    )\n    self._override_tools: ContextVar[\n        _utils.Option[Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]]]\n    ] = ContextVar('_override_tools', default=None)\n    self._override_instructions: ContextVar[\n        _utils.Option[list[str | _system_prompt.SystemPromptFunc[AgentDepsT]]]\n    ] = ContextVar('_override_instructions', default=None)\n\n    self._enter_lock = Lock()\n    self._entered_count = 0\n    self._exit_stack = None\n\n```\n\n#### end_strategy\n\n```python\nend_strategy: EndStrategy = end_strategy\n\n```\n\nStrategy for handling tool calls when a final result is found.\n\n#### model_settings\n\n```python\nmodel_settings: ModelSettings | None = model_settings\n\n```\n\nOptional model request settings to use for this agents's runs, by default.\n\nNote, if `model_settings` is provided by `run`, `run_sync`, or `run_stream`, those settings will be merged with this value, with the runtime argument taking priority.\n\n#### instrument\n\n```python\ninstrument: InstrumentationSettings | bool | None = (\n    instrument\n)\n\n```\n\nOptions to automatically instrument with OpenTelemetry.\n\n#### instrument_all\n\n```python\ninstrument_all(\n    instrument: InstrumentationSettings | bool = True,\n) -> None\n\n```\n\nSet the instrumentation options for all agents where `instrument` is not set.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n```python\n@staticmethod\ndef instrument_all(instrument: InstrumentationSettings | bool = True) -> None:\n    \"\"\"Set the instrumentation options for all agents where `instrument` is not set.\"\"\"\n    Agent._instrument_default = instrument\n\n```\n\n#### model\n\n```python\nmodel: Model | KnownModelName | str | None\n\n```\n\nThe default model configured for this agent.\n\n#### name\n\n```python\nname: str | None\n\n```\n\nThe name of the agent, used for logging.\n\nIf `None`, we try to infer the agent name from the call frame when the agent is first run.\n\n#### deps_type\n\n```python\ndeps_type: type\n\n```\n\nThe type of dependencies used by the agent.\n\n#### output_type\n\n```python\noutput_type: OutputSpec[OutputDataT]\n\n```\n\nThe type of data output by agent runs, used to validate the data returned by the model, defaults to `str`.\n\n#### event_stream_handler\n\n```python\nevent_stream_handler: EventStreamHandler[AgentDepsT] | None\n\n```\n\nOptional handler for events from the model's streaming response and the agent's execution of tools.\n\n#### iter\n\n```python\niter(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AbstractAsyncContextManager[\n    AgentRun[AgentDepsT, OutputDataT]\n]\n\n```\n\n```python\niter(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT],\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AbstractAsyncContextManager[\n    AgentRun[AgentDepsT, RunOutputDataT]\n]\n\n```\n\n```python\niter(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[Any] | None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AsyncIterator[AgentRun[AgentDepsT, Any]]\n\n```\n\nA contextmanager which can be used to iterate over the agent graph's nodes as they are executed.\n\nThis method builds an internal agent graph (using system prompts, tools and output schemas) and then returns an `AgentRun` object. The `AgentRun` can be used to async-iterate over the nodes of the graph as they are executed. This is the API to use if you want to consume the outputs coming from each LLM model response, or the stream of events coming from the execution of tools.\n\nThe `AgentRun` also provides methods to access the full message history, new messages, and usage statistics, and the final result of the run once it has completed.\n\nFor more details, see the documentation of `AgentRun`.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\n\nasync def main():\n    nodes = []\n    async with agent.iter('What is the capital of France?') as agent_run:\n        async for node in agent_run:\n            nodes.append(node)\n    print(nodes)\n    '''\n    [\n        UserPromptNode(\n            user_prompt='What is the capital of France?',\n            instructions_functions=[],\n            system_prompts=(),\n            system_prompt_functions=[],\n            system_prompt_dynamic_functions={},\n        ),\n        ModelRequestNode(\n            request=ModelRequest(\n                parts=[\n                    UserPromptPart(\n                        content='What is the capital of France?',\n                        timestamp=datetime.datetime(...),\n                    )\n                ],\n                run_id='...',\n            )\n        ),\n        CallToolsNode(\n            model_response=ModelResponse(\n                parts=[TextPart(content='The capital of France is Paris.')],\n                usage=RequestUsage(input_tokens=56, output_tokens=7),\n                model_name='gpt-4o',\n                timestamp=datetime.datetime(...),\n                run_id='...',\n            )\n        ),\n        End(data=FinalResult(output='The capital of France is Paris.')),\n    ]\n    '''\n    print(agent_run.result.output)\n    #> The capital of France is Paris.\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `user_prompt` | `str | Sequence[UserContent] | None` | User input to start/continue the conversation. | `None` | | `output_type` | `OutputSpec[Any] | None` | Custom output type to use for this run, output_type may only be used if the agent has no output validators since output validators would expect an argument that matches the agent's output type. | `None` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` | | `deferred_tool_results` | `DeferredToolResults | None` | Optional results for deferred tool calls in the message history. | `None` | | `model` | `Model | KnownModelName | str | None` | Optional model to use for this run, required if model was not set when creating the agent. | `None` | | `instructions` | `Instructions[AgentDepsT]` | Optional additional instructions to use for this run. | `None` | | `deps` | `AgentDepsT` | Optional dependencies to use for this run. | `None` | | `model_settings` | `ModelSettings | None` | Optional settings to use for this model's request. | `None` | | `usage_limits` | `UsageLimits | None` | Optional limits on model request count or token usage. | `None` | | `usage` | `RunUsage | None` | Optional usage to start with, useful for resuming a conversation or agents used in tools. | `None` | | `infer_name` | `bool` | Whether to try to infer the agent name from the call frame if it's not set. | `True` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | None` | Optional additional toolsets for this run. | `None` | | `builtin_tools` | `Sequence[AbstractBuiltinTool] | None` | Optional additional builtin tools for this run. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AsyncIterator[AgentRun[AgentDepsT, Any]]` | The result of the run. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n````python\n@asynccontextmanager\nasync def iter(\n    self,\n    user_prompt: str | Sequence[_messages.UserContent] | None = None,\n    *,\n    output_type: OutputSpec[Any] | None = None,\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n    deferred_tool_results: DeferredToolResults | None = None,\n    model: models.Model | models.KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: _usage.UsageLimits | None = None,\n    usage: _usage.RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n) -> AsyncIterator[AgentRun[AgentDepsT, Any]]:\n    \"\"\"A contextmanager which can be used to iterate over the agent graph's nodes as they are executed.\n\n    This method builds an internal agent graph (using system prompts, tools and output schemas) and then returns an\n    `AgentRun` object. The `AgentRun` can be used to async-iterate over the nodes of the graph as they are\n    executed. This is the API to use if you want to consume the outputs coming from each LLM model response, or the\n    stream of events coming from the execution of tools.\n\n    The `AgentRun` also provides methods to access the full message history, new messages, and usage statistics,\n    and the final result of the run once it has completed.\n\n    For more details, see the documentation of `AgentRun`.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n\n    async def main():\n        nodes = []\n        async with agent.iter('What is the capital of France?') as agent_run:\n            async for node in agent_run:\n                nodes.append(node)\n        print(nodes)\n        '''\n        [\n            UserPromptNode(\n                user_prompt='What is the capital of France?',\n                instructions_functions=[],\n                system_prompts=(),\n                system_prompt_functions=[],\n                system_prompt_dynamic_functions={},\n            ),\n            ModelRequestNode(\n                request=ModelRequest(\n                    parts=[\n                        UserPromptPart(\n                            content='What is the capital of France?',\n                            timestamp=datetime.datetime(...),\n                        )\n                    ],\n                    run_id='...',\n                )\n            ),\n            CallToolsNode(\n                model_response=ModelResponse(\n                    parts=[TextPart(content='The capital of France is Paris.')],\n                    usage=RequestUsage(input_tokens=56, output_tokens=7),\n                    model_name='gpt-4o',\n                    timestamp=datetime.datetime(...),\n                    run_id='...',\n                )\n            ),\n            End(data=FinalResult(output='The capital of France is Paris.')),\n        ]\n        '''\n        print(agent_run.result.output)\n        #> The capital of France is Paris.\n    ```\n\n    Args:\n        user_prompt: User input to start/continue the conversation.\n        output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n            output validators since output validators would expect an argument that matches the agent's output type.\n        message_history: History of the conversation so far.\n        deferred_tool_results: Optional results for deferred tool calls in the message history.\n        model: Optional model to use for this run, required if `model` was not set when creating the agent.\n        instructions: Optional additional instructions to use for this run.\n        deps: Optional dependencies to use for this run.\n        model_settings: Optional settings to use for this model's request.\n        usage_limits: Optional limits on model request count or token usage.\n        usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n        infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n        toolsets: Optional additional toolsets for this run.\n        builtin_tools: Optional additional builtin tools for this run.\n\n    Returns:\n        The result of the run.\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n\n    model_used = self._get_model(model)\n    del model\n\n    deps = self._get_deps(deps)\n    output_schema = self._prepare_output_schema(output_type)\n\n    output_type_ = output_type or self.output_type\n\n    # We consider it a user error if a user tries to restrict the result type while having an output validator that\n    # may change the result type from the restricted type to something else. Therefore, we consider the following\n    # typecast reasonable, even though it is possible to violate it with otherwise-type-checked code.\n    output_validators = self._output_validators\n\n    output_toolset = self._output_toolset\n    if output_schema != self._output_schema or output_validators:\n        output_toolset = output_schema.toolset\n        if output_toolset:\n            output_toolset.max_retries = self._max_result_retries\n            output_toolset.output_validators = output_validators\n    toolset = self._get_toolset(output_toolset=output_toolset, additional_toolsets=toolsets)\n    tool_manager = ToolManager[AgentDepsT](toolset)\n\n    # Build the graph\n    graph = _agent_graph.build_agent_graph(self.name, self._deps_type, output_type_)\n\n    # Build the initial state\n    usage = usage or _usage.RunUsage()\n    state = _agent_graph.GraphAgentState(\n        message_history=list(message_history) if message_history else [],\n        usage=usage,\n        retries=0,\n        run_step=0,\n    )\n\n    # Merge model settings in order of precedence: run > agent > model\n    merged_settings = merge_model_settings(model_used.settings, self.model_settings)\n    model_settings = merge_model_settings(merged_settings, model_settings)\n    usage_limits = usage_limits or _usage.UsageLimits()\n\n    instructions_literal, instructions_functions = self._get_instructions(additional_instructions=instructions)\n\n    async def get_instructions(run_context: RunContext[AgentDepsT]) -> str | None:\n        parts = [\n            instructions_literal,\n            *[await func.run(run_context) for func in instructions_functions],\n        ]\n\n        parts = [p for p in parts if p]\n        if not parts:\n            return None\n        return '\\n\\n'.join(parts).strip()\n\n    if isinstance(model_used, InstrumentedModel):\n        instrumentation_settings = model_used.instrumentation_settings\n        tracer = model_used.instrumentation_settings.tracer\n    else:\n        instrumentation_settings = None\n        tracer = NoOpTracer()\n\n    graph_deps = _agent_graph.GraphAgentDeps[AgentDepsT, OutputDataT](\n        user_deps=deps,\n        prompt=user_prompt,\n        new_message_index=len(message_history) if message_history else 0,\n        model=model_used,\n        model_settings=model_settings,\n        usage_limits=usage_limits,\n        max_result_retries=self._max_result_retries,\n        end_strategy=self.end_strategy,\n        output_schema=output_schema,\n        output_validators=output_validators,\n        validation_context=self._validation_context,\n        history_processors=self.history_processors,\n        builtin_tools=[*self._builtin_tools, *(builtin_tools or [])],\n        tool_manager=tool_manager,\n        tracer=tracer,\n        get_instructions=get_instructions,\n        instrumentation_settings=instrumentation_settings,\n    )\n\n    user_prompt_node = _agent_graph.UserPromptNode[AgentDepsT](\n        user_prompt=user_prompt,\n        deferred_tool_results=deferred_tool_results,\n        instructions=instructions_literal,\n        instructions_functions=instructions_functions,\n        system_prompts=self._system_prompts,\n        system_prompt_functions=self._system_prompt_functions,\n        system_prompt_dynamic_functions=self._system_prompt_dynamic_functions,\n    )\n\n    agent_name = self.name or 'agent'\n    instrumentation_names = InstrumentationNames.for_version(\n        instrumentation_settings.version if instrumentation_settings else DEFAULT_INSTRUMENTATION_VERSION\n    )\n\n    run_span = tracer.start_span(\n        instrumentation_names.get_agent_run_span_name(agent_name),\n        attributes={\n            'model_name': model_used.model_name if model_used else 'no-model',\n            'agent_name': agent_name,\n            'gen_ai.agent.name': agent_name,\n            'logfire.msg': f'{agent_name} run',\n        },\n    )\n\n    try:\n        async with graph.iter(\n            inputs=user_prompt_node,\n            state=state,\n            deps=graph_deps,\n            span=use_span(run_span) if run_span.is_recording() else None,\n            infer_name=False,\n        ) as graph_run:\n            async with toolset:\n                agent_run = AgentRun(graph_run)\n                yield agent_run\n                if (final_result := agent_run.result) is not None and run_span.is_recording():\n                    if instrumentation_settings and instrumentation_settings.include_content:\n                        run_span.set_attribute(\n                            'final_result',\n                            (\n                                final_result.output\n                                if isinstance(final_result.output, str)\n                                else json.dumps(InstrumentedModel.serialize_any(final_result.output))\n                            ),\n                        )\n    finally:\n        try:\n            if instrumentation_settings and run_span.is_recording():\n                run_span.set_attributes(\n                    self._run_span_end_attributes(\n                        instrumentation_settings, usage, state.message_history, graph_deps.new_message_index\n                    )\n                )\n        finally:\n            run_span.end()\n\n````\n\n#### override\n\n```python\noverride(\n    *,\n    name: str | Unset = UNSET,\n    deps: AgentDepsT | Unset = UNSET,\n    model: Model | KnownModelName | str | Unset = UNSET,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | Unset\n    ) = UNSET,\n    tools: (\n        Sequence[\n            Tool[AgentDepsT]\n            | ToolFuncEither[AgentDepsT, ...]\n        ]\n        | Unset\n    ) = UNSET,\n    instructions: Instructions[AgentDepsT] | Unset = UNSET\n) -> Iterator[None]\n\n```\n\nContext manager to temporarily override agent name, dependencies, model, toolsets, tools, or instructions.\n\nThis is particularly useful when testing. You can find an example of this [here](../../testing/#overriding-model-via-pytest-fixtures).\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `name` | `str | Unset` | The name to use instead of the name passed to the agent constructor and agent run. | `UNSET` | | `deps` | `AgentDepsT | Unset` | The dependencies to use instead of the dependencies passed to the agent run. | `UNSET` | | `model` | `Model | KnownModelName | str | Unset` | The model to use instead of the model passed to the agent run. | `UNSET` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | Unset` | The toolsets to use instead of the toolsets passed to the agent constructor and agent run. | `UNSET` | | `tools` | `Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] | Unset` | The tools to use instead of the tools registered with the agent. | `UNSET` | | `instructions` | `Instructions[AgentDepsT] | Unset` | The instructions to use instead of the instructions registered with the agent. | `UNSET` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n```python\n@contextmanager\ndef override(\n    self,\n    *,\n    name: str | _utils.Unset = _utils.UNSET,\n    deps: AgentDepsT | _utils.Unset = _utils.UNSET,\n    model: models.Model | models.KnownModelName | str | _utils.Unset = _utils.UNSET,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | _utils.Unset = _utils.UNSET,\n    tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] | _utils.Unset = _utils.UNSET,\n    instructions: Instructions[AgentDepsT] | _utils.Unset = _utils.UNSET,\n) -> Iterator[None]:\n    \"\"\"Context manager to temporarily override agent name, dependencies, model, toolsets, tools, or instructions.\n\n    This is particularly useful when testing.\n    You can find an example of this [here](../testing.md#overriding-model-via-pytest-fixtures).\n\n    Args:\n        name: The name to use instead of the name passed to the agent constructor and agent run.\n        deps: The dependencies to use instead of the dependencies passed to the agent run.\n        model: The model to use instead of the model passed to the agent run.\n        toolsets: The toolsets to use instead of the toolsets passed to the agent constructor and agent run.\n        tools: The tools to use instead of the tools registered with the agent.\n        instructions: The instructions to use instead of the instructions registered with the agent.\n    \"\"\"\n    if _utils.is_set(name):\n        name_token = self._override_name.set(_utils.Some(name))\n    else:\n        name_token = None\n\n    if _utils.is_set(deps):\n        deps_token = self._override_deps.set(_utils.Some(deps))\n    else:\n        deps_token = None\n\n    if _utils.is_set(model):\n        model_token = self._override_model.set(_utils.Some(models.infer_model(model)))\n    else:\n        model_token = None\n\n    if _utils.is_set(toolsets):\n        toolsets_token = self._override_toolsets.set(_utils.Some(toolsets))\n    else:\n        toolsets_token = None\n\n    if _utils.is_set(tools):\n        tools_token = self._override_tools.set(_utils.Some(tools))\n    else:\n        tools_token = None\n\n    if _utils.is_set(instructions):\n        normalized_instructions = self._normalize_instructions(instructions)\n        instructions_token = self._override_instructions.set(_utils.Some(normalized_instructions))\n    else:\n        instructions_token = None\n\n    try:\n        yield\n    finally:\n        if name_token is not None:\n            self._override_name.reset(name_token)\n        if deps_token is not None:\n            self._override_deps.reset(deps_token)\n        if model_token is not None:\n            self._override_model.reset(model_token)\n        if toolsets_token is not None:\n            self._override_toolsets.reset(toolsets_token)\n        if tools_token is not None:\n            self._override_tools.reset(tools_token)\n        if instructions_token is not None:\n            self._override_instructions.reset(instructions_token)\n\n```\n\n#### instructions\n\n```python\ninstructions(\n    func: Callable[[RunContext[AgentDepsT]], str],\n) -> Callable[[RunContext[AgentDepsT]], str]\n\n```\n\n```python\ninstructions(\n    func: Callable[\n        [RunContext[AgentDepsT]], Awaitable[str]\n    ],\n) -> Callable[[RunContext[AgentDepsT]], Awaitable[str]]\n\n```\n\n```python\ninstructions(func: Callable[[], str]) -> Callable[[], str]\n\n```\n\n```python\ninstructions(\n    func: Callable[[], Awaitable[str]],\n) -> Callable[[], Awaitable[str]]\n\n```\n\n```python\ninstructions() -> Callable[\n    [SystemPromptFunc[AgentDepsT]],\n    SystemPromptFunc[AgentDepsT],\n]\n\n```\n\n```python\ninstructions(\n    func: SystemPromptFunc[AgentDepsT] | None = None,\n) -> (\n    Callable[\n        [SystemPromptFunc[AgentDepsT]],\n        SystemPromptFunc[AgentDepsT],\n    ]\n    | SystemPromptFunc[AgentDepsT]\n)\n\n```\n\nDecorator to register an instructions function.\n\nOptionally takes RunContext as its only argument. Can decorate a sync or async functions.\n\nThe decorator can be used bare (`agent.instructions`).\n\nOverloads for every possible signature of `instructions` are included so the decorator doesn't obscure the type of the function.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent, RunContext\n\nagent = Agent('test', deps_type=str)\n\n@agent.instructions\ndef simple_instructions() -> str:\n    return 'foobar'\n\n@agent.instructions\nasync def async_instructions(ctx: RunContext[str]) -> str:\n    return f'{ctx.deps} is the best'\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n````python\ndef instructions(\n    self,\n    func: _system_prompt.SystemPromptFunc[AgentDepsT] | None = None,\n    /,\n) -> (\n    Callable[[_system_prompt.SystemPromptFunc[AgentDepsT]], _system_prompt.SystemPromptFunc[AgentDepsT]]\n    | _system_prompt.SystemPromptFunc[AgentDepsT]\n):\n    \"\"\"Decorator to register an instructions function.\n\n    Optionally takes [`RunContext`][pydantic_ai.tools.RunContext] as its only argument.\n    Can decorate a sync or async functions.\n\n    The decorator can be used bare (`agent.instructions`).\n\n    Overloads for every possible signature of `instructions` are included so the decorator doesn't obscure\n    the type of the function.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent, RunContext\n\n    agent = Agent('test', deps_type=str)\n\n    @agent.instructions\n    def simple_instructions() -> str:\n        return 'foobar'\n\n    @agent.instructions\n    async def async_instructions(ctx: RunContext[str]) -> str:\n        return f'{ctx.deps} is the best'\n    ```\n    \"\"\"\n    if func is None:\n\n        def decorator(\n            func_: _system_prompt.SystemPromptFunc[AgentDepsT],\n        ) -> _system_prompt.SystemPromptFunc[AgentDepsT]:\n            self._instructions.append(func_)\n            return func_\n\n        return decorator\n    else:\n        self._instructions.append(func)\n        return func\n\n````\n\n#### system_prompt\n\n```python\nsystem_prompt(\n    func: Callable[[RunContext[AgentDepsT]], str],\n) -> Callable[[RunContext[AgentDepsT]], str]\n\n```\n\n```python\nsystem_prompt(\n    func: Callable[\n        [RunContext[AgentDepsT]], Awaitable[str]\n    ],\n) -> Callable[[RunContext[AgentDepsT]], Awaitable[str]]\n\n```\n\n```python\nsystem_prompt(func: Callable[[], str]) -> Callable[[], str]\n\n```\n\n```python\nsystem_prompt(\n    func: Callable[[], Awaitable[str]],\n) -> Callable[[], Awaitable[str]]\n\n```\n\n```python\nsystem_prompt(*, dynamic: bool = False) -> Callable[\n    [SystemPromptFunc[AgentDepsT]],\n    SystemPromptFunc[AgentDepsT],\n]\n\n```\n\n```python\nsystem_prompt(\n    func: SystemPromptFunc[AgentDepsT] | None = None,\n    /,\n    *,\n    dynamic: bool = False,\n) -> (\n    Callable[\n        [SystemPromptFunc[AgentDepsT]],\n        SystemPromptFunc[AgentDepsT],\n    ]\n    | SystemPromptFunc[AgentDepsT]\n)\n\n```\n\nDecorator to register a system prompt function.\n\nOptionally takes RunContext as its only argument. Can decorate a sync or async functions.\n\nThe decorator can be used either bare (`agent.system_prompt`) or as a function call (`agent.system_prompt(...)`), see the examples below.\n\nOverloads for every possible signature of `system_prompt` are included so the decorator doesn't obscure the type of the function, see `tests/typed_agent.py` for tests.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `func` | `SystemPromptFunc[AgentDepsT] | None` | The function to decorate | `None` | | `dynamic` | `bool` | If True, the system prompt will be reevaluated even when messages_history is provided, see SystemPromptPart.dynamic_ref | `False` |\n\nExample:\n\n```python\nfrom pydantic_ai import Agent, RunContext\n\nagent = Agent('test', deps_type=str)\n\n@agent.system_prompt\ndef simple_system_prompt() -> str:\n    return 'foobar'\n\n@agent.system_prompt(dynamic=True)\nasync def async_system_prompt(ctx: RunContext[str]) -> str:\n    return f'{ctx.deps} is the best'\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n````python\ndef system_prompt(\n    self,\n    func: _system_prompt.SystemPromptFunc[AgentDepsT] | None = None,\n    /,\n    *,\n    dynamic: bool = False,\n) -> (\n    Callable[[_system_prompt.SystemPromptFunc[AgentDepsT]], _system_prompt.SystemPromptFunc[AgentDepsT]]\n    | _system_prompt.SystemPromptFunc[AgentDepsT]\n):\n    \"\"\"Decorator to register a system prompt function.\n\n    Optionally takes [`RunContext`][pydantic_ai.tools.RunContext] as its only argument.\n    Can decorate a sync or async functions.\n\n    The decorator can be used either bare (`agent.system_prompt`) or as a function call\n    (`agent.system_prompt(...)`), see the examples below.\n\n    Overloads for every possible signature of `system_prompt` are included so the decorator doesn't obscure\n    the type of the function, see `tests/typed_agent.py` for tests.\n\n    Args:\n        func: The function to decorate\n        dynamic: If True, the system prompt will be reevaluated even when `messages_history` is provided,\n            see [`SystemPromptPart.dynamic_ref`][pydantic_ai.messages.SystemPromptPart.dynamic_ref]\n\n    Example:\n    ```python\n    from pydantic_ai import Agent, RunContext\n\n    agent = Agent('test', deps_type=str)\n\n    @agent.system_prompt\n    def simple_system_prompt() -> str:\n        return 'foobar'\n\n    @agent.system_prompt(dynamic=True)\n    async def async_system_prompt(ctx: RunContext[str]) -> str:\n        return f'{ctx.deps} is the best'\n    ```\n    \"\"\"\n    if func is None:\n\n        def decorator(\n            func_: _system_prompt.SystemPromptFunc[AgentDepsT],\n        ) -> _system_prompt.SystemPromptFunc[AgentDepsT]:\n            runner = _system_prompt.SystemPromptRunner[AgentDepsT](func_, dynamic=dynamic)\n            self._system_prompt_functions.append(runner)\n            if dynamic:  # pragma: lax no cover\n                self._system_prompt_dynamic_functions[func_.__qualname__] = runner\n            return func_\n\n        return decorator\n    else:\n        assert not dynamic, \"dynamic can't be True in this case\"\n        self._system_prompt_functions.append(_system_prompt.SystemPromptRunner[AgentDepsT](func, dynamic=dynamic))\n        return func\n\n````\n\n#### output_validator\n\n```python\noutput_validator(\n    func: Callable[\n        [RunContext[AgentDepsT], OutputDataT], OutputDataT\n    ],\n) -> Callable[\n    [RunContext[AgentDepsT], OutputDataT], OutputDataT\n]\n\n```\n\n```python\noutput_validator(\n    func: Callable[\n        [RunContext[AgentDepsT], OutputDataT],\n        Awaitable[OutputDataT],\n    ],\n) -> Callable[\n    [RunContext[AgentDepsT], OutputDataT],\n    Awaitable[OutputDataT],\n]\n\n```\n\n```python\noutput_validator(\n    func: Callable[[OutputDataT], OutputDataT],\n) -> Callable[[OutputDataT], OutputDataT]\n\n```\n\n```python\noutput_validator(\n    func: Callable[[OutputDataT], Awaitable[OutputDataT]],\n) -> Callable[[OutputDataT], Awaitable[OutputDataT]]\n\n```\n\n```python\noutput_validator(\n    func: OutputValidatorFunc[AgentDepsT, OutputDataT],\n) -> OutputValidatorFunc[AgentDepsT, OutputDataT]\n\n```\n\nDecorator to register an output validator function.\n\nOptionally takes RunContext as its first argument. Can decorate a sync or async functions.\n\nOverloads for every possible signature of `output_validator` are included so the decorator doesn't obscure the type of the function, see `tests/typed_agent.py` for tests.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent, ModelRetry, RunContext\n\nagent = Agent('test', deps_type=str)\n\n@agent.output_validator\ndef output_validator_simple(data: str) -> str:\n    if 'wrong' in data:\n        raise ModelRetry('wrong response')\n    return data\n\n@agent.output_validator\nasync def output_validator_deps(ctx: RunContext[str], data: str) -> str:\n    if ctx.deps in data:\n        raise ModelRetry('wrong response')\n    return data\n\nresult = agent.run_sync('foobar', deps='spam')\nprint(result.output)\n#> success (no tool calls)\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n````python\ndef output_validator(\n    self, func: _output.OutputValidatorFunc[AgentDepsT, OutputDataT], /\n) -> _output.OutputValidatorFunc[AgentDepsT, OutputDataT]:\n    \"\"\"Decorator to register an output validator function.\n\n    Optionally takes [`RunContext`][pydantic_ai.tools.RunContext] as its first argument.\n    Can decorate a sync or async functions.\n\n    Overloads for every possible signature of `output_validator` are included so the decorator doesn't obscure\n    the type of the function, see `tests/typed_agent.py` for tests.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent, ModelRetry, RunContext\n\n    agent = Agent('test', deps_type=str)\n\n    @agent.output_validator\n    def output_validator_simple(data: str) -> str:\n        if 'wrong' in data:\n            raise ModelRetry('wrong response')\n        return data\n\n    @agent.output_validator\n    async def output_validator_deps(ctx: RunContext[str], data: str) -> str:\n        if ctx.deps in data:\n            raise ModelRetry('wrong response')\n        return data\n\n    result = agent.run_sync('foobar', deps='spam')\n    print(result.output)\n    #> success (no tool calls)\n    ```\n    \"\"\"\n    self._output_validators.append(_output.OutputValidator[AgentDepsT, Any](func))\n    return func\n\n````\n\n#### tool\n\n```python\ntool(\n    func: ToolFuncContext[AgentDepsT, ToolParams],\n) -> ToolFuncContext[AgentDepsT, ToolParams]\n\n```\n\n```python\ntool(\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat = \"auto\",\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None\n) -> Callable[\n    [ToolFuncContext[AgentDepsT, ToolParams]],\n    ToolFuncContext[AgentDepsT, ToolParams],\n]\n\n```\n\n```python\ntool(\n    func: (\n        ToolFuncContext[AgentDepsT, ToolParams] | None\n    ) = None,\n    /,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat = \"auto\",\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None,\n) -> Any\n\n```\n\nDecorator to register a tool function which takes RunContext as its first argument.\n\nCan decorate a sync or async functions.\n\nThe docstring is inspected to extract both the tool description and description of each parameter, [learn more](../../tools/#function-tools-and-schema).\n\nWe can't add overloads for every possible signature of tool, since the return type is a recursive union so the signature of functions decorated with `@agent.tool` is obscured.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent, RunContext\n\nagent = Agent('test', deps_type=int)\n\n@agent.tool\ndef foobar(ctx: RunContext[int], x: int) -> int:\n    return ctx.deps + x\n\n@agent.tool(retries=2)\nasync def spam(ctx: RunContext[str], y: float) -> float:\n    return ctx.deps + y\n\nresult = agent.run_sync('foobar', deps=1)\nprint(result.output)\n#> {\"foobar\":1,\"spam\":1.0}\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `func` | `ToolFuncContext[AgentDepsT, ToolParams] | None` | The tool function to register. | `None` | | `name` | `str | None` | The name of the tool, defaults to the function name. | `None` | | `description` | `str | None` | The description of the tool, defaults to the function docstring. | `None` | | `retries` | `int | None` | The number of retries to allow for this tool, defaults to the agent's default retries, which defaults to 1. | `None` | | `prepare` | `ToolPrepareFunc[AgentDepsT] | None` | custom method to prepare the tool definition for each step, return None to omit this tool from a given step. This is useful if you want to customise a tool at call time, or omit it completely from a step. See ToolPrepareFunc. | `None` | | `docstring_format` | `DocstringFormat` | The format of the docstring, see DocstringFormat. Defaults to 'auto', such that the format is inferred from the structure of the docstring. | `'auto'` | | `require_parameter_descriptions` | `bool` | If True, raise an error if a parameter description is missing. Defaults to False. | `False` | | `schema_generator` | `type[GenerateJsonSchema]` | The JSON schema generator class to use for this tool. Defaults to GenerateToolJsonSchema. | `GenerateToolJsonSchema` | | `strict` | `bool | None` | Whether to enforce JSON schema compliance (only affects OpenAI). See ToolDefinition for more info. | `None` | | `sequential` | `bool` | Whether the function requires a sequential/serial execution environment. Defaults to False. | `False` | | `requires_approval` | `bool` | Whether this tool requires human-in-the-loop approval. Defaults to False. See the tools documentation for more info. | `False` | | `metadata` | `dict[str, Any] | None` | Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization. | `None` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n````python\ndef tool(\n    self,\n    func: ToolFuncContext[AgentDepsT, ToolParams] | None = None,\n    /,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat = 'auto',\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None,\n) -> Any:\n    \"\"\"Decorator to register a tool function which takes [`RunContext`][pydantic_ai.tools.RunContext] as its first argument.\n\n    Can decorate a sync or async functions.\n\n    The docstring is inspected to extract both the tool description and description of each parameter,\n    [learn more](../tools.md#function-tools-and-schema).\n\n    We can't add overloads for every possible signature of tool, since the return type is a recursive union\n    so the signature of functions decorated with `@agent.tool` is obscured.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent, RunContext\n\n    agent = Agent('test', deps_type=int)\n\n    @agent.tool\n    def foobar(ctx: RunContext[int], x: int) -> int:\n        return ctx.deps + x\n\n    @agent.tool(retries=2)\n    async def spam(ctx: RunContext[str], y: float) -> float:\n        return ctx.deps + y\n\n    result = agent.run_sync('foobar', deps=1)\n    print(result.output)\n    #> {\"foobar\":1,\"spam\":1.0}\n    ```\n\n    Args:\n        func: The tool function to register.\n        name: The name of the tool, defaults to the function name.\n        description: The description of the tool, defaults to the function docstring.\n        retries: The number of retries to allow for this tool, defaults to the agent's default retries,\n            which defaults to 1.\n        prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n            tool from a given step. This is useful if you want to customise a tool at call time,\n            or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n        docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n            Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.\n        require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.\n        schema_generator: The JSON schema generator class to use for this tool. Defaults to `GenerateToolJsonSchema`.\n        strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n            See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n        sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n        requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n            See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n        metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n    \"\"\"\n\n    def tool_decorator(\n        func_: ToolFuncContext[AgentDepsT, ToolParams],\n    ) -> ToolFuncContext[AgentDepsT, ToolParams]:\n        # noinspection PyTypeChecker\n        self._function_toolset.add_function(\n            func_,\n            takes_ctx=True,\n            name=name,\n            description=description,\n            retries=retries,\n            prepare=prepare,\n            docstring_format=docstring_format,\n            require_parameter_descriptions=require_parameter_descriptions,\n            schema_generator=schema_generator,\n            strict=strict,\n            sequential=sequential,\n            requires_approval=requires_approval,\n            metadata=metadata,\n        )\n        return func_\n\n    return tool_decorator if func is None else tool_decorator(func)\n\n````\n\n#### tool_plain\n\n```python\ntool_plain(\n    func: ToolFuncPlain[ToolParams],\n) -> ToolFuncPlain[ToolParams]\n\n```\n\n```python\ntool_plain(\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat = \"auto\",\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None\n) -> Callable[\n    [ToolFuncPlain[ToolParams]], ToolFuncPlain[ToolParams]\n]\n\n```\n\n```python\ntool_plain(\n    func: ToolFuncPlain[ToolParams] | None = None,\n    /,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat = \"auto\",\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None,\n) -> Any\n\n```\n\nDecorator to register a tool function which DOES NOT take `RunContext` as an argument.\n\nCan decorate a sync or async functions.\n\nThe docstring is inspected to extract both the tool description and description of each parameter, [learn more](../../tools/#function-tools-and-schema).\n\nWe can't add overloads for every possible signature of tool, since the return type is a recursive union so the signature of functions decorated with `@agent.tool` is obscured.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent, RunContext\n\nagent = Agent('test')\n\n@agent.tool\ndef foobar(ctx: RunContext[int]) -> int:\n    return 123\n\n@agent.tool(retries=2)\nasync def spam(ctx: RunContext[str]) -> float:\n    return 3.14\n\nresult = agent.run_sync('foobar', deps=1)\nprint(result.output)\n#> {\"foobar\":123,\"spam\":3.14}\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `func` | `ToolFuncPlain[ToolParams] | None` | The tool function to register. | `None` | | `name` | `str | None` | The name of the tool, defaults to the function name. | `None` | | `description` | `str | None` | The description of the tool, defaults to the function docstring. | `None` | | `retries` | `int | None` | The number of retries to allow for this tool, defaults to the agent's default retries, which defaults to 1. | `None` | | `prepare` | `ToolPrepareFunc[AgentDepsT] | None` | custom method to prepare the tool definition for each step, return None to omit this tool from a given step. This is useful if you want to customise a tool at call time, or omit it completely from a step. See ToolPrepareFunc. | `None` | | `docstring_format` | `DocstringFormat` | The format of the docstring, see DocstringFormat. Defaults to 'auto', such that the format is inferred from the structure of the docstring. | `'auto'` | | `require_parameter_descriptions` | `bool` | If True, raise an error if a parameter description is missing. Defaults to False. | `False` | | `schema_generator` | `type[GenerateJsonSchema]` | The JSON schema generator class to use for this tool. Defaults to GenerateToolJsonSchema. | `GenerateToolJsonSchema` | | `strict` | `bool | None` | Whether to enforce JSON schema compliance (only affects OpenAI). See ToolDefinition for more info. | `None` | | `sequential` | `bool` | Whether the function requires a sequential/serial execution environment. Defaults to False. | `False` | | `requires_approval` | `bool` | Whether this tool requires human-in-the-loop approval. Defaults to False. See the tools documentation for more info. | `False` | | `metadata` | `dict[str, Any] | None` | Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization. | `None` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n````python\ndef tool_plain(\n    self,\n    func: ToolFuncPlain[ToolParams] | None = None,\n    /,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat = 'auto',\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None,\n) -> Any:\n    \"\"\"Decorator to register a tool function which DOES NOT take `RunContext` as an argument.\n\n    Can decorate a sync or async functions.\n\n    The docstring is inspected to extract both the tool description and description of each parameter,\n    [learn more](../tools.md#function-tools-and-schema).\n\n    We can't add overloads for every possible signature of tool, since the return type is a recursive union\n    so the signature of functions decorated with `@agent.tool` is obscured.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent, RunContext\n\n    agent = Agent('test')\n\n    @agent.tool\n    def foobar(ctx: RunContext[int]) -> int:\n        return 123\n\n    @agent.tool(retries=2)\n    async def spam(ctx: RunContext[str]) -> float:\n        return 3.14\n\n    result = agent.run_sync('foobar', deps=1)\n    print(result.output)\n    #> {\"foobar\":123,\"spam\":3.14}\n    ```\n\n    Args:\n        func: The tool function to register.\n        name: The name of the tool, defaults to the function name.\n        description: The description of the tool, defaults to the function docstring.\n        retries: The number of retries to allow for this tool, defaults to the agent's default retries,\n            which defaults to 1.\n        prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n            tool from a given step. This is useful if you want to customise a tool at call time,\n            or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n        docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n            Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.\n        require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.\n        schema_generator: The JSON schema generator class to use for this tool. Defaults to `GenerateToolJsonSchema`.\n        strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n            See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n        sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n        requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n            See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n        metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n    \"\"\"\n\n    def tool_decorator(func_: ToolFuncPlain[ToolParams]) -> ToolFuncPlain[ToolParams]:\n        # noinspection PyTypeChecker\n        self._function_toolset.add_function(\n            func_,\n            takes_ctx=False,\n            name=name,\n            description=description,\n            retries=retries,\n            prepare=prepare,\n            docstring_format=docstring_format,\n            require_parameter_descriptions=require_parameter_descriptions,\n            schema_generator=schema_generator,\n            strict=strict,\n            sequential=sequential,\n            requires_approval=requires_approval,\n            metadata=metadata,\n        )\n        return func_\n\n    return tool_decorator if func is None else tool_decorator(func)\n\n````\n\n#### toolset\n\n```python\ntoolset(\n    func: ToolsetFunc[AgentDepsT],\n) -> ToolsetFunc[AgentDepsT]\n\n```\n\n```python\ntoolset(\n    *, per_run_step: bool = True\n) -> Callable[\n    [ToolsetFunc[AgentDepsT]], ToolsetFunc[AgentDepsT]\n]\n\n```\n\n```python\ntoolset(\n    func: ToolsetFunc[AgentDepsT] | None = None,\n    /,\n    *,\n    per_run_step: bool = True,\n) -> Any\n\n```\n\nDecorator to register a toolset function which takes RunContext as its only argument.\n\nCan decorate a sync or async functions.\n\nThe decorator can be used bare (`agent.toolset`).\n\nExample:\n\n```python\nfrom pydantic_ai import AbstractToolset, Agent, FunctionToolset, RunContext\n\nagent = Agent('test', deps_type=str)\n\n@agent.toolset\nasync def simple_toolset(ctx: RunContext[str]) -> AbstractToolset[str]:\n    return FunctionToolset()\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `func` | `ToolsetFunc[AgentDepsT] | None` | The toolset function to register. | `None` | | `per_run_step` | `bool` | Whether to re-evaluate the toolset for each run step. Defaults to True. | `True` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n````python\ndef toolset(\n    self,\n    func: ToolsetFunc[AgentDepsT] | None = None,\n    /,\n    *,\n    per_run_step: bool = True,\n) -> Any:\n    \"\"\"Decorator to register a toolset function which takes [`RunContext`][pydantic_ai.tools.RunContext] as its only argument.\n\n    Can decorate a sync or async functions.\n\n    The decorator can be used bare (`agent.toolset`).\n\n    Example:\n    ```python\n    from pydantic_ai import AbstractToolset, Agent, FunctionToolset, RunContext\n\n    agent = Agent('test', deps_type=str)\n\n    @agent.toolset\n    async def simple_toolset(ctx: RunContext[str]) -> AbstractToolset[str]:\n        return FunctionToolset()\n    ```\n\n    Args:\n        func: The toolset function to register.\n        per_run_step: Whether to re-evaluate the toolset for each run step. Defaults to True.\n    \"\"\"\n\n    def toolset_decorator(func_: ToolsetFunc[AgentDepsT]) -> ToolsetFunc[AgentDepsT]:\n        self._dynamic_toolsets.append(DynamicToolset(func_, per_run_step=per_run_step))\n        return func_\n\n    return toolset_decorator if func is None else toolset_decorator(func)\n\n````\n\n#### toolsets\n\n```python\ntoolsets: Sequence[AbstractToolset[AgentDepsT]]\n\n```\n\nAll toolsets registered on the agent, including a function toolset holding tools that were registered on the agent directly.\n\nOutput tools are not included.\n\n#### __aenter__\n\n```python\n__aenter__() -> Self\n\n```\n\nEnter the agent context.\n\nThis will start all MCPServerStdios registered as `toolsets` so they are ready to be used.\n\nThis is a no-op if the agent has already been entered.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n```python\nasync def __aenter__(self) -> Self:\n    \"\"\"Enter the agent context.\n\n    This will start all [`MCPServerStdio`s][pydantic_ai.mcp.MCPServerStdio] registered as `toolsets` so they are ready to be used.\n\n    This is a no-op if the agent has already been entered.\n    \"\"\"\n    async with self._enter_lock:\n        if self._entered_count == 0:\n            async with AsyncExitStack() as exit_stack:\n                toolset = self._get_toolset()\n                await exit_stack.enter_async_context(toolset)\n\n                self._exit_stack = exit_stack.pop_all()\n        self._entered_count += 1\n    return self\n\n```\n\n#### set_mcp_sampling_model\n\n```python\nset_mcp_sampling_model(\n    model: Model | KnownModelName | str | None = None,\n) -> None\n\n```\n\nSet the sampling model on all MCP servers registered with the agent.\n\nIf no sampling model is provided, the agent's model will be used.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n```python\ndef set_mcp_sampling_model(self, model: models.Model | models.KnownModelName | str | None = None) -> None:\n    \"\"\"Set the sampling model on all MCP servers registered with the agent.\n\n    If no sampling model is provided, the agent's model will be used.\n    \"\"\"\n    try:\n        sampling_model = models.infer_model(model) if model else self._get_model(None)\n    except exceptions.UserError as e:\n        raise exceptions.UserError('No sampling model provided and no model set on the agent.') from e\n\n    from ..mcp import MCPServer\n\n    def _set_sampling_model(toolset: AbstractToolset[AgentDepsT]) -> None:\n        if isinstance(toolset, MCPServer):\n            toolset.sampling_model = sampling_model\n\n    self._get_toolset().apply(_set_sampling_model)\n\n```\n\n#### run_mcp_servers\n\n```python\nrun_mcp_servers(\n    model: Model | KnownModelName | str | None = None,\n) -> AsyncIterator[None]\n\n```\n\nDeprecated\n\n`run_mcp_servers` is deprecated, use `async with agent:` instead. If you need to set a sampling model on all MCP servers, use `agent.set_mcp_sampling_model()`.\n\nRun MCPServerStdios so they can be used by the agent.\n\nDeprecated: use async with agent instead. If you need to set a sampling model on all MCP servers, use agent.set_mcp_sampling_model().\n\nReturns: a context manager to start and shutdown the servers.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/__init__.py`\n\n```python\n@asynccontextmanager\n@deprecated(\n    '`run_mcp_servers` is deprecated, use `async with agent:` instead. If you need to set a sampling model on all MCP servers, use `agent.set_mcp_sampling_model()`.'\n)\nasync def run_mcp_servers(\n    self, model: models.Model | models.KnownModelName | str | None = None\n) -> AsyncIterator[None]:\n    \"\"\"Run [`MCPServerStdio`s][pydantic_ai.mcp.MCPServerStdio] so they can be used by the agent.\n\n    Deprecated: use [`async with agent`][pydantic_ai.agent.Agent.__aenter__] instead.\n    If you need to set a sampling model on all MCP servers, use [`agent.set_mcp_sampling_model()`][pydantic_ai.agent.Agent.set_mcp_sampling_model].\n\n    Returns: a context manager to start and shutdown the servers.\n    \"\"\"\n    try:\n        self.set_mcp_sampling_model(model)\n    except exceptions.UserError:\n        if model is not None:\n            raise\n\n    async with self:\n        yield\n\n```\n\n### AbstractAgent\n\nBases: `Generic[AgentDepsT, OutputDataT]`, `ABC`\n\nAbstract superclass for Agent, WrapperAgent, and your own custom agent implementations.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\nclass AbstractAgent(Generic[AgentDepsT, OutputDataT], ABC):\n    \"\"\"Abstract superclass for [`Agent`][pydantic_ai.agent.Agent], [`WrapperAgent`][pydantic_ai.agent.WrapperAgent], and your own custom agent implementations.\"\"\"\n\n    @property\n    @abstractmethod\n    def model(self) -> models.Model | models.KnownModelName | str | None:\n        \"\"\"The default model configured for this agent.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def name(self) -> str | None:\n        \"\"\"The name of the agent, used for logging.\n\n        If `None`, we try to infer the agent name from the call frame when the agent is first run.\n        \"\"\"\n        raise NotImplementedError\n\n    @name.setter\n    @abstractmethod\n    def name(self, value: str | None) -> None:\n        \"\"\"Set the name of the agent, used for logging.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def deps_type(self) -> type:\n        \"\"\"The type of dependencies used by the agent.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def output_type(self) -> OutputSpec[OutputDataT]:\n        \"\"\"The type of data output by agent runs, used to validate the data returned by the model, defaults to `str`.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def event_stream_handler(self) -> EventStreamHandler[AgentDepsT] | None:\n        \"\"\"Optional handler for events from the model's streaming response and the agent's execution of tools.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def toolsets(self) -> Sequence[AbstractToolset[AgentDepsT]]:\n        \"\"\"All toolsets registered on the agent.\n\n        Output tools are not included.\n        \"\"\"\n        raise NotImplementedError\n\n    @overload\n    async def run(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> AgentRunResult[OutputDataT]: ...\n\n    @overload\n    async def run(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT],\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> AgentRunResult[RunOutputDataT]: ...\n\n    async def run(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> AgentRunResult[Any]:\n        \"\"\"Run the agent with a user prompt in async mode.\n\n        This method builds an internal agent graph (using system prompts, tools and output schemas) and then\n        runs the graph to completion. The result of the run is returned.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o')\n\n        async def main():\n            agent_run = await agent.run('What is the capital of France?')\n            print(agent_run.output)\n            #> The capital of France is Paris.\n        ```\n\n        Args:\n            user_prompt: User input to start/continue the conversation.\n            output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n                output validators since output validators would expect an argument that matches the agent's output type.\n            message_history: History of the conversation so far.\n            deferred_tool_results: Optional results for deferred tool calls in the message history.\n            model: Optional model to use for this run, required if `model` was not set when creating the agent.\n            instructions: Optional additional instructions to use for this run.\n            deps: Optional dependencies to use for this run.\n            model_settings: Optional settings to use for this model's request.\n            usage_limits: Optional limits on model request count or token usage.\n            usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n            infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n            toolsets: Optional additional toolsets for this run.\n            event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run.\n            builtin_tools: Optional additional builtin tools for this run.\n\n        Returns:\n            The result of the run.\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n\n        event_stream_handler = event_stream_handler or self.event_stream_handler\n\n        async with self.iter(\n            user_prompt=user_prompt,\n            output_type=output_type,\n            message_history=message_history,\n            deferred_tool_results=deferred_tool_results,\n            model=model,\n            instructions=instructions,\n            deps=deps,\n            model_settings=model_settings,\n            usage_limits=usage_limits,\n            usage=usage,\n            toolsets=toolsets,\n            builtin_tools=builtin_tools,\n        ) as agent_run:\n            async for node in agent_run:\n                if event_stream_handler is not None and (\n                    self.is_model_request_node(node) or self.is_call_tools_node(node)\n                ):\n                    async with node.stream(agent_run.ctx) as stream:\n                        await event_stream_handler(_agent_graph.build_run_context(agent_run.ctx), stream)\n\n        assert agent_run.result is not None, 'The graph run did not finish properly'\n        return agent_run.result\n\n    @overload\n    def run_sync(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> AgentRunResult[OutputDataT]: ...\n\n    @overload\n    def run_sync(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT],\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> AgentRunResult[RunOutputDataT]: ...\n\n    def run_sync(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> AgentRunResult[Any]:\n        \"\"\"Synchronously run the agent with a user prompt.\n\n        This is a convenience method that wraps [`self.run`][pydantic_ai.agent.AbstractAgent.run] with `loop.run_until_complete(...)`.\n        You therefore can't use this method inside async code or if there's an active event loop.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o')\n\n        result_sync = agent.run_sync('What is the capital of Italy?')\n        print(result_sync.output)\n        #> The capital of Italy is Rome.\n        ```\n\n        Args:\n            user_prompt: User input to start/continue the conversation.\n            output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n                output validators since output validators would expect an argument that matches the agent's output type.\n            message_history: History of the conversation so far.\n            deferred_tool_results: Optional results for deferred tool calls in the message history.\n            model: Optional model to use for this run, required if `model` was not set when creating the agent.\n            instructions: Optional additional instructions to use for this run.\n            deps: Optional dependencies to use for this run.\n            model_settings: Optional settings to use for this model's request.\n            usage_limits: Optional limits on model request count or token usage.\n            usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n            infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n            toolsets: Optional additional toolsets for this run.\n            event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run.\n            builtin_tools: Optional additional builtin tools for this run.\n\n        Returns:\n            The result of the run.\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n\n        return _utils.get_event_loop().run_until_complete(\n            self.run(\n                user_prompt,\n                output_type=output_type,\n                message_history=message_history,\n                deferred_tool_results=deferred_tool_results,\n                model=model,\n                instructions=instructions,\n                deps=deps,\n                model_settings=model_settings,\n                usage_limits=usage_limits,\n                usage=usage,\n                infer_name=False,\n                toolsets=toolsets,\n                builtin_tools=builtin_tools,\n                event_stream_handler=event_stream_handler,\n            )\n        )\n\n    @overload\n    def run_stream(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> AbstractAsyncContextManager[result.StreamedRunResult[AgentDepsT, OutputDataT]]: ...\n\n    @overload\n    def run_stream(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT],\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> AbstractAsyncContextManager[result.StreamedRunResult[AgentDepsT, RunOutputDataT]]: ...\n\n    @asynccontextmanager\n    async def run_stream(  # noqa: C901\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> AsyncIterator[result.StreamedRunResult[AgentDepsT, Any]]:\n        \"\"\"Run the agent with a user prompt in async streaming mode.\n\n        This method builds an internal agent graph (using system prompts, tools and output schemas) and then\n        runs the graph until the model produces output matching the `output_type`, for example text or structured data.\n        At this point, a streaming run result object is yielded from which you can stream the output as it comes in,\n        and -- once this output has completed streaming -- get the complete output, message history, and usage.\n\n        As this method will consider the first output matching the `output_type` to be the final output,\n        it will stop running the agent graph and will not execute any tool calls made by the model after this \"final\" output.\n        If you want to always run the agent graph to completion and stream events and output at the same time,\n        use [`agent.run()`][pydantic_ai.agent.AbstractAgent.run] with an `event_stream_handler` or [`agent.iter()`][pydantic_ai.agent.AbstractAgent.iter] instead.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o')\n\n        async def main():\n            async with agent.run_stream('What is the capital of the UK?') as response:\n                print(await response.get_output())\n                #> The capital of the UK is London.\n        ```\n\n        Args:\n            user_prompt: User input to start/continue the conversation.\n            output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n                output validators since output validators would expect an argument that matches the agent's output type.\n            message_history: History of the conversation so far.\n            deferred_tool_results: Optional results for deferred tool calls in the message history.\n            model: Optional model to use for this run, required if `model` was not set when creating the agent.\n            instructions: Optional additional instructions to use for this run.\n            deps: Optional dependencies to use for this run.\n            model_settings: Optional settings to use for this model's request.\n            usage_limits: Optional limits on model request count or token usage.\n            usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n            infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n            toolsets: Optional additional toolsets for this run.\n            builtin_tools: Optional additional builtin tools for this run.\n            event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run.\n                It will receive all the events up until the final result is found, which you can then read or stream from inside the context manager.\n                Note that it does _not_ receive any events after the final result is found.\n\n        Returns:\n            The result of the run.\n        \"\"\"\n        if infer_name and self.name is None:\n            # f_back because `asynccontextmanager` adds one frame\n            if frame := inspect.currentframe():  # pragma: no branch\n                self._infer_name(frame.f_back)\n\n        event_stream_handler = event_stream_handler or self.event_stream_handler\n\n        yielded = False\n        async with self.iter(\n            user_prompt,\n            output_type=output_type,\n            message_history=message_history,\n            deferred_tool_results=deferred_tool_results,\n            model=model,\n            deps=deps,\n            instructions=instructions,\n            model_settings=model_settings,\n            usage_limits=usage_limits,\n            usage=usage,\n            infer_name=False,\n            toolsets=toolsets,\n            builtin_tools=builtin_tools,\n        ) as agent_run:\n            first_node = agent_run.next_node  # start with the first node\n            assert isinstance(first_node, _agent_graph.UserPromptNode)  # the first node should be a user prompt node\n            node = first_node\n            while True:\n                graph_ctx = agent_run.ctx\n                if self.is_model_request_node(node):\n                    async with node.stream(graph_ctx) as stream:\n                        final_result_event = None\n\n                        async def stream_to_final(\n                            stream: AgentStream,\n                        ) -> AsyncIterator[_messages.ModelResponseStreamEvent]:\n                            nonlocal final_result_event\n                            async for event in stream:\n                                yield event\n                                if isinstance(event, _messages.FinalResultEvent):\n                                    final_result_event = event\n                                    break\n\n                        if event_stream_handler is not None:\n                            await event_stream_handler(\n                                _agent_graph.build_run_context(graph_ctx), stream_to_final(stream)\n                            )\n                        else:\n                            async for _ in stream_to_final(stream):\n                                pass\n\n                        if final_result_event is not None:\n                            final_result = FinalResult(\n                                None, final_result_event.tool_name, final_result_event.tool_call_id\n                            )\n                            if yielded:\n                                raise exceptions.AgentRunError('Agent run produced final results')  # pragma: no cover\n                            yielded = True\n\n                            messages = graph_ctx.state.message_history.copy()\n\n                            async def on_complete() -> None:\n                                \"\"\"Called when the stream has completed.\n\n                                The model response will have been added to messages by now\n                                by `StreamedRunResult._marked_completed`.\n                                \"\"\"\n                                nonlocal final_result\n                                final_result = FinalResult(\n                                    await stream.get_output(), final_result.tool_name, final_result.tool_call_id\n                                )\n\n                                # When we get here, the `ModelRequestNode` has completed streaming after the final result was found.\n                                # When running an agent with `agent.run`, we'd then move to `CallToolsNode` to execute the tool calls and\n                                # find the final result.\n                                # We also want to execute tool calls (in case `agent.end_strategy == 'exhaustive'`) here, but\n                                # we don't want to use run the `CallToolsNode` logic to determine the final output, as it would be\n                                # wasteful and could produce a different result (e.g. when text output is followed by tool calls).\n                                # So we call `process_tool_calls` directly and then end the run with the found final result.\n\n                                parts: list[_messages.ModelRequestPart] = []\n                                async for _event in _agent_graph.process_tool_calls(\n                                    tool_manager=graph_ctx.deps.tool_manager,\n                                    tool_calls=stream.response.tool_calls,\n                                    tool_call_results=None,\n                                    final_result=final_result,\n                                    ctx=graph_ctx,\n                                    output_parts=parts,\n                                ):\n                                    pass\n\n                                # For backwards compatibility, append a new ModelRequest using the tool returns and retries\n                                if parts:\n                                    messages.append(_messages.ModelRequest(parts, run_id=graph_ctx.state.run_id))\n\n                                await agent_run.next(_agent_graph.SetFinalResult(final_result))\n\n                            yield StreamedRunResult(\n                                messages,\n                                graph_ctx.deps.new_message_index,\n                                stream,\n                                on_complete,\n                            )\n                            break\n                elif self.is_call_tools_node(node) and event_stream_handler is not None:\n                    async with node.stream(agent_run.ctx) as stream:\n                        await event_stream_handler(_agent_graph.build_run_context(agent_run.ctx), stream)\n\n                next_node = await agent_run.next(node)\n                if isinstance(next_node, End) and agent_run.result is not None:\n                    # A final output could have been produced by the CallToolsNode rather than the ModelRequestNode,\n                    # if a tool function raised CallDeferred or ApprovalRequired.\n                    # In this case there's no response to stream, but we still let the user access the output etc as normal.\n                    yield StreamedRunResult(\n                        graph_ctx.state.message_history,\n                        graph_ctx.deps.new_message_index,\n                        run_result=agent_run.result,\n                    )\n                    yielded = True\n                    break\n                if not isinstance(next_node, _agent_graph.AgentNode):\n                    raise exceptions.AgentRunError(  # pragma: no cover\n                        'Should have produced a StreamedRunResult before getting here'\n                    )\n                node = cast(_agent_graph.AgentNode[Any, Any], next_node)\n\n        if not yielded:\n            raise exceptions.AgentRunError('Agent run finished without producing a final result')  # pragma: no cover\n\n    @overload\n    def run_stream_sync(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> result.StreamedRunResultSync[AgentDepsT, OutputDataT]: ...\n\n    @overload\n    def run_stream_sync(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT],\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> result.StreamedRunResultSync[AgentDepsT, RunOutputDataT]: ...\n\n    def run_stream_sync(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n        event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n    ) -> result.StreamedRunResultSync[AgentDepsT, Any]:\n        \"\"\"Run the agent with a user prompt in sync streaming mode.\n\n        This is a convenience method that wraps [`run_stream()`][pydantic_ai.agent.AbstractAgent.run_stream] with `loop.run_until_complete(...)`.\n        You therefore can't use this method inside async code or if there's an active event loop.\n\n        This method builds an internal agent graph (using system prompts, tools and output schemas) and then\n        runs the graph until the model produces output matching the `output_type`, for example text or structured data.\n        At this point, a streaming run result object is yielded from which you can stream the output as it comes in,\n        and -- once this output has completed streaming -- get the complete output, message history, and usage.\n\n        As this method will consider the first output matching the `output_type` to be the final output,\n        it will stop running the agent graph and will not execute any tool calls made by the model after this \"final\" output.\n        If you want to always run the agent graph to completion and stream events and output at the same time,\n        use [`agent.run()`][pydantic_ai.agent.AbstractAgent.run] with an `event_stream_handler` or [`agent.iter()`][pydantic_ai.agent.AbstractAgent.iter] instead.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o')\n\n        def main():\n            response = agent.run_stream_sync('What is the capital of the UK?')\n            print(response.get_output())\n            #> The capital of the UK is London.\n        ```\n\n        Args:\n            user_prompt: User input to start/continue the conversation.\n            output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n                output validators since output validators would expect an argument that matches the agent's output type.\n            message_history: History of the conversation so far.\n            deferred_tool_results: Optional results for deferred tool calls in the message history.\n            model: Optional model to use for this run, required if `model` was not set when creating the agent.\n            deps: Optional dependencies to use for this run.\n            model_settings: Optional settings to use for this model's request.\n            usage_limits: Optional limits on model request count or token usage.\n            usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n            infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n            toolsets: Optional additional toolsets for this run.\n            builtin_tools: Optional additional builtin tools for this run.\n            event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run.\n                It will receive all the events up until the final result is found, which you can then read or stream from inside the context manager.\n                Note that it does _not_ receive any events after the final result is found.\n\n        Returns:\n            The result of the run.\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n\n        async def _consume_stream():\n            async with self.run_stream(\n                user_prompt,\n                output_type=output_type,\n                message_history=message_history,\n                deferred_tool_results=deferred_tool_results,\n                model=model,\n                deps=deps,\n                model_settings=model_settings,\n                usage_limits=usage_limits,\n                usage=usage,\n                infer_name=infer_name,\n                toolsets=toolsets,\n                builtin_tools=builtin_tools,\n                event_stream_handler=event_stream_handler,\n            ) as stream_result:\n                yield stream_result\n\n        async_result = _utils.get_event_loop().run_until_complete(anext(_consume_stream()))\n        return result.StreamedRunResultSync(async_result)\n\n    @overload\n    def run_stream_events(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AsyncIterator[_messages.AgentStreamEvent | AgentRunResultEvent[OutputDataT]]: ...\n\n    @overload\n    def run_stream_events(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT],\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AsyncIterator[_messages.AgentStreamEvent | AgentRunResultEvent[RunOutputDataT]]: ...\n\n    def run_stream_events(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AsyncIterator[_messages.AgentStreamEvent | AgentRunResultEvent[Any]]:\n        \"\"\"Run the agent with a user prompt in async mode and stream events from the run.\n\n        This is a convenience method that wraps [`self.run`][pydantic_ai.agent.AbstractAgent.run] and\n        uses the `event_stream_handler` kwarg to get a stream of events from the run.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent, AgentRunResultEvent, AgentStreamEvent\n\n        agent = Agent('openai:gpt-4o')\n\n        async def main():\n            events: list[AgentStreamEvent | AgentRunResultEvent] = []\n            async for event in agent.run_stream_events('What is the capital of France?'):\n                events.append(event)\n            print(events)\n            '''\n            [\n                PartStartEvent(index=0, part=TextPart(content='The capital of ')),\n                FinalResultEvent(tool_name=None, tool_call_id=None),\n                PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='France is Paris. ')),\n                PartEndEvent(\n                    index=0, part=TextPart(content='The capital of France is Paris. ')\n                ),\n                AgentRunResultEvent(\n                    result=AgentRunResult(output='The capital of France is Paris. ')\n                ),\n            ]\n            '''\n        ```\n\n        Arguments are the same as for [`self.run`][pydantic_ai.agent.AbstractAgent.run],\n        except that `event_stream_handler` is now allowed.\n\n        Args:\n            user_prompt: User input to start/continue the conversation.\n            output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n                output validators since output validators would expect an argument that matches the agent's output type.\n            message_history: History of the conversation so far.\n            deferred_tool_results: Optional results for deferred tool calls in the message history.\n            model: Optional model to use for this run, required if `model` was not set when creating the agent.\n            instructions: Optional additional instructions to use for this run.\n            deps: Optional dependencies to use for this run.\n            model_settings: Optional settings to use for this model's request.\n            usage_limits: Optional limits on model request count or token usage.\n            usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n            infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n            toolsets: Optional additional toolsets for this run.\n            builtin_tools: Optional additional builtin tools for this run.\n\n        Returns:\n            An async iterable of stream events `AgentStreamEvent` and finally a `AgentRunResultEvent` with the final\n            run result.\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n\n        # unfortunately this hack of returning a generator rather than defining it right here is\n        # required to allow overloads of this method to work in python's typing system, or at least with pyright\n        # or at least I couldn't make it work without\n        return self._run_stream_events(\n            user_prompt,\n            output_type=output_type,\n            message_history=message_history,\n            deferred_tool_results=deferred_tool_results,\n            model=model,\n            instructions=instructions,\n            deps=deps,\n            model_settings=model_settings,\n            usage_limits=usage_limits,\n            usage=usage,\n            toolsets=toolsets,\n            builtin_tools=builtin_tools,\n        )\n\n    async def _run_stream_events(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AsyncIterator[_messages.AgentStreamEvent | AgentRunResultEvent[Any]]:\n        send_stream, receive_stream = anyio.create_memory_object_stream[\n            _messages.AgentStreamEvent | AgentRunResultEvent[Any]\n        ]()\n\n        async def event_stream_handler(\n            _: RunContext[AgentDepsT], events: AsyncIterable[_messages.AgentStreamEvent]\n        ) -> None:\n            async for event in events:\n                await send_stream.send(event)\n\n        async def run_agent() -> AgentRunResult[Any]:\n            async with send_stream:\n                return await self.run(\n                    user_prompt,\n                    output_type=output_type,\n                    message_history=message_history,\n                    deferred_tool_results=deferred_tool_results,\n                    model=model,\n                    instructions=instructions,\n                    deps=deps,\n                    model_settings=model_settings,\n                    usage_limits=usage_limits,\n                    usage=usage,\n                    infer_name=False,\n                    toolsets=toolsets,\n                    builtin_tools=builtin_tools,\n                    event_stream_handler=event_stream_handler,\n                )\n\n        task = asyncio.create_task(run_agent())\n\n        async with receive_stream:\n            async for message in receive_stream:\n                yield message\n\n        result = await task\n        yield AgentRunResultEvent(result)\n\n    @overload\n    def iter(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AbstractAsyncContextManager[AgentRun[AgentDepsT, OutputDataT]]: ...\n\n    @overload\n    def iter(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT],\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AbstractAsyncContextManager[AgentRun[AgentDepsT, RunOutputDataT]]: ...\n\n    @asynccontextmanager\n    @abstractmethod\n    async def iter(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AsyncIterator[AgentRun[AgentDepsT, Any]]:\n        \"\"\"A contextmanager which can be used to iterate over the agent graph's nodes as they are executed.\n\n        This method builds an internal agent graph (using system prompts, tools and output schemas) and then returns an\n        `AgentRun` object. The `AgentRun` can be used to async-iterate over the nodes of the graph as they are\n        executed. This is the API to use if you want to consume the outputs coming from each LLM model response, or the\n        stream of events coming from the execution of tools.\n\n        The `AgentRun` also provides methods to access the full message history, new messages, and usage statistics,\n        and the final result of the run once it has completed.\n\n        For more details, see the documentation of `AgentRun`.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o')\n\n        async def main():\n            nodes = []\n            async with agent.iter('What is the capital of France?') as agent_run:\n                async for node in agent_run:\n                    nodes.append(node)\n            print(nodes)\n            '''\n            [\n                UserPromptNode(\n                    user_prompt='What is the capital of France?',\n                    instructions_functions=[],\n                    system_prompts=(),\n                    system_prompt_functions=[],\n                    system_prompt_dynamic_functions={},\n                ),\n                ModelRequestNode(\n                    request=ModelRequest(\n                        parts=[\n                            UserPromptPart(\n                                content='What is the capital of France?',\n                                timestamp=datetime.datetime(...),\n                            )\n                        ],\n                        run_id='...',\n                    )\n                ),\n                CallToolsNode(\n                    model_response=ModelResponse(\n                        parts=[TextPart(content='The capital of France is Paris.')],\n                        usage=RequestUsage(input_tokens=56, output_tokens=7),\n                        model_name='gpt-4o',\n                        timestamp=datetime.datetime(...),\n                        run_id='...',\n                    )\n                ),\n                End(data=FinalResult(output='The capital of France is Paris.')),\n            ]\n            '''\n            print(agent_run.result.output)\n            #> The capital of France is Paris.\n        ```\n\n        Args:\n            user_prompt: User input to start/continue the conversation.\n            output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n                output validators since output validators would expect an argument that matches the agent's output type.\n            message_history: History of the conversation so far.\n            deferred_tool_results: Optional results for deferred tool calls in the message history.\n            model: Optional model to use for this run, required if `model` was not set when creating the agent.\n            instructions: Optional additional instructions to use for this run.\n            deps: Optional dependencies to use for this run.\n            model_settings: Optional settings to use for this model's request.\n            usage_limits: Optional limits on model request count or token usage.\n            usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n            infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n            toolsets: Optional additional toolsets for this run.\n            builtin_tools: Optional additional builtin tools for this run.\n\n        Returns:\n            The result of the run.\n        \"\"\"\n        raise NotImplementedError\n        yield\n\n    @contextmanager\n    @abstractmethod\n    def override(\n        self,\n        *,\n        name: str | _utils.Unset = _utils.UNSET,\n        deps: AgentDepsT | _utils.Unset = _utils.UNSET,\n        model: models.Model | models.KnownModelName | str | _utils.Unset = _utils.UNSET,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | _utils.Unset = _utils.UNSET,\n        tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] | _utils.Unset = _utils.UNSET,\n        instructions: Instructions[AgentDepsT] | _utils.Unset = _utils.UNSET,\n    ) -> Iterator[None]:\n        \"\"\"Context manager to temporarily override agent name, dependencies, model, toolsets, tools, or instructions.\n\n        This is particularly useful when testing.\n        You can find an example of this [here](../testing.md#overriding-model-via-pytest-fixtures).\n\n        Args:\n            name: The name to use instead of the name passed to the agent constructor and agent run.\n            deps: The dependencies to use instead of the dependencies passed to the agent run.\n            model: The model to use instead of the model passed to the agent run.\n            toolsets: The toolsets to use instead of the toolsets passed to the agent constructor and agent run.\n            tools: The tools to use instead of the tools registered with the agent.\n            instructions: The instructions to use instead of the instructions registered with the agent.\n        \"\"\"\n        raise NotImplementedError\n        yield\n\n    def _infer_name(self, function_frame: FrameType | None) -> None:\n        \"\"\"Infer the agent name from the call frame.\n\n        RunUsage should be `self._infer_name(inspect.currentframe())`.\n        \"\"\"\n        assert self.name is None, 'Name already set'\n        if function_frame is not None:  # pragma: no branch\n            if parent_frame := function_frame.f_back:  # pragma: no branch\n                for name, item in parent_frame.f_locals.items():\n                    if item is self:\n                        self.name = name\n                        return\n                if parent_frame.f_locals != parent_frame.f_globals:  # pragma: no branch\n                    # if we couldn't find the agent in locals and globals are a different dict, try globals\n                    for name, item in parent_frame.f_globals.items():\n                        if item is self:\n                            self.name = name\n                            return\n\n    @staticmethod\n    @contextmanager\n    def sequential_tool_calls() -> Iterator[None]:\n        \"\"\"Run tool calls sequentially during the context.\"\"\"\n        with ToolManager.sequential_tool_calls():\n            yield\n\n    @staticmethod\n    def is_model_request_node(\n        node: _agent_graph.AgentNode[T, S] | End[result.FinalResult[S]],\n    ) -> TypeIs[_agent_graph.ModelRequestNode[T, S]]:\n        \"\"\"Check if the node is a `ModelRequestNode`, narrowing the type if it is.\n\n        This method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n        \"\"\"\n        return isinstance(node, _agent_graph.ModelRequestNode)\n\n    @staticmethod\n    def is_call_tools_node(\n        node: _agent_graph.AgentNode[T, S] | End[result.FinalResult[S]],\n    ) -> TypeIs[_agent_graph.CallToolsNode[T, S]]:\n        \"\"\"Check if the node is a `CallToolsNode`, narrowing the type if it is.\n\n        This method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n        \"\"\"\n        return isinstance(node, _agent_graph.CallToolsNode)\n\n    @staticmethod\n    def is_user_prompt_node(\n        node: _agent_graph.AgentNode[T, S] | End[result.FinalResult[S]],\n    ) -> TypeIs[_agent_graph.UserPromptNode[T, S]]:\n        \"\"\"Check if the node is a `UserPromptNode`, narrowing the type if it is.\n\n        This method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n        \"\"\"\n        return isinstance(node, _agent_graph.UserPromptNode)\n\n    @staticmethod\n    def is_end_node(\n        node: _agent_graph.AgentNode[T, S] | End[result.FinalResult[S]],\n    ) -> TypeIs[End[result.FinalResult[S]]]:\n        \"\"\"Check if the node is a `End`, narrowing the type if it is.\n\n        This method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n        \"\"\"\n        return isinstance(node, End)\n\n    @abstractmethod\n    async def __aenter__(self) -> AbstractAgent[AgentDepsT, OutputDataT]:\n        raise NotImplementedError\n\n    @abstractmethod\n    async def __aexit__(self, *args: Any) -> bool | None:\n        raise NotImplementedError\n\n    # TODO (v2): Remove in favor of using `AGUIApp` directly -- we don't have `to_temporal()` or `to_vercel_ai()` either.\n    def to_ag_ui(\n        self,\n        *,\n        # Agent.iter parameters\n        output_type: OutputSpec[OutputDataT] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: UsageLimits | None = None,\n        usage: RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        # Starlette\n        debug: bool = False,\n        routes: Sequence[BaseRoute] | None = None,\n        middleware: Sequence[Middleware] | None = None,\n        exception_handlers: Mapping[Any, ExceptionHandler] | None = None,\n        on_startup: Sequence[Callable[[], Any]] | None = None,\n        on_shutdown: Sequence[Callable[[], Any]] | None = None,\n        lifespan: Lifespan[AGUIApp[AgentDepsT, OutputDataT]] | None = None,\n    ) -> AGUIApp[AgentDepsT, OutputDataT]:\n        \"\"\"Returns an ASGI application that handles every AG-UI request by running the agent.\n\n        Note that the `deps` will be the same for each request, with the exception of the AG-UI state that's\n        injected into the `state` field of a `deps` object that implements the [`StateHandler`][pydantic_ai.ag_ui.StateHandler] protocol.\n        To provide different `deps` for each request (e.g. based on the authenticated user),\n        use [`pydantic_ai.ag_ui.run_ag_ui`][pydantic_ai.ag_ui.run_ag_ui] or\n        [`pydantic_ai.ag_ui.handle_ag_ui_request`][pydantic_ai.ag_ui.handle_ag_ui_request] instead.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o')\n        app = agent.to_ag_ui()\n        ```\n\n        The `app` is an ASGI application that can be used with any ASGI server.\n\n        To run the application, you can use the following command:\n\n        ```bash\n        uvicorn app:app --host 0.0.0.0 --port 8000\n        ```\n\n        See [AG-UI docs](../ui/ag-ui.md) for more information.\n\n        Args:\n            output_type: Custom output type to use for this run, `output_type` may only be used if the agent has\n                no output validators since output validators would expect an argument that matches the agent's\n                output type.\n            message_history: History of the conversation so far.\n            deferred_tool_results: Optional results for deferred tool calls in the message history.\n            model: Optional model to use for this run, required if `model` was not set when creating the agent.\n            deps: Optional dependencies to use for this run.\n            model_settings: Optional settings to use for this model's request.\n            usage_limits: Optional limits on model request count or token usage.\n            usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n            infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n            toolsets: Optional additional toolsets for this run.\n\n            debug: Boolean indicating if debug tracebacks should be returned on errors.\n            routes: A list of routes to serve incoming HTTP and WebSocket requests.\n            middleware: A list of middleware to run for every request. A starlette application will always\n                automatically include two middleware classes. `ServerErrorMiddleware` is added as the very\n                outermost middleware, to handle any uncaught errors occurring anywhere in the entire stack.\n                `ExceptionMiddleware` is added as the very innermost middleware, to deal with handled\n                exception cases occurring in the routing or endpoints.\n            exception_handlers: A mapping of either integer status codes, or exception class types onto\n                callables which handle the exceptions. Exception handler callables should be of the form\n                `handler(request, exc) -> response` and may be either standard functions, or async functions.\n            on_startup: A list of callables to run on application startup. Startup handler callables do not\n                take any arguments, and may be either standard functions, or async functions.\n            on_shutdown: A list of callables to run on application shutdown. Shutdown handler callables do\n                not take any arguments, and may be either standard functions, or async functions.\n            lifespan: A lifespan context function, which can be used to perform startup and shutdown tasks.\n                This is a newer style that replaces the `on_startup` and `on_shutdown` handlers. Use one or\n                the other, not both.\n\n        Returns:\n            An ASGI application for running Pydantic AI agents with AG-UI protocol support.\n        \"\"\"\n        from pydantic_ai.ui.ag_ui.app import AGUIApp\n\n        return AGUIApp(\n            agent=self,\n            # Agent.iter parameters\n            output_type=output_type,\n            message_history=message_history,\n            deferred_tool_results=deferred_tool_results,\n            model=model,\n            deps=deps,\n            model_settings=model_settings,\n            usage_limits=usage_limits,\n            usage=usage,\n            infer_name=infer_name,\n            toolsets=toolsets,\n            # Starlette\n            debug=debug,\n            routes=routes,\n            middleware=middleware,\n            exception_handlers=exception_handlers,\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n            lifespan=lifespan,\n        )\n\n    def to_a2a(\n        self,\n        *,\n        storage: Storage | None = None,\n        broker: Broker | None = None,\n        # Agent card\n        name: str | None = None,\n        url: str = 'http://localhost:8000',\n        version: str = '1.0.0',\n        description: str | None = None,\n        provider: AgentProvider | None = None,\n        skills: list[Skill] | None = None,\n        # Starlette\n        debug: bool = False,\n        routes: Sequence[Route] | None = None,\n        middleware: Sequence[Middleware] | None = None,\n        exception_handlers: dict[Any, ExceptionHandler] | None = None,\n        lifespan: Lifespan[FastA2A] | None = None,\n    ) -> FastA2A:\n        \"\"\"Convert the agent to a FastA2A application.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o')\n        app = agent.to_a2a()\n        ```\n\n        The `app` is an ASGI application that can be used with any ASGI server.\n\n        To run the application, you can use the following command:\n\n        ```bash\n        uvicorn app:app --host 0.0.0.0 --port 8000\n        ```\n        \"\"\"\n        from .._a2a import agent_to_a2a\n\n        return agent_to_a2a(\n            self,\n            storage=storage,\n            broker=broker,\n            name=name,\n            url=url,\n            version=version,\n            description=description,\n            provider=provider,\n            skills=skills,\n            debug=debug,\n            routes=routes,\n            middleware=middleware,\n            exception_handlers=exception_handlers,\n            lifespan=lifespan,\n        )\n\n    async def to_cli(\n        self: Self,\n        deps: AgentDepsT = None,\n        prog_name: str = 'pydantic-ai',\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n    ) -> None:\n        \"\"\"Run the agent in a CLI chat interface.\n\n        Args:\n            deps: The dependencies to pass to the agent.\n            prog_name: The name of the program to use for the CLI. Defaults to 'pydantic-ai'.\n            message_history: History of the conversation so far.\n\n        Example:\n        ```python {title=\"agent_to_cli.py\" test=\"skip\"}\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o', instructions='You always respond in Italian.')\n\n        async def main():\n            await agent.to_cli()\n        ```\n        \"\"\"\n        from rich.console import Console\n\n        from pydantic_ai._cli import run_chat\n\n        await run_chat(\n            stream=True,\n            agent=self,\n            deps=deps,\n            console=Console(),\n            code_theme='monokai',\n            prog_name=prog_name,\n            message_history=message_history,\n        )\n\n    def to_cli_sync(\n        self: Self,\n        deps: AgentDepsT = None,\n        prog_name: str = 'pydantic-ai',\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n    ) -> None:\n        \"\"\"Run the agent in a CLI chat interface with the non-async interface.\n\n        Args:\n            deps: The dependencies to pass to the agent.\n            prog_name: The name of the program to use for the CLI. Defaults to 'pydantic-ai'.\n            message_history: History of the conversation so far.\n\n        ```python {title=\"agent_to_cli_sync.py\" test=\"skip\"}\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o', instructions='You always respond in Italian.')\n        agent.to_cli_sync()\n        agent.to_cli_sync(prog_name='assistant')\n        ```\n        \"\"\"\n        return _utils.get_event_loop().run_until_complete(\n            self.to_cli(deps=deps, prog_name=prog_name, message_history=message_history)\n        )\n\n````\n\n#### model\n\n```python\nmodel: Model | KnownModelName | str | None\n\n```\n\nThe default model configured for this agent.\n\n#### name\n\n```python\nname: str | None\n\n```\n\nThe name of the agent, used for logging.\n\nIf `None`, we try to infer the agent name from the call frame when the agent is first run.\n\n#### deps_type\n\n```python\ndeps_type: type\n\n```\n\nThe type of dependencies used by the agent.\n\n#### output_type\n\n```python\noutput_type: OutputSpec[OutputDataT]\n\n```\n\nThe type of data output by agent runs, used to validate the data returned by the model, defaults to `str`.\n\n#### event_stream_handler\n\n```python\nevent_stream_handler: EventStreamHandler[AgentDepsT] | None\n\n```\n\nOptional handler for events from the model's streaming response and the agent's execution of tools.\n\n#### toolsets\n\n```python\ntoolsets: Sequence[AbstractToolset[AgentDepsT]]\n\n```\n\nAll toolsets registered on the agent.\n\nOutput tools are not included.\n\n#### run\n\n```python\nrun(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> AgentRunResult[OutputDataT]\n\n```\n\n```python\nrun(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT],\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> AgentRunResult[RunOutputDataT]\n\n```\n\n```python\nrun(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> AgentRunResult[Any]\n\n```\n\nRun the agent with a user prompt in async mode.\n\nThis method builds an internal agent graph (using system prompts, tools and output schemas) and then runs the graph to completion. The result of the run is returned.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\n\nasync def main():\n    agent_run = await agent.run('What is the capital of France?')\n    print(agent_run.output)\n    #> The capital of France is Paris.\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `user_prompt` | `str | Sequence[UserContent] | None` | User input to start/continue the conversation. | `None` | | `output_type` | `OutputSpec[RunOutputDataT] | None` | Custom output type to use for this run, output_type may only be used if the agent has no output validators since output validators would expect an argument that matches the agent's output type. | `None` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` | | `deferred_tool_results` | `DeferredToolResults | None` | Optional results for deferred tool calls in the message history. | `None` | | `model` | `Model | KnownModelName | str | None` | Optional model to use for this run, required if model was not set when creating the agent. | `None` | | `instructions` | `Instructions[AgentDepsT]` | Optional additional instructions to use for this run. | `None` | | `deps` | `AgentDepsT` | Optional dependencies to use for this run. | `None` | | `model_settings` | `ModelSettings | None` | Optional settings to use for this model's request. | `None` | | `usage_limits` | `UsageLimits | None` | Optional limits on model request count or token usage. | `None` | | `usage` | `RunUsage | None` | Optional usage to start with, useful for resuming a conversation or agents used in tools. | `None` | | `infer_name` | `bool` | Whether to try to infer the agent name from the call frame if it's not set. | `True` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | None` | Optional additional toolsets for this run. | `None` | | `event_stream_handler` | `EventStreamHandler[AgentDepsT] | None` | Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run. | `None` | | `builtin_tools` | `Sequence[AbstractBuiltinTool] | None` | Optional additional builtin tools for this run. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AgentRunResult[Any]` | The result of the run. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\nasync def run(\n    self,\n    user_prompt: str | Sequence[_messages.UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n    deferred_tool_results: DeferredToolResults | None = None,\n    model: models.Model | models.KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: _usage.UsageLimits | None = None,\n    usage: _usage.RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n) -> AgentRunResult[Any]:\n    \"\"\"Run the agent with a user prompt in async mode.\n\n    This method builds an internal agent graph (using system prompts, tools and output schemas) and then\n    runs the graph to completion. The result of the run is returned.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n\n    async def main():\n        agent_run = await agent.run('What is the capital of France?')\n        print(agent_run.output)\n        #> The capital of France is Paris.\n    ```\n\n    Args:\n        user_prompt: User input to start/continue the conversation.\n        output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n            output validators since output validators would expect an argument that matches the agent's output type.\n        message_history: History of the conversation so far.\n        deferred_tool_results: Optional results for deferred tool calls in the message history.\n        model: Optional model to use for this run, required if `model` was not set when creating the agent.\n        instructions: Optional additional instructions to use for this run.\n        deps: Optional dependencies to use for this run.\n        model_settings: Optional settings to use for this model's request.\n        usage_limits: Optional limits on model request count or token usage.\n        usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n        infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n        toolsets: Optional additional toolsets for this run.\n        event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run.\n        builtin_tools: Optional additional builtin tools for this run.\n\n    Returns:\n        The result of the run.\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n\n    event_stream_handler = event_stream_handler or self.event_stream_handler\n\n    async with self.iter(\n        user_prompt=user_prompt,\n        output_type=output_type,\n        message_history=message_history,\n        deferred_tool_results=deferred_tool_results,\n        model=model,\n        instructions=instructions,\n        deps=deps,\n        model_settings=model_settings,\n        usage_limits=usage_limits,\n        usage=usage,\n        toolsets=toolsets,\n        builtin_tools=builtin_tools,\n    ) as agent_run:\n        async for node in agent_run:\n            if event_stream_handler is not None and (\n                self.is_model_request_node(node) or self.is_call_tools_node(node)\n            ):\n                async with node.stream(agent_run.ctx) as stream:\n                    await event_stream_handler(_agent_graph.build_run_context(agent_run.ctx), stream)\n\n    assert agent_run.result is not None, 'The graph run did not finish properly'\n    return agent_run.result\n\n````\n\n#### run_sync\n\n```python\nrun_sync(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> AgentRunResult[OutputDataT]\n\n```\n\n```python\nrun_sync(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT],\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> AgentRunResult[RunOutputDataT]\n\n```\n\n```python\nrun_sync(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> AgentRunResult[Any]\n\n```\n\nSynchronously run the agent with a user prompt.\n\nThis is a convenience method that wraps self.run with `loop.run_until_complete(...)`. You therefore can't use this method inside async code or if there's an active event loop.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\n\nresult_sync = agent.run_sync('What is the capital of Italy?')\nprint(result_sync.output)\n#> The capital of Italy is Rome.\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `user_prompt` | `str | Sequence[UserContent] | None` | User input to start/continue the conversation. | `None` | | `output_type` | `OutputSpec[RunOutputDataT] | None` | Custom output type to use for this run, output_type may only be used if the agent has no output validators since output validators would expect an argument that matches the agent's output type. | `None` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` | | `deferred_tool_results` | `DeferredToolResults | None` | Optional results for deferred tool calls in the message history. | `None` | | `model` | `Model | KnownModelName | str | None` | Optional model to use for this run, required if model was not set when creating the agent. | `None` | | `instructions` | `Instructions[AgentDepsT]` | Optional additional instructions to use for this run. | `None` | | `deps` | `AgentDepsT` | Optional dependencies to use for this run. | `None` | | `model_settings` | `ModelSettings | None` | Optional settings to use for this model's request. | `None` | | `usage_limits` | `UsageLimits | None` | Optional limits on model request count or token usage. | `None` | | `usage` | `RunUsage | None` | Optional usage to start with, useful for resuming a conversation or agents used in tools. | `None` | | `infer_name` | `bool` | Whether to try to infer the agent name from the call frame if it's not set. | `True` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | None` | Optional additional toolsets for this run. | `None` | | `event_stream_handler` | `EventStreamHandler[AgentDepsT] | None` | Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run. | `None` | | `builtin_tools` | `Sequence[AbstractBuiltinTool] | None` | Optional additional builtin tools for this run. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AgentRunResult[Any]` | The result of the run. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\ndef run_sync(\n    self,\n    user_prompt: str | Sequence[_messages.UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n    deferred_tool_results: DeferredToolResults | None = None,\n    model: models.Model | models.KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: _usage.UsageLimits | None = None,\n    usage: _usage.RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n) -> AgentRunResult[Any]:\n    \"\"\"Synchronously run the agent with a user prompt.\n\n    This is a convenience method that wraps [`self.run`][pydantic_ai.agent.AbstractAgent.run] with `loop.run_until_complete(...)`.\n    You therefore can't use this method inside async code or if there's an active event loop.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n\n    result_sync = agent.run_sync('What is the capital of Italy?')\n    print(result_sync.output)\n    #> The capital of Italy is Rome.\n    ```\n\n    Args:\n        user_prompt: User input to start/continue the conversation.\n        output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n            output validators since output validators would expect an argument that matches the agent's output type.\n        message_history: History of the conversation so far.\n        deferred_tool_results: Optional results for deferred tool calls in the message history.\n        model: Optional model to use for this run, required if `model` was not set when creating the agent.\n        instructions: Optional additional instructions to use for this run.\n        deps: Optional dependencies to use for this run.\n        model_settings: Optional settings to use for this model's request.\n        usage_limits: Optional limits on model request count or token usage.\n        usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n        infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n        toolsets: Optional additional toolsets for this run.\n        event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run.\n        builtin_tools: Optional additional builtin tools for this run.\n\n    Returns:\n        The result of the run.\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n\n    return _utils.get_event_loop().run_until_complete(\n        self.run(\n            user_prompt,\n            output_type=output_type,\n            message_history=message_history,\n            deferred_tool_results=deferred_tool_results,\n            model=model,\n            instructions=instructions,\n            deps=deps,\n            model_settings=model_settings,\n            usage_limits=usage_limits,\n            usage=usage,\n            infer_name=False,\n            toolsets=toolsets,\n            builtin_tools=builtin_tools,\n            event_stream_handler=event_stream_handler,\n        )\n    )\n\n````\n\n#### run_stream\n\n```python\nrun_stream(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> AbstractAsyncContextManager[\n    StreamedRunResult[AgentDepsT, OutputDataT]\n]\n\n```\n\n```python\nrun_stream(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT],\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> AbstractAsyncContextManager[\n    StreamedRunResult[AgentDepsT, RunOutputDataT]\n]\n\n```\n\n```python\nrun_stream(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> AsyncIterator[StreamedRunResult[AgentDepsT, Any]]\n\n```\n\nRun the agent with a user prompt in async streaming mode.\n\nThis method builds an internal agent graph (using system prompts, tools and output schemas) and then runs the graph until the model produces output matching the `output_type`, for example text or structured data. At this point, a streaming run result object is yielded from which you can stream the output as it comes in, and -- once this output has completed streaming -- get the complete output, message history, and usage.\n\nAs this method will consider the first output matching the `output_type` to be the final output, it will stop running the agent graph and will not execute any tool calls made by the model after this \"final\" output. If you want to always run the agent graph to completion and stream events and output at the same time, use agent.run() with an `event_stream_handler` or agent.iter() instead.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\n\nasync def main():\n    async with agent.run_stream('What is the capital of the UK?') as response:\n        print(await response.get_output())\n        #> The capital of the UK is London.\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `user_prompt` | `str | Sequence[UserContent] | None` | User input to start/continue the conversation. | `None` | | `output_type` | `OutputSpec[RunOutputDataT] | None` | Custom output type to use for this run, output_type may only be used if the agent has no output validators since output validators would expect an argument that matches the agent's output type. | `None` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` | | `deferred_tool_results` | `DeferredToolResults | None` | Optional results for deferred tool calls in the message history. | `None` | | `model` | `Model | KnownModelName | str | None` | Optional model to use for this run, required if model was not set when creating the agent. | `None` | | `instructions` | `Instructions[AgentDepsT]` | Optional additional instructions to use for this run. | `None` | | `deps` | `AgentDepsT` | Optional dependencies to use for this run. | `None` | | `model_settings` | `ModelSettings | None` | Optional settings to use for this model's request. | `None` | | `usage_limits` | `UsageLimits | None` | Optional limits on model request count or token usage. | `None` | | `usage` | `RunUsage | None` | Optional usage to start with, useful for resuming a conversation or agents used in tools. | `None` | | `infer_name` | `bool` | Whether to try to infer the agent name from the call frame if it's not set. | `True` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | None` | Optional additional toolsets for this run. | `None` | | `builtin_tools` | `Sequence[AbstractBuiltinTool] | None` | Optional additional builtin tools for this run. | `None` | | `event_stream_handler` | `EventStreamHandler[AgentDepsT] | None` | Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run. It will receive all the events up until the final result is found, which you can then read or stream from inside the context manager. Note that it does not receive any events after the final result is found. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AsyncIterator[StreamedRunResult[AgentDepsT, Any]]` | The result of the run. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\n@asynccontextmanager\nasync def run_stream(  # noqa: C901\n    self,\n    user_prompt: str | Sequence[_messages.UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n    deferred_tool_results: DeferredToolResults | None = None,\n    model: models.Model | models.KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: _usage.UsageLimits | None = None,\n    usage: _usage.RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n) -> AsyncIterator[result.StreamedRunResult[AgentDepsT, Any]]:\n    \"\"\"Run the agent with a user prompt in async streaming mode.\n\n    This method builds an internal agent graph (using system prompts, tools and output schemas) and then\n    runs the graph until the model produces output matching the `output_type`, for example text or structured data.\n    At this point, a streaming run result object is yielded from which you can stream the output as it comes in,\n    and -- once this output has completed streaming -- get the complete output, message history, and usage.\n\n    As this method will consider the first output matching the `output_type` to be the final output,\n    it will stop running the agent graph and will not execute any tool calls made by the model after this \"final\" output.\n    If you want to always run the agent graph to completion and stream events and output at the same time,\n    use [`agent.run()`][pydantic_ai.agent.AbstractAgent.run] with an `event_stream_handler` or [`agent.iter()`][pydantic_ai.agent.AbstractAgent.iter] instead.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n\n    async def main():\n        async with agent.run_stream('What is the capital of the UK?') as response:\n            print(await response.get_output())\n            #> The capital of the UK is London.\n    ```\n\n    Args:\n        user_prompt: User input to start/continue the conversation.\n        output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n            output validators since output validators would expect an argument that matches the agent's output type.\n        message_history: History of the conversation so far.\n        deferred_tool_results: Optional results for deferred tool calls in the message history.\n        model: Optional model to use for this run, required if `model` was not set when creating the agent.\n        instructions: Optional additional instructions to use for this run.\n        deps: Optional dependencies to use for this run.\n        model_settings: Optional settings to use for this model's request.\n        usage_limits: Optional limits on model request count or token usage.\n        usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n        infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n        toolsets: Optional additional toolsets for this run.\n        builtin_tools: Optional additional builtin tools for this run.\n        event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run.\n            It will receive all the events up until the final result is found, which you can then read or stream from inside the context manager.\n            Note that it does _not_ receive any events after the final result is found.\n\n    Returns:\n        The result of the run.\n    \"\"\"\n    if infer_name and self.name is None:\n        # f_back because `asynccontextmanager` adds one frame\n        if frame := inspect.currentframe():  # pragma: no branch\n            self._infer_name(frame.f_back)\n\n    event_stream_handler = event_stream_handler or self.event_stream_handler\n\n    yielded = False\n    async with self.iter(\n        user_prompt,\n        output_type=output_type,\n        message_history=message_history,\n        deferred_tool_results=deferred_tool_results,\n        model=model,\n        deps=deps,\n        instructions=instructions,\n        model_settings=model_settings,\n        usage_limits=usage_limits,\n        usage=usage,\n        infer_name=False,\n        toolsets=toolsets,\n        builtin_tools=builtin_tools,\n    ) as agent_run:\n        first_node = agent_run.next_node  # start with the first node\n        assert isinstance(first_node, _agent_graph.UserPromptNode)  # the first node should be a user prompt node\n        node = first_node\n        while True:\n            graph_ctx = agent_run.ctx\n            if self.is_model_request_node(node):\n                async with node.stream(graph_ctx) as stream:\n                    final_result_event = None\n\n                    async def stream_to_final(\n                        stream: AgentStream,\n                    ) -> AsyncIterator[_messages.ModelResponseStreamEvent]:\n                        nonlocal final_result_event\n                        async for event in stream:\n                            yield event\n                            if isinstance(event, _messages.FinalResultEvent):\n                                final_result_event = event\n                                break\n\n                    if event_stream_handler is not None:\n                        await event_stream_handler(\n                            _agent_graph.build_run_context(graph_ctx), stream_to_final(stream)\n                        )\n                    else:\n                        async for _ in stream_to_final(stream):\n                            pass\n\n                    if final_result_event is not None:\n                        final_result = FinalResult(\n                            None, final_result_event.tool_name, final_result_event.tool_call_id\n                        )\n                        if yielded:\n                            raise exceptions.AgentRunError('Agent run produced final results')  # pragma: no cover\n                        yielded = True\n\n                        messages = graph_ctx.state.message_history.copy()\n\n                        async def on_complete() -> None:\n                            \"\"\"Called when the stream has completed.\n\n                            The model response will have been added to messages by now\n                            by `StreamedRunResult._marked_completed`.\n                            \"\"\"\n                            nonlocal final_result\n                            final_result = FinalResult(\n                                await stream.get_output(), final_result.tool_name, final_result.tool_call_id\n                            )\n\n                            # When we get here, the `ModelRequestNode` has completed streaming after the final result was found.\n                            # When running an agent with `agent.run`, we'd then move to `CallToolsNode` to execute the tool calls and\n                            # find the final result.\n                            # We also want to execute tool calls (in case `agent.end_strategy == 'exhaustive'`) here, but\n                            # we don't want to use run the `CallToolsNode` logic to determine the final output, as it would be\n                            # wasteful and could produce a different result (e.g. when text output is followed by tool calls).\n                            # So we call `process_tool_calls` directly and then end the run with the found final result.\n\n                            parts: list[_messages.ModelRequestPart] = []\n                            async for _event in _agent_graph.process_tool_calls(\n                                tool_manager=graph_ctx.deps.tool_manager,\n                                tool_calls=stream.response.tool_calls,\n                                tool_call_results=None,\n                                final_result=final_result,\n                                ctx=graph_ctx,\n                                output_parts=parts,\n                            ):\n                                pass\n\n                            # For backwards compatibility, append a new ModelRequest using the tool returns and retries\n                            if parts:\n                                messages.append(_messages.ModelRequest(parts, run_id=graph_ctx.state.run_id))\n\n                            await agent_run.next(_agent_graph.SetFinalResult(final_result))\n\n                        yield StreamedRunResult(\n                            messages,\n                            graph_ctx.deps.new_message_index,\n                            stream,\n                            on_complete,\n                        )\n                        break\n            elif self.is_call_tools_node(node) and event_stream_handler is not None:\n                async with node.stream(agent_run.ctx) as stream:\n                    await event_stream_handler(_agent_graph.build_run_context(agent_run.ctx), stream)\n\n            next_node = await agent_run.next(node)\n            if isinstance(next_node, End) and agent_run.result is not None:\n                # A final output could have been produced by the CallToolsNode rather than the ModelRequestNode,\n                # if a tool function raised CallDeferred or ApprovalRequired.\n                # In this case there's no response to stream, but we still let the user access the output etc as normal.\n                yield StreamedRunResult(\n                    graph_ctx.state.message_history,\n                    graph_ctx.deps.new_message_index,\n                    run_result=agent_run.result,\n                )\n                yielded = True\n                break\n            if not isinstance(next_node, _agent_graph.AgentNode):\n                raise exceptions.AgentRunError(  # pragma: no cover\n                    'Should have produced a StreamedRunResult before getting here'\n                )\n            node = cast(_agent_graph.AgentNode[Any, Any], next_node)\n\n    if not yielded:\n        raise exceptions.AgentRunError('Agent run finished without producing a final result')  # pragma: no cover\n\n````\n\n#### run_stream_sync\n\n```python\nrun_stream_sync(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> StreamedRunResultSync[AgentDepsT, OutputDataT]\n\n```\n\n```python\nrun_stream_sync(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT],\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> StreamedRunResultSync[AgentDepsT, RunOutputDataT]\n\n```\n\n```python\nrun_stream_sync(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None,\n    event_stream_handler: (\n        EventStreamHandler[AgentDepsT] | None\n    ) = None\n) -> StreamedRunResultSync[AgentDepsT, Any]\n\n```\n\nRun the agent with a user prompt in sync streaming mode.\n\nThis is a convenience method that wraps run_stream() with `loop.run_until_complete(...)`. You therefore can't use this method inside async code or if there's an active event loop.\n\nThis method builds an internal agent graph (using system prompts, tools and output schemas) and then runs the graph until the model produces output matching the `output_type`, for example text or structured data. At this point, a streaming run result object is yielded from which you can stream the output as it comes in, and -- once this output has completed streaming -- get the complete output, message history, and usage.\n\nAs this method will consider the first output matching the `output_type` to be the final output, it will stop running the agent graph and will not execute any tool calls made by the model after this \"final\" output. If you want to always run the agent graph to completion and stream events and output at the same time, use agent.run() with an `event_stream_handler` or agent.iter() instead.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\n\ndef main():\n    response = agent.run_stream_sync('What is the capital of the UK?')\n    print(response.get_output())\n    #> The capital of the UK is London.\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `user_prompt` | `str | Sequence[UserContent] | None` | User input to start/continue the conversation. | `None` | | `output_type` | `OutputSpec[RunOutputDataT] | None` | Custom output type to use for this run, output_type may only be used if the agent has no output validators since output validators would expect an argument that matches the agent's output type. | `None` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` | | `deferred_tool_results` | `DeferredToolResults | None` | Optional results for deferred tool calls in the message history. | `None` | | `model` | `Model | KnownModelName | str | None` | Optional model to use for this run, required if model was not set when creating the agent. | `None` | | `deps` | `AgentDepsT` | Optional dependencies to use for this run. | `None` | | `model_settings` | `ModelSettings | None` | Optional settings to use for this model's request. | `None` | | `usage_limits` | `UsageLimits | None` | Optional limits on model request count or token usage. | `None` | | `usage` | `RunUsage | None` | Optional usage to start with, useful for resuming a conversation or agents used in tools. | `None` | | `infer_name` | `bool` | Whether to try to infer the agent name from the call frame if it's not set. | `True` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | None` | Optional additional toolsets for this run. | `None` | | `builtin_tools` | `Sequence[AbstractBuiltinTool] | None` | Optional additional builtin tools for this run. | `None` | | `event_stream_handler` | `EventStreamHandler[AgentDepsT] | None` | Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run. It will receive all the events up until the final result is found, which you can then read or stream from inside the context manager. Note that it does not receive any events after the final result is found. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `StreamedRunResultSync[AgentDepsT, Any]` | The result of the run. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\ndef run_stream_sync(\n    self,\n    user_prompt: str | Sequence[_messages.UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n    deferred_tool_results: DeferredToolResults | None = None,\n    model: models.Model | models.KnownModelName | str | None = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: _usage.UsageLimits | None = None,\n    usage: _usage.RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    event_stream_handler: EventStreamHandler[AgentDepsT] | None = None,\n) -> result.StreamedRunResultSync[AgentDepsT, Any]:\n    \"\"\"Run the agent with a user prompt in sync streaming mode.\n\n    This is a convenience method that wraps [`run_stream()`][pydantic_ai.agent.AbstractAgent.run_stream] with `loop.run_until_complete(...)`.\n    You therefore can't use this method inside async code or if there's an active event loop.\n\n    This method builds an internal agent graph (using system prompts, tools and output schemas) and then\n    runs the graph until the model produces output matching the `output_type`, for example text or structured data.\n    At this point, a streaming run result object is yielded from which you can stream the output as it comes in,\n    and -- once this output has completed streaming -- get the complete output, message history, and usage.\n\n    As this method will consider the first output matching the `output_type` to be the final output,\n    it will stop running the agent graph and will not execute any tool calls made by the model after this \"final\" output.\n    If you want to always run the agent graph to completion and stream events and output at the same time,\n    use [`agent.run()`][pydantic_ai.agent.AbstractAgent.run] with an `event_stream_handler` or [`agent.iter()`][pydantic_ai.agent.AbstractAgent.iter] instead.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n\n    def main():\n        response = agent.run_stream_sync('What is the capital of the UK?')\n        print(response.get_output())\n        #> The capital of the UK is London.\n    ```\n\n    Args:\n        user_prompt: User input to start/continue the conversation.\n        output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n            output validators since output validators would expect an argument that matches the agent's output type.\n        message_history: History of the conversation so far.\n        deferred_tool_results: Optional results for deferred tool calls in the message history.\n        model: Optional model to use for this run, required if `model` was not set when creating the agent.\n        deps: Optional dependencies to use for this run.\n        model_settings: Optional settings to use for this model's request.\n        usage_limits: Optional limits on model request count or token usage.\n        usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n        infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n        toolsets: Optional additional toolsets for this run.\n        builtin_tools: Optional additional builtin tools for this run.\n        event_stream_handler: Optional handler for events from the model's streaming response and the agent's execution of tools to use for this run.\n            It will receive all the events up until the final result is found, which you can then read or stream from inside the context manager.\n            Note that it does _not_ receive any events after the final result is found.\n\n    Returns:\n        The result of the run.\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n\n    async def _consume_stream():\n        async with self.run_stream(\n            user_prompt,\n            output_type=output_type,\n            message_history=message_history,\n            deferred_tool_results=deferred_tool_results,\n            model=model,\n            deps=deps,\n            model_settings=model_settings,\n            usage_limits=usage_limits,\n            usage=usage,\n            infer_name=infer_name,\n            toolsets=toolsets,\n            builtin_tools=builtin_tools,\n            event_stream_handler=event_stream_handler,\n        ) as stream_result:\n            yield stream_result\n\n    async_result = _utils.get_event_loop().run_until_complete(anext(_consume_stream()))\n    return result.StreamedRunResultSync(async_result)\n\n````\n\n#### run_stream_events\n\n```python\nrun_stream_events(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AsyncIterator[\n    AgentStreamEvent | AgentRunResultEvent[OutputDataT]\n]\n\n```\n\n```python\nrun_stream_events(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT],\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AsyncIterator[\n    AgentStreamEvent | AgentRunResultEvent[RunOutputDataT]\n]\n\n```\n\n```python\nrun_stream_events(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AsyncIterator[\n    AgentStreamEvent | AgentRunResultEvent[Any]\n]\n\n```\n\nRun the agent with a user prompt in async mode and stream events from the run.\n\nThis is a convenience method that wraps self.run and uses the `event_stream_handler` kwarg to get a stream of events from the run.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent, AgentRunResultEvent, AgentStreamEvent\n\nagent = Agent('openai:gpt-4o')\n\nasync def main():\n    events: list[AgentStreamEvent | AgentRunResultEvent] = []\n    async for event in agent.run_stream_events('What is the capital of France?'):\n        events.append(event)\n    print(events)\n    '''\n    [\n        PartStartEvent(index=0, part=TextPart(content='The capital of ')),\n        FinalResultEvent(tool_name=None, tool_call_id=None),\n        PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='France is Paris. ')),\n        PartEndEvent(\n            index=0, part=TextPart(content='The capital of France is Paris. ')\n        ),\n        AgentRunResultEvent(\n            result=AgentRunResult(output='The capital of France is Paris. ')\n        ),\n    ]\n    '''\n\n```\n\nArguments are the same as for self.run, except that `event_stream_handler` is now allowed.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `user_prompt` | `str | Sequence[UserContent] | None` | User input to start/continue the conversation. | `None` | | `output_type` | `OutputSpec[RunOutputDataT] | None` | Custom output type to use for this run, output_type may only be used if the agent has no output validators since output validators would expect an argument that matches the agent's output type. | `None` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` | | `deferred_tool_results` | `DeferredToolResults | None` | Optional results for deferred tool calls in the message history. | `None` | | `model` | `Model | KnownModelName | str | None` | Optional model to use for this run, required if model was not set when creating the agent. | `None` | | `instructions` | `Instructions[AgentDepsT]` | Optional additional instructions to use for this run. | `None` | | `deps` | `AgentDepsT` | Optional dependencies to use for this run. | `None` | | `model_settings` | `ModelSettings | None` | Optional settings to use for this model's request. | `None` | | `usage_limits` | `UsageLimits | None` | Optional limits on model request count or token usage. | `None` | | `usage` | `RunUsage | None` | Optional usage to start with, useful for resuming a conversation or agents used in tools. | `None` | | `infer_name` | `bool` | Whether to try to infer the agent name from the call frame if it's not set. | `True` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | None` | Optional additional toolsets for this run. | `None` | | `builtin_tools` | `Sequence[AbstractBuiltinTool] | None` | Optional additional builtin tools for this run. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AsyncIterator[AgentStreamEvent | AgentRunResultEvent[Any]]` | An async iterable of stream events AgentStreamEvent and finally a AgentRunResultEvent with the final | | `AsyncIterator[AgentStreamEvent | AgentRunResultEvent[Any]]` | run result. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\ndef run_stream_events(\n    self,\n    user_prompt: str | Sequence[_messages.UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n    deferred_tool_results: DeferredToolResults | None = None,\n    model: models.Model | models.KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: _usage.UsageLimits | None = None,\n    usage: _usage.RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n) -> AsyncIterator[_messages.AgentStreamEvent | AgentRunResultEvent[Any]]:\n    \"\"\"Run the agent with a user prompt in async mode and stream events from the run.\n\n    This is a convenience method that wraps [`self.run`][pydantic_ai.agent.AbstractAgent.run] and\n    uses the `event_stream_handler` kwarg to get a stream of events from the run.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent, AgentRunResultEvent, AgentStreamEvent\n\n    agent = Agent('openai:gpt-4o')\n\n    async def main():\n        events: list[AgentStreamEvent | AgentRunResultEvent] = []\n        async for event in agent.run_stream_events('What is the capital of France?'):\n            events.append(event)\n        print(events)\n        '''\n        [\n            PartStartEvent(index=0, part=TextPart(content='The capital of ')),\n            FinalResultEvent(tool_name=None, tool_call_id=None),\n            PartDeltaEvent(index=0, delta=TextPartDelta(content_delta='France is Paris. ')),\n            PartEndEvent(\n                index=0, part=TextPart(content='The capital of France is Paris. ')\n            ),\n            AgentRunResultEvent(\n                result=AgentRunResult(output='The capital of France is Paris. ')\n            ),\n        ]\n        '''\n    ```\n\n    Arguments are the same as for [`self.run`][pydantic_ai.agent.AbstractAgent.run],\n    except that `event_stream_handler` is now allowed.\n\n    Args:\n        user_prompt: User input to start/continue the conversation.\n        output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n            output validators since output validators would expect an argument that matches the agent's output type.\n        message_history: History of the conversation so far.\n        deferred_tool_results: Optional results for deferred tool calls in the message history.\n        model: Optional model to use for this run, required if `model` was not set when creating the agent.\n        instructions: Optional additional instructions to use for this run.\n        deps: Optional dependencies to use for this run.\n        model_settings: Optional settings to use for this model's request.\n        usage_limits: Optional limits on model request count or token usage.\n        usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n        infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n        toolsets: Optional additional toolsets for this run.\n        builtin_tools: Optional additional builtin tools for this run.\n\n    Returns:\n        An async iterable of stream events `AgentStreamEvent` and finally a `AgentRunResultEvent` with the final\n        run result.\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n\n    # unfortunately this hack of returning a generator rather than defining it right here is\n    # required to allow overloads of this method to work in python's typing system, or at least with pyright\n    # or at least I couldn't make it work without\n    return self._run_stream_events(\n        user_prompt,\n        output_type=output_type,\n        message_history=message_history,\n        deferred_tool_results=deferred_tool_results,\n        model=model,\n        instructions=instructions,\n        deps=deps,\n        model_settings=model_settings,\n        usage_limits=usage_limits,\n        usage=usage,\n        toolsets=toolsets,\n        builtin_tools=builtin_tools,\n    )\n\n````\n\n#### iter\n\n```python\niter(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AbstractAsyncContextManager[\n    AgentRun[AgentDepsT, OutputDataT]\n]\n\n```\n\n```python\niter(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT],\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AbstractAsyncContextManager[\n    AgentRun[AgentDepsT, RunOutputDataT]\n]\n\n```\n\n```python\niter(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AsyncIterator[AgentRun[AgentDepsT, Any]]\n\n```\n\nA contextmanager which can be used to iterate over the agent graph's nodes as they are executed.\n\nThis method builds an internal agent graph (using system prompts, tools and output schemas) and then returns an `AgentRun` object. The `AgentRun` can be used to async-iterate over the nodes of the graph as they are executed. This is the API to use if you want to consume the outputs coming from each LLM model response, or the stream of events coming from the execution of tools.\n\nThe `AgentRun` also provides methods to access the full message history, new messages, and usage statistics, and the final result of the run once it has completed.\n\nFor more details, see the documentation of `AgentRun`.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\n\nasync def main():\n    nodes = []\n    async with agent.iter('What is the capital of France?') as agent_run:\n        async for node in agent_run:\n            nodes.append(node)\n    print(nodes)\n    '''\n    [\n        UserPromptNode(\n            user_prompt='What is the capital of France?',\n            instructions_functions=[],\n            system_prompts=(),\n            system_prompt_functions=[],\n            system_prompt_dynamic_functions={},\n        ),\n        ModelRequestNode(\n            request=ModelRequest(\n                parts=[\n                    UserPromptPart(\n                        content='What is the capital of France?',\n                        timestamp=datetime.datetime(...),\n                    )\n                ],\n                run_id='...',\n            )\n        ),\n        CallToolsNode(\n            model_response=ModelResponse(\n                parts=[TextPart(content='The capital of France is Paris.')],\n                usage=RequestUsage(input_tokens=56, output_tokens=7),\n                model_name='gpt-4o',\n                timestamp=datetime.datetime(...),\n                run_id='...',\n            )\n        ),\n        End(data=FinalResult(output='The capital of France is Paris.')),\n    ]\n    '''\n    print(agent_run.result.output)\n    #> The capital of France is Paris.\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `user_prompt` | `str | Sequence[UserContent] | None` | User input to start/continue the conversation. | `None` | | `output_type` | `OutputSpec[RunOutputDataT] | None` | Custom output type to use for this run, output_type may only be used if the agent has no output validators since output validators would expect an argument that matches the agent's output type. | `None` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` | | `deferred_tool_results` | `DeferredToolResults | None` | Optional results for deferred tool calls in the message history. | `None` | | `model` | `Model | KnownModelName | str | None` | Optional model to use for this run, required if model was not set when creating the agent. | `None` | | `instructions` | `Instructions[AgentDepsT]` | Optional additional instructions to use for this run. | `None` | | `deps` | `AgentDepsT` | Optional dependencies to use for this run. | `None` | | `model_settings` | `ModelSettings | None` | Optional settings to use for this model's request. | `None` | | `usage_limits` | `UsageLimits | None` | Optional limits on model request count or token usage. | `None` | | `usage` | `RunUsage | None` | Optional usage to start with, useful for resuming a conversation or agents used in tools. | `None` | | `infer_name` | `bool` | Whether to try to infer the agent name from the call frame if it's not set. | `True` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | None` | Optional additional toolsets for this run. | `None` | | `builtin_tools` | `Sequence[AbstractBuiltinTool] | None` | Optional additional builtin tools for this run. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AsyncIterator[AgentRun[AgentDepsT, Any]]` | The result of the run. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\n@asynccontextmanager\n@abstractmethod\nasync def iter(\n    self,\n    user_prompt: str | Sequence[_messages.UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n    deferred_tool_results: DeferredToolResults | None = None,\n    model: models.Model | models.KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: _usage.UsageLimits | None = None,\n    usage: _usage.RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n) -> AsyncIterator[AgentRun[AgentDepsT, Any]]:\n    \"\"\"A contextmanager which can be used to iterate over the agent graph's nodes as they are executed.\n\n    This method builds an internal agent graph (using system prompts, tools and output schemas) and then returns an\n    `AgentRun` object. The `AgentRun` can be used to async-iterate over the nodes of the graph as they are\n    executed. This is the API to use if you want to consume the outputs coming from each LLM model response, or the\n    stream of events coming from the execution of tools.\n\n    The `AgentRun` also provides methods to access the full message history, new messages, and usage statistics,\n    and the final result of the run once it has completed.\n\n    For more details, see the documentation of `AgentRun`.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n\n    async def main():\n        nodes = []\n        async with agent.iter('What is the capital of France?') as agent_run:\n            async for node in agent_run:\n                nodes.append(node)\n        print(nodes)\n        '''\n        [\n            UserPromptNode(\n                user_prompt='What is the capital of France?',\n                instructions_functions=[],\n                system_prompts=(),\n                system_prompt_functions=[],\n                system_prompt_dynamic_functions={},\n            ),\n            ModelRequestNode(\n                request=ModelRequest(\n                    parts=[\n                        UserPromptPart(\n                            content='What is the capital of France?',\n                            timestamp=datetime.datetime(...),\n                        )\n                    ],\n                    run_id='...',\n                )\n            ),\n            CallToolsNode(\n                model_response=ModelResponse(\n                    parts=[TextPart(content='The capital of France is Paris.')],\n                    usage=RequestUsage(input_tokens=56, output_tokens=7),\n                    model_name='gpt-4o',\n                    timestamp=datetime.datetime(...),\n                    run_id='...',\n                )\n            ),\n            End(data=FinalResult(output='The capital of France is Paris.')),\n        ]\n        '''\n        print(agent_run.result.output)\n        #> The capital of France is Paris.\n    ```\n\n    Args:\n        user_prompt: User input to start/continue the conversation.\n        output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n            output validators since output validators would expect an argument that matches the agent's output type.\n        message_history: History of the conversation so far.\n        deferred_tool_results: Optional results for deferred tool calls in the message history.\n        model: Optional model to use for this run, required if `model` was not set when creating the agent.\n        instructions: Optional additional instructions to use for this run.\n        deps: Optional dependencies to use for this run.\n        model_settings: Optional settings to use for this model's request.\n        usage_limits: Optional limits on model request count or token usage.\n        usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n        infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n        toolsets: Optional additional toolsets for this run.\n        builtin_tools: Optional additional builtin tools for this run.\n\n    Returns:\n        The result of the run.\n    \"\"\"\n    raise NotImplementedError\n    yield\n\n````\n\n#### override\n\n```python\noverride(\n    *,\n    name: str | Unset = UNSET,\n    deps: AgentDepsT | Unset = UNSET,\n    model: Model | KnownModelName | str | Unset = UNSET,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | Unset\n    ) = UNSET,\n    tools: (\n        Sequence[\n            Tool[AgentDepsT]\n            | ToolFuncEither[AgentDepsT, ...]\n        ]\n        | Unset\n    ) = UNSET,\n    instructions: Instructions[AgentDepsT] | Unset = UNSET\n) -> Iterator[None]\n\n```\n\nContext manager to temporarily override agent name, dependencies, model, toolsets, tools, or instructions.\n\nThis is particularly useful when testing. You can find an example of this [here](../../testing/#overriding-model-via-pytest-fixtures).\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `name` | `str | Unset` | The name to use instead of the name passed to the agent constructor and agent run. | `UNSET` | | `deps` | `AgentDepsT | Unset` | The dependencies to use instead of the dependencies passed to the agent run. | `UNSET` | | `model` | `Model | KnownModelName | str | Unset` | The model to use instead of the model passed to the agent run. | `UNSET` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | Unset` | The toolsets to use instead of the toolsets passed to the agent constructor and agent run. | `UNSET` | | `tools` | `Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] | Unset` | The tools to use instead of the tools registered with the agent. | `UNSET` | | `instructions` | `Instructions[AgentDepsT] | Unset` | The instructions to use instead of the instructions registered with the agent. | `UNSET` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n```python\n@contextmanager\n@abstractmethod\ndef override(\n    self,\n    *,\n    name: str | _utils.Unset = _utils.UNSET,\n    deps: AgentDepsT | _utils.Unset = _utils.UNSET,\n    model: models.Model | models.KnownModelName | str | _utils.Unset = _utils.UNSET,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | _utils.Unset = _utils.UNSET,\n    tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] | _utils.Unset = _utils.UNSET,\n    instructions: Instructions[AgentDepsT] | _utils.Unset = _utils.UNSET,\n) -> Iterator[None]:\n    \"\"\"Context manager to temporarily override agent name, dependencies, model, toolsets, tools, or instructions.\n\n    This is particularly useful when testing.\n    You can find an example of this [here](../testing.md#overriding-model-via-pytest-fixtures).\n\n    Args:\n        name: The name to use instead of the name passed to the agent constructor and agent run.\n        deps: The dependencies to use instead of the dependencies passed to the agent run.\n        model: The model to use instead of the model passed to the agent run.\n        toolsets: The toolsets to use instead of the toolsets passed to the agent constructor and agent run.\n        tools: The tools to use instead of the tools registered with the agent.\n        instructions: The instructions to use instead of the instructions registered with the agent.\n    \"\"\"\n    raise NotImplementedError\n    yield\n\n```\n\n#### sequential_tool_calls\n\n```python\nsequential_tool_calls() -> Iterator[None]\n\n```\n\nRun tool calls sequentially during the context.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n```python\n@staticmethod\n@contextmanager\ndef sequential_tool_calls() -> Iterator[None]:\n    \"\"\"Run tool calls sequentially during the context.\"\"\"\n    with ToolManager.sequential_tool_calls():\n        yield\n\n```\n\n#### is_model_request_node\n\n```python\nis_model_request_node(\n    node: AgentNode[T, S] | End[FinalResult[S]],\n) -> TypeIs[ModelRequestNode[T, S]]\n\n```\n\nCheck if the node is a `ModelRequestNode`, narrowing the type if it is.\n\nThis method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n```python\n@staticmethod\ndef is_model_request_node(\n    node: _agent_graph.AgentNode[T, S] | End[result.FinalResult[S]],\n) -> TypeIs[_agent_graph.ModelRequestNode[T, S]]:\n    \"\"\"Check if the node is a `ModelRequestNode`, narrowing the type if it is.\n\n    This method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n    \"\"\"\n    return isinstance(node, _agent_graph.ModelRequestNode)\n\n```\n\n#### is_call_tools_node\n\n```python\nis_call_tools_node(\n    node: AgentNode[T, S] | End[FinalResult[S]],\n) -> TypeIs[CallToolsNode[T, S]]\n\n```\n\nCheck if the node is a `CallToolsNode`, narrowing the type if it is.\n\nThis method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n```python\n@staticmethod\ndef is_call_tools_node(\n    node: _agent_graph.AgentNode[T, S] | End[result.FinalResult[S]],\n) -> TypeIs[_agent_graph.CallToolsNode[T, S]]:\n    \"\"\"Check if the node is a `CallToolsNode`, narrowing the type if it is.\n\n    This method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n    \"\"\"\n    return isinstance(node, _agent_graph.CallToolsNode)\n\n```\n\n#### is_user_prompt_node\n\n```python\nis_user_prompt_node(\n    node: AgentNode[T, S] | End[FinalResult[S]],\n) -> TypeIs[UserPromptNode[T, S]]\n\n```\n\nCheck if the node is a `UserPromptNode`, narrowing the type if it is.\n\nThis method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n```python\n@staticmethod\ndef is_user_prompt_node(\n    node: _agent_graph.AgentNode[T, S] | End[result.FinalResult[S]],\n) -> TypeIs[_agent_graph.UserPromptNode[T, S]]:\n    \"\"\"Check if the node is a `UserPromptNode`, narrowing the type if it is.\n\n    This method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n    \"\"\"\n    return isinstance(node, _agent_graph.UserPromptNode)\n\n```\n\n#### is_end_node\n\n```python\nis_end_node(\n    node: AgentNode[T, S] | End[FinalResult[S]],\n) -> TypeIs[End[FinalResult[S]]]\n\n```\n\nCheck if the node is a `End`, narrowing the type if it is.\n\nThis method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n```python\n@staticmethod\ndef is_end_node(\n    node: _agent_graph.AgentNode[T, S] | End[result.FinalResult[S]],\n) -> TypeIs[End[result.FinalResult[S]]]:\n    \"\"\"Check if the node is a `End`, narrowing the type if it is.\n\n    This method preserves the generic parameters while narrowing the type, unlike a direct call to `isinstance`.\n    \"\"\"\n    return isinstance(node, End)\n\n```\n\n#### to_ag_ui\n\n```python\nto_ag_ui(\n    *,\n    output_type: OutputSpec[OutputDataT] | None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    debug: bool = False,\n    routes: Sequence[BaseRoute] | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    exception_handlers: (\n        Mapping[Any, ExceptionHandler] | None\n    ) = None,\n    on_startup: Sequence[Callable[[], Any]] | None = None,\n    on_shutdown: Sequence[Callable[[], Any]] | None = None,\n    lifespan: (\n        Lifespan[AGUIApp[AgentDepsT, OutputDataT]] | None\n    ) = None\n) -> AGUIApp[AgentDepsT, OutputDataT]\n\n```\n\nReturns an ASGI application that handles every AG-UI request by running the agent.\n\nNote that the `deps` will be the same for each request, with the exception of the AG-UI state that's injected into the `state` field of a `deps` object that implements the StateHandler protocol. To provide different `deps` for each request (e.g. based on the authenticated user), use pydantic_ai.ag_ui.run_ag_ui or pydantic_ai.ag_ui.handle_ag_ui_request instead.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\napp = agent.to_ag_ui()\n\n```\n\nThe `app` is an ASGI application that can be used with any ASGI server.\n\nTo run the application, you can use the following command:\n\n```bash\nuvicorn app:app --host 0.0.0.0 --port 8000\n\n```\n\nSee [AG-UI docs](../../ui/ag-ui/) for more information.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `output_type` | `OutputSpec[OutputDataT] | None` | Custom output type to use for this run, output_type may only be used if the agent has no output validators since output validators would expect an argument that matches the agent's output type. | `None` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` | | `deferred_tool_results` | `DeferredToolResults | None` | Optional results for deferred tool calls in the message history. | `None` | | `model` | `Model | KnownModelName | str | None` | Optional model to use for this run, required if model was not set when creating the agent. | `None` | | `deps` | `AgentDepsT` | Optional dependencies to use for this run. | `None` | | `model_settings` | `ModelSettings | None` | Optional settings to use for this model's request. | `None` | | `usage_limits` | `UsageLimits | None` | Optional limits on model request count or token usage. | `None` | | `usage` | `RunUsage | None` | Optional usage to start with, useful for resuming a conversation or agents used in tools. | `None` | | `infer_name` | `bool` | Whether to try to infer the agent name from the call frame if it's not set. | `True` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | None` | Optional additional toolsets for this run. | `None` | | `debug` | `bool` | Boolean indicating if debug tracebacks should be returned on errors. | `False` | | `routes` | `Sequence[BaseRoute] | None` | A list of routes to serve incoming HTTP and WebSocket requests. | `None` | | `middleware` | `Sequence[Middleware] | None` | A list of middleware to run for every request. A starlette application will always automatically include two middleware classes. ServerErrorMiddleware is added as the very outermost middleware, to handle any uncaught errors occurring anywhere in the entire stack. ExceptionMiddleware is added as the very innermost middleware, to deal with handled exception cases occurring in the routing or endpoints. | `None` | | `exception_handlers` | `Mapping[Any, ExceptionHandler] | None` | A mapping of either integer status codes, or exception class types onto callables which handle the exceptions. Exception handler callables should be of the form handler(request, exc) -> response and may be either standard functions, or async functions. | `None` | | `on_startup` | `Sequence[Callable[[], Any]] | None` | A list of callables to run on application startup. Startup handler callables do not take any arguments, and may be either standard functions, or async functions. | `None` | | `on_shutdown` | `Sequence[Callable[[], Any]] | None` | A list of callables to run on application shutdown. Shutdown handler callables do not take any arguments, and may be either standard functions, or async functions. | `None` | | `lifespan` | `Lifespan[AGUIApp[AgentDepsT, OutputDataT]] | None` | A lifespan context function, which can be used to perform startup and shutdown tasks. This is a newer style that replaces the on_startup and on_shutdown handlers. Use one or the other, not both. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AGUIApp[AgentDepsT, OutputDataT]` | An ASGI application for running Pydantic AI agents with AG-UI protocol support. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\ndef to_ag_ui(\n    self,\n    *,\n    # Agent.iter parameters\n    output_type: OutputSpec[OutputDataT] | None = None,\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n    deferred_tool_results: DeferredToolResults | None = None,\n    model: models.Model | models.KnownModelName | str | None = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    # Starlette\n    debug: bool = False,\n    routes: Sequence[BaseRoute] | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    exception_handlers: Mapping[Any, ExceptionHandler] | None = None,\n    on_startup: Sequence[Callable[[], Any]] | None = None,\n    on_shutdown: Sequence[Callable[[], Any]] | None = None,\n    lifespan: Lifespan[AGUIApp[AgentDepsT, OutputDataT]] | None = None,\n) -> AGUIApp[AgentDepsT, OutputDataT]:\n    \"\"\"Returns an ASGI application that handles every AG-UI request by running the agent.\n\n    Note that the `deps` will be the same for each request, with the exception of the AG-UI state that's\n    injected into the `state` field of a `deps` object that implements the [`StateHandler`][pydantic_ai.ag_ui.StateHandler] protocol.\n    To provide different `deps` for each request (e.g. based on the authenticated user),\n    use [`pydantic_ai.ag_ui.run_ag_ui`][pydantic_ai.ag_ui.run_ag_ui] or\n    [`pydantic_ai.ag_ui.handle_ag_ui_request`][pydantic_ai.ag_ui.handle_ag_ui_request] instead.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n    app = agent.to_ag_ui()\n    ```\n\n    The `app` is an ASGI application that can be used with any ASGI server.\n\n    To run the application, you can use the following command:\n\n    ```bash\n    uvicorn app:app --host 0.0.0.0 --port 8000\n    ```\n\n    See [AG-UI docs](../ui/ag-ui.md) for more information.\n\n    Args:\n        output_type: Custom output type to use for this run, `output_type` may only be used if the agent has\n            no output validators since output validators would expect an argument that matches the agent's\n            output type.\n        message_history: History of the conversation so far.\n        deferred_tool_results: Optional results for deferred tool calls in the message history.\n        model: Optional model to use for this run, required if `model` was not set when creating the agent.\n        deps: Optional dependencies to use for this run.\n        model_settings: Optional settings to use for this model's request.\n        usage_limits: Optional limits on model request count or token usage.\n        usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n        infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n        toolsets: Optional additional toolsets for this run.\n\n        debug: Boolean indicating if debug tracebacks should be returned on errors.\n        routes: A list of routes to serve incoming HTTP and WebSocket requests.\n        middleware: A list of middleware to run for every request. A starlette application will always\n            automatically include two middleware classes. `ServerErrorMiddleware` is added as the very\n            outermost middleware, to handle any uncaught errors occurring anywhere in the entire stack.\n            `ExceptionMiddleware` is added as the very innermost middleware, to deal with handled\n            exception cases occurring in the routing or endpoints.\n        exception_handlers: A mapping of either integer status codes, or exception class types onto\n            callables which handle the exceptions. Exception handler callables should be of the form\n            `handler(request, exc) -> response` and may be either standard functions, or async functions.\n        on_startup: A list of callables to run on application startup. Startup handler callables do not\n            take any arguments, and may be either standard functions, or async functions.\n        on_shutdown: A list of callables to run on application shutdown. Shutdown handler callables do\n            not take any arguments, and may be either standard functions, or async functions.\n        lifespan: A lifespan context function, which can be used to perform startup and shutdown tasks.\n            This is a newer style that replaces the `on_startup` and `on_shutdown` handlers. Use one or\n            the other, not both.\n\n    Returns:\n        An ASGI application for running Pydantic AI agents with AG-UI protocol support.\n    \"\"\"\n    from pydantic_ai.ui.ag_ui.app import AGUIApp\n\n    return AGUIApp(\n        agent=self,\n        # Agent.iter parameters\n        output_type=output_type,\n        message_history=message_history,\n        deferred_tool_results=deferred_tool_results,\n        model=model,\n        deps=deps,\n        model_settings=model_settings,\n        usage_limits=usage_limits,\n        usage=usage,\n        infer_name=infer_name,\n        toolsets=toolsets,\n        # Starlette\n        debug=debug,\n        routes=routes,\n        middleware=middleware,\n        exception_handlers=exception_handlers,\n        on_startup=on_startup,\n        on_shutdown=on_shutdown,\n        lifespan=lifespan,\n    )\n\n````\n\n#### to_a2a\n\n```python\nto_a2a(\n    *,\n    storage: Storage | None = None,\n    broker: Broker | None = None,\n    name: str | None = None,\n    url: str = \"http://localhost:8000\",\n    version: str = \"1.0.0\",\n    description: str | None = None,\n    provider: AgentProvider | None = None,\n    skills: list[Skill] | None = None,\n    debug: bool = False,\n    routes: Sequence[Route] | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    exception_handlers: (\n        dict[Any, ExceptionHandler] | None\n    ) = None,\n    lifespan: Lifespan[FastA2A] | None = None\n) -> FastA2A\n\n```\n\nConvert the agent to a FastA2A application.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\napp = agent.to_a2a()\n\n```\n\nThe `app` is an ASGI application that can be used with any ASGI server.\n\nTo run the application, you can use the following command:\n\n```bash\nuvicorn app:app --host 0.0.0.0 --port 8000\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\ndef to_a2a(\n    self,\n    *,\n    storage: Storage | None = None,\n    broker: Broker | None = None,\n    # Agent card\n    name: str | None = None,\n    url: str = 'http://localhost:8000',\n    version: str = '1.0.0',\n    description: str | None = None,\n    provider: AgentProvider | None = None,\n    skills: list[Skill] | None = None,\n    # Starlette\n    debug: bool = False,\n    routes: Sequence[Route] | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    exception_handlers: dict[Any, ExceptionHandler] | None = None,\n    lifespan: Lifespan[FastA2A] | None = None,\n) -> FastA2A:\n    \"\"\"Convert the agent to a FastA2A application.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n    app = agent.to_a2a()\n    ```\n\n    The `app` is an ASGI application that can be used with any ASGI server.\n\n    To run the application, you can use the following command:\n\n    ```bash\n    uvicorn app:app --host 0.0.0.0 --port 8000\n    ```\n    \"\"\"\n    from .._a2a import agent_to_a2a\n\n    return agent_to_a2a(\n        self,\n        storage=storage,\n        broker=broker,\n        name=name,\n        url=url,\n        version=version,\n        description=description,\n        provider=provider,\n        skills=skills,\n        debug=debug,\n        routes=routes,\n        middleware=middleware,\n        exception_handlers=exception_handlers,\n        lifespan=lifespan,\n    )\n\n````\n\n#### to_cli\n\n```python\nto_cli(\n    deps: AgentDepsT = None,\n    prog_name: str = \"pydantic-ai\",\n    message_history: Sequence[ModelMessage] | None = None,\n) -> None\n\n```\n\nRun the agent in a CLI chat interface.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `deps` | `AgentDepsT` | The dependencies to pass to the agent. | `None` | | `prog_name` | `str` | The name of the program to use for the CLI. Defaults to 'pydantic-ai'. | `'pydantic-ai'` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` |\n\nExample: agent_to_cli.py\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o', instructions='You always respond in Italian.')\n\nasync def main():\n    await agent.to_cli()\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\nasync def to_cli(\n    self: Self,\n    deps: AgentDepsT = None,\n    prog_name: str = 'pydantic-ai',\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n) -> None:\n    \"\"\"Run the agent in a CLI chat interface.\n\n    Args:\n        deps: The dependencies to pass to the agent.\n        prog_name: The name of the program to use for the CLI. Defaults to 'pydantic-ai'.\n        message_history: History of the conversation so far.\n\n    Example:\n    ```python {title=\"agent_to_cli.py\" test=\"skip\"}\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o', instructions='You always respond in Italian.')\n\n    async def main():\n        await agent.to_cli()\n    ```\n    \"\"\"\n    from rich.console import Console\n\n    from pydantic_ai._cli import run_chat\n\n    await run_chat(\n        stream=True,\n        agent=self,\n        deps=deps,\n        console=Console(),\n        code_theme='monokai',\n        prog_name=prog_name,\n        message_history=message_history,\n    )\n\n````\n\n#### to_cli_sync\n\n```python\nto_cli_sync(\n    deps: AgentDepsT = None,\n    prog_name: str = \"pydantic-ai\",\n    message_history: Sequence[ModelMessage] | None = None,\n) -> None\n\n```\n\nRun the agent in a CLI chat interface with the non-async interface.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `deps` | `AgentDepsT` | The dependencies to pass to the agent. | `None` | | `prog_name` | `str` | The name of the program to use for the CLI. Defaults to 'pydantic-ai'. | `'pydantic-ai'` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` |\n\nagent_to_cli_sync.py\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o', instructions='You always respond in Italian.')\nagent.to_cli_sync()\nagent.to_cli_sync(prog_name='assistant')\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/abstract.py`\n\n````python\ndef to_cli_sync(\n    self: Self,\n    deps: AgentDepsT = None,\n    prog_name: str = 'pydantic-ai',\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n) -> None:\n    \"\"\"Run the agent in a CLI chat interface with the non-async interface.\n\n    Args:\n        deps: The dependencies to pass to the agent.\n        prog_name: The name of the program to use for the CLI. Defaults to 'pydantic-ai'.\n        message_history: History of the conversation so far.\n\n    ```python {title=\"agent_to_cli_sync.py\" test=\"skip\"}\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o', instructions='You always respond in Italian.')\n    agent.to_cli_sync()\n    agent.to_cli_sync(prog_name='assistant')\n    ```\n    \"\"\"\n    return _utils.get_event_loop().run_until_complete(\n        self.to_cli(deps=deps, prog_name=prog_name, message_history=message_history)\n    )\n\n````\n\n### WrapperAgent\n\nBases: `AbstractAgent[AgentDepsT, OutputDataT]`\n\nAgent which wraps another agent.\n\nDoes nothing on its own, used as a base class.\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/wrapper.py`\n\n````python\nclass WrapperAgent(AbstractAgent[AgentDepsT, OutputDataT]):\n    \"\"\"Agent which wraps another agent.\n\n    Does nothing on its own, used as a base class.\n    \"\"\"\n\n    def __init__(self, wrapped: AbstractAgent[AgentDepsT, OutputDataT]):\n        self.wrapped = wrapped\n\n    @property\n    def model(self) -> models.Model | models.KnownModelName | str | None:\n        return self.wrapped.model\n\n    @property\n    def name(self) -> str | None:\n        return self.wrapped.name\n\n    @name.setter\n    def name(self, value: str | None) -> None:\n        self.wrapped.name = value\n\n    @property\n    def deps_type(self) -> type:\n        return self.wrapped.deps_type\n\n    @property\n    def output_type(self) -> OutputSpec[OutputDataT]:\n        return self.wrapped.output_type\n\n    @property\n    def event_stream_handler(self) -> EventStreamHandler[AgentDepsT] | None:\n        return self.wrapped.event_stream_handler\n\n    @property\n    def toolsets(self) -> Sequence[AbstractToolset[AgentDepsT]]:\n        return self.wrapped.toolsets\n\n    async def __aenter__(self) -> AbstractAgent[AgentDepsT, OutputDataT]:\n        return await self.wrapped.__aenter__()\n\n    async def __aexit__(self, *args: Any) -> bool | None:\n        return await self.wrapped.__aexit__(*args)\n\n    @overload\n    def iter(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AbstractAsyncContextManager[AgentRun[AgentDepsT, OutputDataT]]: ...\n\n    @overload\n    def iter(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT],\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AbstractAsyncContextManager[AgentRun[AgentDepsT, RunOutputDataT]]: ...\n\n    @asynccontextmanager\n    async def iter(\n        self,\n        user_prompt: str | Sequence[_messages.UserContent] | None = None,\n        *,\n        output_type: OutputSpec[RunOutputDataT] | None = None,\n        message_history: Sequence[_messages.ModelMessage] | None = None,\n        deferred_tool_results: DeferredToolResults | None = None,\n        model: models.Model | models.KnownModelName | str | None = None,\n        instructions: Instructions[AgentDepsT] = None,\n        deps: AgentDepsT = None,\n        model_settings: ModelSettings | None = None,\n        usage_limits: _usage.UsageLimits | None = None,\n        usage: _usage.RunUsage | None = None,\n        infer_name: bool = True,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n        builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n    ) -> AsyncIterator[AgentRun[AgentDepsT, Any]]:\n        \"\"\"A contextmanager which can be used to iterate over the agent graph's nodes as they are executed.\n\n        This method builds an internal agent graph (using system prompts, tools and output schemas) and then returns an\n        `AgentRun` object. The `AgentRun` can be used to async-iterate over the nodes of the graph as they are\n        executed. This is the API to use if you want to consume the outputs coming from each LLM model response, or the\n        stream of events coming from the execution of tools.\n\n        The `AgentRun` also provides methods to access the full message history, new messages, and usage statistics,\n        and the final result of the run once it has completed.\n\n        For more details, see the documentation of `AgentRun`.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n\n        agent = Agent('openai:gpt-4o')\n\n        async def main():\n            nodes = []\n            async with agent.iter('What is the capital of France?') as agent_run:\n                async for node in agent_run:\n                    nodes.append(node)\n            print(nodes)\n            '''\n            [\n                UserPromptNode(\n                    user_prompt='What is the capital of France?',\n                    instructions_functions=[],\n                    system_prompts=(),\n                    system_prompt_functions=[],\n                    system_prompt_dynamic_functions={},\n                ),\n                ModelRequestNode(\n                    request=ModelRequest(\n                        parts=[\n                            UserPromptPart(\n                                content='What is the capital of France?',\n                                timestamp=datetime.datetime(...),\n                            )\n                        ],\n                        run_id='...',\n                    )\n                ),\n                CallToolsNode(\n                    model_response=ModelResponse(\n                        parts=[TextPart(content='The capital of France is Paris.')],\n                        usage=RequestUsage(input_tokens=56, output_tokens=7),\n                        model_name='gpt-4o',\n                        timestamp=datetime.datetime(...),\n                        run_id='...',\n                    )\n                ),\n                End(data=FinalResult(output='The capital of France is Paris.')),\n            ]\n            '''\n            print(agent_run.result.output)\n            #> The capital of France is Paris.\n        ```\n\n        Args:\n            user_prompt: User input to start/continue the conversation.\n            output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n                output validators since output validators would expect an argument that matches the agent's output type.\n            message_history: History of the conversation so far.\n            deferred_tool_results: Optional results for deferred tool calls in the message history.\n            model: Optional model to use for this run, required if `model` was not set when creating the agent.\n            instructions: Optional additional instructions to use for this run.\n            deps: Optional dependencies to use for this run.\n            model_settings: Optional settings to use for this model's request.\n            usage_limits: Optional limits on model request count or token usage.\n            usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n            infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n            toolsets: Optional additional toolsets for this run.\n            builtin_tools: Optional additional builtin tools for this run.\n\n        Returns:\n            The result of the run.\n        \"\"\"\n        async with self.wrapped.iter(\n            user_prompt=user_prompt,\n            output_type=output_type,\n            message_history=message_history,\n            deferred_tool_results=deferred_tool_results,\n            model=model,\n            instructions=instructions,\n            deps=deps,\n            model_settings=model_settings,\n            usage_limits=usage_limits,\n            usage=usage,\n            infer_name=infer_name,\n            toolsets=toolsets,\n            builtin_tools=builtin_tools,\n        ) as run:\n            yield run\n\n    @contextmanager\n    def override(\n        self,\n        *,\n        name: str | _utils.Unset = _utils.UNSET,\n        deps: AgentDepsT | _utils.Unset = _utils.UNSET,\n        model: models.Model | models.KnownModelName | str | _utils.Unset = _utils.UNSET,\n        toolsets: Sequence[AbstractToolset[AgentDepsT]] | _utils.Unset = _utils.UNSET,\n        tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] | _utils.Unset = _utils.UNSET,\n        instructions: Instructions[AgentDepsT] | _utils.Unset = _utils.UNSET,\n    ) -> Iterator[None]:\n        \"\"\"Context manager to temporarily override agent name, dependencies, model, toolsets, tools, or instructions.\n\n        This is particularly useful when testing.\n        You can find an example of this [here](../testing.md#overriding-model-via-pytest-fixtures).\n\n        Args:\n            name: The name to use instead of the name passed to the agent constructor and agent run.\n            deps: The dependencies to use instead of the dependencies passed to the agent run.\n            model: The model to use instead of the model passed to the agent run.\n            toolsets: The toolsets to use instead of the toolsets passed to the agent constructor and agent run.\n            tools: The tools to use instead of the tools registered with the agent.\n            instructions: The instructions to use instead of the instructions registered with the agent.\n        \"\"\"\n        with self.wrapped.override(\n            name=name,\n            deps=deps,\n            model=model,\n            toolsets=toolsets,\n            tools=tools,\n            instructions=instructions,\n        ):\n            yield\n\n````\n\n#### iter\n\n```python\niter(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AbstractAsyncContextManager[\n    AgentRun[AgentDepsT, OutputDataT]\n]\n\n```\n\n```python\niter(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT],\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AbstractAsyncContextManager[\n    AgentRun[AgentDepsT, RunOutputDataT]\n]\n\n```\n\n```python\niter(\n    user_prompt: str | Sequence[UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[ModelMessage] | None = None,\n    deferred_tool_results: (\n        DeferredToolResults | None\n    ) = None,\n    model: Model | KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: UsageLimits | None = None,\n    usage: RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | None\n    ) = None,\n    builtin_tools: (\n        Sequence[AbstractBuiltinTool] | None\n    ) = None\n) -> AsyncIterator[AgentRun[AgentDepsT, Any]]\n\n```\n\nA contextmanager which can be used to iterate over the agent graph's nodes as they are executed.\n\nThis method builds an internal agent graph (using system prompts, tools and output schemas) and then returns an `AgentRun` object. The `AgentRun` can be used to async-iterate over the nodes of the graph as they are executed. This is the API to use if you want to consume the outputs coming from each LLM model response, or the stream of events coming from the execution of tools.\n\nThe `AgentRun` also provides methods to access the full message history, new messages, and usage statistics, and the final result of the run once it has completed.\n\nFor more details, see the documentation of `AgentRun`.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\n\nasync def main():\n    nodes = []\n    async with agent.iter('What is the capital of France?') as agent_run:\n        async for node in agent_run:\n            nodes.append(node)\n    print(nodes)\n    '''\n    [\n        UserPromptNode(\n            user_prompt='What is the capital of France?',\n            instructions_functions=[],\n            system_prompts=(),\n            system_prompt_functions=[],\n            system_prompt_dynamic_functions={},\n        ),\n        ModelRequestNode(\n            request=ModelRequest(\n                parts=[\n                    UserPromptPart(\n                        content='What is the capital of France?',\n                        timestamp=datetime.datetime(...),\n                    )\n                ],\n                run_id='...',\n            )\n        ),\n        CallToolsNode(\n            model_response=ModelResponse(\n                parts=[TextPart(content='The capital of France is Paris.')],\n                usage=RequestUsage(input_tokens=56, output_tokens=7),\n                model_name='gpt-4o',\n                timestamp=datetime.datetime(...),\n                run_id='...',\n            )\n        ),\n        End(data=FinalResult(output='The capital of France is Paris.')),\n    ]\n    '''\n    print(agent_run.result.output)\n    #> The capital of France is Paris.\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `user_prompt` | `str | Sequence[UserContent] | None` | User input to start/continue the conversation. | `None` | | `output_type` | `OutputSpec[RunOutputDataT] | None` | Custom output type to use for this run, output_type may only be used if the agent has no output validators since output validators would expect an argument that matches the agent's output type. | `None` | | `message_history` | `Sequence[ModelMessage] | None` | History of the conversation so far. | `None` | | `deferred_tool_results` | `DeferredToolResults | None` | Optional results for deferred tool calls in the message history. | `None` | | `model` | `Model | KnownModelName | str | None` | Optional model to use for this run, required if model was not set when creating the agent. | `None` | | `instructions` | `Instructions[AgentDepsT]` | Optional additional instructions to use for this run. | `None` | | `deps` | `AgentDepsT` | Optional dependencies to use for this run. | `None` | | `model_settings` | `ModelSettings | None` | Optional settings to use for this model's request. | `None` | | `usage_limits` | `UsageLimits | None` | Optional limits on model request count or token usage. | `None` | | `usage` | `RunUsage | None` | Optional usage to start with, useful for resuming a conversation or agents used in tools. | `None` | | `infer_name` | `bool` | Whether to try to infer the agent name from the call frame if it's not set. | `True` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | None` | Optional additional toolsets for this run. | `None` | | `builtin_tools` | `Sequence[AbstractBuiltinTool] | None` | Optional additional builtin tools for this run. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AsyncIterator[AgentRun[AgentDepsT, Any]]` | The result of the run. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/wrapper.py`\n\n````python\n@asynccontextmanager\nasync def iter(\n    self,\n    user_prompt: str | Sequence[_messages.UserContent] | None = None,\n    *,\n    output_type: OutputSpec[RunOutputDataT] | None = None,\n    message_history: Sequence[_messages.ModelMessage] | None = None,\n    deferred_tool_results: DeferredToolResults | None = None,\n    model: models.Model | models.KnownModelName | str | None = None,\n    instructions: Instructions[AgentDepsT] = None,\n    deps: AgentDepsT = None,\n    model_settings: ModelSettings | None = None,\n    usage_limits: _usage.UsageLimits | None = None,\n    usage: _usage.RunUsage | None = None,\n    infer_name: bool = True,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | None = None,\n    builtin_tools: Sequence[AbstractBuiltinTool] | None = None,\n) -> AsyncIterator[AgentRun[AgentDepsT, Any]]:\n    \"\"\"A contextmanager which can be used to iterate over the agent graph's nodes as they are executed.\n\n    This method builds an internal agent graph (using system prompts, tools and output schemas) and then returns an\n    `AgentRun` object. The `AgentRun` can be used to async-iterate over the nodes of the graph as they are\n    executed. This is the API to use if you want to consume the outputs coming from each LLM model response, or the\n    stream of events coming from the execution of tools.\n\n    The `AgentRun` also provides methods to access the full message history, new messages, and usage statistics,\n    and the final result of the run once it has completed.\n\n    For more details, see the documentation of `AgentRun`.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n\n    async def main():\n        nodes = []\n        async with agent.iter('What is the capital of France?') as agent_run:\n            async for node in agent_run:\n                nodes.append(node)\n        print(nodes)\n        '''\n        [\n            UserPromptNode(\n                user_prompt='What is the capital of France?',\n                instructions_functions=[],\n                system_prompts=(),\n                system_prompt_functions=[],\n                system_prompt_dynamic_functions={},\n            ),\n            ModelRequestNode(\n                request=ModelRequest(\n                    parts=[\n                        UserPromptPart(\n                            content='What is the capital of France?',\n                            timestamp=datetime.datetime(...),\n                        )\n                    ],\n                    run_id='...',\n                )\n            ),\n            CallToolsNode(\n                model_response=ModelResponse(\n                    parts=[TextPart(content='The capital of France is Paris.')],\n                    usage=RequestUsage(input_tokens=56, output_tokens=7),\n                    model_name='gpt-4o',\n                    timestamp=datetime.datetime(...),\n                    run_id='...',\n                )\n            ),\n            End(data=FinalResult(output='The capital of France is Paris.')),\n        ]\n        '''\n        print(agent_run.result.output)\n        #> The capital of France is Paris.\n    ```\n\n    Args:\n        user_prompt: User input to start/continue the conversation.\n        output_type: Custom output type to use for this run, `output_type` may only be used if the agent has no\n            output validators since output validators would expect an argument that matches the agent's output type.\n        message_history: History of the conversation so far.\n        deferred_tool_results: Optional results for deferred tool calls in the message history.\n        model: Optional model to use for this run, required if `model` was not set when creating the agent.\n        instructions: Optional additional instructions to use for this run.\n        deps: Optional dependencies to use for this run.\n        model_settings: Optional settings to use for this model's request.\n        usage_limits: Optional limits on model request count or token usage.\n        usage: Optional usage to start with, useful for resuming a conversation or agents used in tools.\n        infer_name: Whether to try to infer the agent name from the call frame if it's not set.\n        toolsets: Optional additional toolsets for this run.\n        builtin_tools: Optional additional builtin tools for this run.\n\n    Returns:\n        The result of the run.\n    \"\"\"\n    async with self.wrapped.iter(\n        user_prompt=user_prompt,\n        output_type=output_type,\n        message_history=message_history,\n        deferred_tool_results=deferred_tool_results,\n        model=model,\n        instructions=instructions,\n        deps=deps,\n        model_settings=model_settings,\n        usage_limits=usage_limits,\n        usage=usage,\n        infer_name=infer_name,\n        toolsets=toolsets,\n        builtin_tools=builtin_tools,\n    ) as run:\n        yield run\n\n````\n\n#### override\n\n```python\noverride(\n    *,\n    name: str | Unset = UNSET,\n    deps: AgentDepsT | Unset = UNSET,\n    model: Model | KnownModelName | str | Unset = UNSET,\n    toolsets: (\n        Sequence[AbstractToolset[AgentDepsT]] | Unset\n    ) = UNSET,\n    tools: (\n        Sequence[\n            Tool[AgentDepsT]\n            | ToolFuncEither[AgentDepsT, ...]\n        ]\n        | Unset\n    ) = UNSET,\n    instructions: Instructions[AgentDepsT] | Unset = UNSET\n) -> Iterator[None]\n\n```\n\nContext manager to temporarily override agent name, dependencies, model, toolsets, tools, or instructions.\n\nThis is particularly useful when testing. You can find an example of this [here](../../testing/#overriding-model-via-pytest-fixtures).\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `name` | `str | Unset` | The name to use instead of the name passed to the agent constructor and agent run. | `UNSET` | | `deps` | `AgentDepsT | Unset` | The dependencies to use instead of the dependencies passed to the agent run. | `UNSET` | | `model` | `Model | KnownModelName | str | Unset` | The model to use instead of the model passed to the agent run. | `UNSET` | | `toolsets` | `Sequence[AbstractToolset[AgentDepsT]] | Unset` | The toolsets to use instead of the toolsets passed to the agent constructor and agent run. | `UNSET` | | `tools` | `Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] | Unset` | The tools to use instead of the tools registered with the agent. | `UNSET` | | `instructions` | `Instructions[AgentDepsT] | Unset` | The instructions to use instead of the instructions registered with the agent. | `UNSET` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/agent/wrapper.py`\n\n```python\n@contextmanager\ndef override(\n    self,\n    *,\n    name: str | _utils.Unset = _utils.UNSET,\n    deps: AgentDepsT | _utils.Unset = _utils.UNSET,\n    model: models.Model | models.KnownModelName | str | _utils.Unset = _utils.UNSET,\n    toolsets: Sequence[AbstractToolset[AgentDepsT]] | _utils.Unset = _utils.UNSET,\n    tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] | _utils.Unset = _utils.UNSET,\n    instructions: Instructions[AgentDepsT] | _utils.Unset = _utils.UNSET,\n) -> Iterator[None]:\n    \"\"\"Context manager to temporarily override agent name, dependencies, model, toolsets, tools, or instructions.\n\n    This is particularly useful when testing.\n    You can find an example of this [here](../testing.md#overriding-model-via-pytest-fixtures).\n\n    Args:\n        name: The name to use instead of the name passed to the agent constructor and agent run.\n        deps: The dependencies to use instead of the dependencies passed to the agent run.\n        model: The model to use instead of the model passed to the agent run.\n        toolsets: The toolsets to use instead of the toolsets passed to the agent constructor and agent run.\n        tools: The tools to use instead of the tools registered with the agent.\n        instructions: The instructions to use instead of the instructions registered with the agent.\n    \"\"\"\n    with self.wrapped.override(\n        name=name,\n        deps=deps,\n        model=model,\n        toolsets=toolsets,\n        tools=tools,\n        instructions=instructions,\n    ):\n        yield\n\n```\n\n### AgentRun\n\nBases: `Generic[AgentDepsT, OutputDataT]`\n\nA stateful, async-iterable run of an Agent.\n\nYou generally obtain an `AgentRun` instance by calling `async with my_agent.iter(...) as agent_run:`.\n\nOnce you have an instance, you can use it to iterate through the run's nodes as they execute. When an End is reached, the run finishes and result becomes available.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('openai:gpt-4o')\n\nasync def main():\n    nodes = []\n    # Iterate through the run, recording each node along the way:\n    async with agent.iter('What is the capital of France?') as agent_run:\n        async for node in agent_run:\n            nodes.append(node)\n    print(nodes)\n    '''\n    [\n        UserPromptNode(\n            user_prompt='What is the capital of France?',\n            instructions_functions=[],\n            system_prompts=(),\n            system_prompt_functions=[],\n            system_prompt_dynamic_functions={},\n        ),\n        ModelRequestNode(\n            request=ModelRequest(\n                parts=[\n                    UserPromptPart(\n                        content='What is the capital of France?',\n                        timestamp=datetime.datetime(...),\n                    )\n                ],\n                run_id='...',\n            )\n        ),\n        CallToolsNode(\n            model_response=ModelResponse(\n                parts=[TextPart(content='The capital of France is Paris.')],\n                usage=RequestUsage(input_tokens=56, output_tokens=7),\n                model_name='gpt-4o',\n                timestamp=datetime.datetime(...),\n                run_id='...',\n            )\n        ),\n        End(data=FinalResult(output='The capital of France is Paris.')),\n    ]\n    '''\n    print(agent_run.result.output)\n    #> The capital of France is Paris.\n\n```\n\nYou can also manually drive the iteration using the next method for more granular control.\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n````python\n@dataclasses.dataclass(repr=False)\nclass AgentRun(Generic[AgentDepsT, OutputDataT]):\n    \"\"\"A stateful, async-iterable run of an [`Agent`][pydantic_ai.agent.Agent].\n\n    You generally obtain an `AgentRun` instance by calling `async with my_agent.iter(...) as agent_run:`.\n\n    Once you have an instance, you can use it to iterate through the run's nodes as they execute. When an\n    [`End`][pydantic_graph.nodes.End] is reached, the run finishes and [`result`][pydantic_ai.agent.AgentRun.result]\n    becomes available.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n\n    agent = Agent('openai:gpt-4o')\n\n    async def main():\n        nodes = []\n        # Iterate through the run, recording each node along the way:\n        async with agent.iter('What is the capital of France?') as agent_run:\n            async for node in agent_run:\n                nodes.append(node)\n        print(nodes)\n        '''\n        [\n            UserPromptNode(\n                user_prompt='What is the capital of France?',\n                instructions_functions=[],\n                system_prompts=(),\n                system_prompt_functions=[],\n                system_prompt_dynamic_functions={},\n            ),\n            ModelRequestNode(\n                request=ModelRequest(\n                    parts=[\n                        UserPromptPart(\n                            content='What is the capital of France?',\n                            timestamp=datetime.datetime(...),\n                        )\n                    ],\n                    run_id='...',\n                )\n            ),\n            CallToolsNode(\n                model_response=ModelResponse(\n                    parts=[TextPart(content='The capital of France is Paris.')],\n                    usage=RequestUsage(input_tokens=56, output_tokens=7),\n                    model_name='gpt-4o',\n                    timestamp=datetime.datetime(...),\n                    run_id='...',\n                )\n            ),\n            End(data=FinalResult(output='The capital of France is Paris.')),\n        ]\n        '''\n        print(agent_run.result.output)\n        #> The capital of France is Paris.\n    ```\n\n    You can also manually drive the iteration using the [`next`][pydantic_ai.agent.AgentRun.next] method for\n    more granular control.\n    \"\"\"\n\n    _graph_run: GraphRun[\n        _agent_graph.GraphAgentState, _agent_graph.GraphAgentDeps[AgentDepsT, Any], FinalResult[OutputDataT]\n    ]\n\n    @overload\n    def _traceparent(self, *, required: Literal[False]) -> str | None: ...\n    @overload\n    def _traceparent(self) -> str: ...\n    def _traceparent(self, *, required: bool = True) -> str | None:\n        traceparent = self._graph_run._traceparent(required=False)  # type: ignore[reportPrivateUsage]\n        if traceparent is None and required:  # pragma: no cover\n            raise AttributeError('No span was created for this agent run')\n        return traceparent\n\n    @property\n    def ctx(self) -> GraphRunContext[_agent_graph.GraphAgentState, _agent_graph.GraphAgentDeps[AgentDepsT, Any]]:\n        \"\"\"The current context of the agent run.\"\"\"\n        return GraphRunContext[_agent_graph.GraphAgentState, _agent_graph.GraphAgentDeps[AgentDepsT, Any]](\n            state=self._graph_run.state, deps=self._graph_run.deps\n        )\n\n    @property\n    def next_node(\n        self,\n    ) -> _agent_graph.AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]:\n        \"\"\"The next node that will be run in the agent graph.\n\n        This is the next node that will be used during async iteration, or if a node is not passed to `self.next(...)`.\n        \"\"\"\n        task = self._graph_run.next_task\n        return self._task_to_node(task)\n\n    @property\n    def result(self) -> AgentRunResult[OutputDataT] | None:\n        \"\"\"The final result of the run if it has ended, otherwise `None`.\n\n        Once the run returns an [`End`][pydantic_graph.nodes.End] node, `result` is populated\n        with an [`AgentRunResult`][pydantic_ai.agent.AgentRunResult].\n        \"\"\"\n        graph_run_output = self._graph_run.output\n        if graph_run_output is None:\n            return None\n        return AgentRunResult(\n            graph_run_output.output,\n            graph_run_output.tool_name,\n            self._graph_run.state,\n            self._graph_run.deps.new_message_index,\n            self._traceparent(required=False),\n        )\n\n    def all_messages(self) -> list[_messages.ModelMessage]:\n        \"\"\"Return all messages for the run so far.\n\n        Messages from older runs are included.\n        \"\"\"\n        return self.ctx.state.message_history\n\n    def all_messages_json(self, *, output_tool_return_content: str | None = None) -> bytes:\n        \"\"\"Return all messages from [`all_messages`][pydantic_ai.agent.AgentRun.all_messages] as JSON bytes.\n\n        Returns:\n            JSON bytes representing the messages.\n        \"\"\"\n        return _messages.ModelMessagesTypeAdapter.dump_json(self.all_messages())\n\n    def new_messages(self) -> list[_messages.ModelMessage]:\n        \"\"\"Return new messages for the run so far.\n\n        Messages from older runs are excluded.\n        \"\"\"\n        return self.all_messages()[self.ctx.deps.new_message_index :]\n\n    def new_messages_json(self) -> bytes:\n        \"\"\"Return new messages from [`new_messages`][pydantic_ai.agent.AgentRun.new_messages] as JSON bytes.\n\n        Returns:\n            JSON bytes representing the new messages.\n        \"\"\"\n        return _messages.ModelMessagesTypeAdapter.dump_json(self.new_messages())\n\n    def __aiter__(\n        self,\n    ) -> AsyncIterator[_agent_graph.AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]]:\n        \"\"\"Provide async-iteration over the nodes in the agent run.\"\"\"\n        return self\n\n    async def __anext__(\n        self,\n    ) -> _agent_graph.AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]:\n        \"\"\"Advance to the next node automatically based on the last returned node.\"\"\"\n        task = await anext(self._graph_run)\n        return self._task_to_node(task)\n\n    def _task_to_node(\n        self, task: EndMarker[FinalResult[OutputDataT]] | JoinItem | Sequence[GraphTaskRequest]\n    ) -> _agent_graph.AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]:\n        if isinstance(task, Sequence) and len(task) == 1:\n            first_task = task[0]\n            if isinstance(first_task.inputs, BaseNode):  # pragma: no branch\n                base_node: BaseNode[\n                    _agent_graph.GraphAgentState,\n                    _agent_graph.GraphAgentDeps[AgentDepsT, OutputDataT],\n                    FinalResult[OutputDataT],\n                ] = first_task.inputs  # type: ignore[reportUnknownMemberType]\n                if _agent_graph.is_agent_node(node=base_node):  # pragma: no branch\n                    return base_node\n        if isinstance(task, EndMarker):\n            return End(task.value)\n        raise exceptions.AgentRunError(f'Unexpected node: {task}')  # pragma: no cover\n\n    def _node_to_task(self, node: _agent_graph.AgentNode[AgentDepsT, OutputDataT]) -> GraphTaskRequest:\n        return GraphTaskRequest(NodeStep(type(node)).id, inputs=node, fork_stack=())\n\n    async def next(\n        self,\n        node: _agent_graph.AgentNode[AgentDepsT, OutputDataT],\n    ) -> _agent_graph.AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]:\n        \"\"\"Manually drive the agent run by passing in the node you want to run next.\n\n        This lets you inspect or mutate the node before continuing execution, or skip certain nodes\n        under dynamic conditions. The agent run should be stopped when you return an [`End`][pydantic_graph.nodes.End]\n        node.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent\n        from pydantic_graph import End\n\n        agent = Agent('openai:gpt-4o')\n\n        async def main():\n            async with agent.iter('What is the capital of France?') as agent_run:\n                next_node = agent_run.next_node  # start with the first node\n                nodes = [next_node]\n                while not isinstance(next_node, End):\n                    next_node = await agent_run.next(next_node)\n                    nodes.append(next_node)\n                # Once `next_node` is an End, we've finished:\n                print(nodes)\n                '''\n                [\n                    UserPromptNode(\n                        user_prompt='What is the capital of France?',\n                        instructions_functions=[],\n                        system_prompts=(),\n                        system_prompt_functions=[],\n                        system_prompt_dynamic_functions={},\n                    ),\n                    ModelRequestNode(\n                        request=ModelRequest(\n                            parts=[\n                                UserPromptPart(\n                                    content='What is the capital of France?',\n                                    timestamp=datetime.datetime(...),\n                                )\n                            ],\n                            run_id='...',\n                        )\n                    ),\n                    CallToolsNode(\n                        model_response=ModelResponse(\n                            parts=[TextPart(content='The capital of France is Paris.')],\n                            usage=RequestUsage(input_tokens=56, output_tokens=7),\n                            model_name='gpt-4o',\n                            timestamp=datetime.datetime(...),\n                            run_id='...',\n                        )\n                    ),\n                    End(data=FinalResult(output='The capital of France is Paris.')),\n                ]\n                '''\n                print('Final result:', agent_run.result.output)\n                #> Final result: The capital of France is Paris.\n        ```\n\n        Args:\n            node: The node to run next in the graph.\n\n        Returns:\n            The next node returned by the graph logic, or an [`End`][pydantic_graph.nodes.End] node if\n            the run has completed.\n        \"\"\"\n        # Note: It might be nice to expose a synchronous interface for iteration, but we shouldn't do it\n        # on this class, or else IDEs won't warn you if you accidentally use `for` instead of `async for` to iterate.\n        task = [self._node_to_task(node)]\n        try:\n            task = await self._graph_run.next(task)\n        except StopAsyncIteration:\n            pass\n        return self._task_to_node(task)\n\n    # TODO (v2): Make this a property\n    def usage(self) -> _usage.RunUsage:\n        \"\"\"Get usage statistics for the run so far, including token usage, model requests, and so on.\"\"\"\n        return self._graph_run.state.usage\n\n    @property\n    def run_id(self) -> str:\n        \"\"\"The unique identifier for the agent run.\"\"\"\n        return self._graph_run.state.run_id\n\n    def __repr__(self) -> str:  # pragma: no cover\n        result = self._graph_run.output\n        result_repr = '<run not finished>' if result is None else repr(result.output)\n        return f'<{type(self).__name__} result={result_repr} usage={self.usage()}>'\n\n````\n\n#### ctx\n\n```python\nctx: GraphRunContext[\n    GraphAgentState, GraphAgentDeps[AgentDepsT, Any]\n]\n\n```\n\nThe current context of the agent run.\n\n#### next_node\n\n```python\nnext_node: (\n    AgentNode[AgentDepsT, OutputDataT]\n    | End[FinalResult[OutputDataT]]\n)\n\n```\n\nThe next node that will be run in the agent graph.\n\nThis is the next node that will be used during async iteration, or if a node is not passed to `self.next(...)`.\n\n#### result\n\n```python\nresult: AgentRunResult[OutputDataT] | None\n\n```\n\nThe final result of the run if it has ended, otherwise `None`.\n\nOnce the run returns an End node, `result` is populated with an AgentRunResult.\n\n#### all_messages\n\n```python\nall_messages() -> list[ModelMessage]\n\n```\n\nReturn all messages for the run so far.\n\nMessages from older runs are included.\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef all_messages(self) -> list[_messages.ModelMessage]:\n    \"\"\"Return all messages for the run so far.\n\n    Messages from older runs are included.\n    \"\"\"\n    return self.ctx.state.message_history\n\n```\n\n#### all_messages_json\n\n```python\nall_messages_json(\n    *, output_tool_return_content: str | None = None\n) -> bytes\n\n```\n\nReturn all messages from all_messages as JSON bytes.\n\nReturns:\n\n| Type | Description | | --- | --- | | `bytes` | JSON bytes representing the messages. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef all_messages_json(self, *, output_tool_return_content: str | None = None) -> bytes:\n    \"\"\"Return all messages from [`all_messages`][pydantic_ai.agent.AgentRun.all_messages] as JSON bytes.\n\n    Returns:\n        JSON bytes representing the messages.\n    \"\"\"\n    return _messages.ModelMessagesTypeAdapter.dump_json(self.all_messages())\n\n```\n\n#### new_messages\n\n```python\nnew_messages() -> list[ModelMessage]\n\n```\n\nReturn new messages for the run so far.\n\nMessages from older runs are excluded.\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef new_messages(self) -> list[_messages.ModelMessage]:\n    \"\"\"Return new messages for the run so far.\n\n    Messages from older runs are excluded.\n    \"\"\"\n    return self.all_messages()[self.ctx.deps.new_message_index :]\n\n```\n\n#### new_messages_json\n\n```python\nnew_messages_json() -> bytes\n\n```\n\nReturn new messages from new_messages as JSON bytes.\n\nReturns:\n\n| Type | Description | | --- | --- | | `bytes` | JSON bytes representing the new messages. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef new_messages_json(self) -> bytes:\n    \"\"\"Return new messages from [`new_messages`][pydantic_ai.agent.AgentRun.new_messages] as JSON bytes.\n\n    Returns:\n        JSON bytes representing the new messages.\n    \"\"\"\n    return _messages.ModelMessagesTypeAdapter.dump_json(self.new_messages())\n\n```\n\n#### __aiter__\n\n```python\n__aiter__() -> (\n    AsyncIterator[\n        AgentNode[AgentDepsT, OutputDataT]\n        | End[FinalResult[OutputDataT]]\n    ]\n)\n\n```\n\nProvide async-iteration over the nodes in the agent run.\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef __aiter__(\n    self,\n) -> AsyncIterator[_agent_graph.AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]]:\n    \"\"\"Provide async-iteration over the nodes in the agent run.\"\"\"\n    return self\n\n```\n\n#### __anext__\n\n```python\n__anext__() -> (\n    AgentNode[AgentDepsT, OutputDataT]\n    | End[FinalResult[OutputDataT]]\n)\n\n```\n\nAdvance to the next node automatically based on the last returned node.\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\nasync def __anext__(\n    self,\n) -> _agent_graph.AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]:\n    \"\"\"Advance to the next node automatically based on the last returned node.\"\"\"\n    task = await anext(self._graph_run)\n    return self._task_to_node(task)\n\n```\n\n#### next\n\n```python\nnext(\n    node: AgentNode[AgentDepsT, OutputDataT],\n) -> (\n    AgentNode[AgentDepsT, OutputDataT]\n    | End[FinalResult[OutputDataT]]\n)\n\n```\n\nManually drive the agent run by passing in the node you want to run next.\n\nThis lets you inspect or mutate the node before continuing execution, or skip certain nodes under dynamic conditions. The agent run should be stopped when you return an End node.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent\nfrom pydantic_graph import End\n\nagent = Agent('openai:gpt-4o')\n\nasync def main():\n    async with agent.iter('What is the capital of France?') as agent_run:\n        next_node = agent_run.next_node  # start with the first node\n        nodes = [next_node]\n        while not isinstance(next_node, End):\n            next_node = await agent_run.next(next_node)\n            nodes.append(next_node)\n        # Once `next_node` is an End, we've finished:\n        print(nodes)\n        '''\n        [\n            UserPromptNode(\n                user_prompt='What is the capital of France?',\n                instructions_functions=[],\n                system_prompts=(),\n                system_prompt_functions=[],\n                system_prompt_dynamic_functions={},\n            ),\n            ModelRequestNode(\n                request=ModelRequest(\n                    parts=[\n                        UserPromptPart(\n                            content='What is the capital of France?',\n                            timestamp=datetime.datetime(...),\n                        )\n                    ],\n                    run_id='...',\n                )\n            ),\n            CallToolsNode(\n                model_response=ModelResponse(\n                    parts=[TextPart(content='The capital of France is Paris.')],\n                    usage=RequestUsage(input_tokens=56, output_tokens=7),\n                    model_name='gpt-4o',\n                    timestamp=datetime.datetime(...),\n                    run_id='...',\n                )\n            ),\n            End(data=FinalResult(output='The capital of France is Paris.')),\n        ]\n        '''\n        print('Final result:', agent_run.result.output)\n        #> Final result: The capital of France is Paris.\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `node` | `AgentNode[AgentDepsT, OutputDataT]` | The node to run next in the graph. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]` | The next node returned by the graph logic, or an End node if | | `AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]` | the run has completed. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n````python\nasync def next(\n    self,\n    node: _agent_graph.AgentNode[AgentDepsT, OutputDataT],\n) -> _agent_graph.AgentNode[AgentDepsT, OutputDataT] | End[FinalResult[OutputDataT]]:\n    \"\"\"Manually drive the agent run by passing in the node you want to run next.\n\n    This lets you inspect or mutate the node before continuing execution, or skip certain nodes\n    under dynamic conditions. The agent run should be stopped when you return an [`End`][pydantic_graph.nodes.End]\n    node.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent\n    from pydantic_graph import End\n\n    agent = Agent('openai:gpt-4o')\n\n    async def main():\n        async with agent.iter('What is the capital of France?') as agent_run:\n            next_node = agent_run.next_node  # start with the first node\n            nodes = [next_node]\n            while not isinstance(next_node, End):\n                next_node = await agent_run.next(next_node)\n                nodes.append(next_node)\n            # Once `next_node` is an End, we've finished:\n            print(nodes)\n            '''\n            [\n                UserPromptNode(\n                    user_prompt='What is the capital of France?',\n                    instructions_functions=[],\n                    system_prompts=(),\n                    system_prompt_functions=[],\n                    system_prompt_dynamic_functions={},\n                ),\n                ModelRequestNode(\n                    request=ModelRequest(\n                        parts=[\n                            UserPromptPart(\n                                content='What is the capital of France?',\n                                timestamp=datetime.datetime(...),\n                            )\n                        ],\n                        run_id='...',\n                    )\n                ),\n                CallToolsNode(\n                    model_response=ModelResponse(\n                        parts=[TextPart(content='The capital of France is Paris.')],\n                        usage=RequestUsage(input_tokens=56, output_tokens=7),\n                        model_name='gpt-4o',\n                        timestamp=datetime.datetime(...),\n                        run_id='...',\n                    )\n                ),\n                End(data=FinalResult(output='The capital of France is Paris.')),\n            ]\n            '''\n            print('Final result:', agent_run.result.output)\n            #> Final result: The capital of France is Paris.\n    ```\n\n    Args:\n        node: The node to run next in the graph.\n\n    Returns:\n        The next node returned by the graph logic, or an [`End`][pydantic_graph.nodes.End] node if\n        the run has completed.\n    \"\"\"\n    # Note: It might be nice to expose a synchronous interface for iteration, but we shouldn't do it\n    # on this class, or else IDEs won't warn you if you accidentally use `for` instead of `async for` to iterate.\n    task = [self._node_to_task(node)]\n    try:\n        task = await self._graph_run.next(task)\n    except StopAsyncIteration:\n        pass\n    return self._task_to_node(task)\n\n````\n\n#### usage\n\n```python\nusage() -> RunUsage\n\n```\n\nGet usage statistics for the run so far, including token usage, model requests, and so on.\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef usage(self) -> _usage.RunUsage:\n    \"\"\"Get usage statistics for the run so far, including token usage, model requests, and so on.\"\"\"\n    return self._graph_run.state.usage\n\n```\n\n#### run_id\n\n```python\nrun_id: str\n\n```\n\nThe unique identifier for the agent run.\n\n### AgentRunResult\n\nBases: `Generic[OutputDataT]`\n\nThe final result of an agent run.\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\n@dataclasses.dataclass\nclass AgentRunResult(Generic[OutputDataT]):\n    \"\"\"The final result of an agent run.\"\"\"\n\n    output: OutputDataT\n    \"\"\"The output data from the agent run.\"\"\"\n\n    _output_tool_name: str | None = dataclasses.field(repr=False, compare=False, default=None)\n    _state: _agent_graph.GraphAgentState = dataclasses.field(\n        repr=False, compare=False, default_factory=_agent_graph.GraphAgentState\n    )\n    _new_message_index: int = dataclasses.field(repr=False, compare=False, default=0)\n    _traceparent_value: str | None = dataclasses.field(repr=False, compare=False, default=None)\n\n    @overload\n    def _traceparent(self, *, required: Literal[False]) -> str | None: ...\n    @overload\n    def _traceparent(self) -> str: ...\n    def _traceparent(self, *, required: bool = True) -> str | None:\n        if self._traceparent_value is None and required:  # pragma: no cover\n            raise AttributeError('No span was created for this agent run')\n        return self._traceparent_value\n\n    def _set_output_tool_return(self, return_content: str) -> list[_messages.ModelMessage]:\n        \"\"\"Set return content for the output tool.\n\n        Useful if you want to continue the conversation and want to set the response to the output tool call.\n        \"\"\"\n        if not self._output_tool_name:\n            raise ValueError('Cannot set output tool return content when the return type is `str`.')\n\n        messages = self._state.message_history\n        last_message = messages[-1]\n        for idx, part in enumerate(last_message.parts):\n            if isinstance(part, _messages.ToolReturnPart) and part.tool_name == self._output_tool_name:\n                # Only do deepcopy when we have to modify\n                copied_messages = list(messages)\n                copied_last = deepcopy(last_message)\n                copied_last.parts[idx].content = return_content  # type: ignore[misc]\n                copied_messages[-1] = copied_last\n                return copied_messages\n\n        raise LookupError(f'No tool call found with tool name {self._output_tool_name!r}.')\n\n    def all_messages(self, *, output_tool_return_content: str | None = None) -> list[_messages.ModelMessage]:\n        \"\"\"Return the history of _messages.\n\n        Args:\n            output_tool_return_content: The return content of the tool call to set in the last message.\n                This provides a convenient way to modify the content of the output tool call if you want to continue\n                the conversation and want to set the response to the output tool call. If `None`, the last message will\n                not be modified.\n\n        Returns:\n            List of messages.\n        \"\"\"\n        if output_tool_return_content is not None:\n            return self._set_output_tool_return(output_tool_return_content)\n        else:\n            return self._state.message_history\n\n    def all_messages_json(self, *, output_tool_return_content: str | None = None) -> bytes:\n        \"\"\"Return all messages from [`all_messages`][pydantic_ai.agent.AgentRunResult.all_messages] as JSON bytes.\n\n        Args:\n            output_tool_return_content: The return content of the tool call to set in the last message.\n                This provides a convenient way to modify the content of the output tool call if you want to continue\n                the conversation and want to set the response to the output tool call. If `None`, the last message will\n                not be modified.\n\n        Returns:\n            JSON bytes representing the messages.\n        \"\"\"\n        return _messages.ModelMessagesTypeAdapter.dump_json(\n            self.all_messages(output_tool_return_content=output_tool_return_content)\n        )\n\n    def new_messages(self, *, output_tool_return_content: str | None = None) -> list[_messages.ModelMessage]:\n        \"\"\"Return new messages associated with this run.\n\n        Messages from older runs are excluded.\n\n        Args:\n            output_tool_return_content: The return content of the tool call to set in the last message.\n                This provides a convenient way to modify the content of the output tool call if you want to continue\n                the conversation and want to set the response to the output tool call. If `None`, the last message will\n                not be modified.\n\n        Returns:\n            List of new messages.\n        \"\"\"\n        return self.all_messages(output_tool_return_content=output_tool_return_content)[self._new_message_index :]\n\n    def new_messages_json(self, *, output_tool_return_content: str | None = None) -> bytes:\n        \"\"\"Return new messages from [`new_messages`][pydantic_ai.agent.AgentRunResult.new_messages] as JSON bytes.\n\n        Args:\n            output_tool_return_content: The return content of the tool call to set in the last message.\n                This provides a convenient way to modify the content of the output tool call if you want to continue\n                the conversation and want to set the response to the output tool call. If `None`, the last message will\n                not be modified.\n\n        Returns:\n            JSON bytes representing the new messages.\n        \"\"\"\n        return _messages.ModelMessagesTypeAdapter.dump_json(\n            self.new_messages(output_tool_return_content=output_tool_return_content)\n        )\n\n    @property\n    def response(self) -> _messages.ModelResponse:\n        \"\"\"Return the last response from the message history.\"\"\"\n        # The response may not be the very last item if it contained an output tool call. See `CallToolsNode._handle_final_result`.\n        for message in reversed(self.all_messages()):\n            if isinstance(message, _messages.ModelResponse):\n                return message\n        raise ValueError('No response found in the message history')  # pragma: no cover\n\n    # TODO (v2): Make this a property\n    def usage(self) -> _usage.RunUsage:\n        \"\"\"Return the usage of the whole run.\"\"\"\n        return self._state.usage\n\n    # TODO (v2): Make this a property\n    def timestamp(self) -> datetime:\n        \"\"\"Return the timestamp of last response.\"\"\"\n        return self.response.timestamp\n\n    @property\n    def run_id(self) -> str:\n        \"\"\"The unique identifier for the agent run.\"\"\"\n        return self._state.run_id\n\n```\n\n#### output\n\n```python\noutput: OutputDataT\n\n```\n\nThe output data from the agent run.\n\n#### all_messages\n\n```python\nall_messages(\n    *, output_tool_return_content: str | None = None\n) -> list[ModelMessage]\n\n```\n\nReturn the history of \\_messages.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `output_tool_return_content` | `str | None` | The return content of the tool call to set in the last message. This provides a convenient way to modify the content of the output tool call if you want to continue the conversation and want to set the response to the output tool call. If None, the last message will not be modified. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `list[ModelMessage]` | List of messages. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef all_messages(self, *, output_tool_return_content: str | None = None) -> list[_messages.ModelMessage]:\n    \"\"\"Return the history of _messages.\n\n    Args:\n        output_tool_return_content: The return content of the tool call to set in the last message.\n            This provides a convenient way to modify the content of the output tool call if you want to continue\n            the conversation and want to set the response to the output tool call. If `None`, the last message will\n            not be modified.\n\n    Returns:\n        List of messages.\n    \"\"\"\n    if output_tool_return_content is not None:\n        return self._set_output_tool_return(output_tool_return_content)\n    else:\n        return self._state.message_history\n\n```\n\n#### all_messages_json\n\n```python\nall_messages_json(\n    *, output_tool_return_content: str | None = None\n) -> bytes\n\n```\n\nReturn all messages from all_messages as JSON bytes.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `output_tool_return_content` | `str | None` | The return content of the tool call to set in the last message. This provides a convenient way to modify the content of the output tool call if you want to continue the conversation and want to set the response to the output tool call. If None, the last message will not be modified. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `bytes` | JSON bytes representing the messages. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef all_messages_json(self, *, output_tool_return_content: str | None = None) -> bytes:\n    \"\"\"Return all messages from [`all_messages`][pydantic_ai.agent.AgentRunResult.all_messages] as JSON bytes.\n\n    Args:\n        output_tool_return_content: The return content of the tool call to set in the last message.\n            This provides a convenient way to modify the content of the output tool call if you want to continue\n            the conversation and want to set the response to the output tool call. If `None`, the last message will\n            not be modified.\n\n    Returns:\n        JSON bytes representing the messages.\n    \"\"\"\n    return _messages.ModelMessagesTypeAdapter.dump_json(\n        self.all_messages(output_tool_return_content=output_tool_return_content)\n    )\n\n```\n\n#### new_messages\n\n```python\nnew_messages(\n    *, output_tool_return_content: str | None = None\n) -> list[ModelMessage]\n\n```\n\nReturn new messages associated with this run.\n\nMessages from older runs are excluded.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `output_tool_return_content` | `str | None` | The return content of the tool call to set in the last message. This provides a convenient way to modify the content of the output tool call if you want to continue the conversation and want to set the response to the output tool call. If None, the last message will not be modified. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `list[ModelMessage]` | List of new messages. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef new_messages(self, *, output_tool_return_content: str | None = None) -> list[_messages.ModelMessage]:\n    \"\"\"Return new messages associated with this run.\n\n    Messages from older runs are excluded.\n\n    Args:\n        output_tool_return_content: The return content of the tool call to set in the last message.\n            This provides a convenient way to modify the content of the output tool call if you want to continue\n            the conversation and want to set the response to the output tool call. If `None`, the last message will\n            not be modified.\n\n    Returns:\n        List of new messages.\n    \"\"\"\n    return self.all_messages(output_tool_return_content=output_tool_return_content)[self._new_message_index :]\n\n```\n\n#### new_messages_json\n\n```python\nnew_messages_json(\n    *, output_tool_return_content: str | None = None\n) -> bytes\n\n```\n\nReturn new messages from new_messages as JSON bytes.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `output_tool_return_content` | `str | None` | The return content of the tool call to set in the last message. This provides a convenient way to modify the content of the output tool call if you want to continue the conversation and want to set the response to the output tool call. If None, the last message will not be modified. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `bytes` | JSON bytes representing the new messages. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef new_messages_json(self, *, output_tool_return_content: str | None = None) -> bytes:\n    \"\"\"Return new messages from [`new_messages`][pydantic_ai.agent.AgentRunResult.new_messages] as JSON bytes.\n\n    Args:\n        output_tool_return_content: The return content of the tool call to set in the last message.\n            This provides a convenient way to modify the content of the output tool call if you want to continue\n            the conversation and want to set the response to the output tool call. If `None`, the last message will\n            not be modified.\n\n    Returns:\n        JSON bytes representing the new messages.\n    \"\"\"\n    return _messages.ModelMessagesTypeAdapter.dump_json(\n        self.new_messages(output_tool_return_content=output_tool_return_content)\n    )\n\n```\n\n#### response\n\n```python\nresponse: ModelResponse\n\n```\n\nReturn the last response from the message history.\n\n#### usage\n\n```python\nusage() -> RunUsage\n\n```\n\nReturn the usage of the whole run.\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef usage(self) -> _usage.RunUsage:\n    \"\"\"Return the usage of the whole run.\"\"\"\n    return self._state.usage\n\n```\n\n#### timestamp\n\n```python\ntimestamp() -> datetime\n\n```\n\nReturn the timestamp of last response.\n\nSource code in `pydantic_ai_slim/pydantic_ai/run.py`\n\n```python\ndef timestamp(self) -> datetime:\n    \"\"\"Return the timestamp of last response.\"\"\"\n    return self.response.timestamp\n\n```\n\n#### run_id\n\n```python\nrun_id: str\n\n```\n\nThe unique identifier for the agent run.\n\n### EndStrategy\n\n```python\nEndStrategy = Literal['early', 'exhaustive']\n\n```\n\nThe strategy for handling multiple tool calls when a final result is found.\n\n- `'early'`: Stop processing other tool calls once a final result is found\n- `'exhaustive'`: Process all tool calls even after finding a final result\n\n### RunOutputDataT\n\n```python\nRunOutputDataT = TypeVar('RunOutputDataT')\n\n```\n\nType variable for the result data of a run where `output_type` was customized on the run call.\n\n### capture_run_messages\n\n```python\ncapture_run_messages() -> Iterator[list[ModelMessage]]\n\n```\n\nContext manager to access the messages used in a run, run_sync, or run_stream call.\n\nUseful when a run may raise an exception, see [model errors](../../agents/#model-errors) for more information.\n\nExamples:\n\n```python\nfrom pydantic_ai import Agent, capture_run_messages\n\nagent = Agent('test')\n\nwith capture_run_messages() as messages:\n    try:\n        result = agent.run_sync('foobar')\n    except Exception:\n        print(messages)\n        raise\n\n```\n\nNote\n\nIf you call `run`, `run_sync`, or `run_stream` more than once within a single `capture_run_messages` context, `messages` will represent the messages exchanged during the first call only.\n\nSource code in `pydantic_ai_slim/pydantic_ai/_agent_graph.py`\n\n````python\n@contextmanager\ndef capture_run_messages() -> Iterator[list[_messages.ModelMessage]]:\n    \"\"\"Context manager to access the messages used in a [`run`][pydantic_ai.agent.AbstractAgent.run], [`run_sync`][pydantic_ai.agent.AbstractAgent.run_sync], or [`run_stream`][pydantic_ai.agent.AbstractAgent.run_stream] call.\n\n    Useful when a run may raise an exception, see [model errors](../agents.md#model-errors) for more information.\n\n    Examples:\n    ```python\n    from pydantic_ai import Agent, capture_run_messages\n\n    agent = Agent('test')\n\n    with capture_run_messages() as messages:\n        try:\n            result = agent.run_sync('foobar')\n        except Exception:\n            print(messages)\n            raise\n    ```\n\n    !!! note\n        If you call `run`, `run_sync`, or `run_stream` more than once within a single `capture_run_messages` context,\n        `messages` will represent the messages exchanged during the first call only.\n    \"\"\"\n    token = None\n    messages: list[_messages.ModelMessage] = []\n\n    # Try to reuse existing message context if available\n    try:\n        messages = _messages_ctx_var.get().messages\n    except LookupError:\n        # No existing context, create a new one\n        token = _messages_ctx_var.set(_RunMessages(messages))\n\n    try:\n        yield messages\n    finally:\n        # Clean up context if we created it\n        if token is not None:\n            _messages_ctx_var.reset(token)\n\n````\n\n### InstrumentationSettings\n\nOptions for instrumenting models and agents with OpenTelemetry.\n\nUsed in:\n\n- `Agent(instrument=...)`\n- Agent.instrument_all()\n- InstrumentedModel\n\nSee the [Debugging and Monitoring guide](https://ai.pydantic.dev/logfire/) for more info.\n\nSource code in `pydantic_ai_slim/pydantic_ai/models/instrumented.py`\n\n```python\n@dataclass(init=False)\nclass InstrumentationSettings:\n    \"\"\"Options for instrumenting models and agents with OpenTelemetry.\n\n    Used in:\n\n    - `Agent(instrument=...)`\n    - [`Agent.instrument_all()`][pydantic_ai.agent.Agent.instrument_all]\n    - [`InstrumentedModel`][pydantic_ai.models.instrumented.InstrumentedModel]\n\n    See the [Debugging and Monitoring guide](https://ai.pydantic.dev/logfire/) for more info.\n    \"\"\"\n\n    tracer: Tracer = field(repr=False)\n    event_logger: EventLogger = field(repr=False)\n    event_mode: Literal['attributes', 'logs'] = 'attributes'\n    include_binary_content: bool = True\n    include_content: bool = True\n    version: Literal[1, 2, 3] = DEFAULT_INSTRUMENTATION_VERSION\n\n    def __init__(\n        self,\n        *,\n        tracer_provider: TracerProvider | None = None,\n        meter_provider: MeterProvider | None = None,\n        include_binary_content: bool = True,\n        include_content: bool = True,\n        version: Literal[1, 2, 3] = DEFAULT_INSTRUMENTATION_VERSION,\n        event_mode: Literal['attributes', 'logs'] = 'attributes',\n        event_logger_provider: EventLoggerProvider | None = None,\n    ):\n        \"\"\"Create instrumentation options.\n\n        Args:\n            tracer_provider: The OpenTelemetry tracer provider to use.\n                If not provided, the global tracer provider is used.\n                Calling `logfire.configure()` sets the global tracer provider, so most users don't need this.\n            meter_provider: The OpenTelemetry meter provider to use.\n                If not provided, the global meter provider is used.\n                Calling `logfire.configure()` sets the global meter provider, so most users don't need this.\n            include_binary_content: Whether to include binary content in the instrumentation events.\n            include_content: Whether to include prompts, completions, and tool call arguments and responses\n                in the instrumentation events.\n            version: Version of the data format. This is unrelated to the Pydantic AI package version.\n                Version 1 is based on the legacy event-based OpenTelemetry GenAI spec\n                    and will be removed in a future release.\n                    The parameters `event_mode` and `event_logger_provider` are only relevant for version 1.\n                Version 2 uses the newer OpenTelemetry GenAI spec and stores messages in the following attributes:\n                    - `gen_ai.system_instructions` for instructions passed to the agent.\n                    - `gen_ai.input.messages` and `gen_ai.output.messages` on model request spans.\n                    - `pydantic_ai.all_messages` on agent run spans.\n            event_mode: The mode for emitting events in version 1.\n                If `'attributes'`, events are attached to the span as attributes.\n                If `'logs'`, events are emitted as OpenTelemetry log-based events.\n            event_logger_provider: The OpenTelemetry event logger provider to use.\n                If not provided, the global event logger provider is used.\n                Calling `logfire.configure()` sets the global event logger provider, so most users don't need this.\n                This is only used if `event_mode='logs'` and `version=1`.\n        \"\"\"\n        from pydantic_ai import __version__\n\n        tracer_provider = tracer_provider or get_tracer_provider()\n        meter_provider = meter_provider or get_meter_provider()\n        event_logger_provider = event_logger_provider or get_event_logger_provider()\n        scope_name = 'pydantic-ai'\n        self.tracer = tracer_provider.get_tracer(scope_name, __version__)\n        self.meter = meter_provider.get_meter(scope_name, __version__)\n        self.event_logger = event_logger_provider.get_event_logger(scope_name, __version__)\n        self.event_mode = event_mode\n        self.include_binary_content = include_binary_content\n        self.include_content = include_content\n\n        if event_mode == 'logs' and version != 1:\n            warnings.warn(\n                'event_mode is only relevant for version=1 which is deprecated and will be removed in a future release.',\n                stacklevel=2,\n            )\n            version = 1\n\n        self.version = version\n\n        # As specified in the OpenTelemetry GenAI metrics spec:\n        # https://opentelemetry.io/docs/specs/semconv/gen-ai/gen-ai-metrics/#metric-gen_aiclienttokenusage\n        tokens_histogram_kwargs = dict(\n            name='gen_ai.client.token.usage',\n            unit='{token}',\n            description='Measures number of input and output tokens used',\n        )\n        try:\n            self.tokens_histogram = self.meter.create_histogram(\n                **tokens_histogram_kwargs,\n                explicit_bucket_boundaries_advisory=TOKEN_HISTOGRAM_BOUNDARIES,\n            )\n        except TypeError:  # pragma: lax no cover\n            # Older OTel/logfire versions don't support explicit_bucket_boundaries_advisory\n            self.tokens_histogram = self.meter.create_histogram(\n                **tokens_histogram_kwargs,  # pyright: ignore\n            )\n        self.cost_histogram = self.meter.create_histogram(\n            'operation.cost',\n            unit='{USD}',\n            description='Monetary cost',\n        )\n\n    def messages_to_otel_events(\n        self, messages: list[ModelMessage], parameters: ModelRequestParameters | None = None\n    ) -> list[Event]:\n        \"\"\"Convert a list of model messages to OpenTelemetry events.\n\n        Args:\n            messages: The messages to convert.\n            parameters: The model request parameters.\n\n        Returns:\n            A list of OpenTelemetry events.\n        \"\"\"\n        events: list[Event] = []\n        instructions = InstrumentedModel._get_instructions(messages, parameters)  # pyright: ignore [reportPrivateUsage]\n        if instructions is not None:\n            events.append(\n                Event(\n                    'gen_ai.system.message',\n                    body={**({'content': instructions} if self.include_content else {}), 'role': 'system'},\n                )\n            )\n\n        for message_index, message in enumerate(messages):\n            message_events: list[Event] = []\n            if isinstance(message, ModelRequest):\n                for part in message.parts:\n                    if hasattr(part, 'otel_event'):\n                        message_events.append(part.otel_event(self))\n            elif isinstance(message, ModelResponse):  # pragma: no branch\n                message_events = message.otel_events(self)\n            for event in message_events:\n                event.attributes = {\n                    'gen_ai.message.index': message_index,\n                    **(event.attributes or {}),\n                }\n            events.extend(message_events)\n\n        for event in events:\n            event.body = InstrumentedModel.serialize_any(event.body)\n        return events\n\n    def messages_to_otel_messages(self, messages: list[ModelMessage]) -> list[_otel_messages.ChatMessage]:\n        result: list[_otel_messages.ChatMessage] = []\n        for message in messages:\n            if isinstance(message, ModelRequest):\n                for is_system, group in itertools.groupby(message.parts, key=lambda p: isinstance(p, SystemPromptPart)):\n                    message_parts: list[_otel_messages.MessagePart] = []\n                    for part in group:\n                        if hasattr(part, 'otel_message_parts'):\n                            message_parts.extend(part.otel_message_parts(self))\n                    result.append(\n                        _otel_messages.ChatMessage(role='system' if is_system else 'user', parts=message_parts)\n                    )\n            elif isinstance(message, ModelResponse):  # pragma: no branch\n                otel_message = _otel_messages.OutputMessage(role='assistant', parts=message.otel_message_parts(self))\n                if message.finish_reason is not None:\n                    otel_message['finish_reason'] = message.finish_reason\n                result.append(otel_message)\n        return result\n\n    def handle_messages(\n        self,\n        input_messages: list[ModelMessage],\n        response: ModelResponse,\n        system: str,\n        span: Span,\n        parameters: ModelRequestParameters | None = None,\n    ):\n        if self.version == 1:\n            events = self.messages_to_otel_events(input_messages, parameters)\n            for event in self.messages_to_otel_events([response], parameters):\n                events.append(\n                    Event(\n                        'gen_ai.choice',\n                        body={\n                            'index': 0,\n                            'message': event.body,\n                        },\n                    )\n                )\n            for event in events:\n                event.attributes = {\n                    GEN_AI_SYSTEM_ATTRIBUTE: system,\n                    **(event.attributes or {}),\n                }\n            self._emit_events(span, events)\n        else:\n            output_messages = self.messages_to_otel_messages([response])\n            assert len(output_messages) == 1\n            output_message = output_messages[0]\n            instructions = InstrumentedModel._get_instructions(input_messages, parameters)  # pyright: ignore [reportPrivateUsage]\n            system_instructions_attributes = self.system_instructions_attributes(instructions)\n            attributes: dict[str, AttributeValue] = {\n                'gen_ai.input.messages': json.dumps(self.messages_to_otel_messages(input_messages)),\n                'gen_ai.output.messages': json.dumps([output_message]),\n                **system_instructions_attributes,\n                'logfire.json_schema': json.dumps(\n                    {\n                        'type': 'object',\n                        'properties': {\n                            'gen_ai.input.messages': {'type': 'array'},\n                            'gen_ai.output.messages': {'type': 'array'},\n                            **(\n                                {'gen_ai.system_instructions': {'type': 'array'}}\n                                if system_instructions_attributes\n                                else {}\n                            ),\n                            'model_request_parameters': {'type': 'object'},\n                        },\n                    }\n                ),\n            }\n            span.set_attributes(attributes)\n\n    def system_instructions_attributes(self, instructions: str | None) -> dict[str, str]:\n        if instructions and self.include_content:\n            return {\n                'gen_ai.system_instructions': json.dumps([_otel_messages.TextPart(type='text', content=instructions)]),\n            }\n        return {}\n\n    def _emit_events(self, span: Span, events: list[Event]) -> None:\n        if self.event_mode == 'logs':\n            for event in events:\n                self.event_logger.emit(event)\n        else:\n            attr_name = 'events'\n            span.set_attributes(\n                {\n                    attr_name: json.dumps([InstrumentedModel.event_to_dict(event) for event in events]),\n                    'logfire.json_schema': json.dumps(\n                        {\n                            'type': 'object',\n                            'properties': {\n                                attr_name: {'type': 'array'},\n                                'model_request_parameters': {'type': 'object'},\n                            },\n                        }\n                    ),\n                }\n            )\n\n    def record_metrics(\n        self,\n        response: ModelResponse,\n        price_calculation: PriceCalculation | None,\n        attributes: dict[str, AttributeValue],\n    ):\n        for typ in ['input', 'output']:\n            if not (tokens := getattr(response.usage, f'{typ}_tokens', 0)):  # pragma: no cover\n                continue\n            token_attributes = {**attributes, 'gen_ai.token.type': typ}\n            self.tokens_histogram.record(tokens, token_attributes)\n            if price_calculation:\n                cost = float(getattr(price_calculation, f'{typ}_price'))\n                self.cost_histogram.record(cost, token_attributes)\n\n```\n\n#### __init__\n\n```python\n__init__(\n    *,\n    tracer_provider: TracerProvider | None = None,\n    meter_provider: MeterProvider | None = None,\n    include_binary_content: bool = True,\n    include_content: bool = True,\n    version: Literal[\n        1, 2, 3\n    ] = DEFAULT_INSTRUMENTATION_VERSION,\n    event_mode: Literal[\n        \"attributes\", \"logs\"\n    ] = \"attributes\",\n    event_logger_provider: EventLoggerProvider | None = None\n)\n\n```\n\nCreate instrumentation options.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `tracer_provider` | `TracerProvider | None` | The OpenTelemetry tracer provider to use. If not provided, the global tracer provider is used. Calling logfire.configure() sets the global tracer provider, so most users don't need this. | `None` | | `meter_provider` | `MeterProvider | None` | The OpenTelemetry meter provider to use. If not provided, the global meter provider is used. Calling logfire.configure() sets the global meter provider, so most users don't need this. | `None` | | `include_binary_content` | `bool` | Whether to include binary content in the instrumentation events. | `True` | | `include_content` | `bool` | Whether to include prompts, completions, and tool call arguments and responses in the instrumentation events. | `True` | | `version` | `Literal[1, 2, 3]` | Version of the data format. This is unrelated to the Pydantic AI package version. Version 1 is based on the legacy event-based OpenTelemetry GenAI spec and will be removed in a future release. The parameters event_mode and event_logger_provider are only relevant for version 1. Version 2 uses the newer OpenTelemetry GenAI spec and stores messages in the following attributes: - gen_ai.system_instructions for instructions passed to the agent. - gen_ai.input.messages and gen_ai.output.messages on model request spans. - pydantic_ai.all_messages on agent run spans. | `DEFAULT_INSTRUMENTATION_VERSION` | | `event_mode` | `Literal['attributes', 'logs']` | The mode for emitting events in version 1. If 'attributes', events are attached to the span as attributes. If 'logs', events are emitted as OpenTelemetry log-based events. | `'attributes'` | | `event_logger_provider` | `EventLoggerProvider | None` | The OpenTelemetry event logger provider to use. If not provided, the global event logger provider is used. Calling logfire.configure() sets the global event logger provider, so most users don't need this. This is only used if event_mode='logs' and version=1. | `None` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/models/instrumented.py`\n\n```python\ndef __init__(\n    self,\n    *,\n    tracer_provider: TracerProvider | None = None,\n    meter_provider: MeterProvider | None = None,\n    include_binary_content: bool = True,\n    include_content: bool = True,\n    version: Literal[1, 2, 3] = DEFAULT_INSTRUMENTATION_VERSION,\n    event_mode: Literal['attributes', 'logs'] = 'attributes',\n    event_logger_provider: EventLoggerProvider | None = None,\n):\n    \"\"\"Create instrumentation options.\n\n    Args:\n        tracer_provider: The OpenTelemetry tracer provider to use.\n            If not provided, the global tracer provider is used.\n            Calling `logfire.configure()` sets the global tracer provider, so most users don't need this.\n        meter_provider: The OpenTelemetry meter provider to use.\n            If not provided, the global meter provider is used.\n            Calling `logfire.configure()` sets the global meter provider, so most users don't need this.\n        include_binary_content: Whether to include binary content in the instrumentation events.\n        include_content: Whether to include prompts, completions, and tool call arguments and responses\n            in the instrumentation events.\n        version: Version of the data format. This is unrelated to the Pydantic AI package version.\n            Version 1 is based on the legacy event-based OpenTelemetry GenAI spec\n                and will be removed in a future release.\n                The parameters `event_mode` and `event_logger_provider` are only relevant for version 1.\n            Version 2 uses the newer OpenTelemetry GenAI spec and stores messages in the following attributes:\n                - `gen_ai.system_instructions` for instructions passed to the agent.\n                - `gen_ai.input.messages` and `gen_ai.output.messages` on model request spans.\n                - `pydantic_ai.all_messages` on agent run spans.\n        event_mode: The mode for emitting events in version 1.\n            If `'attributes'`, events are attached to the span as attributes.\n            If `'logs'`, events are emitted as OpenTelemetry log-based events.\n        event_logger_provider: The OpenTelemetry event logger provider to use.\n            If not provided, the global event logger provider is used.\n            Calling `logfire.configure()` sets the global event logger provider, so most users don't need this.\n            This is only used if `event_mode='logs'` and `version=1`.\n    \"\"\"\n    from pydantic_ai import __version__\n\n    tracer_provider = tracer_provider or get_tracer_provider()\n    meter_provider = meter_provider or get_meter_provider()\n    event_logger_provider = event_logger_provider or get_event_logger_provider()\n    scope_name = 'pydantic-ai'\n    self.tracer = tracer_provider.get_tracer(scope_name, __version__)\n    self.meter = meter_provider.get_meter(scope_name, __version__)\n    self.event_logger = event_logger_provider.get_event_logger(scope_name, __version__)\n    self.event_mode = event_mode\n    self.include_binary_content = include_binary_content\n    self.include_content = include_content\n\n    if event_mode == 'logs' and version != 1:\n        warnings.warn(\n            'event_mode is only relevant for version=1 which is deprecated and will be removed in a future release.',\n            stacklevel=2,\n        )\n        version = 1\n\n    self.version = version\n\n    # As specified in the OpenTelemetry GenAI metrics spec:\n    # https://opentelemetry.io/docs/specs/semconv/gen-ai/gen-ai-metrics/#metric-gen_aiclienttokenusage\n    tokens_histogram_kwargs = dict(\n        name='gen_ai.client.token.usage',\n        unit='{token}',\n        description='Measures number of input and output tokens used',\n    )\n    try:\n        self.tokens_histogram = self.meter.create_histogram(\n            **tokens_histogram_kwargs,\n            explicit_bucket_boundaries_advisory=TOKEN_HISTOGRAM_BOUNDARIES,\n        )\n    except TypeError:  # pragma: lax no cover\n        # Older OTel/logfire versions don't support explicit_bucket_boundaries_advisory\n        self.tokens_histogram = self.meter.create_histogram(\n            **tokens_histogram_kwargs,  # pyright: ignore\n        )\n    self.cost_histogram = self.meter.create_histogram(\n        'operation.cost',\n        unit='{USD}',\n        description='Monetary cost',\n    )\n\n```\n\n#### messages_to_otel_events\n\n```python\nmessages_to_otel_events(\n    messages: list[ModelMessage],\n    parameters: ModelRequestParameters | None = None,\n) -> list[Event]\n\n```\n\nConvert a list of model messages to OpenTelemetry events.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `messages` | `list[ModelMessage]` | The messages to convert. | *required* | | `parameters` | `ModelRequestParameters | None` | The model request parameters. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `list[Event]` | A list of OpenTelemetry events. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/models/instrumented.py`\n\n```python\ndef messages_to_otel_events(\n    self, messages: list[ModelMessage], parameters: ModelRequestParameters | None = None\n) -> list[Event]:\n    \"\"\"Convert a list of model messages to OpenTelemetry events.\n\n    Args:\n        messages: The messages to convert.\n        parameters: The model request parameters.\n\n    Returns:\n        A list of OpenTelemetry events.\n    \"\"\"\n    events: list[Event] = []\n    instructions = InstrumentedModel._get_instructions(messages, parameters)  # pyright: ignore [reportPrivateUsage]\n    if instructions is not None:\n        events.append(\n            Event(\n                'gen_ai.system.message',\n                body={**({'content': instructions} if self.include_content else {}), 'role': 'system'},\n            )\n        )\n\n    for message_index, message in enumerate(messages):\n        message_events: list[Event] = []\n        if isinstance(message, ModelRequest):\n            for part in message.parts:\n                if hasattr(part, 'otel_event'):\n                    message_events.append(part.otel_event(self))\n        elif isinstance(message, ModelResponse):  # pragma: no branch\n            message_events = message.otel_events(self)\n        for event in message_events:\n            event.attributes = {\n                'gen_ai.message.index': message_index,\n                **(event.attributes or {}),\n            }\n        events.extend(message_events)\n\n    for event in events:\n        event.body = InstrumentedModel.serialize_any(event.body)\n    return events\n\n```\n\n### EventStreamHandler\n\n```python\nEventStreamHandler: TypeAlias = Callable[\n    [\n        RunContext[AgentDepsT],\n        AsyncIterable[AgentStreamEvent],\n    ],\n    Awaitable[None],\n]\n\n```\n\nA function that receives agent RunContext and an async iterable of events from the model's streaming response and the agent's execution of tools.",
  "content_length": 376831
}