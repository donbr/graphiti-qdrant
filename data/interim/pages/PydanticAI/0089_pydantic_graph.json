{
  "title": "`pydantic_graph`",
  "source_url": null,
  "content": "### Graph\n\nBases: `Generic[StateT, DepsT, RunEndT]`\n\nDefinition of a graph.\n\nIn `pydantic-graph`, a graph is a collection of nodes that can be run in sequence. The nodes define their outgoing edges — e.g. which nodes may be run next, and thereby the structure of the graph.\n\nHere's a very simple example of a graph which increments a number by 1, but makes sure the number is never 42 at the end.\n\nnever_42.py\n\n```py\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\n\nfrom pydantic_graph import BaseNode, End, Graph, GraphRunContext\n\n@dataclass\nclass MyState:\n    number: int\n\n@dataclass\nclass Increment(BaseNode[MyState]):\n    async def run(self, ctx: GraphRunContext) -> Check42:\n        ctx.state.number += 1\n        return Check42()\n\n@dataclass\nclass Check42(BaseNode[MyState, None, int]):\n    async def run(self, ctx: GraphRunContext) -> Increment | End[int]:\n        if ctx.state.number == 42:\n            return Increment()\n        else:\n            return End(ctx.state.number)\n\nnever_42_graph = Graph(nodes=(Increment, Check42))\n\n```\n\n*(This example is complete, it can be run \"as is\")*\n\nSee run For an example of running graph, and mermaid_code for an example of generating a mermaid diagram from the graph.\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n````python\n@dataclass(init=False)\nclass Graph(Generic[StateT, DepsT, RunEndT]):\n    \"\"\"Definition of a graph.\n\n    In `pydantic-graph`, a graph is a collection of nodes that can be run in sequence. The nodes define\n    their outgoing edges — e.g. which nodes may be run next, and thereby the structure of the graph.\n\n    Here's a very simple example of a graph which increments a number by 1, but makes sure the number is never\n    42 at the end.\n\n    ```py {title=\"never_42.py\" noqa=\"I001\"}\n    from __future__ import annotations\n\n    from dataclasses import dataclass\n\n    from pydantic_graph import BaseNode, End, Graph, GraphRunContext\n\n    @dataclass\n    class MyState:\n        number: int\n\n    @dataclass\n    class Increment(BaseNode[MyState]):\n        async def run(self, ctx: GraphRunContext) -> Check42:\n            ctx.state.number += 1\n            return Check42()\n\n    @dataclass\n    class Check42(BaseNode[MyState, None, int]):\n        async def run(self, ctx: GraphRunContext) -> Increment | End[int]:\n            if ctx.state.number == 42:\n                return Increment()\n            else:\n                return End(ctx.state.number)\n\n    never_42_graph = Graph(nodes=(Increment, Check42))\n    ```\n    _(This example is complete, it can be run \"as is\")_\n\n    See [`run`][pydantic_graph.graph.Graph.run] For an example of running graph, and\n    [`mermaid_code`][pydantic_graph.graph.Graph.mermaid_code] for an example of generating a mermaid diagram\n    from the graph.\n    \"\"\"\n\n    name: str | None\n    node_defs: dict[str, NodeDef[StateT, DepsT, RunEndT]]\n    _state_type: type[StateT] | _utils.Unset = field(repr=False)\n    _run_end_type: type[RunEndT] | _utils.Unset = field(repr=False)\n    auto_instrument: bool = field(repr=False)\n\n    def __init__(\n        self,\n        *,\n        nodes: Sequence[type[BaseNode[StateT, DepsT, RunEndT]]],\n        name: str | None = None,\n        state_type: type[StateT] | _utils.Unset = _utils.UNSET,\n        run_end_type: type[RunEndT] | _utils.Unset = _utils.UNSET,\n        auto_instrument: bool = True,\n    ):\n        \"\"\"Create a graph from a sequence of nodes.\n\n        Args:\n            nodes: The nodes which make up the graph, nodes need to be unique and all be generic in the same\n                state type.\n            name: Optional name for the graph, if not provided the name will be inferred from the calling frame\n                on the first call to a graph method.\n            state_type: The type of the state for the graph, this can generally be inferred from `nodes`.\n            run_end_type: The type of the result of running the graph, this can generally be inferred from `nodes`.\n            auto_instrument: Whether to create a span for the graph run and the execution of each node's run method.\n        \"\"\"\n        self.name = name\n        self._state_type = state_type\n        self._run_end_type = run_end_type\n        self.auto_instrument = auto_instrument\n\n        parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n        self.node_defs = {}\n        for node in nodes:\n            self._register_node(node, parent_namespace)\n\n        self._validate_edges()\n\n    async def run(\n        self,\n        start_node: BaseNode[StateT, DepsT, RunEndT],\n        *,\n        state: StateT = None,\n        deps: DepsT = None,\n        persistence: BaseStatePersistence[StateT, RunEndT] | None = None,\n        infer_name: bool = True,\n    ) -> GraphRunResult[StateT, RunEndT]:\n        \"\"\"Run the graph from a starting node until it ends.\n\n        Args:\n            start_node: the first node to run, since the graph definition doesn't define the entry point in the graph,\n                you need to provide the starting node.\n            state: The initial state of the graph.\n            deps: The dependencies of the graph.\n            persistence: State persistence interface, defaults to\n                [`SimpleStatePersistence`][pydantic_graph.SimpleStatePersistence] if `None`.\n            infer_name: Whether to infer the graph name from the calling frame.\n\n        Returns:\n            A `GraphRunResult` containing information about the run, including its final result.\n\n        Here's an example of running the graph from [above][pydantic_graph.graph.Graph]:\n\n        ```py {title=\"run_never_42.py\" noqa=\"I001\" requires=\"never_42.py\"}\n        from never_42 import Increment, MyState, never_42_graph\n\n        async def main():\n            state = MyState(1)\n            await never_42_graph.run(Increment(), state=state)\n            print(state)\n            #> MyState(number=2)\n\n            state = MyState(41)\n            await never_42_graph.run(Increment(), state=state)\n            print(state)\n            #> MyState(number=43)\n        ```\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n\n        async with self.iter(\n            start_node, state=state, deps=deps, persistence=persistence, infer_name=False\n        ) as graph_run:\n            async for _node in graph_run:\n                pass\n\n        result = graph_run.result\n        assert result is not None, 'GraphRun should have a result'\n        return result\n\n    def run_sync(\n        self,\n        start_node: BaseNode[StateT, DepsT, RunEndT],\n        *,\n        state: StateT = None,\n        deps: DepsT = None,\n        persistence: BaseStatePersistence[StateT, RunEndT] | None = None,\n        infer_name: bool = True,\n    ) -> GraphRunResult[StateT, RunEndT]:\n        \"\"\"Synchronously run the graph.\n\n        This is a convenience method that wraps [`self.run`][pydantic_graph.Graph.run] with `loop.run_until_complete(...)`.\n        You therefore can't use this method inside async code or if there's an active event loop.\n\n        Args:\n            start_node: the first node to run, since the graph definition doesn't define the entry point in the graph,\n                you need to provide the starting node.\n            state: The initial state of the graph.\n            deps: The dependencies of the graph.\n            persistence: State persistence interface, defaults to\n                [`SimpleStatePersistence`][pydantic_graph.SimpleStatePersistence] if `None`.\n            infer_name: Whether to infer the graph name from the calling frame.\n\n        Returns:\n            The result type from ending the run and the history of the run.\n        \"\"\"\n        if infer_name and self.name is None:  # pragma: no branch\n            self._infer_name(inspect.currentframe())\n\n        return _utils.get_event_loop().run_until_complete(\n            self.run(start_node, state=state, deps=deps, persistence=persistence, infer_name=False)\n        )\n\n    @asynccontextmanager\n    async def iter(\n        self,\n        start_node: BaseNode[StateT, DepsT, RunEndT],\n        *,\n        state: StateT = None,\n        deps: DepsT = None,\n        persistence: BaseStatePersistence[StateT, RunEndT] | None = None,\n        span: AbstractContextManager[AbstractSpan] | None = None,\n        infer_name: bool = True,\n    ) -> AsyncIterator[GraphRun[StateT, DepsT, RunEndT]]:\n        \"\"\"A contextmanager which can be used to iterate over the graph's nodes as they are executed.\n\n        This method returns a `GraphRun` object which can be used to async-iterate over the nodes of this `Graph` as\n        they are executed. This is the API to use if you want to record or interact with the nodes as the graph\n        execution unfolds.\n\n        The `GraphRun` can also be used to manually drive the graph execution by calling\n        [`GraphRun.next`][pydantic_graph.graph.GraphRun.next].\n\n        The `GraphRun` provides access to the full run history, state, deps, and the final result of the run once\n        it has completed.\n\n        For more details, see the API documentation of [`GraphRun`][pydantic_graph.graph.GraphRun].\n\n        Args:\n            start_node: the first node to run. Since the graph definition doesn't define the entry point in the graph,\n                you need to provide the starting node.\n            state: The initial state of the graph.\n            deps: The dependencies of the graph.\n            persistence: State persistence interface, defaults to\n                [`SimpleStatePersistence`][pydantic_graph.SimpleStatePersistence] if `None`.\n            span: The span to use for the graph run. If not provided, a new span will be created.\n            infer_name: Whether to infer the graph name from the calling frame.\n\n        Returns: A GraphRun that can be async iterated over to drive the graph to completion.\n        \"\"\"\n        if infer_name and self.name is None:\n            # f_back because `asynccontextmanager` adds one frame\n            if frame := inspect.currentframe():  # pragma: no branch\n                self._infer_name(frame.f_back)\n\n        if persistence is None:\n            persistence = SimpleStatePersistence()\n        persistence.set_graph_types(self)\n\n        with ExitStack() as stack:\n            entered_span: AbstractSpan | None = None\n            if span is None:\n                if self.auto_instrument:  # pragma: no branch\n                    # Separate variable because we actually don't want logfire's f-string magic here,\n                    # we want the span_name to be preformatted for other backends\n                    # as requested in https://github.com/pydantic/pydantic-ai/issues/3173.\n                    span_name = f'run graph {self.name}'\n                    entered_span = stack.enter_context(logfire_span(span_name, graph=self))\n            else:\n                entered_span = stack.enter_context(span)\n            traceparent = None if entered_span is None else get_traceparent(entered_span)\n            yield GraphRun[StateT, DepsT, RunEndT](\n                graph=self,\n                start_node=start_node,\n                persistence=persistence,\n                state=state,\n                deps=deps,\n                traceparent=traceparent,\n            )\n\n    @asynccontextmanager\n    async def iter_from_persistence(\n        self,\n        persistence: BaseStatePersistence[StateT, RunEndT],\n        *,\n        deps: DepsT = None,\n        span: AbstractContextManager[AbstractSpan] | None = None,\n        infer_name: bool = True,\n    ) -> AsyncIterator[GraphRun[StateT, DepsT, RunEndT]]:\n        \"\"\"A contextmanager to iterate over the graph's nodes as they are executed, created from a persistence object.\n\n        This method has similar functionality to [`iter`][pydantic_graph.graph.Graph.iter],\n        but instead of passing the node to run, it will restore the node and state from state persistence.\n\n        Args:\n            persistence: The state persistence interface to use.\n            deps: The dependencies of the graph.\n            span: The span to use for the graph run. If not provided, a new span will be created.\n            infer_name: Whether to infer the graph name from the calling frame.\n\n        Returns: A GraphRun that can be async iterated over to drive the graph to completion.\n        \"\"\"\n        if infer_name and self.name is None:\n            # f_back because `asynccontextmanager` adds one frame\n            if frame := inspect.currentframe():  # pragma: no branch\n                self._infer_name(frame.f_back)\n\n        persistence.set_graph_types(self)\n\n        snapshot = await persistence.load_next()\n        if snapshot is None:\n            raise exceptions.GraphRuntimeError('Unable to restore snapshot from state persistence.')\n\n        snapshot.node.set_snapshot_id(snapshot.id)\n\n        if self.auto_instrument and span is None:  # pragma: no branch\n            span = logfire_span('run graph {graph.name}', graph=self)\n\n        with ExitStack() as stack:\n            entered_span = None if span is None else stack.enter_context(span)\n            traceparent = None if entered_span is None else get_traceparent(entered_span)\n            yield GraphRun[StateT, DepsT, RunEndT](\n                graph=self,\n                start_node=snapshot.node,\n                persistence=persistence,\n                state=snapshot.state,\n                deps=deps,\n                snapshot_id=snapshot.id,\n                traceparent=traceparent,\n            )\n\n    async def initialize(\n        self,\n        node: BaseNode[StateT, DepsT, RunEndT],\n        persistence: BaseStatePersistence[StateT, RunEndT],\n        *,\n        state: StateT = None,\n        infer_name: bool = True,\n    ) -> None:\n        \"\"\"Initialize a new graph run in persistence without running it.\n\n        This is useful if you want to set up a graph run to be run later, e.g. via\n        [`iter_from_persistence`][pydantic_graph.graph.Graph.iter_from_persistence].\n\n        Args:\n            node: The node to run first.\n            persistence: State persistence interface.\n            state: The start state of the graph.\n            infer_name: Whether to infer the graph name from the calling frame.\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n\n        persistence.set_graph_types(self)\n        await persistence.snapshot_node(state, node)\n\n    def mermaid_code(\n        self,\n        *,\n        start_node: Sequence[mermaid.NodeIdent] | mermaid.NodeIdent | None = None,\n        title: str | None | typing_extensions.Literal[False] = None,\n        edge_labels: bool = True,\n        notes: bool = True,\n        highlighted_nodes: Sequence[mermaid.NodeIdent] | mermaid.NodeIdent | None = None,\n        highlight_css: str = mermaid.DEFAULT_HIGHLIGHT_CSS,\n        infer_name: bool = True,\n        direction: mermaid.StateDiagramDirection | None = None,\n    ) -> str:\n        \"\"\"Generate a diagram representing the graph as [mermaid](https://mermaid.js.org/) diagram.\n\n        This method calls [`pydantic_graph.mermaid.generate_code`][pydantic_graph.mermaid.generate_code].\n\n        Args:\n            start_node: The node or nodes which can start the graph.\n            title: The title of the diagram, use `False` to not include a title.\n            edge_labels: Whether to include edge labels.\n            notes: Whether to include notes on each node.\n            highlighted_nodes: Optional node or nodes to highlight.\n            highlight_css: The CSS to use for highlighting nodes.\n            infer_name: Whether to infer the graph name from the calling frame.\n            direction: The direction of flow.\n\n        Returns:\n            The mermaid code for the graph, which can then be rendered as a diagram.\n\n        Here's an example of generating a diagram for the graph from [above][pydantic_graph.graph.Graph]:\n\n        ```py {title=\"mermaid_never_42.py\" requires=\"never_42.py\"}\n        from never_42 import Increment, never_42_graph\n\n        print(never_42_graph.mermaid_code(start_node=Increment))\n        '''\n        ---\n        title: never_42_graph\n        ---\n        stateDiagram-v2\n          [*] --> Increment\n          Increment --> Check42\n          Check42 --> Increment\n          Check42 --> [*]\n        '''\n        ```\n\n        The rendered diagram will look like this:\n\n        ```mermaid\n        ---\n        title: never_42_graph\n        ---\n        stateDiagram-v2\n          [*] --> Increment\n          Increment --> Check42\n          Check42 --> Increment\n          Check42 --> [*]\n        ```\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n        if title is None and self.name:\n            title = self.name\n        return mermaid.generate_code(\n            self,\n            start_node=start_node,\n            highlighted_nodes=highlighted_nodes,\n            highlight_css=highlight_css,\n            title=title or None,\n            edge_labels=edge_labels,\n            notes=notes,\n            direction=direction,\n        )\n\n    def mermaid_image(\n        self, infer_name: bool = True, **kwargs: typing_extensions.Unpack[mermaid.MermaidConfig]\n    ) -> bytes:\n        \"\"\"Generate a diagram representing the graph as an image.\n\n        The format and diagram can be customized using `kwargs`,\n        see [`pydantic_graph.mermaid.MermaidConfig`][pydantic_graph.mermaid.MermaidConfig].\n\n        !!! note \"Uses external service\"\n            This method makes a request to [mermaid.ink](https://mermaid.ink) to render the image, `mermaid.ink`\n            is a free service not affiliated with Pydantic.\n\n        Args:\n            infer_name: Whether to infer the graph name from the calling frame.\n            **kwargs: Additional arguments to pass to `mermaid.request_image`.\n\n        Returns:\n            The image bytes.\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n        if 'title' not in kwargs and self.name:\n            kwargs['title'] = self.name\n        return mermaid.request_image(self, **kwargs)\n\n    def mermaid_save(\n        self, path: Path | str, /, *, infer_name: bool = True, **kwargs: typing_extensions.Unpack[mermaid.MermaidConfig]\n    ) -> None:\n        \"\"\"Generate a diagram representing the graph and save it as an image.\n\n        The format and diagram can be customized using `kwargs`,\n        see [`pydantic_graph.mermaid.MermaidConfig`][pydantic_graph.mermaid.MermaidConfig].\n\n        !!! note \"Uses external service\"\n            This method makes a request to [mermaid.ink](https://mermaid.ink) to render the image, `mermaid.ink`\n            is a free service not affiliated with Pydantic.\n\n        Args:\n            path: The path to save the image to.\n            infer_name: Whether to infer the graph name from the calling frame.\n            **kwargs: Additional arguments to pass to `mermaid.save_image`.\n        \"\"\"\n        if infer_name and self.name is None:\n            self._infer_name(inspect.currentframe())\n        if 'title' not in kwargs and self.name:\n            kwargs['title'] = self.name\n        mermaid.save_image(path, self, **kwargs)\n\n    def get_nodes(self) -> Sequence[type[BaseNode[StateT, DepsT, RunEndT]]]:\n        \"\"\"Get the nodes in the graph.\"\"\"\n        return [node_def.node for node_def in self.node_defs.values()]\n\n    @cached_property\n    def inferred_types(self) -> tuple[type[StateT], type[RunEndT]]:\n        # Get the types of the state and run end from the graph.\n        if _utils.is_set(self._state_type) and _utils.is_set(self._run_end_type):\n            return self._state_type, self._run_end_type\n\n        state_type = self._state_type\n        run_end_type = self._run_end_type\n\n        for node_def in self.node_defs.values():\n            for base in typing_extensions.get_original_bases(node_def.node):\n                if typing_extensions.get_origin(base) is BaseNode:\n                    args = typing_extensions.get_args(base)\n                    if not _utils.is_set(state_type) and args:\n                        state_type = args[0]\n\n                    if not _utils.is_set(run_end_type) and len(args) == 3:\n                        t = args[2]\n                        if not typing_objects.is_never(t):\n                            run_end_type = t\n                    if _utils.is_set(state_type) and _utils.is_set(run_end_type):\n                        return state_type, run_end_type  # pyright: ignore[reportReturnType]\n                    # break the inner (bases) loop\n                    break\n\n        if not _utils.is_set(state_type):  # pragma: no branch\n            # state defaults to None, so use that if we can't infer it\n            state_type = None\n        if not _utils.is_set(run_end_type):\n            # this happens if a graph has no return nodes, use None so any downstream errors are clear\n            run_end_type = None\n        return state_type, run_end_type  # pyright: ignore[reportReturnType]\n\n    def _register_node(\n        self,\n        node: type[BaseNode[StateT, DepsT, RunEndT]],\n        parent_namespace: dict[str, Any] | None,\n    ) -> None:\n        node_id = node.get_node_id()\n        if existing_node := self.node_defs.get(node_id):\n            raise exceptions.GraphSetupError(\n                f'Node ID `{node_id}` is not unique — found on {existing_node.node} and {node}'\n            )\n        else:\n            self.node_defs[node_id] = node.get_node_def(parent_namespace)\n\n    def _validate_edges(self):\n        known_node_ids = self.node_defs.keys()\n        bad_edges: dict[str, list[str]] = {}\n\n        for node_id, node_def in self.node_defs.items():\n            for edge in node_def.next_node_edges.keys():\n                if edge not in known_node_ids:\n                    bad_edges.setdefault(edge, []).append(f'`{node_id}`')\n\n        if bad_edges:\n            bad_edges_list = [f'`{k}` is referenced by {_utils.comma_and(v)}' for k, v in bad_edges.items()]\n            if len(bad_edges_list) == 1:\n                raise exceptions.GraphSetupError(f'{bad_edges_list[0]} but not included in the graph.')\n            else:\n                b = '\\n'.join(f' {be}' for be in bad_edges_list)\n                raise exceptions.GraphSetupError(\n                    f'Nodes are referenced in the graph but not included in the graph:\\n{b}'\n                )\n\n    def _infer_name(self, function_frame: types.FrameType | None) -> None:\n        \"\"\"Infer the agent name from the call frame.\n\n        Usage should be `self._infer_name(inspect.currentframe())`.\n\n        Copied from `Agent`.\n        \"\"\"\n        assert self.name is None, 'Name already set'\n        if function_frame is not None and (parent_frame := function_frame.f_back):  # pragma: no branch\n            for name, item in parent_frame.f_locals.items():\n                if item is self:\n                    self.name = name\n                    return\n            if parent_frame.f_locals != parent_frame.f_globals:  # pragma: no branch\n                # if we couldn't find the agent in locals and globals are a different dict, try globals\n                for name, item in parent_frame.f_globals.items():  # pragma: no branch\n                    if item is self:\n                        self.name = name\n                        return\n\n````\n\n#### __init__\n\n```python\n__init__(\n    *,\n    nodes: Sequence[type[BaseNode[StateT, DepsT, RunEndT]]],\n    name: str | None = None,\n    state_type: type[StateT] | Unset = UNSET,\n    run_end_type: type[RunEndT] | Unset = UNSET,\n    auto_instrument: bool = True\n)\n\n```\n\nCreate a graph from a sequence of nodes.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `nodes` | `Sequence[type[BaseNode[StateT, DepsT, RunEndT]]]` | The nodes which make up the graph, nodes need to be unique and all be generic in the same state type. | *required* | | `name` | `str | None` | Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method. | `None` | | `state_type` | `type[StateT] | Unset` | The type of the state for the graph, this can generally be inferred from nodes. | `UNSET` | | `run_end_type` | `type[RunEndT] | Unset` | The type of the result of running the graph, this can generally be inferred from nodes. | `UNSET` | | `auto_instrument` | `bool` | Whether to create a span for the graph run and the execution of each node's run method. | `True` |\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\ndef __init__(\n    self,\n    *,\n    nodes: Sequence[type[BaseNode[StateT, DepsT, RunEndT]]],\n    name: str | None = None,\n    state_type: type[StateT] | _utils.Unset = _utils.UNSET,\n    run_end_type: type[RunEndT] | _utils.Unset = _utils.UNSET,\n    auto_instrument: bool = True,\n):\n    \"\"\"Create a graph from a sequence of nodes.\n\n    Args:\n        nodes: The nodes which make up the graph, nodes need to be unique and all be generic in the same\n            state type.\n        name: Optional name for the graph, if not provided the name will be inferred from the calling frame\n            on the first call to a graph method.\n        state_type: The type of the state for the graph, this can generally be inferred from `nodes`.\n        run_end_type: The type of the result of running the graph, this can generally be inferred from `nodes`.\n        auto_instrument: Whether to create a span for the graph run and the execution of each node's run method.\n    \"\"\"\n    self.name = name\n    self._state_type = state_type\n    self._run_end_type = run_end_type\n    self.auto_instrument = auto_instrument\n\n    parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n    self.node_defs = {}\n    for node in nodes:\n        self._register_node(node, parent_namespace)\n\n    self._validate_edges()\n\n```\n\n#### run\n\n```python\nrun(\n    start_node: BaseNode[StateT, DepsT, RunEndT],\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    persistence: (\n        BaseStatePersistence[StateT, RunEndT] | None\n    ) = None,\n    infer_name: bool = True\n) -> GraphRunResult[StateT, RunEndT]\n\n```\n\nRun the graph from a starting node until it ends.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `start_node` | `BaseNode[StateT, DepsT, RunEndT]` | the first node to run, since the graph definition doesn't define the entry point in the graph, you need to provide the starting node. | *required* | | `state` | `StateT` | The initial state of the graph. | `None` | | `deps` | `DepsT` | The dependencies of the graph. | `None` | | `persistence` | `BaseStatePersistence[StateT, RunEndT] | None` | State persistence interface, defaults to SimpleStatePersistence if None. | `None` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `GraphRunResult[StateT, RunEndT]` | A GraphRunResult containing information about the run, including its final result. |\n\nHere's an example of running the graph from above:\n\nrun_never_42.py\n\n```py\nfrom never_42 import Increment, MyState, never_42_graph\n\nasync def main():\n    state = MyState(1)\n    await never_42_graph.run(Increment(), state=state)\n    print(state)\n    #> MyState(number=2)\n\n    state = MyState(41)\n    await never_42_graph.run(Increment(), state=state)\n    print(state)\n    #> MyState(number=43)\n\n```\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n````python\nasync def run(\n    self,\n    start_node: BaseNode[StateT, DepsT, RunEndT],\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    persistence: BaseStatePersistence[StateT, RunEndT] | None = None,\n    infer_name: bool = True,\n) -> GraphRunResult[StateT, RunEndT]:\n    \"\"\"Run the graph from a starting node until it ends.\n\n    Args:\n        start_node: the first node to run, since the graph definition doesn't define the entry point in the graph,\n            you need to provide the starting node.\n        state: The initial state of the graph.\n        deps: The dependencies of the graph.\n        persistence: State persistence interface, defaults to\n            [`SimpleStatePersistence`][pydantic_graph.SimpleStatePersistence] if `None`.\n        infer_name: Whether to infer the graph name from the calling frame.\n\n    Returns:\n        A `GraphRunResult` containing information about the run, including its final result.\n\n    Here's an example of running the graph from [above][pydantic_graph.graph.Graph]:\n\n    ```py {title=\"run_never_42.py\" noqa=\"I001\" requires=\"never_42.py\"}\n    from never_42 import Increment, MyState, never_42_graph\n\n    async def main():\n        state = MyState(1)\n        await never_42_graph.run(Increment(), state=state)\n        print(state)\n        #> MyState(number=2)\n\n        state = MyState(41)\n        await never_42_graph.run(Increment(), state=state)\n        print(state)\n        #> MyState(number=43)\n    ```\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n\n    async with self.iter(\n        start_node, state=state, deps=deps, persistence=persistence, infer_name=False\n    ) as graph_run:\n        async for _node in graph_run:\n            pass\n\n    result = graph_run.result\n    assert result is not None, 'GraphRun should have a result'\n    return result\n\n````\n\n#### run_sync\n\n```python\nrun_sync(\n    start_node: BaseNode[StateT, DepsT, RunEndT],\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    persistence: (\n        BaseStatePersistence[StateT, RunEndT] | None\n    ) = None,\n    infer_name: bool = True\n) -> GraphRunResult[StateT, RunEndT]\n\n```\n\nSynchronously run the graph.\n\nThis is a convenience method that wraps self.run with `loop.run_until_complete(...)`. You therefore can't use this method inside async code or if there's an active event loop.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `start_node` | `BaseNode[StateT, DepsT, RunEndT]` | the first node to run, since the graph definition doesn't define the entry point in the graph, you need to provide the starting node. | *required* | | `state` | `StateT` | The initial state of the graph. | `None` | | `deps` | `DepsT` | The dependencies of the graph. | `None` | | `persistence` | `BaseStatePersistence[StateT, RunEndT] | None` | State persistence interface, defaults to SimpleStatePersistence if None. | `None` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `GraphRunResult[StateT, RunEndT]` | The result type from ending the run and the history of the run. |\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\ndef run_sync(\n    self,\n    start_node: BaseNode[StateT, DepsT, RunEndT],\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    persistence: BaseStatePersistence[StateT, RunEndT] | None = None,\n    infer_name: bool = True,\n) -> GraphRunResult[StateT, RunEndT]:\n    \"\"\"Synchronously run the graph.\n\n    This is a convenience method that wraps [`self.run`][pydantic_graph.Graph.run] with `loop.run_until_complete(...)`.\n    You therefore can't use this method inside async code or if there's an active event loop.\n\n    Args:\n        start_node: the first node to run, since the graph definition doesn't define the entry point in the graph,\n            you need to provide the starting node.\n        state: The initial state of the graph.\n        deps: The dependencies of the graph.\n        persistence: State persistence interface, defaults to\n            [`SimpleStatePersistence`][pydantic_graph.SimpleStatePersistence] if `None`.\n        infer_name: Whether to infer the graph name from the calling frame.\n\n    Returns:\n        The result type from ending the run and the history of the run.\n    \"\"\"\n    if infer_name and self.name is None:  # pragma: no branch\n        self._infer_name(inspect.currentframe())\n\n    return _utils.get_event_loop().run_until_complete(\n        self.run(start_node, state=state, deps=deps, persistence=persistence, infer_name=False)\n    )\n\n```\n\n#### iter\n\n```python\niter(\n    start_node: BaseNode[StateT, DepsT, RunEndT],\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    persistence: (\n        BaseStatePersistence[StateT, RunEndT] | None\n    ) = None,\n    span: (\n        AbstractContextManager[AbstractSpan] | None\n    ) = None,\n    infer_name: bool = True\n) -> AsyncIterator[GraphRun[StateT, DepsT, RunEndT]]\n\n```\n\nA contextmanager which can be used to iterate over the graph's nodes as they are executed.\n\nThis method returns a `GraphRun` object which can be used to async-iterate over the nodes of this `Graph` as they are executed. This is the API to use if you want to record or interact with the nodes as the graph execution unfolds.\n\nThe `GraphRun` can also be used to manually drive the graph execution by calling GraphRun.next.\n\nThe `GraphRun` provides access to the full run history, state, deps, and the final result of the run once it has completed.\n\nFor more details, see the API documentation of GraphRun.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `start_node` | `BaseNode[StateT, DepsT, RunEndT]` | the first node to run. Since the graph definition doesn't define the entry point in the graph, you need to provide the starting node. | *required* | | `state` | `StateT` | The initial state of the graph. | `None` | | `deps` | `DepsT` | The dependencies of the graph. | `None` | | `persistence` | `BaseStatePersistence[StateT, RunEndT] | None` | State persistence interface, defaults to SimpleStatePersistence if None. | `None` | | `span` | `AbstractContextManager[AbstractSpan] | None` | The span to use for the graph run. If not provided, a new span will be created. | `None` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` |\n\nReturns: A GraphRun that can be async iterated over to drive the graph to completion.\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\n@asynccontextmanager\nasync def iter(\n    self,\n    start_node: BaseNode[StateT, DepsT, RunEndT],\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    persistence: BaseStatePersistence[StateT, RunEndT] | None = None,\n    span: AbstractContextManager[AbstractSpan] | None = None,\n    infer_name: bool = True,\n) -> AsyncIterator[GraphRun[StateT, DepsT, RunEndT]]:\n    \"\"\"A contextmanager which can be used to iterate over the graph's nodes as they are executed.\n\n    This method returns a `GraphRun` object which can be used to async-iterate over the nodes of this `Graph` as\n    they are executed. This is the API to use if you want to record or interact with the nodes as the graph\n    execution unfolds.\n\n    The `GraphRun` can also be used to manually drive the graph execution by calling\n    [`GraphRun.next`][pydantic_graph.graph.GraphRun.next].\n\n    The `GraphRun` provides access to the full run history, state, deps, and the final result of the run once\n    it has completed.\n\n    For more details, see the API documentation of [`GraphRun`][pydantic_graph.graph.GraphRun].\n\n    Args:\n        start_node: the first node to run. Since the graph definition doesn't define the entry point in the graph,\n            you need to provide the starting node.\n        state: The initial state of the graph.\n        deps: The dependencies of the graph.\n        persistence: State persistence interface, defaults to\n            [`SimpleStatePersistence`][pydantic_graph.SimpleStatePersistence] if `None`.\n        span: The span to use for the graph run. If not provided, a new span will be created.\n        infer_name: Whether to infer the graph name from the calling frame.\n\n    Returns: A GraphRun that can be async iterated over to drive the graph to completion.\n    \"\"\"\n    if infer_name and self.name is None:\n        # f_back because `asynccontextmanager` adds one frame\n        if frame := inspect.currentframe():  # pragma: no branch\n            self._infer_name(frame.f_back)\n\n    if persistence is None:\n        persistence = SimpleStatePersistence()\n    persistence.set_graph_types(self)\n\n    with ExitStack() as stack:\n        entered_span: AbstractSpan | None = None\n        if span is None:\n            if self.auto_instrument:  # pragma: no branch\n                # Separate variable because we actually don't want logfire's f-string magic here,\n                # we want the span_name to be preformatted for other backends\n                # as requested in https://github.com/pydantic/pydantic-ai/issues/3173.\n                span_name = f'run graph {self.name}'\n                entered_span = stack.enter_context(logfire_span(span_name, graph=self))\n        else:\n            entered_span = stack.enter_context(span)\n        traceparent = None if entered_span is None else get_traceparent(entered_span)\n        yield GraphRun[StateT, DepsT, RunEndT](\n            graph=self,\n            start_node=start_node,\n            persistence=persistence,\n            state=state,\n            deps=deps,\n            traceparent=traceparent,\n        )\n\n```\n\n#### iter_from_persistence\n\n```python\niter_from_persistence(\n    persistence: BaseStatePersistence[StateT, RunEndT],\n    *,\n    deps: DepsT = None,\n    span: (\n        AbstractContextManager[AbstractSpan] | None\n    ) = None,\n    infer_name: bool = True\n) -> AsyncIterator[GraphRun[StateT, DepsT, RunEndT]]\n\n```\n\nA contextmanager to iterate over the graph's nodes as they are executed, created from a persistence object.\n\nThis method has similar functionality to iter, but instead of passing the node to run, it will restore the node and state from state persistence.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `persistence` | `BaseStatePersistence[StateT, RunEndT]` | The state persistence interface to use. | *required* | | `deps` | `DepsT` | The dependencies of the graph. | `None` | | `span` | `AbstractContextManager[AbstractSpan] | None` | The span to use for the graph run. If not provided, a new span will be created. | `None` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` |\n\nReturns: A GraphRun that can be async iterated over to drive the graph to completion.\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\n@asynccontextmanager\nasync def iter_from_persistence(\n    self,\n    persistence: BaseStatePersistence[StateT, RunEndT],\n    *,\n    deps: DepsT = None,\n    span: AbstractContextManager[AbstractSpan] | None = None,\n    infer_name: bool = True,\n) -> AsyncIterator[GraphRun[StateT, DepsT, RunEndT]]:\n    \"\"\"A contextmanager to iterate over the graph's nodes as they are executed, created from a persistence object.\n\n    This method has similar functionality to [`iter`][pydantic_graph.graph.Graph.iter],\n    but instead of passing the node to run, it will restore the node and state from state persistence.\n\n    Args:\n        persistence: The state persistence interface to use.\n        deps: The dependencies of the graph.\n        span: The span to use for the graph run. If not provided, a new span will be created.\n        infer_name: Whether to infer the graph name from the calling frame.\n\n    Returns: A GraphRun that can be async iterated over to drive the graph to completion.\n    \"\"\"\n    if infer_name and self.name is None:\n        # f_back because `asynccontextmanager` adds one frame\n        if frame := inspect.currentframe():  # pragma: no branch\n            self._infer_name(frame.f_back)\n\n    persistence.set_graph_types(self)\n\n    snapshot = await persistence.load_next()\n    if snapshot is None:\n        raise exceptions.GraphRuntimeError('Unable to restore snapshot from state persistence.')\n\n    snapshot.node.set_snapshot_id(snapshot.id)\n\n    if self.auto_instrument and span is None:  # pragma: no branch\n        span = logfire_span('run graph {graph.name}', graph=self)\n\n    with ExitStack() as stack:\n        entered_span = None if span is None else stack.enter_context(span)\n        traceparent = None if entered_span is None else get_traceparent(entered_span)\n        yield GraphRun[StateT, DepsT, RunEndT](\n            graph=self,\n            start_node=snapshot.node,\n            persistence=persistence,\n            state=snapshot.state,\n            deps=deps,\n            snapshot_id=snapshot.id,\n            traceparent=traceparent,\n        )\n\n```\n\n#### initialize\n\n```python\ninitialize(\n    node: BaseNode[StateT, DepsT, RunEndT],\n    persistence: BaseStatePersistence[StateT, RunEndT],\n    *,\n    state: StateT = None,\n    infer_name: bool = True\n) -> None\n\n```\n\nInitialize a new graph run in persistence without running it.\n\nThis is useful if you want to set up a graph run to be run later, e.g. via iter_from_persistence.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `node` | `BaseNode[StateT, DepsT, RunEndT]` | The node to run first. | *required* | | `persistence` | `BaseStatePersistence[StateT, RunEndT]` | State persistence interface. | *required* | | `state` | `StateT` | The start state of the graph. | `None` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` |\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\nasync def initialize(\n    self,\n    node: BaseNode[StateT, DepsT, RunEndT],\n    persistence: BaseStatePersistence[StateT, RunEndT],\n    *,\n    state: StateT = None,\n    infer_name: bool = True,\n) -> None:\n    \"\"\"Initialize a new graph run in persistence without running it.\n\n    This is useful if you want to set up a graph run to be run later, e.g. via\n    [`iter_from_persistence`][pydantic_graph.graph.Graph.iter_from_persistence].\n\n    Args:\n        node: The node to run first.\n        persistence: State persistence interface.\n        state: The start state of the graph.\n        infer_name: Whether to infer the graph name from the calling frame.\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n\n    persistence.set_graph_types(self)\n    await persistence.snapshot_node(state, node)\n\n```\n\n#### mermaid_code\n\n```python\nmermaid_code(\n    *,\n    start_node: (\n        Sequence[NodeIdent] | NodeIdent | None\n    ) = None,\n    title: str | None | Literal[False] = None,\n    edge_labels: bool = True,\n    notes: bool = True,\n    highlighted_nodes: (\n        Sequence[NodeIdent] | NodeIdent | None\n    ) = None,\n    highlight_css: str = DEFAULT_HIGHLIGHT_CSS,\n    infer_name: bool = True,\n    direction: StateDiagramDirection | None = None\n) -> str\n\n```\n\nGenerate a diagram representing the graph as [mermaid](https://mermaid.js.org/) diagram.\n\nThis method calls pydantic_graph.mermaid.generate_code.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `start_node` | `Sequence[NodeIdent] | NodeIdent | None` | The node or nodes which can start the graph. | `None` | | `title` | `str | None | Literal[False]` | The title of the diagram, use False to not include a title. | `None` | | `edge_labels` | `bool` | Whether to include edge labels. | `True` | | `notes` | `bool` | Whether to include notes on each node. | `True` | | `highlighted_nodes` | `Sequence[NodeIdent] | NodeIdent | None` | Optional node or nodes to highlight. | `None` | | `highlight_css` | `str` | The CSS to use for highlighting nodes. | `DEFAULT_HIGHLIGHT_CSS` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` | | `direction` | `StateDiagramDirection | None` | The direction of flow. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `str` | The mermaid code for the graph, which can then be rendered as a diagram. |\n\nHere's an example of generating a diagram for the graph from above:\n\nmermaid_never_42.py\n\n```py\nfrom never_42 import Increment, never_42_graph\n\nprint(never_42_graph.mermaid_code(start_node=Increment))\n'''\n---\ntitle: never_42_graph\n---\nstateDiagram-v2\n  [*] --> Increment\n  Increment --> Check42\n  Check42 --> Increment\n  Check42 --> [*]\n'''\n\n```\n\nThe rendered diagram will look like this:\n\n```\n---\ntitle: never_42_graph\n---\nstateDiagram-v2\n  [*] --> Increment\n  Increment --> Check42\n  Check42 --> Increment\n  Check42 --> [*]\n```\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n````python\ndef mermaid_code(\n    self,\n    *,\n    start_node: Sequence[mermaid.NodeIdent] | mermaid.NodeIdent | None = None,\n    title: str | None | typing_extensions.Literal[False] = None,\n    edge_labels: bool = True,\n    notes: bool = True,\n    highlighted_nodes: Sequence[mermaid.NodeIdent] | mermaid.NodeIdent | None = None,\n    highlight_css: str = mermaid.DEFAULT_HIGHLIGHT_CSS,\n    infer_name: bool = True,\n    direction: mermaid.StateDiagramDirection | None = None,\n) -> str:\n    \"\"\"Generate a diagram representing the graph as [mermaid](https://mermaid.js.org/) diagram.\n\n    This method calls [`pydantic_graph.mermaid.generate_code`][pydantic_graph.mermaid.generate_code].\n\n    Args:\n        start_node: The node or nodes which can start the graph.\n        title: The title of the diagram, use `False` to not include a title.\n        edge_labels: Whether to include edge labels.\n        notes: Whether to include notes on each node.\n        highlighted_nodes: Optional node or nodes to highlight.\n        highlight_css: The CSS to use for highlighting nodes.\n        infer_name: Whether to infer the graph name from the calling frame.\n        direction: The direction of flow.\n\n    Returns:\n        The mermaid code for the graph, which can then be rendered as a diagram.\n\n    Here's an example of generating a diagram for the graph from [above][pydantic_graph.graph.Graph]:\n\n    ```py {title=\"mermaid_never_42.py\" requires=\"never_42.py\"}\n    from never_42 import Increment, never_42_graph\n\n    print(never_42_graph.mermaid_code(start_node=Increment))\n    '''\n    ---\n    title: never_42_graph\n    ---\n    stateDiagram-v2\n      [*] --> Increment\n      Increment --> Check42\n      Check42 --> Increment\n      Check42 --> [*]\n    '''\n    ```\n\n    The rendered diagram will look like this:\n\n    ```mermaid\n    ---\n    title: never_42_graph\n    ---\n    stateDiagram-v2\n      [*] --> Increment\n      Increment --> Check42\n      Check42 --> Increment\n      Check42 --> [*]\n    ```\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n    if title is None and self.name:\n        title = self.name\n    return mermaid.generate_code(\n        self,\n        start_node=start_node,\n        highlighted_nodes=highlighted_nodes,\n        highlight_css=highlight_css,\n        title=title or None,\n        edge_labels=edge_labels,\n        notes=notes,\n        direction=direction,\n    )\n\n````\n\n#### mermaid_image\n\n```python\nmermaid_image(\n    infer_name: bool = True, **kwargs: Unpack[MermaidConfig]\n) -> bytes\n\n```\n\nGenerate a diagram representing the graph as an image.\n\nThe format and diagram can be customized using `kwargs`, see pydantic_graph.mermaid.MermaidConfig.\n\nUses external service\n\nThis method makes a request to [mermaid.ink](https://mermaid.ink) to render the image, `mermaid.ink` is a free service not affiliated with Pydantic.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` | | `**kwargs` | `Unpack[MermaidConfig]` | Additional arguments to pass to mermaid.request_image. | `{}` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `bytes` | The image bytes. |\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\ndef mermaid_image(\n    self, infer_name: bool = True, **kwargs: typing_extensions.Unpack[mermaid.MermaidConfig]\n) -> bytes:\n    \"\"\"Generate a diagram representing the graph as an image.\n\n    The format and diagram can be customized using `kwargs`,\n    see [`pydantic_graph.mermaid.MermaidConfig`][pydantic_graph.mermaid.MermaidConfig].\n\n    !!! note \"Uses external service\"\n        This method makes a request to [mermaid.ink](https://mermaid.ink) to render the image, `mermaid.ink`\n        is a free service not affiliated with Pydantic.\n\n    Args:\n        infer_name: Whether to infer the graph name from the calling frame.\n        **kwargs: Additional arguments to pass to `mermaid.request_image`.\n\n    Returns:\n        The image bytes.\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n    if 'title' not in kwargs and self.name:\n        kwargs['title'] = self.name\n    return mermaid.request_image(self, **kwargs)\n\n```\n\n#### mermaid_save\n\n```python\nmermaid_save(\n    path: Path | str,\n    /,\n    *,\n    infer_name: bool = True,\n    **kwargs: Unpack[MermaidConfig],\n) -> None\n\n```\n\nGenerate a diagram representing the graph and save it as an image.\n\nThe format and diagram can be customized using `kwargs`, see pydantic_graph.mermaid.MermaidConfig.\n\nUses external service\n\nThis method makes a request to [mermaid.ink](https://mermaid.ink) to render the image, `mermaid.ink` is a free service not affiliated with Pydantic.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `path` | `Path | str` | The path to save the image to. | *required* | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` | | `**kwargs` | `Unpack[MermaidConfig]` | Additional arguments to pass to mermaid.save_image. | `{}` |\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\ndef mermaid_save(\n    self, path: Path | str, /, *, infer_name: bool = True, **kwargs: typing_extensions.Unpack[mermaid.MermaidConfig]\n) -> None:\n    \"\"\"Generate a diagram representing the graph and save it as an image.\n\n    The format and diagram can be customized using `kwargs`,\n    see [`pydantic_graph.mermaid.MermaidConfig`][pydantic_graph.mermaid.MermaidConfig].\n\n    !!! note \"Uses external service\"\n        This method makes a request to [mermaid.ink](https://mermaid.ink) to render the image, `mermaid.ink`\n        is a free service not affiliated with Pydantic.\n\n    Args:\n        path: The path to save the image to.\n        infer_name: Whether to infer the graph name from the calling frame.\n        **kwargs: Additional arguments to pass to `mermaid.save_image`.\n    \"\"\"\n    if infer_name and self.name is None:\n        self._infer_name(inspect.currentframe())\n    if 'title' not in kwargs and self.name:\n        kwargs['title'] = self.name\n    mermaid.save_image(path, self, **kwargs)\n\n```\n\n#### get_nodes\n\n```python\nget_nodes() -> (\n    Sequence[type[BaseNode[StateT, DepsT, RunEndT]]]\n)\n\n```\n\nGet the nodes in the graph.\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\ndef get_nodes(self) -> Sequence[type[BaseNode[StateT, DepsT, RunEndT]]]:\n    \"\"\"Get the nodes in the graph.\"\"\"\n    return [node_def.node for node_def in self.node_defs.values()]\n\n```\n\n### GraphRun\n\nBases: `Generic[StateT, DepsT, RunEndT]`\n\nA stateful, async-iterable run of a Graph.\n\nYou typically get a `GraphRun` instance from calling `async with [my_graph.iter(...)][pydantic_graph.graph.Graph.iter] as graph_run:`. That gives you the ability to iterate through nodes as they run, either by `async for` iteration or by repeatedly calling `.next(...)`.\n\nHere's an example of iterating over the graph from above: iter_never_42.py\n\n```py\nfrom copy import deepcopy\nfrom never_42 import Increment, MyState, never_42_graph\n\nasync def main():\n    state = MyState(1)\n    async with never_42_graph.iter(Increment(), state=state) as graph_run:\n        node_states = [(graph_run.next_node, deepcopy(graph_run.state))]\n        async for node in graph_run:\n            node_states.append((node, deepcopy(graph_run.state)))\n        print(node_states)\n        '''\n        [\n            (Increment(), MyState(number=1)),\n            (Increment(), MyState(number=1)),\n            (Check42(), MyState(number=2)),\n            (End(data=2), MyState(number=2)),\n        ]\n        '''\n\n    state = MyState(41)\n    async with never_42_graph.iter(Increment(), state=state) as graph_run:\n        node_states = [(graph_run.next_node, deepcopy(graph_run.state))]\n        async for node in graph_run:\n            node_states.append((node, deepcopy(graph_run.state)))\n        print(node_states)\n        '''\n        [\n            (Increment(), MyState(number=41)),\n            (Increment(), MyState(number=41)),\n            (Check42(), MyState(number=42)),\n            (Increment(), MyState(number=42)),\n            (Check42(), MyState(number=43)),\n            (End(data=43), MyState(number=43)),\n        ]\n        '''\n\n```\n\nSee the GraphRun.next documentation for an example of how to manually drive the graph run.\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n````python\nclass GraphRun(Generic[StateT, DepsT, RunEndT]):\n    \"\"\"A stateful, async-iterable run of a [`Graph`][pydantic_graph.graph.Graph].\n\n    You typically get a `GraphRun` instance from calling\n    `async with [my_graph.iter(...)][pydantic_graph.graph.Graph.iter] as graph_run:`. That gives you the ability to iterate\n    through nodes as they run, either by `async for` iteration or by repeatedly calling `.next(...)`.\n\n    Here's an example of iterating over the graph from [above][pydantic_graph.graph.Graph]:\n    ```py {title=\"iter_never_42.py\" noqa=\"I001\" requires=\"never_42.py\"}\n    from copy import deepcopy\n    from never_42 import Increment, MyState, never_42_graph\n\n    async def main():\n        state = MyState(1)\n        async with never_42_graph.iter(Increment(), state=state) as graph_run:\n            node_states = [(graph_run.next_node, deepcopy(graph_run.state))]\n            async for node in graph_run:\n                node_states.append((node, deepcopy(graph_run.state)))\n            print(node_states)\n            '''\n            [\n                (Increment(), MyState(number=1)),\n                (Increment(), MyState(number=1)),\n                (Check42(), MyState(number=2)),\n                (End(data=2), MyState(number=2)),\n            ]\n            '''\n\n        state = MyState(41)\n        async with never_42_graph.iter(Increment(), state=state) as graph_run:\n            node_states = [(graph_run.next_node, deepcopy(graph_run.state))]\n            async for node in graph_run:\n                node_states.append((node, deepcopy(graph_run.state)))\n            print(node_states)\n            '''\n            [\n                (Increment(), MyState(number=41)),\n                (Increment(), MyState(number=41)),\n                (Check42(), MyState(number=42)),\n                (Increment(), MyState(number=42)),\n                (Check42(), MyState(number=43)),\n                (End(data=43), MyState(number=43)),\n            ]\n            '''\n    ```\n\n    See the [`GraphRun.next` documentation][pydantic_graph.graph.GraphRun.next] for an example of how to manually\n    drive the graph run.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        graph: Graph[StateT, DepsT, RunEndT],\n        start_node: BaseNode[StateT, DepsT, RunEndT],\n        persistence: BaseStatePersistence[StateT, RunEndT],\n        state: StateT,\n        deps: DepsT,\n        traceparent: str | None,\n        snapshot_id: str | None = None,\n    ):\n        \"\"\"Create a new run for a given graph, starting at the specified node.\n\n        Typically, you'll use [`Graph.iter`][pydantic_graph.graph.Graph.iter] rather than calling this directly.\n\n        Args:\n            graph: The [`Graph`][pydantic_graph.graph.Graph] to run.\n            start_node: The node where execution will begin.\n            persistence: State persistence interface.\n            state: A shared state object or primitive (like a counter, dataclass, etc.) that is available\n                to all nodes via `ctx.state`.\n            deps: Optional dependencies that each node can access via `ctx.deps`, e.g. database connections,\n                configuration, or logging clients.\n            traceparent: The traceparent for the span used for the graph run.\n            snapshot_id: The ID of the snapshot the node came from.\n        \"\"\"\n        self.graph = graph\n        self.persistence = persistence\n        self._snapshot_id: str | None = snapshot_id\n        self.state = state\n        self.deps = deps\n\n        self.__traceparent = traceparent\n        self._next_node: BaseNode[StateT, DepsT, RunEndT] | End[RunEndT] = start_node\n        self._is_started: bool = False\n\n    @overload\n    def _traceparent(self, *, required: typing_extensions.Literal[False]) -> str | None: ...\n    @overload\n    def _traceparent(self) -> str: ...\n    def _traceparent(self, *, required: bool = True) -> str | None:\n        if self.__traceparent is None and required:  # pragma: no cover\n            raise exceptions.GraphRuntimeError('No span was created for this graph run')\n        return self.__traceparent\n\n    @property\n    def next_node(self) -> BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]:\n        \"\"\"The next node that will be run in the graph.\n\n        This is the next node that will be used during async iteration, or if a node is not passed to `self.next(...)`.\n        \"\"\"\n        return self._next_node\n\n    @property\n    def result(self) -> GraphRunResult[StateT, RunEndT] | None:\n        \"\"\"The final result of the graph run if the run is completed, otherwise `None`.\"\"\"\n        if not isinstance(self._next_node, End):\n            return None  # The GraphRun has not finished running\n        return GraphRunResult[StateT, RunEndT](\n            self._next_node.data,\n            state=self.state,\n            persistence=self.persistence,\n            traceparent=self._traceparent(required=False),\n        )\n\n    async def next(\n        self, node: BaseNode[StateT, DepsT, RunEndT] | None = None\n    ) -> BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]:\n        \"\"\"Manually drive the graph run by passing in the node you want to run next.\n\n        This lets you inspect or mutate the node before continuing execution, or skip certain nodes\n        under dynamic conditions. The graph run should stop when you return an [`End`][pydantic_graph.nodes.End] node.\n\n        Here's an example of using `next` to drive the graph from [above][pydantic_graph.graph.Graph]:\n        ```py {title=\"next_never_42.py\" noqa=\"I001\" requires=\"never_42.py\"}\n        from copy import deepcopy\n        from pydantic_graph import End\n        from never_42 import Increment, MyState, never_42_graph\n\n        async def main():\n            state = MyState(48)\n            async with never_42_graph.iter(Increment(), state=state) as graph_run:\n                next_node = graph_run.next_node  # start with the first node\n                node_states = [(next_node, deepcopy(graph_run.state))]\n\n                while not isinstance(next_node, End):\n                    if graph_run.state.number == 50:\n                        graph_run.state.number = 42\n                    next_node = await graph_run.next(next_node)\n                    node_states.append((next_node, deepcopy(graph_run.state)))\n\n                print(node_states)\n                '''\n                [\n                    (Increment(), MyState(number=48)),\n                    (Check42(), MyState(number=49)),\n                    (End(data=49), MyState(number=49)),\n                ]\n                '''\n        ```\n\n        Args:\n            node: The node to run next in the graph. If not specified, uses `self.next_node`, which is initialized to\n                the `start_node` of the run and updated each time a new node is returned.\n\n        Returns:\n            The next node returned by the graph logic, or an [`End`][pydantic_graph.nodes.End] node if\n            the run has completed.\n        \"\"\"\n        if node is None:\n            # This cast is necessary because self._next_node could be an `End`. You'll get a runtime error if that's\n            # the case, but if it is, the only way to get there would be to have tried calling next manually after\n            # the run finished. Either way, maybe it would be better to not do this cast...\n            node = cast(BaseNode[StateT, DepsT, RunEndT], self._next_node)\n            node_snapshot_id = node.get_snapshot_id()\n        else:\n            node_snapshot_id = node.get_snapshot_id()\n\n        if node_snapshot_id != self._snapshot_id:\n            await self.persistence.snapshot_node_if_new(node_snapshot_id, self.state, node)\n            self._snapshot_id = node_snapshot_id\n\n        if not isinstance(node, BaseNode):\n            # While technically this is not compatible with the documented method signature, it's an easy mistake to\n            # make, and we should eagerly provide a more helpful error message than you'd get otherwise.\n            raise TypeError(f'`next` must be called with a `BaseNode` instance, got {node!r}.')\n\n        node_id = node.get_node_id()\n        if node_id not in self.graph.node_defs:\n            raise exceptions.GraphRuntimeError(f'Node `{node}` is not in the graph.')\n\n        with ExitStack() as stack:\n            if self.graph.auto_instrument:  # pragma: no branch\n                # Separate variable because we actually don't want logfire's f-string magic here,\n                # we want the span_name to be preformatted for other backends\n                # as requested in https://github.com/pydantic/pydantic-ai/issues/3173.\n                span_name = f'run node {node_id}'\n                stack.enter_context(logfire_span(span_name, node_id=node_id, node=node))\n\n            async with self.persistence.record_run(node_snapshot_id):\n                ctx = GraphRunContext(state=self.state, deps=self.deps)\n                self._next_node = await node.run(ctx)\n\n        if isinstance(self._next_node, End):\n            self._snapshot_id = self._next_node.get_snapshot_id()\n            await self.persistence.snapshot_end(self.state, self._next_node)\n        elif isinstance(self._next_node, BaseNode):\n            self._snapshot_id = self._next_node.get_snapshot_id()\n            await self.persistence.snapshot_node(self.state, self._next_node)\n        else:\n            raise exceptions.GraphRuntimeError(\n                f'Invalid node return type: `{type(self._next_node).__name__}`. Expected `BaseNode` or `End`.'\n            )\n\n        return self._next_node\n\n    def __aiter__(self) -> AsyncIterator[BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]]:\n        return self\n\n    async def __anext__(self) -> BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]:\n        \"\"\"Use the last returned node as the input to `Graph.next`.\"\"\"\n        if not self._is_started:\n            self._is_started = True\n            return self._next_node\n\n        if isinstance(self._next_node, End):\n            raise StopAsyncIteration\n\n        return await self.next(self._next_node)\n\n    def __repr__(self) -> str:\n        return f'<GraphRun graph={self.graph.name or \"[unnamed]\"}>'\n\n````\n\n#### __init__\n\n```python\n__init__(\n    *,\n    graph: Graph[StateT, DepsT, RunEndT],\n    start_node: BaseNode[StateT, DepsT, RunEndT],\n    persistence: BaseStatePersistence[StateT, RunEndT],\n    state: StateT,\n    deps: DepsT,\n    traceparent: str | None,\n    snapshot_id: str | None = None\n)\n\n```\n\nCreate a new run for a given graph, starting at the specified node.\n\nTypically, you'll use Graph.iter rather than calling this directly.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `graph` | `Graph[StateT, DepsT, RunEndT]` | The Graph to run. | *required* | | `start_node` | `BaseNode[StateT, DepsT, RunEndT]` | The node where execution will begin. | *required* | | `persistence` | `BaseStatePersistence[StateT, RunEndT]` | State persistence interface. | *required* | | `state` | `StateT` | A shared state object or primitive (like a counter, dataclass, etc.) that is available to all nodes via ctx.state. | *required* | | `deps` | `DepsT` | Optional dependencies that each node can access via ctx.deps, e.g. database connections, configuration, or logging clients. | *required* | | `traceparent` | `str | None` | The traceparent for the span used for the graph run. | *required* | | `snapshot_id` | `str | None` | The ID of the snapshot the node came from. | `None` |\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\ndef __init__(\n    self,\n    *,\n    graph: Graph[StateT, DepsT, RunEndT],\n    start_node: BaseNode[StateT, DepsT, RunEndT],\n    persistence: BaseStatePersistence[StateT, RunEndT],\n    state: StateT,\n    deps: DepsT,\n    traceparent: str | None,\n    snapshot_id: str | None = None,\n):\n    \"\"\"Create a new run for a given graph, starting at the specified node.\n\n    Typically, you'll use [`Graph.iter`][pydantic_graph.graph.Graph.iter] rather than calling this directly.\n\n    Args:\n        graph: The [`Graph`][pydantic_graph.graph.Graph] to run.\n        start_node: The node where execution will begin.\n        persistence: State persistence interface.\n        state: A shared state object or primitive (like a counter, dataclass, etc.) that is available\n            to all nodes via `ctx.state`.\n        deps: Optional dependencies that each node can access via `ctx.deps`, e.g. database connections,\n            configuration, or logging clients.\n        traceparent: The traceparent for the span used for the graph run.\n        snapshot_id: The ID of the snapshot the node came from.\n    \"\"\"\n    self.graph = graph\n    self.persistence = persistence\n    self._snapshot_id: str | None = snapshot_id\n    self.state = state\n    self.deps = deps\n\n    self.__traceparent = traceparent\n    self._next_node: BaseNode[StateT, DepsT, RunEndT] | End[RunEndT] = start_node\n    self._is_started: bool = False\n\n```\n\n#### next_node\n\n```python\nnext_node: BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]\n\n```\n\nThe next node that will be run in the graph.\n\nThis is the next node that will be used during async iteration, or if a node is not passed to `self.next(...)`.\n\n#### result\n\n```python\nresult: GraphRunResult[StateT, RunEndT] | None\n\n```\n\nThe final result of the graph run if the run is completed, otherwise `None`.\n\n#### next\n\n```python\nnext(\n    node: BaseNode[StateT, DepsT, RunEndT] | None = None,\n) -> BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]\n\n```\n\nManually drive the graph run by passing in the node you want to run next.\n\nThis lets you inspect or mutate the node before continuing execution, or skip certain nodes under dynamic conditions. The graph run should stop when you return an End node.\n\nHere's an example of using `next` to drive the graph from above: next_never_42.py\n\n```py\nfrom copy import deepcopy\nfrom pydantic_graph import End\nfrom never_42 import Increment, MyState, never_42_graph\n\nasync def main():\n    state = MyState(48)\n    async with never_42_graph.iter(Increment(), state=state) as graph_run:\n        next_node = graph_run.next_node  # start with the first node\n        node_states = [(next_node, deepcopy(graph_run.state))]\n\n        while not isinstance(next_node, End):\n            if graph_run.state.number == 50:\n                graph_run.state.number = 42\n            next_node = await graph_run.next(next_node)\n            node_states.append((next_node, deepcopy(graph_run.state)))\n\n        print(node_states)\n        '''\n        [\n            (Increment(), MyState(number=48)),\n            (Check42(), MyState(number=49)),\n            (End(data=49), MyState(number=49)),\n        ]\n        '''\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `node` | `BaseNode[StateT, DepsT, RunEndT] | None` | The node to run next in the graph. If not specified, uses self.next_node, which is initialized to the start_node of the run and updated each time a new node is returned. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]` | The next node returned by the graph logic, or an End node if | | `BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]` | the run has completed. |\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n````python\nasync def next(\n    self, node: BaseNode[StateT, DepsT, RunEndT] | None = None\n) -> BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]:\n    \"\"\"Manually drive the graph run by passing in the node you want to run next.\n\n    This lets you inspect or mutate the node before continuing execution, or skip certain nodes\n    under dynamic conditions. The graph run should stop when you return an [`End`][pydantic_graph.nodes.End] node.\n\n    Here's an example of using `next` to drive the graph from [above][pydantic_graph.graph.Graph]:\n    ```py {title=\"next_never_42.py\" noqa=\"I001\" requires=\"never_42.py\"}\n    from copy import deepcopy\n    from pydantic_graph import End\n    from never_42 import Increment, MyState, never_42_graph\n\n    async def main():\n        state = MyState(48)\n        async with never_42_graph.iter(Increment(), state=state) as graph_run:\n            next_node = graph_run.next_node  # start with the first node\n            node_states = [(next_node, deepcopy(graph_run.state))]\n\n            while not isinstance(next_node, End):\n                if graph_run.state.number == 50:\n                    graph_run.state.number = 42\n                next_node = await graph_run.next(next_node)\n                node_states.append((next_node, deepcopy(graph_run.state)))\n\n            print(node_states)\n            '''\n            [\n                (Increment(), MyState(number=48)),\n                (Check42(), MyState(number=49)),\n                (End(data=49), MyState(number=49)),\n            ]\n            '''\n    ```\n\n    Args:\n        node: The node to run next in the graph. If not specified, uses `self.next_node`, which is initialized to\n            the `start_node` of the run and updated each time a new node is returned.\n\n    Returns:\n        The next node returned by the graph logic, or an [`End`][pydantic_graph.nodes.End] node if\n        the run has completed.\n    \"\"\"\n    if node is None:\n        # This cast is necessary because self._next_node could be an `End`. You'll get a runtime error if that's\n        # the case, but if it is, the only way to get there would be to have tried calling next manually after\n        # the run finished. Either way, maybe it would be better to not do this cast...\n        node = cast(BaseNode[StateT, DepsT, RunEndT], self._next_node)\n        node_snapshot_id = node.get_snapshot_id()\n    else:\n        node_snapshot_id = node.get_snapshot_id()\n\n    if node_snapshot_id != self._snapshot_id:\n        await self.persistence.snapshot_node_if_new(node_snapshot_id, self.state, node)\n        self._snapshot_id = node_snapshot_id\n\n    if not isinstance(node, BaseNode):\n        # While technically this is not compatible with the documented method signature, it's an easy mistake to\n        # make, and we should eagerly provide a more helpful error message than you'd get otherwise.\n        raise TypeError(f'`next` must be called with a `BaseNode` instance, got {node!r}.')\n\n    node_id = node.get_node_id()\n    if node_id not in self.graph.node_defs:\n        raise exceptions.GraphRuntimeError(f'Node `{node}` is not in the graph.')\n\n    with ExitStack() as stack:\n        if self.graph.auto_instrument:  # pragma: no branch\n            # Separate variable because we actually don't want logfire's f-string magic here,\n            # we want the span_name to be preformatted for other backends\n            # as requested in https://github.com/pydantic/pydantic-ai/issues/3173.\n            span_name = f'run node {node_id}'\n            stack.enter_context(logfire_span(span_name, node_id=node_id, node=node))\n\n        async with self.persistence.record_run(node_snapshot_id):\n            ctx = GraphRunContext(state=self.state, deps=self.deps)\n            self._next_node = await node.run(ctx)\n\n    if isinstance(self._next_node, End):\n        self._snapshot_id = self._next_node.get_snapshot_id()\n        await self.persistence.snapshot_end(self.state, self._next_node)\n    elif isinstance(self._next_node, BaseNode):\n        self._snapshot_id = self._next_node.get_snapshot_id()\n        await self.persistence.snapshot_node(self.state, self._next_node)\n    else:\n        raise exceptions.GraphRuntimeError(\n            f'Invalid node return type: `{type(self._next_node).__name__}`. Expected `BaseNode` or `End`.'\n        )\n\n    return self._next_node\n\n````\n\n#### __anext__\n\n```python\n__anext__() -> (\n    BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]\n)\n\n```\n\nUse the last returned node as the input to `Graph.next`.\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\nasync def __anext__(self) -> BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]:\n    \"\"\"Use the last returned node as the input to `Graph.next`.\"\"\"\n    if not self._is_started:\n        self._is_started = True\n        return self._next_node\n\n    if isinstance(self._next_node, End):\n        raise StopAsyncIteration\n\n    return await self.next(self._next_node)\n\n```\n\n### GraphRunResult\n\nBases: `Generic[StateT, RunEndT]`\n\nThe final result of running a graph.\n\nSource code in `pydantic_graph/pydantic_graph/graph.py`\n\n```python\n@dataclass(init=False)\nclass GraphRunResult(Generic[StateT, RunEndT]):\n    \"\"\"The final result of running a graph.\"\"\"\n\n    output: RunEndT\n    state: StateT\n    persistence: BaseStatePersistence[StateT, RunEndT] = field(repr=False)\n\n    def __init__(\n        self,\n        output: RunEndT,\n        state: StateT,\n        persistence: BaseStatePersistence[StateT, RunEndT],\n        traceparent: str | None = None,\n    ):\n        self.output = output\n        self.state = state\n        self.persistence = persistence\n        self.__traceparent = traceparent\n\n    @overload\n    def _traceparent(self, *, required: typing_extensions.Literal[False]) -> str | None: ...\n    @overload\n    def _traceparent(self) -> str: ...\n    def _traceparent(self, *, required: bool = True) -> str | None:  # pragma: no cover\n        if self.__traceparent is None and required:\n            raise exceptions.GraphRuntimeError('No span was created for this graph run.')\n        return self.__traceparent\n\n```",
  "content_length": 74127
}