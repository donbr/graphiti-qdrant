{
  "title": "`pydantic_ai.ext`",
  "source_url": null,
  "content": "### tool_from_langchain\n\n```python\ntool_from_langchain(langchain_tool: LangChainTool) -> Tool\n\n```\n\nCreates a Pydantic AI tool proxy from a LangChain tool.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `langchain_tool` | `LangChainTool` | The LangChain tool to wrap. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Tool` | A Pydantic AI tool that corresponds to the LangChain tool. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/ext/langchain.py`\n\n```python\ndef tool_from_langchain(langchain_tool: LangChainTool) -> Tool:\n    \"\"\"Creates a Pydantic AI tool proxy from a LangChain tool.\n\n    Args:\n        langchain_tool: The LangChain tool to wrap.\n\n    Returns:\n        A Pydantic AI tool that corresponds to the LangChain tool.\n    \"\"\"\n    function_name = langchain_tool.name\n    function_description = langchain_tool.description\n    inputs = langchain_tool.args.copy()\n    required = sorted({name for name, detail in inputs.items() if 'default' not in detail})\n    schema: JsonSchemaValue = langchain_tool.get_input_jsonschema()\n    if 'additionalProperties' not in schema:\n        schema['additionalProperties'] = False\n    if required:\n        schema['required'] = required\n\n    defaults = {name: detail['default'] for name, detail in inputs.items() if 'default' in detail}\n\n    # restructures the arguments to match langchain tool run\n    def proxy(*args: Any, **kwargs: Any) -> str:\n        assert not args, 'This should always be called with kwargs'\n        kwargs = defaults | kwargs\n        return langchain_tool.run(kwargs)\n\n    return Tool.from_schema(\n        function=proxy,\n        name=function_name,\n        description=function_description,\n        json_schema=schema,\n    )\n\n```\n\n### LangChainToolset\n\nBases: `FunctionToolset`\n\nA toolset that wraps LangChain tools.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ext/langchain.py`\n\n```python\nclass LangChainToolset(FunctionToolset):\n    \"\"\"A toolset that wraps LangChain tools.\"\"\"\n\n    def __init__(self, tools: list[LangChainTool], *, id: str | None = None):\n        super().__init__([tool_from_langchain(tool) for tool in tools], id=id)\n\n```\n\n### tool_from_aci\n\n```python\ntool_from_aci(\n    aci_function: str, linked_account_owner_id: str\n) -> Tool\n\n```\n\nCreates a Pydantic AI tool proxy from an ACI.dev function.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `aci_function` | `str` | The ACI.dev function to wrap. | *required* | | `linked_account_owner_id` | `str` | The ACI user ID to execute the function on behalf of. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Tool` | A Pydantic AI tool that corresponds to the ACI.dev tool. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/ext/aci.py`\n\n```python\ndef tool_from_aci(aci_function: str, linked_account_owner_id: str) -> Tool:\n    \"\"\"Creates a Pydantic AI tool proxy from an ACI.dev function.\n\n    Args:\n        aci_function: The ACI.dev function to wrap.\n        linked_account_owner_id: The ACI user ID to execute the function on behalf of.\n\n    Returns:\n        A Pydantic AI tool that corresponds to the ACI.dev tool.\n    \"\"\"\n    aci = ACI()\n    function_definition = aci.functions.get_definition(aci_function)\n    function_name = function_definition['function']['name']\n    function_description = function_definition['function']['description']\n    inputs = function_definition['function']['parameters']\n\n    json_schema = {\n        'additionalProperties': inputs.get('additionalProperties', False),\n        'properties': inputs.get('properties', {}),\n        'required': inputs.get('required', []),\n        # Default to 'object' if not specified\n        'type': inputs.get('type', 'object'),\n    }\n\n    # Clean the schema\n    json_schema = _clean_schema(json_schema)\n\n    def implementation(*args: Any, **kwargs: Any) -> str:\n        if args:\n            raise TypeError('Positional arguments are not allowed')\n        return aci.handle_function_call(\n            function_name,\n            kwargs,\n            linked_account_owner_id=linked_account_owner_id,\n            allowed_apps_only=True,\n        )\n\n    return Tool.from_schema(\n        function=implementation,\n        name=function_name,\n        description=function_description,\n        json_schema=json_schema,\n    )\n\n```\n\n### ACIToolset\n\nBases: `FunctionToolset`\n\nA toolset that wraps ACI.dev tools.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ext/aci.py`\n\n```python\nclass ACIToolset(FunctionToolset):\n    \"\"\"A toolset that wraps ACI.dev tools.\"\"\"\n\n    def __init__(self, aci_functions: Sequence[str], linked_account_owner_id: str, *, id: str | None = None):\n        super().__init__(\n            [tool_from_aci(aci_function, linked_account_owner_id) for aci_function in aci_functions], id=id\n        )\n\n```",
  "content_length": 4809
}