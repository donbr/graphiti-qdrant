{
  "title": "`pydantic_graph.beta`",
  "source_url": null,
  "content": "The next version of the pydantic-graph framework with enhanced graph execution capabilities.\n\nThis module provides a parallel control flow graph execution framework with support for:\n\n- 'Step' nodes for task execution\n- 'Decision' nodes for conditional branching\n- 'Fork' nodes for parallel execution coordination\n- 'Join' nodes and 'Reducer's for re-joining parallel executions\n- Mermaid diagram generation for graph visualization\n\n### Graph\n\nBases: `Generic[StateT, DepsT, InputT, OutputT]`\n\nA complete graph definition ready for execution.\n\nThe Graph class represents a complete workflow graph with typed inputs, outputs, state, and dependencies. It contains all nodes, edges, and metadata needed for execution.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies InputT: The type of the input data OutputT: The type of the output data\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\n@dataclass(repr=False)\nclass Graph(Generic[StateT, DepsT, InputT, OutputT]):\n    \"\"\"A complete graph definition ready for execution.\n\n    The Graph class represents a complete workflow graph with typed inputs,\n    outputs, state, and dependencies. It contains all nodes, edges, and\n    metadata needed for execution.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        InputT: The type of the input data\n        OutputT: The type of the output data\n    \"\"\"\n\n    name: str | None\n    \"\"\"Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\"\"\"\n\n    state_type: type[StateT]\n    \"\"\"The type of the graph state.\"\"\"\n\n    deps_type: type[DepsT]\n    \"\"\"The type of the dependencies.\"\"\"\n\n    input_type: type[InputT]\n    \"\"\"The type of the input data.\"\"\"\n\n    output_type: type[OutputT]\n    \"\"\"The type of the output data.\"\"\"\n\n    auto_instrument: bool\n    \"\"\"Whether to automatically create instrumentation spans.\"\"\"\n\n    nodes: dict[NodeID, AnyNode]\n    \"\"\"All nodes in the graph indexed by their ID.\"\"\"\n\n    edges_by_source: dict[NodeID, list[Path]]\n    \"\"\"Outgoing paths from each source node.\"\"\"\n\n    parent_forks: dict[JoinID, ParentFork[NodeID]]\n    \"\"\"Parent fork information for each join node.\"\"\"\n\n    intermediate_join_nodes: dict[JoinID, set[JoinID]]\n    \"\"\"For each join, the set of other joins that appear between it and its parent fork.\n\n    Used to determine which joins are \"final\" (have no other joins as intermediates) and\n    which joins should preserve fork stacks when proceeding downstream.\"\"\"\n\n    def get_parent_fork(self, join_id: JoinID) -> ParentFork[NodeID]:\n        \"\"\"Get the parent fork information for a join node.\n\n        Args:\n            join_id: The ID of the join node\n\n        Returns:\n            The parent fork information for the join\n\n        Raises:\n            RuntimeError: If the join ID is not found or has no parent fork\n        \"\"\"\n        result = self.parent_forks.get(join_id)\n        if result is None:\n            raise RuntimeError(f'Node {join_id} is not a join node or did not have a dominating fork (this is a bug)')\n        return result\n\n    def is_final_join(self, join_id: JoinID) -> bool:\n        \"\"\"Check if a join is 'final' (has no downstream joins with the same parent fork).\n\n        A join is non-final if it appears as an intermediate node for another join\n        with the same parent fork.\n\n        Args:\n            join_id: The ID of the join node\n\n        Returns:\n            True if the join is final, False if it's non-final\n        \"\"\"\n        # Check if this join appears in any other join's intermediate_join_nodes\n        for intermediate_joins in self.intermediate_join_nodes.values():\n            if join_id in intermediate_joins:\n                return False\n        return True\n\n    async def run(\n        self,\n        *,\n        state: StateT = None,\n        deps: DepsT = None,\n        inputs: InputT = None,\n        span: AbstractContextManager[AbstractSpan] | None = None,\n        infer_name: bool = True,\n    ) -> OutputT:\n        \"\"\"Execute the graph and return the final output.\n\n        This is the main entry point for graph execution. It runs the graph\n        to completion and returns the final output value.\n\n        Args:\n            state: The graph state instance\n            deps: The dependencies instance\n            inputs: The input data for the graph\n            span: Optional span for tracing/instrumentation\n            infer_name: Whether to infer the graph name from the calling frame.\n\n        Returns:\n            The final output from the graph execution\n        \"\"\"\n        if infer_name and self.name is None:\n            inferred_name = infer_obj_name(self, depth=2)\n            if inferred_name is not None:  # pragma: no branch\n                self.name = inferred_name\n\n        async with self.iter(state=state, deps=deps, inputs=inputs, span=span, infer_name=False) as graph_run:\n            # Note: This would probably be better using `async for _ in graph_run`, but this tests the `next` method,\n            # which I'm less confident will be implemented correctly if not used on the critical path. We can change it\n            # once we have tests, etc.\n            event: Any = None\n            while True:\n                try:\n                    event = await graph_run.next(event)\n                except StopAsyncIteration:\n                    assert isinstance(event, EndMarker), 'Graph run should end with an EndMarker.'\n                    return cast(EndMarker[OutputT], event).value\n\n    @asynccontextmanager\n    async def iter(\n        self,\n        *,\n        state: StateT = None,\n        deps: DepsT = None,\n        inputs: InputT = None,\n        span: AbstractContextManager[AbstractSpan] | None = None,\n        infer_name: bool = True,\n    ) -> AsyncIterator[GraphRun[StateT, DepsT, OutputT]]:\n        \"\"\"Create an iterator for step-by-step graph execution.\n\n        This method allows for more fine-grained control over graph execution,\n        enabling inspection of intermediate states and results.\n\n        Args:\n            state: The graph state instance\n            deps: The dependencies instance\n            inputs: The input data for the graph\n            span: Optional span for tracing/instrumentation\n            infer_name: Whether to infer the graph name from the calling frame.\n\n        Yields:\n            A GraphRun instance that can be iterated for step-by-step execution\n        \"\"\"\n        if infer_name and self.name is None:\n            inferred_name = infer_obj_name(self, depth=3)  # depth=3 because asynccontextmanager adds one\n            if inferred_name is not None:  # pragma: no branch\n                self.name = inferred_name\n\n        with ExitStack() as stack:\n            entered_span: AbstractSpan | None = None\n            if span is None:\n                if self.auto_instrument:\n                    entered_span = stack.enter_context(logfire_span('run graph {graph.name}', graph=self))\n            else:\n                entered_span = stack.enter_context(span)\n            traceparent = None if entered_span is None else get_traceparent(entered_span)\n            async with GraphRun[StateT, DepsT, OutputT](\n                graph=self,\n                state=state,\n                deps=deps,\n                inputs=inputs,\n                traceparent=traceparent,\n            ) as graph_run:\n                yield graph_run\n\n    def render(self, *, title: str | None = None, direction: StateDiagramDirection | None = None) -> str:\n        \"\"\"Render the graph as a Mermaid diagram string.\n\n        Args:\n            title: Optional title for the diagram\n            direction: Optional direction for the diagram layout\n\n        Returns:\n            A string containing the Mermaid diagram representation\n        \"\"\"\n        from pydantic_graph.beta.mermaid import build_mermaid_graph\n\n        return build_mermaid_graph(self.nodes, self.edges_by_source).render(title=title, direction=direction)\n\n    def __repr__(self) -> str:\n        super_repr = super().__repr__()  # include class and memory address\n        # Insert the result of calling `__str__` before the final '>' in the repr\n        return f'{super_repr[:-1]}\\n{self}\\n{super_repr[-1]}'\n\n    def __str__(self) -> str:\n        \"\"\"Return a Mermaid diagram representation of the graph.\n\n        Returns:\n            A string containing the Mermaid diagram of the graph\n        \"\"\"\n        return self.render()\n\n```\n\n#### name\n\n```python\nname: str | None\n\n```\n\nOptional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\n\n#### state_type\n\n```python\nstate_type: type[StateT]\n\n```\n\nThe type of the graph state.\n\n#### deps_type\n\n```python\ndeps_type: type[DepsT]\n\n```\n\nThe type of the dependencies.\n\n#### input_type\n\n```python\ninput_type: type[InputT]\n\n```\n\nThe type of the input data.\n\n#### output_type\n\n```python\noutput_type: type[OutputT]\n\n```\n\nThe type of the output data.\n\n#### auto_instrument\n\n```python\nauto_instrument: bool\n\n```\n\nWhether to automatically create instrumentation spans.\n\n#### nodes\n\n```python\nnodes: dict[NodeID, AnyNode]\n\n```\n\nAll nodes in the graph indexed by their ID.\n\n#### edges_by_source\n\n```python\nedges_by_source: dict[NodeID, list[Path]]\n\n```\n\nOutgoing paths from each source node.\n\n#### parent_forks\n\n```python\nparent_forks: dict[JoinID, ParentFork[NodeID]]\n\n```\n\nParent fork information for each join node.\n\n#### intermediate_join_nodes\n\n```python\nintermediate_join_nodes: dict[JoinID, set[JoinID]]\n\n```\n\nFor each join, the set of other joins that appear between it and its parent fork.\n\nUsed to determine which joins are \"final\" (have no other joins as intermediates) and which joins should preserve fork stacks when proceeding downstream.\n\n#### get_parent_fork\n\n```python\nget_parent_fork(join_id: JoinID) -> ParentFork[NodeID]\n\n```\n\nGet the parent fork information for a join node.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `join_id` | `JoinID` | The ID of the join node | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `ParentFork[NodeID]` | The parent fork information for the join |\n\nRaises:\n\n| Type | Description | | --- | --- | | `RuntimeError` | If the join ID is not found or has no parent fork |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef get_parent_fork(self, join_id: JoinID) -> ParentFork[NodeID]:\n    \"\"\"Get the parent fork information for a join node.\n\n    Args:\n        join_id: The ID of the join node\n\n    Returns:\n        The parent fork information for the join\n\n    Raises:\n        RuntimeError: If the join ID is not found or has no parent fork\n    \"\"\"\n    result = self.parent_forks.get(join_id)\n    if result is None:\n        raise RuntimeError(f'Node {join_id} is not a join node or did not have a dominating fork (this is a bug)')\n    return result\n\n```\n\n#### is_final_join\n\n```python\nis_final_join(join_id: JoinID) -> bool\n\n```\n\nCheck if a join is 'final' (has no downstream joins with the same parent fork).\n\nA join is non-final if it appears as an intermediate node for another join with the same parent fork.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `join_id` | `JoinID` | The ID of the join node | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `bool` | True if the join is final, False if it's non-final |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef is_final_join(self, join_id: JoinID) -> bool:\n    \"\"\"Check if a join is 'final' (has no downstream joins with the same parent fork).\n\n    A join is non-final if it appears as an intermediate node for another join\n    with the same parent fork.\n\n    Args:\n        join_id: The ID of the join node\n\n    Returns:\n        True if the join is final, False if it's non-final\n    \"\"\"\n    # Check if this join appears in any other join's intermediate_join_nodes\n    for intermediate_joins in self.intermediate_join_nodes.values():\n        if join_id in intermediate_joins:\n            return False\n    return True\n\n```\n\n#### run\n\n```python\nrun(\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    inputs: InputT = None,\n    span: (\n        AbstractContextManager[AbstractSpan] | None\n    ) = None,\n    infer_name: bool = True\n) -> OutputT\n\n```\n\nExecute the graph and return the final output.\n\nThis is the main entry point for graph execution. It runs the graph to completion and returns the final output value.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `state` | `StateT` | The graph state instance | `None` | | `deps` | `DepsT` | The dependencies instance | `None` | | `inputs` | `InputT` | The input data for the graph | `None` | | `span` | `AbstractContextManager[AbstractSpan] | None` | Optional span for tracing/instrumentation | `None` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `OutputT` | The final output from the graph execution |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\nasync def run(\n    self,\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    inputs: InputT = None,\n    span: AbstractContextManager[AbstractSpan] | None = None,\n    infer_name: bool = True,\n) -> OutputT:\n    \"\"\"Execute the graph and return the final output.\n\n    This is the main entry point for graph execution. It runs the graph\n    to completion and returns the final output value.\n\n    Args:\n        state: The graph state instance\n        deps: The dependencies instance\n        inputs: The input data for the graph\n        span: Optional span for tracing/instrumentation\n        infer_name: Whether to infer the graph name from the calling frame.\n\n    Returns:\n        The final output from the graph execution\n    \"\"\"\n    if infer_name and self.name is None:\n        inferred_name = infer_obj_name(self, depth=2)\n        if inferred_name is not None:  # pragma: no branch\n            self.name = inferred_name\n\n    async with self.iter(state=state, deps=deps, inputs=inputs, span=span, infer_name=False) as graph_run:\n        # Note: This would probably be better using `async for _ in graph_run`, but this tests the `next` method,\n        # which I'm less confident will be implemented correctly if not used on the critical path. We can change it\n        # once we have tests, etc.\n        event: Any = None\n        while True:\n            try:\n                event = await graph_run.next(event)\n            except StopAsyncIteration:\n                assert isinstance(event, EndMarker), 'Graph run should end with an EndMarker.'\n                return cast(EndMarker[OutputT], event).value\n\n```\n\n#### iter\n\n```python\niter(\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    inputs: InputT = None,\n    span: (\n        AbstractContextManager[AbstractSpan] | None\n    ) = None,\n    infer_name: bool = True\n) -> AsyncIterator[GraphRun[StateT, DepsT, OutputT]]\n\n```\n\nCreate an iterator for step-by-step graph execution.\n\nThis method allows for more fine-grained control over graph execution, enabling inspection of intermediate states and results.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `state` | `StateT` | The graph state instance | `None` | | `deps` | `DepsT` | The dependencies instance | `None` | | `inputs` | `InputT` | The input data for the graph | `None` | | `span` | `AbstractContextManager[AbstractSpan] | None` | Optional span for tracing/instrumentation | `None` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` |\n\nYields:\n\n| Type | Description | | --- | --- | | `AsyncIterator[GraphRun[StateT, DepsT, OutputT]]` | A GraphRun instance that can be iterated for step-by-step execution |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\n@asynccontextmanager\nasync def iter(\n    self,\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    inputs: InputT = None,\n    span: AbstractContextManager[AbstractSpan] | None = None,\n    infer_name: bool = True,\n) -> AsyncIterator[GraphRun[StateT, DepsT, OutputT]]:\n    \"\"\"Create an iterator for step-by-step graph execution.\n\n    This method allows for more fine-grained control over graph execution,\n    enabling inspection of intermediate states and results.\n\n    Args:\n        state: The graph state instance\n        deps: The dependencies instance\n        inputs: The input data for the graph\n        span: Optional span for tracing/instrumentation\n        infer_name: Whether to infer the graph name from the calling frame.\n\n    Yields:\n        A GraphRun instance that can be iterated for step-by-step execution\n    \"\"\"\n    if infer_name and self.name is None:\n        inferred_name = infer_obj_name(self, depth=3)  # depth=3 because asynccontextmanager adds one\n        if inferred_name is not None:  # pragma: no branch\n            self.name = inferred_name\n\n    with ExitStack() as stack:\n        entered_span: AbstractSpan | None = None\n        if span is None:\n            if self.auto_instrument:\n                entered_span = stack.enter_context(logfire_span('run graph {graph.name}', graph=self))\n        else:\n            entered_span = stack.enter_context(span)\n        traceparent = None if entered_span is None else get_traceparent(entered_span)\n        async with GraphRun[StateT, DepsT, OutputT](\n            graph=self,\n            state=state,\n            deps=deps,\n            inputs=inputs,\n            traceparent=traceparent,\n        ) as graph_run:\n            yield graph_run\n\n```\n\n#### render\n\n```python\nrender(\n    *,\n    title: str | None = None,\n    direction: StateDiagramDirection | None = None\n) -> str\n\n```\n\nRender the graph as a Mermaid diagram string.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `title` | `str | None` | Optional title for the diagram | `None` | | `direction` | `StateDiagramDirection | None` | Optional direction for the diagram layout | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `str` | A string containing the Mermaid diagram representation |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef render(self, *, title: str | None = None, direction: StateDiagramDirection | None = None) -> str:\n    \"\"\"Render the graph as a Mermaid diagram string.\n\n    Args:\n        title: Optional title for the diagram\n        direction: Optional direction for the diagram layout\n\n    Returns:\n        A string containing the Mermaid diagram representation\n    \"\"\"\n    from pydantic_graph.beta.mermaid import build_mermaid_graph\n\n    return build_mermaid_graph(self.nodes, self.edges_by_source).render(title=title, direction=direction)\n\n```\n\n#### __str__\n\n```python\n__str__() -> str\n\n```\n\nReturn a Mermaid diagram representation of the graph.\n\nReturns:\n\n| Type | Description | | --- | --- | | `str` | A string containing the Mermaid diagram of the graph |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef __str__(self) -> str:\n    \"\"\"Return a Mermaid diagram representation of the graph.\n\n    Returns:\n        A string containing the Mermaid diagram of the graph\n    \"\"\"\n    return self.render()\n\n```\n\n### GraphBuilder\n\nBases: `Generic[StateT, DepsT, GraphInputT, GraphOutputT]`\n\nA builder for constructing executable graph definitions.\n\nGraphBuilder provides a fluent interface for defining nodes, edges, and routing in a graph workflow. It supports typed state, dependencies, and input/output validation.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies GraphInputT: The type of the graph input data GraphOutputT: The type of the graph output data\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\n@dataclass(init=False)\nclass GraphBuilder(Generic[StateT, DepsT, GraphInputT, GraphOutputT]):\n    \"\"\"A builder for constructing executable graph definitions.\n\n    GraphBuilder provides a fluent interface for defining nodes, edges, and\n    routing in a graph workflow. It supports typed state, dependencies, and\n    input/output validation.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        GraphInputT: The type of the graph input data\n        GraphOutputT: The type of the graph output data\n    \"\"\"\n\n    name: str | None\n    \"\"\"Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\"\"\"\n\n    state_type: TypeOrTypeExpression[StateT]\n    \"\"\"The type of the graph state.\"\"\"\n\n    deps_type: TypeOrTypeExpression[DepsT]\n    \"\"\"The type of the dependencies.\"\"\"\n\n    input_type: TypeOrTypeExpression[GraphInputT]\n    \"\"\"The type of the graph input data.\"\"\"\n\n    output_type: TypeOrTypeExpression[GraphOutputT]\n    \"\"\"The type of the graph output data.\"\"\"\n\n    auto_instrument: bool\n    \"\"\"Whether to automatically create instrumentation spans.\"\"\"\n\n    _nodes: dict[NodeID, AnyNode]\n    \"\"\"Internal storage for nodes in the graph.\"\"\"\n\n    _edges_by_source: dict[NodeID, list[Path]]\n    \"\"\"Internal storage for edges by source node.\"\"\"\n\n    _decision_index: int\n    \"\"\"Counter for generating unique decision node IDs.\"\"\"\n\n    Source = TypeAliasType('Source', SourceNode[StateT, DepsT, OutputT], type_params=(OutputT,))\n    Destination = TypeAliasType('Destination', DestinationNode[StateT, DepsT, InputT], type_params=(InputT,))\n\n    def __init__(\n        self,\n        *,\n        name: str | None = None,\n        state_type: TypeOrTypeExpression[StateT] = NoneType,\n        deps_type: TypeOrTypeExpression[DepsT] = NoneType,\n        input_type: TypeOrTypeExpression[GraphInputT] = NoneType,\n        output_type: TypeOrTypeExpression[GraphOutputT] = NoneType,\n        auto_instrument: bool = True,\n    ):\n        \"\"\"Initialize a graph builder.\n\n        Args:\n            name: Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\n            state_type: The type of the graph state\n            deps_type: The type of the dependencies\n            input_type: The type of the graph input data\n            output_type: The type of the graph output data\n            auto_instrument: Whether to automatically create instrumentation spans\n        \"\"\"\n        self.name = name\n\n        self.state_type = state_type\n        self.deps_type = deps_type\n        self.input_type = input_type\n        self.output_type = output_type\n\n        self.auto_instrument = auto_instrument\n\n        self._nodes = {}\n        self._edges_by_source = defaultdict(list)\n        self._decision_index = 1\n\n        self._start_node = StartNode[GraphInputT]()\n        self._end_node = EndNode[GraphOutputT]()\n\n    # Node building\n    @property\n    def start_node(self) -> StartNode[GraphInputT]:\n        \"\"\"Get the start node for the graph.\n\n        Returns:\n            The start node that receives the initial graph input\n        \"\"\"\n        return self._start_node\n\n    @property\n    def end_node(self) -> EndNode[GraphOutputT]:\n        \"\"\"Get the end node for the graph.\n\n        Returns:\n            The end node that produces the final graph output\n        \"\"\"\n        return self._end_node\n\n    @overload\n    def step(\n        self,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> Callable[[StepFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, OutputT]]: ...\n    @overload\n    def step(\n        self,\n        call: StepFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> Step[StateT, DepsT, InputT, OutputT]: ...\n    def step(\n        self,\n        call: StepFunction[StateT, DepsT, InputT, OutputT] | None = None,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> (\n        Step[StateT, DepsT, InputT, OutputT]\n        | Callable[[StepFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, OutputT]]\n    ):\n        \"\"\"Create a step from a step function.\n\n        This method can be used as a decorator or called directly to create\n        a step node from an async function.\n\n        Args:\n            call: The step function to wrap\n            node_id: Optional ID for the node\n            label: Optional human-readable label\n\n        Returns:\n            Either a Step instance or a decorator function\n        \"\"\"\n        if call is None:\n\n            def decorator(\n                func: StepFunction[StateT, DepsT, InputT, OutputT],\n            ) -> Step[StateT, DepsT, InputT, OutputT]:\n                return self.step(call=func, node_id=node_id, label=label)\n\n            return decorator\n\n        node_id = node_id or get_callable_name(call)\n\n        step = Step[StateT, DepsT, InputT, OutputT](id=NodeID(node_id), call=call, label=label)\n\n        return step\n\n    @overload\n    def stream(\n        self,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> Callable[\n        [StreamFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n    ]: ...\n    @overload\n    def stream(\n        self,\n        call: StreamFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]: ...\n    @overload\n    def stream(\n        self,\n        call: StreamFunction[StateT, DepsT, InputT, OutputT] | None = None,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> (\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n        | Callable[\n            [StreamFunction[StateT, DepsT, InputT, OutputT]],\n            Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n        ]\n    ): ...\n    def stream(\n        self,\n        call: StreamFunction[StateT, DepsT, InputT, OutputT] | None = None,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> (\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n        | Callable[\n            [StreamFunction[StateT, DepsT, InputT, OutputT]],\n            Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n        ]\n    ):\n        \"\"\"Create a step from an async iterator (which functions like a \"stream\").\n\n        This method can be used as a decorator or called directly to create\n        a step node from an async function.\n\n        Args:\n            call: The step function to wrap\n            node_id: Optional ID for the node\n            label: Optional human-readable label\n\n        Returns:\n            Either a Step instance or a decorator function\n        \"\"\"\n        if call is None:\n\n            def decorator(\n                func: StreamFunction[StateT, DepsT, InputT, OutputT],\n            ) -> Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]:\n                return self.stream(call=func, node_id=node_id, label=label)\n\n            return decorator\n\n        # We need to wrap the call so that we can call `await` even though the result is an async iterator\n        async def wrapper(ctx: StepContext[StateT, DepsT, InputT]):\n            return call(ctx)\n\n        return self.step(call=wrapper, node_id=node_id, label=label)\n\n    @overload\n    def join(\n        self,\n        reducer: ReducerFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        initial: OutputT,\n        node_id: str | None = None,\n        parent_fork_id: str | None = None,\n        preferred_parent_fork: Literal['farthest', 'closest'] = 'farthest',\n    ) -> Join[StateT, DepsT, InputT, OutputT]: ...\n    @overload\n    def join(\n        self,\n        reducer: ReducerFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        initial_factory: Callable[[], OutputT],\n        node_id: str | None = None,\n        parent_fork_id: str | None = None,\n        preferred_parent_fork: Literal['farthest', 'closest'] = 'farthest',\n    ) -> Join[StateT, DepsT, InputT, OutputT]: ...\n\n    def join(\n        self,\n        reducer: ReducerFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        initial: OutputT | Unset = UNSET,\n        initial_factory: Callable[[], OutputT] | Unset = UNSET,\n        node_id: str | None = None,\n        parent_fork_id: str | None = None,\n        preferred_parent_fork: Literal['farthest', 'closest'] = 'farthest',\n    ) -> Join[StateT, DepsT, InputT, OutputT]:\n        if initial_factory is UNSET:\n            initial_factory = lambda: initial  # pyright: ignore[reportAssignmentType]  # noqa: E731\n\n        return Join[StateT, DepsT, InputT, OutputT](\n            id=JoinID(NodeID(node_id or generate_placeholder_node_id(get_callable_name(reducer)))),\n            reducer=reducer,\n            initial_factory=cast(Callable[[], OutputT], initial_factory),\n            parent_fork_id=ForkID(parent_fork_id) if parent_fork_id is not None else None,\n            preferred_parent_fork=preferred_parent_fork,\n        )\n\n    # Edge building\n    def add(self, *edges: EdgePath[StateT, DepsT]) -> None:  # noqa: C901\n        \"\"\"Add one or more edge paths to the graph.\n\n        This method processes edge paths and automatically creates any necessary\n        fork nodes for broadcasts and maps.\n\n        Args:\n            *edges: The edge paths to add to the graph\n        \"\"\"\n\n        def _handle_path(p: Path):\n            \"\"\"Process a path and create necessary fork nodes.\n\n            Args:\n                p: The path to process\n            \"\"\"\n            for item in p.items:\n                if isinstance(item, BroadcastMarker):\n                    new_node = Fork[Any, Any](id=item.fork_id, is_map=False, downstream_join_id=None)\n                    self._insert_node(new_node)\n                    for path in item.paths:\n                        _handle_path(Path(items=[*path.items]))\n                elif isinstance(item, MapMarker):\n                    new_node = Fork[Any, Any](id=item.fork_id, is_map=True, downstream_join_id=item.downstream_join_id)\n                    self._insert_node(new_node)\n                elif isinstance(item, DestinationMarker):\n                    pass\n\n        def _handle_destination_node(d: AnyDestinationNode):\n            if id(d) in destination_ids:\n                return  # prevent infinite recursion if there is a cycle of decisions\n\n            destination_ids.add(id(d))\n            destinations.append(d)\n            self._insert_node(d)\n            if isinstance(d, Decision):\n                for branch in d.branches:\n                    _handle_path(branch.path)\n                    for d2 in branch.destinations:\n                        _handle_destination_node(d2)\n\n        destination_ids = set[int]()\n        destinations: list[AnyDestinationNode] = []\n        for edge in edges:\n            for source_node in edge.sources:\n                self._insert_node(source_node)\n                self._edges_by_source[source_node.id].append(edge.path)\n            for destination_node in edge.destinations:\n                _handle_destination_node(destination_node)\n            _handle_path(edge.path)\n\n        # Automatically create edges from step function return hints including `BaseNode`s\n        for destination in destinations:\n            if not isinstance(destination, Step) or isinstance(destination, NodeStep):\n                continue\n            parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n            type_hints = get_type_hints(destination.call, localns=parent_namespace, include_extras=True)\n            try:\n                return_hint = type_hints['return']\n            except KeyError:\n                pass\n            else:\n                edge = self._edge_from_return_hint(destination, return_hint)\n                if edge is not None:\n                    self.add(edge)\n\n    def add_edge(self, source: Source[T], destination: Destination[T], *, label: str | None = None) -> None:\n        \"\"\"Add a simple edge between two nodes.\n\n        Args:\n            source: The source node\n            destination: The destination node\n            label: Optional label for the edge\n        \"\"\"\n        builder = self.edge_from(source)\n        if label is not None:\n            builder = builder.label(label)\n        self.add(builder.to(destination))\n\n    def add_mapping_edge(\n        self,\n        source: Source[Iterable[T]],\n        map_to: Destination[T],\n        *,\n        pre_map_label: str | None = None,\n        post_map_label: str | None = None,\n        fork_id: ForkID | None = None,\n        downstream_join_id: JoinID | None = None,\n    ) -> None:\n        \"\"\"Add an edge that maps iterable data across parallel paths.\n\n        Args:\n            source: The source node that produces iterable data\n            map_to: The destination node that receives individual items\n            pre_map_label: Optional label before the map operation\n            post_map_label: Optional label after the map operation\n            fork_id: Optional ID for the fork node produced for this map operation\n            downstream_join_id: Optional ID of a join node that will always be downstream of this map.\n                Specifying this ensures correct handling if you try to map an empty iterable.\n        \"\"\"\n        builder = self.edge_from(source)\n        if pre_map_label is not None:\n            builder = builder.label(pre_map_label)\n        builder = builder.map(fork_id=fork_id, downstream_join_id=downstream_join_id)\n        if post_map_label is not None:\n            builder = builder.label(post_map_label)\n        self.add(builder.to(map_to))\n\n    # TODO(DavidM): Support adding subgraphs; I think this behaves like a step with the same inputs/outputs but gets rendered as a subgraph in mermaid\n\n    def edge_from(self, *sources: Source[SourceOutputT]) -> EdgePathBuilder[StateT, DepsT, SourceOutputT]:\n        \"\"\"Create an edge path builder starting from the given source nodes.\n\n        Args:\n            *sources: The source nodes to start the edge path from\n\n        Returns:\n            An EdgePathBuilder for constructing the complete edge path\n        \"\"\"\n        return EdgePathBuilder[StateT, DepsT, SourceOutputT](\n            sources=sources, path_builder=PathBuilder(working_items=[])\n        )\n\n    def decision(self, *, note: str | None = None, node_id: str | None = None) -> Decision[StateT, DepsT, Never]:\n        \"\"\"Create a new decision node.\n\n        Args:\n            note: Optional note to describe the decision logic\n            node_id: Optional ID for the node produced for this decision logic\n\n        Returns:\n            A new Decision node with no branches\n        \"\"\"\n        return Decision(id=NodeID(node_id or generate_placeholder_node_id('decision')), branches=[], note=note)\n\n    def match(\n        self,\n        source: TypeOrTypeExpression[SourceT],\n        *,\n        matches: Callable[[Any], bool] | None = None,\n    ) -> DecisionBranchBuilder[StateT, DepsT, SourceT, SourceT, Never]:\n        \"\"\"Create a decision branch matcher.\n\n        Args:\n            source: The type or type expression to match against\n            matches: Optional custom matching function\n\n        Returns:\n            A DecisionBranchBuilder for constructing the branch\n        \"\"\"\n        # Note, the following node_id really is just a placeholder and shouldn't end up in the final graph\n        # This is why we don't expose a way for end users to override the value used here.\n        node_id = NodeID(generate_placeholder_node_id('match_decision'))\n        decision = Decision[StateT, DepsT, Never](id=node_id, branches=[], note=None)\n        new_path_builder = PathBuilder[StateT, DepsT, SourceT](working_items=[])\n        return DecisionBranchBuilder(decision=decision, source=source, matches=matches, path_builder=new_path_builder)\n\n    def match_node(\n        self,\n        source: type[SourceNodeT],\n        *,\n        matches: Callable[[Any], bool] | None = None,\n    ) -> DecisionBranch[SourceNodeT]:\n        \"\"\"Create a decision branch for BaseNode subclasses.\n\n        This is similar to match() but specifically designed for matching\n        against BaseNode types from the v1 system.\n\n        Args:\n            source: The BaseNode subclass to match against\n            matches: Optional custom matching function\n\n        Returns:\n            A DecisionBranch for the BaseNode type\n        \"\"\"\n        node = NodeStep(source)\n        path = Path(items=[DestinationMarker(node.id)])\n        return DecisionBranch(source=source, matches=matches, path=path, destinations=[node])\n\n    def node(\n        self,\n        node_type: type[BaseNode[StateT, DepsT, GraphOutputT]],\n    ) -> EdgePath[StateT, DepsT]:\n        \"\"\"Create an edge path from a BaseNode class.\n\n        This method integrates v1-style BaseNode classes into the v2 graph\n        system by analyzing their type hints and creating appropriate edges.\n\n        Args:\n            node_type: The BaseNode subclass to integrate\n\n        Returns:\n            An EdgePath representing the node and its connections\n\n        Raises:\n            GraphSetupError: If the node type is missing required type hints\n        \"\"\"\n        parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n        type_hints = get_type_hints(node_type.run, localns=parent_namespace, include_extras=True)\n        try:\n            return_hint = type_hints['return']\n        except KeyError as e:  # pragma: no cover\n            raise exceptions.GraphSetupError(\n                f'Node {node_type} is missing a return type hint on its `run` method'\n            ) from e\n\n        node = NodeStep(node_type)\n\n        edge = self._edge_from_return_hint(node, return_hint)\n        if not edge:  # pragma: no cover\n            raise exceptions.GraphSetupError(f'Node {node_type} is missing a return type hint on its `run` method')\n\n        return edge\n\n    # Helpers\n    def _insert_node(self, node: AnyNode) -> None:\n        \"\"\"Insert a node into the graph, checking for ID conflicts.\n\n        Args:\n            node: The node to insert\n\n        Raises:\n            ValueError: If a different node with the same ID already exists\n        \"\"\"\n        existing = self._nodes.get(node.id)\n        if existing is None:\n            self._nodes[node.id] = node\n        elif isinstance(existing, NodeStep) and isinstance(node, NodeStep) and existing.node_type is node.node_type:\n            pass\n        elif existing is not node:\n            raise GraphBuildingError(\n                f'All nodes must have unique node IDs. {node.id!r} was the ID for {existing} and {node}'\n            )\n\n    def _edge_from_return_hint(\n        self, node: SourceNode[StateT, DepsT, Any], return_hint: TypeOrTypeExpression[Any]\n    ) -> EdgePath[StateT, DepsT] | None:\n        \"\"\"Create edges from a return type hint.\n\n        This method analyzes return type hints from step functions or node methods\n        to automatically create appropriate edges in the graph.\n\n        Args:\n            node: The source node\n            return_hint: The return type hint to analyze\n\n        Returns:\n            An EdgePath if edges can be inferred, None otherwise\n\n        Raises:\n            GraphSetupError: If the return type hint is invalid or incomplete\n        \"\"\"\n        destinations: list[AnyDestinationNode] = []\n        union_args = _utils.get_union_args(return_hint)\n        for return_type in union_args:\n            return_type, annotations = _utils.unpack_annotated(return_type)\n            return_type_origin = get_origin(return_type) or return_type\n            if return_type_origin is End:\n                destinations.append(self.end_node)\n            elif return_type_origin is BaseNode:\n                raise exceptions.GraphSetupError(  # pragma: no cover\n                    f'Node {node} return type hint includes a plain `BaseNode`. '\n                    'Edge inference requires each possible returned `BaseNode` subclass to be listed explicitly.'\n                )\n            elif return_type_origin is StepNode:\n                step = cast(\n                    Step[StateT, DepsT, Any, Any] | None,\n                    next((a for a in annotations if isinstance(a, Step)), None),  # pyright: ignore[reportUnknownArgumentType]\n                )\n                if step is None:\n                    raise exceptions.GraphSetupError(  # pragma: no cover\n                        f'Node {node} return type hint includes a `StepNode` without a `Step` annotation. '\n                        'When returning `my_step.as_node()`, use `Annotated[StepNode[StateT, DepsT], my_step]` as the return type hint.'\n                    )\n                destinations.append(step)\n            elif return_type_origin is JoinNode:\n                join = cast(\n                    Join[StateT, DepsT, Any, Any] | None,\n                    next((a for a in annotations if isinstance(a, Join)), None),  # pyright: ignore[reportUnknownArgumentType]\n                )\n                if join is None:\n                    raise exceptions.GraphSetupError(  # pragma: no cover\n                        f'Node {node} return type hint includes a `JoinNode` without a `Join` annotation. '\n                        'When returning `my_join.as_node()`, use `Annotated[JoinNode[StateT, DepsT], my_join]` as the return type hint.'\n                    )\n                destinations.append(join)\n            elif inspect.isclass(return_type_origin) and issubclass(return_type_origin, BaseNode):\n                destinations.append(NodeStep(return_type))\n\n        if len(destinations) < len(union_args):\n            # Only build edges if all the return types are nodes\n            return None\n\n        edge = self.edge_from(node)\n        if len(destinations) == 1:\n            return edge.to(destinations[0])\n        else:\n            decision = self.decision()\n            for destination in destinations:\n                # We don't actually use this decision mechanism, but we need to build the edges for parent-fork finding\n                decision = decision.branch(self.match(NoneType).to(destination))\n            return edge.to(decision)\n\n    # Graph building\n    def build(self, validate_graph_structure: bool = True) -> Graph[StateT, DepsT, GraphInputT, GraphOutputT]:\n        \"\"\"Build the final executable graph from the accumulated nodes and edges.\n\n        This method performs validation, normalization, and analysis of the graph\n        structure to create a complete, executable graph instance.\n\n        Args:\n            validate_graph_structure: whether to perform validation of the graph structure\n                See the docstring of _validate_graph_structure below for more details.\n\n        Returns:\n            A complete Graph instance ready for execution\n\n        Raises:\n            ValueError: If the graph structure is invalid (e.g., join without parent fork)\n        \"\"\"\n        nodes = self._nodes\n        edges_by_source = self._edges_by_source\n\n        nodes, edges_by_source = _replace_placeholder_node_ids(nodes, edges_by_source)\n        nodes, edges_by_source = _flatten_paths(nodes, edges_by_source)\n        nodes, edges_by_source = _normalize_forks(nodes, edges_by_source)\n        if validate_graph_structure:\n            _validate_graph_structure(nodes, edges_by_source)\n        parent_forks = _collect_dominating_forks(nodes, edges_by_source)\n        intermediate_join_nodes = _compute_intermediate_join_nodes(nodes, parent_forks)\n\n        return Graph[StateT, DepsT, GraphInputT, GraphOutputT](\n            name=self.name,\n            state_type=unpack_type_expression(self.state_type),\n            deps_type=unpack_type_expression(self.deps_type),\n            input_type=unpack_type_expression(self.input_type),\n            output_type=unpack_type_expression(self.output_type),\n            nodes=nodes,\n            edges_by_source=edges_by_source,\n            parent_forks=parent_forks,\n            intermediate_join_nodes=intermediate_join_nodes,\n            auto_instrument=self.auto_instrument,\n        )\n\n```\n\n#### name\n\n```python\nname: str | None = name\n\n```\n\nOptional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\n\n#### state_type\n\n```python\nstate_type: TypeOrTypeExpression[StateT] = state_type\n\n```\n\nThe type of the graph state.\n\n#### deps_type\n\n```python\ndeps_type: TypeOrTypeExpression[DepsT] = deps_type\n\n```\n\nThe type of the dependencies.\n\n#### input_type\n\n```python\ninput_type: TypeOrTypeExpression[GraphInputT] = input_type\n\n```\n\nThe type of the graph input data.\n\n#### output_type\n\n```python\noutput_type: TypeOrTypeExpression[GraphOutputT] = (\n    output_type\n)\n\n```\n\nThe type of the graph output data.\n\n#### auto_instrument\n\n```python\nauto_instrument: bool = auto_instrument\n\n```\n\nWhether to automatically create instrumentation spans.\n\n#### __init__\n\n```python\n__init__(\n    *,\n    name: str | None = None,\n    state_type: TypeOrTypeExpression[StateT] = NoneType,\n    deps_type: TypeOrTypeExpression[DepsT] = NoneType,\n    input_type: TypeOrTypeExpression[\n        GraphInputT\n    ] = NoneType,\n    output_type: TypeOrTypeExpression[\n        GraphOutputT\n    ] = NoneType,\n    auto_instrument: bool = True\n)\n\n```\n\nInitialize a graph builder.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `name` | `str | None` | Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method. | `None` | | `state_type` | `TypeOrTypeExpression[StateT]` | The type of the graph state | `NoneType` | | `deps_type` | `TypeOrTypeExpression[DepsT]` | The type of the dependencies | `NoneType` | | `input_type` | `TypeOrTypeExpression[GraphInputT]` | The type of the graph input data | `NoneType` | | `output_type` | `TypeOrTypeExpression[GraphOutputT]` | The type of the graph output data | `NoneType` | | `auto_instrument` | `bool` | Whether to automatically create instrumentation spans | `True` |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef __init__(\n    self,\n    *,\n    name: str | None = None,\n    state_type: TypeOrTypeExpression[StateT] = NoneType,\n    deps_type: TypeOrTypeExpression[DepsT] = NoneType,\n    input_type: TypeOrTypeExpression[GraphInputT] = NoneType,\n    output_type: TypeOrTypeExpression[GraphOutputT] = NoneType,\n    auto_instrument: bool = True,\n):\n    \"\"\"Initialize a graph builder.\n\n    Args:\n        name: Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\n        state_type: The type of the graph state\n        deps_type: The type of the dependencies\n        input_type: The type of the graph input data\n        output_type: The type of the graph output data\n        auto_instrument: Whether to automatically create instrumentation spans\n    \"\"\"\n    self.name = name\n\n    self.state_type = state_type\n    self.deps_type = deps_type\n    self.input_type = input_type\n    self.output_type = output_type\n\n    self.auto_instrument = auto_instrument\n\n    self._nodes = {}\n    self._edges_by_source = defaultdict(list)\n    self._decision_index = 1\n\n    self._start_node = StartNode[GraphInputT]()\n    self._end_node = EndNode[GraphOutputT]()\n\n```\n\n#### start_node\n\n```python\nstart_node: StartNode[GraphInputT]\n\n```\n\nGet the start node for the graph.\n\nReturns:\n\n| Type | Description | | --- | --- | | `StartNode[GraphInputT]` | The start node that receives the initial graph input |\n\n#### end_node\n\n```python\nend_node: EndNode[GraphOutputT]\n\n```\n\nGet the end node for the graph.\n\nReturns:\n\n| Type | Description | | --- | --- | | `EndNode[GraphOutputT]` | The end node that produces the final graph output |\n\n#### step\n\n```python\nstep(\n    *, node_id: str | None = None, label: str | None = None\n) -> Callable[\n    [StepFunction[StateT, DepsT, InputT, OutputT]],\n    Step[StateT, DepsT, InputT, OutputT],\n]\n\n```\n\n```python\nstep(\n    call: StepFunction[StateT, DepsT, InputT, OutputT],\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> Step[StateT, DepsT, InputT, OutputT]\n\n```\n\n```python\nstep(\n    call: (\n        StepFunction[StateT, DepsT, InputT, OutputT] | None\n    ) = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> (\n    Step[StateT, DepsT, InputT, OutputT]\n    | Callable[\n        [StepFunction[StateT, DepsT, InputT, OutputT]],\n        Step[StateT, DepsT, InputT, OutputT],\n    ]\n)\n\n```\n\nCreate a step from a step function.\n\nThis method can be used as a decorator or called directly to create a step node from an async function.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `call` | `StepFunction[StateT, DepsT, InputT, OutputT] | None` | The step function to wrap | `None` | | `node_id` | `str | None` | Optional ID for the node | `None` | | `label` | `str | None` | Optional human-readable label | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Step[StateT, DepsT, InputT, OutputT] | Callable[[StepFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, OutputT]]` | Either a Step instance or a decorator function |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef step(\n    self,\n    call: StepFunction[StateT, DepsT, InputT, OutputT] | None = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None,\n) -> (\n    Step[StateT, DepsT, InputT, OutputT]\n    | Callable[[StepFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, OutputT]]\n):\n    \"\"\"Create a step from a step function.\n\n    This method can be used as a decorator or called directly to create\n    a step node from an async function.\n\n    Args:\n        call: The step function to wrap\n        node_id: Optional ID for the node\n        label: Optional human-readable label\n\n    Returns:\n        Either a Step instance or a decorator function\n    \"\"\"\n    if call is None:\n\n        def decorator(\n            func: StepFunction[StateT, DepsT, InputT, OutputT],\n        ) -> Step[StateT, DepsT, InputT, OutputT]:\n            return self.step(call=func, node_id=node_id, label=label)\n\n        return decorator\n\n    node_id = node_id or get_callable_name(call)\n\n    step = Step[StateT, DepsT, InputT, OutputT](id=NodeID(node_id), call=call, label=label)\n\n    return step\n\n```\n\n#### stream\n\n```python\nstream(\n    *, node_id: str | None = None, label: str | None = None\n) -> Callable[\n    [StreamFunction[StateT, DepsT, InputT, OutputT]],\n    Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n]\n\n```\n\n```python\nstream(\n    call: StreamFunction[StateT, DepsT, InputT, OutputT],\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n\n```\n\n```python\nstream(\n    call: (\n        StreamFunction[StateT, DepsT, InputT, OutputT]\n        | None\n    ) = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> (\n    Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n    | Callable[\n        [StreamFunction[StateT, DepsT, InputT, OutputT]],\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n    ]\n)\n\n```\n\n```python\nstream(\n    call: (\n        StreamFunction[StateT, DepsT, InputT, OutputT]\n        | None\n    ) = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> (\n    Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n    | Callable[\n        [StreamFunction[StateT, DepsT, InputT, OutputT]],\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n    ]\n)\n\n```\n\nCreate a step from an async iterator (which functions like a \"stream\").\n\nThis method can be used as a decorator or called directly to create a step node from an async function.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `call` | `StreamFunction[StateT, DepsT, InputT, OutputT] | None` | The step function to wrap | `None` | | `node_id` | `str | None` | Optional ID for the node | `None` | | `label` | `str | None` | Optional human-readable label | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Step[StateT, DepsT, InputT, AsyncIterable[OutputT]] | Callable[[StreamFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]]` | Either a Step instance or a decorator function |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef stream(\n    self,\n    call: StreamFunction[StateT, DepsT, InputT, OutputT] | None = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None,\n) -> (\n    Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n    | Callable[\n        [StreamFunction[StateT, DepsT, InputT, OutputT]],\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n    ]\n):\n    \"\"\"Create a step from an async iterator (which functions like a \"stream\").\n\n    This method can be used as a decorator or called directly to create\n    a step node from an async function.\n\n    Args:\n        call: The step function to wrap\n        node_id: Optional ID for the node\n        label: Optional human-readable label\n\n    Returns:\n        Either a Step instance or a decorator function\n    \"\"\"\n    if call is None:\n\n        def decorator(\n            func: StreamFunction[StateT, DepsT, InputT, OutputT],\n        ) -> Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]:\n            return self.stream(call=func, node_id=node_id, label=label)\n\n        return decorator\n\n    # We need to wrap the call so that we can call `await` even though the result is an async iterator\n    async def wrapper(ctx: StepContext[StateT, DepsT, InputT]):\n        return call(ctx)\n\n    return self.step(call=wrapper, node_id=node_id, label=label)\n\n```\n\n#### add\n\n```python\nadd(*edges: EdgePath[StateT, DepsT]) -> None\n\n```\n\nAdd one or more edge paths to the graph.\n\nThis method processes edge paths and automatically creates any necessary fork nodes for broadcasts and maps.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `*edges` | `EdgePath[StateT, DepsT]` | The edge paths to add to the graph | `()` |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef add(self, *edges: EdgePath[StateT, DepsT]) -> None:  # noqa: C901\n    \"\"\"Add one or more edge paths to the graph.\n\n    This method processes edge paths and automatically creates any necessary\n    fork nodes for broadcasts and maps.\n\n    Args:\n        *edges: The edge paths to add to the graph\n    \"\"\"\n\n    def _handle_path(p: Path):\n        \"\"\"Process a path and create necessary fork nodes.\n\n        Args:\n            p: The path to process\n        \"\"\"\n        for item in p.items:\n            if isinstance(item, BroadcastMarker):\n                new_node = Fork[Any, Any](id=item.fork_id, is_map=False, downstream_join_id=None)\n                self._insert_node(new_node)\n                for path in item.paths:\n                    _handle_path(Path(items=[*path.items]))\n            elif isinstance(item, MapMarker):\n                new_node = Fork[Any, Any](id=item.fork_id, is_map=True, downstream_join_id=item.downstream_join_id)\n                self._insert_node(new_node)\n            elif isinstance(item, DestinationMarker):\n                pass\n\n    def _handle_destination_node(d: AnyDestinationNode):\n        if id(d) in destination_ids:\n            return  # prevent infinite recursion if there is a cycle of decisions\n\n        destination_ids.add(id(d))\n        destinations.append(d)\n        self._insert_node(d)\n        if isinstance(d, Decision):\n            for branch in d.branches:\n                _handle_path(branch.path)\n                for d2 in branch.destinations:\n                    _handle_destination_node(d2)\n\n    destination_ids = set[int]()\n    destinations: list[AnyDestinationNode] = []\n    for edge in edges:\n        for source_node in edge.sources:\n            self._insert_node(source_node)\n            self._edges_by_source[source_node.id].append(edge.path)\n        for destination_node in edge.destinations:\n            _handle_destination_node(destination_node)\n        _handle_path(edge.path)\n\n    # Automatically create edges from step function return hints including `BaseNode`s\n    for destination in destinations:\n        if not isinstance(destination, Step) or isinstance(destination, NodeStep):\n            continue\n        parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n        type_hints = get_type_hints(destination.call, localns=parent_namespace, include_extras=True)\n        try:\n            return_hint = type_hints['return']\n        except KeyError:\n            pass\n        else:\n            edge = self._edge_from_return_hint(destination, return_hint)\n            if edge is not None:\n                self.add(edge)\n\n```\n\n#### add_edge\n\n```python\nadd_edge(\n    source: Source[T],\n    destination: Destination[T],\n    *,\n    label: str | None = None\n) -> None\n\n```\n\nAdd a simple edge between two nodes.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `source` | `Source[T]` | The source node | *required* | | `destination` | `Destination[T]` | The destination node | *required* | | `label` | `str | None` | Optional label for the edge | `None` |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef add_edge(self, source: Source[T], destination: Destination[T], *, label: str | None = None) -> None:\n    \"\"\"Add a simple edge between two nodes.\n\n    Args:\n        source: The source node\n        destination: The destination node\n        label: Optional label for the edge\n    \"\"\"\n    builder = self.edge_from(source)\n    if label is not None:\n        builder = builder.label(label)\n    self.add(builder.to(destination))\n\n```\n\n#### add_mapping_edge\n\n```python\nadd_mapping_edge(\n    source: Source[Iterable[T]],\n    map_to: Destination[T],\n    *,\n    pre_map_label: str | None = None,\n    post_map_label: str | None = None,\n    fork_id: ForkID | None = None,\n    downstream_join_id: JoinID | None = None\n) -> None\n\n```\n\nAdd an edge that maps iterable data across parallel paths.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `source` | `Source[Iterable[T]]` | The source node that produces iterable data | *required* | | `map_to` | `Destination[T]` | The destination node that receives individual items | *required* | | `pre_map_label` | `str | None` | Optional label before the map operation | `None` | | `post_map_label` | `str | None` | Optional label after the map operation | `None` | | `fork_id` | `ForkID | None` | Optional ID for the fork node produced for this map operation | `None` | | `downstream_join_id` | `JoinID | None` | Optional ID of a join node that will always be downstream of this map. Specifying this ensures correct handling if you try to map an empty iterable. | `None` |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef add_mapping_edge(\n    self,\n    source: Source[Iterable[T]],\n    map_to: Destination[T],\n    *,\n    pre_map_label: str | None = None,\n    post_map_label: str | None = None,\n    fork_id: ForkID | None = None,\n    downstream_join_id: JoinID | None = None,\n) -> None:\n    \"\"\"Add an edge that maps iterable data across parallel paths.\n\n    Args:\n        source: The source node that produces iterable data\n        map_to: The destination node that receives individual items\n        pre_map_label: Optional label before the map operation\n        post_map_label: Optional label after the map operation\n        fork_id: Optional ID for the fork node produced for this map operation\n        downstream_join_id: Optional ID of a join node that will always be downstream of this map.\n            Specifying this ensures correct handling if you try to map an empty iterable.\n    \"\"\"\n    builder = self.edge_from(source)\n    if pre_map_label is not None:\n        builder = builder.label(pre_map_label)\n    builder = builder.map(fork_id=fork_id, downstream_join_id=downstream_join_id)\n    if post_map_label is not None:\n        builder = builder.label(post_map_label)\n    self.add(builder.to(map_to))\n\n```\n\n#### edge_from\n\n```python\nedge_from(\n    *sources: Source[SourceOutputT],\n) -> EdgePathBuilder[StateT, DepsT, SourceOutputT]\n\n```\n\nCreate an edge path builder starting from the given source nodes.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `*sources` | `Source[SourceOutputT]` | The source nodes to start the edge path from | `()` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `EdgePathBuilder[StateT, DepsT, SourceOutputT]` | An EdgePathBuilder for constructing the complete edge path |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef edge_from(self, *sources: Source[SourceOutputT]) -> EdgePathBuilder[StateT, DepsT, SourceOutputT]:\n    \"\"\"Create an edge path builder starting from the given source nodes.\n\n    Args:\n        *sources: The source nodes to start the edge path from\n\n    Returns:\n        An EdgePathBuilder for constructing the complete edge path\n    \"\"\"\n    return EdgePathBuilder[StateT, DepsT, SourceOutputT](\n        sources=sources, path_builder=PathBuilder(working_items=[])\n    )\n\n```\n\n#### decision\n\n```python\ndecision(\n    *, note: str | None = None, node_id: str | None = None\n) -> Decision[StateT, DepsT, Never]\n\n```\n\nCreate a new decision node.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `note` | `str | None` | Optional note to describe the decision logic | `None` | | `node_id` | `str | None` | Optional ID for the node produced for this decision logic | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Decision[StateT, DepsT, Never]` | A new Decision node with no branches |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef decision(self, *, note: str | None = None, node_id: str | None = None) -> Decision[StateT, DepsT, Never]:\n    \"\"\"Create a new decision node.\n\n    Args:\n        note: Optional note to describe the decision logic\n        node_id: Optional ID for the node produced for this decision logic\n\n    Returns:\n        A new Decision node with no branches\n    \"\"\"\n    return Decision(id=NodeID(node_id or generate_placeholder_node_id('decision')), branches=[], note=note)\n\n```\n\n#### match\n\n```python\nmatch(\n    source: TypeOrTypeExpression[SourceT],\n    *,\n    matches: Callable[[Any], bool] | None = None\n) -> DecisionBranchBuilder[\n    StateT, DepsT, SourceT, SourceT, Never\n]\n\n```\n\nCreate a decision branch matcher.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `source` | `TypeOrTypeExpression[SourceT]` | The type or type expression to match against | *required* | | `matches` | `Callable[[Any], bool] | None` | Optional custom matching function | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `DecisionBranchBuilder[StateT, DepsT, SourceT, SourceT, Never]` | A DecisionBranchBuilder for constructing the branch |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef match(\n    self,\n    source: TypeOrTypeExpression[SourceT],\n    *,\n    matches: Callable[[Any], bool] | None = None,\n) -> DecisionBranchBuilder[StateT, DepsT, SourceT, SourceT, Never]:\n    \"\"\"Create a decision branch matcher.\n\n    Args:\n        source: The type or type expression to match against\n        matches: Optional custom matching function\n\n    Returns:\n        A DecisionBranchBuilder for constructing the branch\n    \"\"\"\n    # Note, the following node_id really is just a placeholder and shouldn't end up in the final graph\n    # This is why we don't expose a way for end users to override the value used here.\n    node_id = NodeID(generate_placeholder_node_id('match_decision'))\n    decision = Decision[StateT, DepsT, Never](id=node_id, branches=[], note=None)\n    new_path_builder = PathBuilder[StateT, DepsT, SourceT](working_items=[])\n    return DecisionBranchBuilder(decision=decision, source=source, matches=matches, path_builder=new_path_builder)\n\n```\n\n#### match_node\n\n```python\nmatch_node(\n    source: type[SourceNodeT],\n    *,\n    matches: Callable[[Any], bool] | None = None\n) -> DecisionBranch[SourceNodeT]\n\n```\n\nCreate a decision branch for BaseNode subclasses.\n\nThis is similar to match() but specifically designed for matching against BaseNode types from the v1 system.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `source` | `type[SourceNodeT]` | The BaseNode subclass to match against | *required* | | `matches` | `Callable[[Any], bool] | None` | Optional custom matching function | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `DecisionBranch[SourceNodeT]` | A DecisionBranch for the BaseNode type |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef match_node(\n    self,\n    source: type[SourceNodeT],\n    *,\n    matches: Callable[[Any], bool] | None = None,\n) -> DecisionBranch[SourceNodeT]:\n    \"\"\"Create a decision branch for BaseNode subclasses.\n\n    This is similar to match() but specifically designed for matching\n    against BaseNode types from the v1 system.\n\n    Args:\n        source: The BaseNode subclass to match against\n        matches: Optional custom matching function\n\n    Returns:\n        A DecisionBranch for the BaseNode type\n    \"\"\"\n    node = NodeStep(source)\n    path = Path(items=[DestinationMarker(node.id)])\n    return DecisionBranch(source=source, matches=matches, path=path, destinations=[node])\n\n```\n\n#### node\n\n```python\nnode(\n    node_type: type[BaseNode[StateT, DepsT, GraphOutputT]],\n) -> EdgePath[StateT, DepsT]\n\n```\n\nCreate an edge path from a BaseNode class.\n\nThis method integrates v1-style BaseNode classes into the v2 graph system by analyzing their type hints and creating appropriate edges.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `node_type` | `type[BaseNode[StateT, DepsT, GraphOutputT]]` | The BaseNode subclass to integrate | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `EdgePath[StateT, DepsT]` | An EdgePath representing the node and its connections |\n\nRaises:\n\n| Type | Description | | --- | --- | | `GraphSetupError` | If the node type is missing required type hints |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef node(\n    self,\n    node_type: type[BaseNode[StateT, DepsT, GraphOutputT]],\n) -> EdgePath[StateT, DepsT]:\n    \"\"\"Create an edge path from a BaseNode class.\n\n    This method integrates v1-style BaseNode classes into the v2 graph\n    system by analyzing their type hints and creating appropriate edges.\n\n    Args:\n        node_type: The BaseNode subclass to integrate\n\n    Returns:\n        An EdgePath representing the node and its connections\n\n    Raises:\n        GraphSetupError: If the node type is missing required type hints\n    \"\"\"\n    parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n    type_hints = get_type_hints(node_type.run, localns=parent_namespace, include_extras=True)\n    try:\n        return_hint = type_hints['return']\n    except KeyError as e:  # pragma: no cover\n        raise exceptions.GraphSetupError(\n            f'Node {node_type} is missing a return type hint on its `run` method'\n        ) from e\n\n    node = NodeStep(node_type)\n\n    edge = self._edge_from_return_hint(node, return_hint)\n    if not edge:  # pragma: no cover\n        raise exceptions.GraphSetupError(f'Node {node_type} is missing a return type hint on its `run` method')\n\n    return edge\n\n```\n\n#### build\n\n```python\nbuild(\n    validate_graph_structure: bool = True,\n) -> Graph[StateT, DepsT, GraphInputT, GraphOutputT]\n\n```\n\nBuild the final executable graph from the accumulated nodes and edges.\n\nThis method performs validation, normalization, and analysis of the graph structure to create a complete, executable graph instance.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `validate_graph_structure` | `bool` | whether to perform validation of the graph structure See the docstring of \\_validate_graph_structure below for more details. | `True` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Graph[StateT, DepsT, GraphInputT, GraphOutputT]` | A complete Graph instance ready for execution |\n\nRaises:\n\n| Type | Description | | --- | --- | | `ValueError` | If the graph structure is invalid (e.g., join without parent fork) |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef build(self, validate_graph_structure: bool = True) -> Graph[StateT, DepsT, GraphInputT, GraphOutputT]:\n    \"\"\"Build the final executable graph from the accumulated nodes and edges.\n\n    This method performs validation, normalization, and analysis of the graph\n    structure to create a complete, executable graph instance.\n\n    Args:\n        validate_graph_structure: whether to perform validation of the graph structure\n            See the docstring of _validate_graph_structure below for more details.\n\n    Returns:\n        A complete Graph instance ready for execution\n\n    Raises:\n        ValueError: If the graph structure is invalid (e.g., join without parent fork)\n    \"\"\"\n    nodes = self._nodes\n    edges_by_source = self._edges_by_source\n\n    nodes, edges_by_source = _replace_placeholder_node_ids(nodes, edges_by_source)\n    nodes, edges_by_source = _flatten_paths(nodes, edges_by_source)\n    nodes, edges_by_source = _normalize_forks(nodes, edges_by_source)\n    if validate_graph_structure:\n        _validate_graph_structure(nodes, edges_by_source)\n    parent_forks = _collect_dominating_forks(nodes, edges_by_source)\n    intermediate_join_nodes = _compute_intermediate_join_nodes(nodes, parent_forks)\n\n    return Graph[StateT, DepsT, GraphInputT, GraphOutputT](\n        name=self.name,\n        state_type=unpack_type_expression(self.state_type),\n        deps_type=unpack_type_expression(self.deps_type),\n        input_type=unpack_type_expression(self.input_type),\n        output_type=unpack_type_expression(self.output_type),\n        nodes=nodes,\n        edges_by_source=edges_by_source,\n        parent_forks=parent_forks,\n        intermediate_join_nodes=intermediate_join_nodes,\n        auto_instrument=self.auto_instrument,\n    )\n\n```\n\n### EndNode\n\nBases: `Generic[InputT]`\n\nTerminal node representing the completion of graph execution.\n\nThe EndNode marks the successful completion of a graph execution flow and can collect the final output data.\n\nSource code in `pydantic_graph/pydantic_graph/beta/node.py`\n\n```python\nclass EndNode(Generic[InputT]):\n    \"\"\"Terminal node representing the completion of graph execution.\n\n    The EndNode marks the successful completion of a graph execution flow\n    and can collect the final output data.\n    \"\"\"\n\n    id = NodeID('__end__')\n    \"\"\"Fixed identifier for the end node.\"\"\"\n\n    def _force_variance(self, inputs: InputT) -> None:  # pragma: no cover\n        \"\"\"Force type variance for proper generic typing.\n\n        This method exists solely for type checking purposes and should never be called.\n\n        Args:\n            inputs: Input data of type InputT.\n\n        Raises:\n            RuntimeError: Always, as this method should never be executed.\n        \"\"\"\n        raise RuntimeError('This method should never be called, it is just defined for typing purposes.')\n\n```\n\n#### id\n\n```python\nid = NodeID('__end__')\n\n```\n\nFixed identifier for the end node.\n\n### StartNode\n\nBases: `Generic[OutputT]`\n\nEntry point node for graph execution.\n\nThe StartNode represents the beginning of a graph execution flow.\n\nSource code in `pydantic_graph/pydantic_graph/beta/node.py`\n\n```python\nclass StartNode(Generic[OutputT]):\n    \"\"\"Entry point node for graph execution.\n\n    The StartNode represents the beginning of a graph execution flow.\n    \"\"\"\n\n    id = NodeID('__start__')\n    \"\"\"Fixed identifier for the start node.\"\"\"\n\n```\n\n#### id\n\n```python\nid = NodeID('__start__')\n\n```\n\nFixed identifier for the start node.\n\n### StepContext\n\nBases: `Generic[StateT, DepsT, InputT]`\n\nContext information passed to step functions during graph execution.\n\nThe step context provides access to the current graph state, dependencies, and input data for a step.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies InputT: The type of the input data\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\n@dataclass(init=False)\nclass StepContext(Generic[StateT, DepsT, InputT]):\n    \"\"\"Context information passed to step functions during graph execution.\n\n    The step context provides access to the current graph state, dependencies, and input data for a step.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        InputT: The type of the input data\n    \"\"\"\n\n    _state: StateT\n    \"\"\"The current graph state.\"\"\"\n    _deps: DepsT\n    \"\"\"The graph run dependencies.\"\"\"\n    _inputs: InputT\n    \"\"\"The input data for this step.\"\"\"\n\n    def __init__(self, *, state: StateT, deps: DepsT, inputs: InputT):\n        self._state = state\n        self._deps = deps\n        self._inputs = inputs\n\n    @property\n    def state(self) -> StateT:\n        return self._state\n\n    @property\n    def deps(self) -> DepsT:\n        return self._deps\n\n    @property\n    def inputs(self) -> InputT:\n        \"\"\"The input data for this step.\n\n        This must be a property to ensure correct variance behavior\n        \"\"\"\n        return self._inputs\n\n```\n\n#### inputs\n\n```python\ninputs: InputT\n\n```\n\nThe input data for this step.\n\nThis must be a property to ensure correct variance behavior\n\n### StepNode\n\nBases: `BaseNode[StateT, DepsT, Any]`\n\nA base node that represents a step with bound inputs.\n\nStepNode bridges between the v1 and v2 graph execution systems by wrapping a Step with bound inputs in a BaseNode interface. It is not meant to be run directly but rather used to indicate transitions to v2-style steps.\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\n@dataclass\nclass StepNode(BaseNode[StateT, DepsT, Any]):\n    \"\"\"A base node that represents a step with bound inputs.\n\n    StepNode bridges between the v1 and v2 graph execution systems by wrapping\n    a [`Step`][pydantic_graph.beta.step.Step] with bound inputs in a BaseNode interface.\n    It is not meant to be run directly but rather used to indicate transitions\n    to v2-style steps.\n    \"\"\"\n\n    step: Step[StateT, DepsT, Any, Any]\n    \"\"\"The step to execute.\"\"\"\n\n    inputs: Any\n    \"\"\"The inputs bound to this step.\"\"\"\n\n    async def run(self, ctx: GraphRunContext[StateT, DepsT]) -> BaseNode[StateT, DepsT, Any] | End[Any]:\n        \"\"\"Attempt to run the step node.\n\n        Args:\n            ctx: The graph execution context\n\n        Returns:\n            The result of step execution\n\n        Raises:\n            NotImplementedError: Always raised as StepNode is not meant to be run directly\n        \"\"\"\n        raise NotImplementedError(\n            '`StepNode` is not meant to be run directly, it is meant to be used in `BaseNode` subclasses to indicate a transition to v2-style steps.'\n        )\n\n```\n\n#### step\n\n```python\nstep: Step[StateT, DepsT, Any, Any]\n\n```\n\nThe step to execute.\n\n#### inputs\n\n```python\ninputs: Any\n\n```\n\nThe inputs bound to this step.\n\n#### run\n\n```python\nrun(\n    ctx: GraphRunContext[StateT, DepsT],\n) -> BaseNode[StateT, DepsT, Any] | End[Any]\n\n```\n\nAttempt to run the step node.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `ctx` | `GraphRunContext[StateT, DepsT]` | The graph execution context | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `BaseNode[StateT, DepsT, Any] | End[Any]` | The result of step execution |\n\nRaises:\n\n| Type | Description | | --- | --- | | `NotImplementedError` | Always raised as StepNode is not meant to be run directly |\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\nasync def run(self, ctx: GraphRunContext[StateT, DepsT]) -> BaseNode[StateT, DepsT, Any] | End[Any]:\n    \"\"\"Attempt to run the step node.\n\n    Args:\n        ctx: The graph execution context\n\n    Returns:\n        The result of step execution\n\n    Raises:\n        NotImplementedError: Always raised as StepNode is not meant to be run directly\n    \"\"\"\n    raise NotImplementedError(\n        '`StepNode` is not meant to be run directly, it is meant to be used in `BaseNode` subclasses to indicate a transition to v2-style steps.'\n    )\n\n```\n\n### TypeExpression\n\nBases: `Generic[T]`\n\nA workaround for type checker limitations when using complex type expressions.\n\n```text\nThis class serves as a wrapper for types that cannot normally be used in positions\n\n```\n\nrequiring `type[T]`, such as `Any`, `Union[...]`, or `Literal[...]`. It provides a way to pass these complex type expressions to functions expecting concrete types.\n\nExample\n\nInstead of `output_type=Union[str, int]` (which may cause type errors), use `output_type=TypeExpression[Union[str, int]]`.\n\nNote\n\nThis is a workaround for the lack of TypeForm in the Python type system.\n\nSource code in `pydantic_graph/pydantic_graph/beta/util.py`\n\n```python\nclass TypeExpression(Generic[T]):\n    \"\"\"A workaround for type checker limitations when using complex type expressions.\n\n        This class serves as a wrapper for types that cannot normally be used in positions\n    requiring `type[T]`, such as `Any`, `Union[...]`, or `Literal[...]`. It provides a\n        way to pass these complex type expressions to functions expecting concrete types.\n\n    Example:\n            Instead of `output_type=Union[str, int]` (which may cause type errors),\n            use `output_type=TypeExpression[Union[str, int]]`.\n\n    Note:\n            This is a workaround for the lack of TypeForm in the Python type system.\n    \"\"\"\n\n    pass\n\n```",
  "content_length": 78149
}