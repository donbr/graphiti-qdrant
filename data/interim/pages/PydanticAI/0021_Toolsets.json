{
  "title": "Toolsets",
  "source_url": null,
  "content": "A toolset represents a collection of [tools](../tools/) that can be registered with an agent in one go. They can be reused by different agents, swapped out at runtime or during testing, and composed in order to dynamically filter which tools are available, modify tool definitions, or change tool execution behavior. A toolset can contain locally defined functions, depend on an external service to provide them, or implement custom logic to list available tools and handle them being called.\n\nToolsets are used (among many other things) to define [MCP servers](../mcp/client/) available to an agent. Pydantic AI includes many kinds of toolsets which are described below, and you can define a [custom toolset](#building-a-custom-toolset) by inheriting from the AbstractToolset class.\n\nThe toolsets that will be available during an agent run can be specified in four different ways:\n\n- at agent construction time, via the toolsets keyword argument to `Agent`, which takes toolset instances as well as functions that generate toolsets [dynamically](#dynamically-building-a-toolset) based on the agent run context\n- at agent run time, via the `toolsets` keyword argument to agent.run(), agent.run_sync(), agent.run_stream(), or agent.iter(). These toolsets will be additional to those registered on the `Agent`\n- [dynamically](#dynamically-building-a-toolset), via the @agent.toolset decorator which lets you build a toolset based on the agent run context\n- as a contextual override, via the `toolsets` keyword argument to the agent.override() context manager. These toolsets will replace those provided at agent construction or run time during the life of the context manager\n\ntoolsets.py\n\n```python\nfrom pydantic_ai import Agent, FunctionToolset\nfrom pydantic_ai.models.test import TestModel\n\n\ndef agent_tool():\n    return \"I'm registered directly on the agent\"\n\n\ndef extra_tool():\n    return \"I'm passed as an extra tool for a specific run\"\n\n\ndef override_tool():\n    return 'I override all other tools'\n\n\nagent_toolset = FunctionToolset(tools=[agent_tool]) # (1)!\nextra_toolset = FunctionToolset(tools=[extra_tool])\noverride_toolset = FunctionToolset(tools=[override_tool])\n\ntest_model = TestModel() # (2)!\nagent = Agent(test_model, toolsets=[agent_toolset])\n\nresult = agent.run_sync('What tools are available?')\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])\n#> ['agent_tool']\n\nresult = agent.run_sync('What tools are available?', toolsets=[extra_toolset])\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])\n#> ['agent_tool', 'extra_tool']\n\nwith agent.override(toolsets=[override_toolset]):\n    result = agent.run_sync('What tools are available?', toolsets=[extra_toolset]) # (3)!\n    print([t.name for t in test_model.last_model_request_parameters.function_tools])\n    #> ['override_tool']\n\n```\n\n1. The FunctionToolset will be explained in detail in the next section.\n1. We're using TestModel here because it makes it easy to see which tools were available on each run.\n1. This `extra_toolset` will be ignored because we're inside an override context.\n\n*(This example is complete, it can be run \"as is\")*\n\n## Function Toolset\n\nAs the name suggests, a FunctionToolset makes locally defined functions available as tools.\n\nFunctions can be added as tools in three different ways:\n\n- via the @toolset.tool decorator\n- via the tools keyword argument to the constructor which can take either plain functions, or instances of Tool\n- via the toolset.add_function() and toolset.add_tool() methods which can take a plain function or an instance of Tool respectively\n\nFunctions registered in any of these ways can define an initial `ctx: RunContext` argument in order to receive the agent run context. The `add_function()` and `add_tool()` methods can also be used from a tool function to dynamically register new tools during a run to be available in future run steps.\n\nfunction_toolset.py\n\n```python\nfrom datetime import datetime\n\nfrom pydantic_ai import Agent, FunctionToolset, RunContext\nfrom pydantic_ai.models.test import TestModel\n\n\ndef temperature_celsius(city: str) -> float:\n    return 21.0\n\n\ndef temperature_fahrenheit(city: str) -> float:\n    return 69.8\n\n\nweather_toolset = FunctionToolset(tools=[temperature_celsius, temperature_fahrenheit])\n\n\n@weather_toolset.tool\ndef conditions(ctx: RunContext, city: str) -> str:\n    if ctx.run_step % 2 == 0:\n        return \"It's sunny\"\n    else:\n        return \"It's raining\"\n\n\ndatetime_toolset = FunctionToolset()\ndatetime_toolset.add_function(lambda: datetime.now(), name='now')\n\ntest_model = TestModel()  # (1)!\nagent = Agent(test_model)\n\nresult = agent.run_sync('What tools are available?', toolsets=[weather_toolset])\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])\n#> ['temperature_celsius', 'temperature_fahrenheit', 'conditions']\n\nresult = agent.run_sync('What tools are available?', toolsets=[datetime_toolset])\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])\n#> ['now']\n\n```\n\n1. We're using TestModel here because it makes it easy to see which tools were available on each run.\n\n*(This example is complete, it can be run \"as is\")*\n\n## Toolset Composition\n\nToolsets can be composed to dynamically filter which tools are available, modify tool definitions, or change tool execution behavior. Multiple toolsets can also be combined into one.\n\n### Combining Toolsets\n\nCombinedToolset takes a list of toolsets and lets them be used as one.\n\ncombined_toolset.py\n\n```python\nfrom pydantic_ai import Agent, CombinedToolset\nfrom pydantic_ai.models.test import TestModel\n\nfrom function_toolset import datetime_toolset, weather_toolset\n\ncombined_toolset = CombinedToolset([weather_toolset, datetime_toolset])\n\ntest_model = TestModel() # (1)!\nagent = Agent(test_model, toolsets=[combined_toolset])\nresult = agent.run_sync('What tools are available?')\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])\n#> ['temperature_celsius', 'temperature_fahrenheit', 'conditions', 'now']\n\n```\n\n1. We're using TestModel here because it makes it easy to see which tools were available on each run.\n\n*(This example is complete, it can be run \"as is\")*\n\n### Filtering Tools\n\nFilteredToolset wraps a toolset and filters available tools ahead of each step of the run based on a user-defined function that is passed the agent run context and each tool's ToolDefinition and returns a boolean to indicate whether or not a given tool should be available.\n\nTo easily chain different modifications, you can also call filtered() on any toolset instead of directly constructing a `FilteredToolset`.\n\nfiltered_toolset.py\n\n```python\nfrom pydantic_ai import Agent\nfrom pydantic_ai.models.test import TestModel\n\nfrom combined_toolset import combined_toolset\n\nfiltered_toolset = combined_toolset.filtered(lambda ctx, tool_def: 'fahrenheit' not in tool_def.name)\n\ntest_model = TestModel() # (1)!\nagent = Agent(test_model, toolsets=[filtered_toolset])\nresult = agent.run_sync('What tools are available?')\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])\n#> ['weather_temperature_celsius', 'weather_conditions', 'datetime_now']\n\n```\n\n1. We're using TestModel here because it makes it easy to see which tools were available on each run.\n\n*(This example is complete, it can be run \"as is\")*\n\n### Prefixing Tool Names\n\nPrefixedToolset wraps a toolset and adds a prefix to each tool name to prevent tool name conflicts between different toolsets.\n\nTo easily chain different modifications, you can also call prefixed() on any toolset instead of directly constructing a `PrefixedToolset`.\n\ncombined_toolset.py\n\n```python\nfrom pydantic_ai import Agent, CombinedToolset\nfrom pydantic_ai.models.test import TestModel\n\nfrom function_toolset import datetime_toolset, weather_toolset\n\ncombined_toolset = CombinedToolset(\n    [\n        weather_toolset.prefixed('weather'),\n        datetime_toolset.prefixed('datetime')\n    ]\n)\n\ntest_model = TestModel() # (1)!\nagent = Agent(test_model, toolsets=[combined_toolset])\nresult = agent.run_sync('What tools are available?')\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])\n\"\"\"\n[\n    'weather_temperature_celsius',\n    'weather_temperature_fahrenheit',\n    'weather_conditions',\n    'datetime_now',\n]\n\"\"\"\n\n```\n\n1. We're using TestModel here because it makes it easy to see which tools were available on each run.\n\n*(This example is complete, it can be run \"as is\")*\n\n### Renaming Tools\n\nRenamedToolset wraps a toolset and lets you rename tools using a dictionary mapping new names to original names. This is useful when the names provided by a toolset are ambiguous or would conflict with tools defined by other toolsets, but [prefixing them](#prefixing-tool-names) creates a name that is unnecessarily long or could be confusing to the model.\n\nTo easily chain different modifications, you can also call renamed() on any toolset instead of directly constructing a `RenamedToolset`.\n\nrenamed_toolset.py\n\n```python\nfrom pydantic_ai import Agent\nfrom pydantic_ai.models.test import TestModel\n\nfrom combined_toolset import combined_toolset\n\nrenamed_toolset = combined_toolset.renamed(\n    {\n        'current_time': 'datetime_now',\n        'temperature_celsius': 'weather_temperature_celsius',\n        'temperature_fahrenheit': 'weather_temperature_fahrenheit'\n    }\n)\n\ntest_model = TestModel() # (1)!\nagent = Agent(test_model, toolsets=[renamed_toolset])\nresult = agent.run_sync('What tools are available?')\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])\n\"\"\"\n['temperature_celsius', 'temperature_fahrenheit', 'weather_conditions', 'current_time']\n\"\"\"\n\n```\n\n1. We're using TestModel here because it makes it easy to see which tools were available on each run.\n\n*(This example is complete, it can be run \"as is\")*\n\n### Dynamic Tool Definitions\n\nPreparedToolset lets you modify the entire list of available tools ahead of each step of the agent run using a user-defined function that takes the agent run context and a list of ToolDefinitions and returns a list of modified `ToolDefinition`s.\n\nThis is the toolset-specific equivalent of the [`prepare_tools`](../tools-advanced/#prepare-tools) argument to `Agent` that prepares all tool definitions registered on an agent across toolsets.\n\nNote that it is not possible to add or rename tools using `PreparedToolset`. Instead, you can use [`FunctionToolset.add_function()`](#function-toolset) or [`RenamedToolset`](#renaming-tools).\n\nTo easily chain different modifications, you can also call prepared() on any toolset instead of directly constructing a `PreparedToolset`.\n\nprepared_toolset.py\n\n```python\nfrom dataclasses import replace\n\nfrom pydantic_ai import Agent, RunContext, ToolDefinition\nfrom pydantic_ai.models.test import TestModel\n\nfrom renamed_toolset import renamed_toolset\n\ndescriptions = {\n    'temperature_celsius': 'Get the temperature in degrees Celsius',\n    'temperature_fahrenheit': 'Get the temperature in degrees Fahrenheit',\n    'weather_conditions': 'Get the current weather conditions',\n    'current_time': 'Get the current time',\n}\n\nasync def add_descriptions(ctx: RunContext, tool_defs: list[ToolDefinition]) -> list[ToolDefinition] | None:\n    return [\n        replace(tool_def, description=description)\n        if (description := descriptions.get(tool_def.name, None))\n        else tool_def\n        for tool_def\n        in tool_defs\n    ]\n\nprepared_toolset = renamed_toolset.prepared(add_descriptions)\n\ntest_model = TestModel() # (1)!\nagent = Agent(test_model, toolsets=[prepared_toolset])\nresult = agent.run_sync('What tools are available?')\nprint(test_model.last_model_request_parameters.function_tools)\n\"\"\"\n[\n    ToolDefinition(\n        name='temperature_celsius',\n        parameters_json_schema={\n            'additionalProperties': False,\n            'properties': {'city': {'type': 'string'}},\n            'required': ['city'],\n            'type': 'object',\n        },\n        description='Get the temperature in degrees Celsius',\n    ),\n    ToolDefinition(\n        name='temperature_fahrenheit',\n        parameters_json_schema={\n            'additionalProperties': False,\n            'properties': {'city': {'type': 'string'}},\n            'required': ['city'],\n            'type': 'object',\n        },\n        description='Get the temperature in degrees Fahrenheit',\n    ),\n    ToolDefinition(\n        name='weather_conditions',\n        parameters_json_schema={\n            'additionalProperties': False,\n            'properties': {'city': {'type': 'string'}},\n            'required': ['city'],\n            'type': 'object',\n        },\n        description='Get the current weather conditions',\n    ),\n    ToolDefinition(\n        name='current_time',\n        parameters_json_schema={\n            'additionalProperties': False,\n            'properties': {},\n            'type': 'object',\n        },\n        description='Get the current time',\n    ),\n]\n\"\"\"\n\n```\n\n1. We're using TestModel here because it makes it easy to see which tools were available on each run.\n\n### Requiring Tool Approval\n\nApprovalRequiredToolset wraps a toolset and lets you dynamically [require approval](../deferred-tools/#human-in-the-loop-tool-approval) for a given tool call based on a user-defined function that is passed the agent run context, the tool's ToolDefinition, and the validated tool call arguments. If no function is provided, all tool calls will require approval.\n\nTo easily chain different modifications, you can also call approval_required() on any toolset instead of directly constructing a `ApprovalRequiredToolset`.\n\nSee the [Human-in-the-Loop Tool Approval](../deferred-tools/#human-in-the-loop-tool-approval) documentation for more information on how to handle agent runs that call tools that require approval and how to pass in the results.\n\napproval_required_toolset.py\n\n```python\nfrom pydantic_ai import Agent, DeferredToolRequests, DeferredToolResults\nfrom pydantic_ai.models.test import TestModel\n\nfrom prepared_toolset import prepared_toolset\n\napproval_required_toolset = prepared_toolset.approval_required(lambda ctx, tool_def, tool_args: tool_def.name.startswith('temperature'))\n\ntest_model = TestModel(call_tools=['temperature_celsius', 'temperature_fahrenheit']) # (1)!\nagent = Agent(\n    test_model,\n    toolsets=[approval_required_toolset],\n    output_type=[str, DeferredToolRequests],\n)\nresult = agent.run_sync('Call the temperature tools')\nmessages = result.all_messages()\nprint(result.output)\n\"\"\"\nDeferredToolRequests(\n    calls=[],\n    approvals=[\n        ToolCallPart(\n            tool_name='temperature_celsius',\n            args={'city': 'a'},\n            tool_call_id='pyd_ai_tool_call_id__temperature_celsius',\n        ),\n        ToolCallPart(\n            tool_name='temperature_fahrenheit',\n            args={'city': 'a'},\n            tool_call_id='pyd_ai_tool_call_id__temperature_fahrenheit',\n        ),\n    ],\n    metadata={},\n)\n\"\"\"\n\nresult = agent.run_sync(\n    message_history=messages,\n    deferred_tool_results=DeferredToolResults(\n        approvals={\n            'pyd_ai_tool_call_id__temperature_celsius': True,\n            'pyd_ai_tool_call_id__temperature_fahrenheit': False,\n        }\n    )\n)\nprint(result.output)\n#> {\"temperature_celsius\":21.0,\"temperature_fahrenheit\":\"The tool call was denied.\"}\n\n```\n\n1. We're using TestModel here because it makes it easy to specify which tools to call.\n\n*(This example is complete, it can be run \"as is\")*\n\n### Changing Tool Execution\n\nWrapperToolset wraps another toolset and delegates all responsibility to it.\n\nIt is is a no-op by default, but you can subclass `WrapperToolset` to change the wrapped toolset's tool execution behavior by overriding the call_tool() method.\n\nlogging_toolset.py\n\n```python\nimport asyncio\n\nfrom typing_extensions import Any\n\nfrom pydantic_ai import Agent, RunContext, ToolsetTool, WrapperToolset\nfrom pydantic_ai.models.test import TestModel\n\nfrom prepared_toolset import prepared_toolset\n\nLOG = []\n\nclass LoggingToolset(WrapperToolset):\n    async def call_tool(self, name: str, tool_args: dict[str, Any], ctx: RunContext, tool: ToolsetTool) -> Any:\n        LOG.append(f'Calling tool {name!r} with args: {tool_args!r}')\n        try:\n            await asyncio.sleep(0.1 * len(LOG)) # (1)!\n\n            result = await super().call_tool(name, tool_args, ctx, tool)\n            LOG.append(f'Finished calling tool {name!r} with result: {result!r}')\n        except Exception as e:\n            LOG.append(f'Error calling tool {name!r}: {e}')\n            raise e\n        else:\n            return result\n\n\nlogging_toolset = LoggingToolset(prepared_toolset)\n\nagent = Agent(TestModel(), toolsets=[logging_toolset]) # (2)!\nresult = agent.run_sync('Call all the tools')\nprint(LOG)\n\"\"\"\n[\n    \"Calling tool 'temperature_celsius' with args: {'city': 'a'}\",\n    \"Calling tool 'temperature_fahrenheit' with args: {'city': 'a'}\",\n    \"Calling tool 'weather_conditions' with args: {'city': 'a'}\",\n    \"Calling tool 'current_time' with args: {}\",\n    \"Finished calling tool 'temperature_celsius' with result: 21.0\",\n    \"Finished calling tool 'temperature_fahrenheit' with result: 69.8\",\n    'Finished calling tool \\'weather_conditions\\' with result: \"It\\'s raining\"',\n    \"Finished calling tool 'current_time' with result: datetime.datetime(...)\",\n]\n\"\"\"\n\n```\n\n1. All docs examples are tested in CI and their their output is verified, so we need `LOG` to always have the same order whenever this code is run. Since the tools could finish in any order, we sleep an increasing amount of time based on which number tool call we are to ensure that they finish (and log) in the same order they were called in.\n1. We use TestModel here as it will automatically call each tool.\n\n*(This example is complete, it can be run \"as is\")*\n\n## External Toolset\n\nIf your agent needs to be able to call [external tools](../deferred-tools/#external-tool-execution) that are provided and executed by an upstream service or frontend, you can build an ExternalToolset from a list of ToolDefinitions containing the tool names, arguments JSON schemas, and descriptions.\n\nWhen the model calls an external tool, the call is considered to be [\"deferred\"](../deferred-tools/#deferred-tools), and the agent run will end with a DeferredToolRequests output object with a `calls` list holding ToolCallParts containing the tool name, validated arguments, and a unique tool call ID, which are expected to be passed to the upstream service or frontend that will produce the results.\n\nWhen the tool call results are received from the upstream service or frontend, you can build a DeferredToolResults object with a `calls` dictionary that maps each tool call ID to an arbitrary value to be returned to the model, a [`ToolReturn`](../tools-advanced/#advanced-tool-returns) object, or a ModelRetry exception in case the tool call failed and the model should [try again](../tools-advanced/#tool-retries). This `DeferredToolResults` object can then be provided to one of the agent run methods as `deferred_tool_results`, alongside the original run's [message history](../message-history/).\n\nNote that you need to add `DeferredToolRequests` to the `Agent`'s or `agent.run()`'s [`output_type`](../output/#structured-output) so that the possible types of the agent run output are correctly inferred. For more information, see the [Deferred Tools](../deferred-tools/#deferred-tools) documentation.\n\nTo demonstrate, let us first define a simple agent *without* deferred tools:\n\n[Learn about Gateway](../gateway) deferred_toolset_agent.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, FunctionToolset\n\ntoolset = FunctionToolset()\n\n\n@toolset.tool\ndef get_default_language():\n    return 'en-US'\n\n\n@toolset.tool\ndef get_user_name():\n    return 'David'\n\n\nclass PersonalizedGreeting(BaseModel):\n    greeting: str\n    language_code: str\n\n\nagent = Agent('gateway/openai:gpt-5', toolsets=[toolset], output_type=PersonalizedGreeting)\n\nresult = agent.run_sync('Greet the user in a personalized way')\nprint(repr(result.output))\n#> PersonalizedGreeting(greeting='Hello, David!', language_code='en-US')\n\n```\n\ndeferred_toolset_agent.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, FunctionToolset\n\ntoolset = FunctionToolset()\n\n\n@toolset.tool\ndef get_default_language():\n    return 'en-US'\n\n\n@toolset.tool\ndef get_user_name():\n    return 'David'\n\n\nclass PersonalizedGreeting(BaseModel):\n    greeting: str\n    language_code: str\n\n\nagent = Agent('openai:gpt-5', toolsets=[toolset], output_type=PersonalizedGreeting)\n\nresult = agent.run_sync('Greet the user in a personalized way')\nprint(repr(result.output))\n#> PersonalizedGreeting(greeting='Hello, David!', language_code='en-US')\n\n```\n\nNext, let's define a function that represents a hypothetical \"run agent\" API endpoint that can be called by the frontend and takes a list of messages to send to the model, a list of frontend tool definitions, and optional deferred tool results. This is where `ExternalToolset`, `DeferredToolRequests`, and `DeferredToolResults` come in:\n\ndeferred_toolset_api.py\n\n```python\nfrom pydantic_ai import (\n    DeferredToolRequests,\n    DeferredToolResults,\n    ExternalToolset,\n    ModelMessage,\n    ToolDefinition,\n)\n\nfrom deferred_toolset_agent import PersonalizedGreeting, agent\n\n\ndef run_agent(\n    messages: list[ModelMessage] = [],\n    frontend_tools: list[ToolDefinition] = {},\n    deferred_tool_results: DeferredToolResults | None = None,\n) -> tuple[PersonalizedGreeting | DeferredToolRequests, list[ModelMessage]]:\n    deferred_toolset = ExternalToolset(frontend_tools)\n    result = agent.run_sync(\n        toolsets=[deferred_toolset], # (1)!\n        output_type=[agent.output_type, DeferredToolRequests], # (2)!\n        message_history=messages, # (3)!\n        deferred_tool_results=deferred_tool_results,\n    )\n    return result.output, result.new_messages()\n\n```\n\n1. As mentioned in the [Deferred Tools](../deferred-tools/#deferred-tools) documentation, these `toolsets` are additional to those provided to the `Agent` constructor\n1. As mentioned in the [Deferred Tools](../deferred-tools/#deferred-tools) documentation, this `output_type` overrides the one provided to the `Agent` constructor, so we have to make sure to not lose it\n1. We don't include an `user_prompt` keyword argument as we expect the frontend to provide it via `messages`\n\nNow, imagine that the code below is implemented on the frontend, and `run_agent` stands in for an API call to the backend that runs the agent. This is where we actually execute the deferred tool calls and start a new run with the new result included:\n\ndeferred_tools.py\n\n```python\nfrom pydantic_ai import (\n    DeferredToolRequests,\n    DeferredToolResults,\n    ModelMessage,\n    ModelRequest,\n    ModelRetry,\n    ToolDefinition,\n    UserPromptPart,\n)\n\nfrom deferred_toolset_api import run_agent\n\nfrontend_tool_definitions = [\n    ToolDefinition(\n        name='get_preferred_language',\n        parameters_json_schema={'type': 'object', 'properties': {'default_language': {'type': 'string'}}},\n        description=\"Get the user's preferred language from their browser\",\n    )\n]\n\ndef get_preferred_language(default_language: str) -> str:\n    return 'es-MX' # (1)!\n\nfrontend_tool_functions = {'get_preferred_language': get_preferred_language}\n\nmessages: list[ModelMessage] = [\n    ModelRequest(\n        parts=[\n            UserPromptPart(content='Greet the user in a personalized way')\n        ]\n    )\n]\n\ndeferred_tool_results: DeferredToolResults | None = None\n\nfinal_output = None\nwhile True:\n    output, new_messages = run_agent(messages, frontend_tool_definitions, deferred_tool_results)\n    messages += new_messages\n\n    if not isinstance(output, DeferredToolRequests):\n        final_output = output\n        break\n\n    print(output.calls)\n    \"\"\"\n    [\n        ToolCallPart(\n            tool_name='get_preferred_language',\n            args={'default_language': 'en-US'},\n            tool_call_id='pyd_ai_tool_call_id',\n        )\n    ]\n    \"\"\"\n    deferred_tool_results = DeferredToolResults()\n    for tool_call in output.calls:\n        if function := frontend_tool_functions.get(tool_call.tool_name):\n            result = function(**tool_call.args_as_dict())\n        else:\n            result = ModelRetry(f'Unknown tool {tool_call.tool_name!r}')\n        deferred_tool_results.calls[tool_call.tool_call_id] = result\n\nprint(repr(final_output))\n\"\"\"\nPersonalizedGreeting(greeting='Hola, David! Espero que tengas un gran dÃ­a!', language_code='es-MX')\n\"\"\"\n\n```\n\n1. Imagine that this returns the frontend [`navigator.language`](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/language).\n\n*(This example is complete, it can be run \"as is\")*\n\n## Dynamically Building a Toolset\n\nToolsets can be built dynamically ahead of each agent run or run step using a function that takes the agent run context and returns a toolset or `None`. This is useful when a toolset (like an MCP server) depends on information specific to an agent run, like its [dependencies](../dependencies/).\n\nTo register a dynamic toolset, you can pass a function that takes RunContext to the `toolsets` argument of the `Agent` constructor, or you can wrap a compliant function in the @agent.toolset decorator.\n\nBy default, the function will be called again ahead of each agent run step. If you are using the decorator, you can optionally provide a `per_run_step=False` argument to indicate that the toolset only needs to be built once for the entire run.\n\ndynamic_toolset.py\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Literal\n\nfrom pydantic_ai import Agent, RunContext\nfrom pydantic_ai.models.test import TestModel\n\nfrom function_toolset import datetime_toolset, weather_toolset\n\n\n@dataclass\nclass ToggleableDeps:\n    active: Literal['weather', 'datetime']\n\n    def toggle(self):\n        if self.active == 'weather':\n            self.active = 'datetime'\n        else:\n            self.active = 'weather'\n\ntest_model = TestModel()  # (1)!\nagent = Agent(\n    test_model,\n    deps_type=ToggleableDeps  # (2)!\n)\n\n@agent.toolset\ndef toggleable_toolset(ctx: RunContext[ToggleableDeps]):\n    if ctx.deps.active == 'weather':\n        return weather_toolset\n    else:\n        return datetime_toolset\n\n@agent.tool\ndef toggle(ctx: RunContext[ToggleableDeps]):\n    ctx.deps.toggle()\n\ndeps = ToggleableDeps('weather')\n\nresult = agent.run_sync('Toggle the toolset', deps=deps)\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])  # (3)!\n#> ['toggle', 'now']\n\nresult = agent.run_sync('Toggle the toolset', deps=deps)\nprint([t.name for t in test_model.last_model_request_parameters.function_tools])\n#> ['toggle', 'temperature_celsius', 'temperature_fahrenheit', 'conditions']\n\n```\n\n1. We're using TestModel here because it makes it easy to see which tools were available on each run.\n1. We're using the agent's dependencies to give the `toggle` tool access to the `active` via the `RunContext` argument.\n1. This shows the available tools *after* the `toggle` tool was executed, as the \"last model request\" was the one that returned the `toggle` tool result to the model.\n\n*(This example is complete, it can be run \"as is\")*\n\n## Building a Custom Toolset\n\nTo define a fully custom toolset with its own logic to list available tools and handle them being called, you can subclass AbstractToolset and implement the get_tools() and call_tool() methods.\n\nIf you want to reuse a network connection or session across tool listings and calls during an agent run, you can implement __aenter__() and __aexit__().\n\n## Third-Party Toolsets\n\n### MCP Servers\n\nPydantic AI provides two toolsets that allow an agent to connect to and call tools on local and remote MCP Servers:\n\n1. `MCPServer`: the [MCP SDK-based Client](../mcp/client/) which offers more direct control by leveraging the MCP SDK directly\n1. `FastMCPToolset`: the [FastMCP-based Client](../mcp/fastmcp-client/) which offers additional capabilities like Tool Transformation, simpler OAuth configuration, and more.\n\n### LangChain Tools\n\nIf you'd like to use tools or a [toolkit](https://python.langchain.com/docs/concepts/tools/#toolkits) from LangChain's [community tool library](https://python.langchain.com/docs/integrations/tools/) with Pydantic AI, you can use the LangChainToolset which takes a list of LangChain tools. Note that Pydantic AI will not validate the arguments in this case -- it's up to the model to provide arguments matching the schema specified by the LangChain tool, and up to the LangChain tool to raise an error if the arguments are invalid.\n\nYou will need to install the `langchain-community` package and any others required by the tools in question.\n\n[Learn about Gateway](../gateway)\n\n```python\nfrom langchain_community.agent_toolkits import SlackToolkit\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ext.langchain import LangChainToolset\n\ntoolkit = SlackToolkit()\ntoolset = LangChainToolset(toolkit.get_tools())\n\nagent = Agent('gateway/openai:gpt-5', toolsets=[toolset])\n### ...\n\n```\n\n```python\nfrom langchain_community.agent_toolkits import SlackToolkit\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ext.langchain import LangChainToolset\n\ntoolkit = SlackToolkit()\ntoolset = LangChainToolset(toolkit.get_tools())\n\nagent = Agent('openai:gpt-5', toolsets=[toolset])\n### ...\n\n```\n\n### ACI.dev Tools\n\nIf you'd like to use tools from the [ACI.dev tool library](https://www.aci.dev/tools) with Pydantic AI, you can use the ACIToolset [toolset](./) which takes a list of ACI tool names as well as the `linked_account_owner_id`. Note that Pydantic AI will not validate the arguments in this case -- it's up to the model to provide arguments matching the schema specified by the ACI tool, and up to the ACI tool to raise an error if the arguments are invalid.\n\nYou will need to install the `aci-sdk` package, set your ACI API key in the `ACI_API_KEY` environment variable, and pass your ACI \"linked account owner ID\" to the function.\n\n[Learn about Gateway](../gateway)\n\n```python\nimport os\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ext.aci import ACIToolset\n\ntoolset = ACIToolset(\n    [\n        'OPEN_WEATHER_MAP__CURRENT_WEATHER',\n        'OPEN_WEATHER_MAP__FORECAST',\n    ],\n    linked_account_owner_id=os.getenv('LINKED_ACCOUNT_OWNER_ID'),\n)\n\nagent = Agent('gateway/openai:gpt-5', toolsets=[toolset])\n\n```\n\n```python\nimport os\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ext.aci import ACIToolset\n\ntoolset = ACIToolset(\n    [\n        'OPEN_WEATHER_MAP__CURRENT_WEATHER',\n        'OPEN_WEATHER_MAP__FORECAST',\n    ],\n    linked_account_owner_id=os.getenv('LINKED_ACCOUNT_OWNER_ID'),\n)\n\nagent = Agent('openai:gpt-5', toolsets=[toolset])\n\n```",
  "content_length": 30814
}