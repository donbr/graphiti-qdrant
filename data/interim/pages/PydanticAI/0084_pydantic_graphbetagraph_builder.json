{
  "title": "`pydantic_graph.beta.graph_builder`",
  "source_url": null,
  "content": "Graph builder for constructing executable graph definitions.\n\nThis module provides the GraphBuilder class and related utilities for constructing typed, executable graph definitions with steps, joins, decisions, and edge routing.\n\n### GraphBuilder\n\nBases: `Generic[StateT, DepsT, GraphInputT, GraphOutputT]`\n\nA builder for constructing executable graph definitions.\n\nGraphBuilder provides a fluent interface for defining nodes, edges, and routing in a graph workflow. It supports typed state, dependencies, and input/output validation.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies GraphInputT: The type of the graph input data GraphOutputT: The type of the graph output data\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\n@dataclass(init=False)\nclass GraphBuilder(Generic[StateT, DepsT, GraphInputT, GraphOutputT]):\n    \"\"\"A builder for constructing executable graph definitions.\n\n    GraphBuilder provides a fluent interface for defining nodes, edges, and\n    routing in a graph workflow. It supports typed state, dependencies, and\n    input/output validation.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        GraphInputT: The type of the graph input data\n        GraphOutputT: The type of the graph output data\n    \"\"\"\n\n    name: str | None\n    \"\"\"Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\"\"\"\n\n    state_type: TypeOrTypeExpression[StateT]\n    \"\"\"The type of the graph state.\"\"\"\n\n    deps_type: TypeOrTypeExpression[DepsT]\n    \"\"\"The type of the dependencies.\"\"\"\n\n    input_type: TypeOrTypeExpression[GraphInputT]\n    \"\"\"The type of the graph input data.\"\"\"\n\n    output_type: TypeOrTypeExpression[GraphOutputT]\n    \"\"\"The type of the graph output data.\"\"\"\n\n    auto_instrument: bool\n    \"\"\"Whether to automatically create instrumentation spans.\"\"\"\n\n    _nodes: dict[NodeID, AnyNode]\n    \"\"\"Internal storage for nodes in the graph.\"\"\"\n\n    _edges_by_source: dict[NodeID, list[Path]]\n    \"\"\"Internal storage for edges by source node.\"\"\"\n\n    _decision_index: int\n    \"\"\"Counter for generating unique decision node IDs.\"\"\"\n\n    Source = TypeAliasType('Source', SourceNode[StateT, DepsT, OutputT], type_params=(OutputT,))\n    Destination = TypeAliasType('Destination', DestinationNode[StateT, DepsT, InputT], type_params=(InputT,))\n\n    def __init__(\n        self,\n        *,\n        name: str | None = None,\n        state_type: TypeOrTypeExpression[StateT] = NoneType,\n        deps_type: TypeOrTypeExpression[DepsT] = NoneType,\n        input_type: TypeOrTypeExpression[GraphInputT] = NoneType,\n        output_type: TypeOrTypeExpression[GraphOutputT] = NoneType,\n        auto_instrument: bool = True,\n    ):\n        \"\"\"Initialize a graph builder.\n\n        Args:\n            name: Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\n            state_type: The type of the graph state\n            deps_type: The type of the dependencies\n            input_type: The type of the graph input data\n            output_type: The type of the graph output data\n            auto_instrument: Whether to automatically create instrumentation spans\n        \"\"\"\n        self.name = name\n\n        self.state_type = state_type\n        self.deps_type = deps_type\n        self.input_type = input_type\n        self.output_type = output_type\n\n        self.auto_instrument = auto_instrument\n\n        self._nodes = {}\n        self._edges_by_source = defaultdict(list)\n        self._decision_index = 1\n\n        self._start_node = StartNode[GraphInputT]()\n        self._end_node = EndNode[GraphOutputT]()\n\n    # Node building\n    @property\n    def start_node(self) -> StartNode[GraphInputT]:\n        \"\"\"Get the start node for the graph.\n\n        Returns:\n            The start node that receives the initial graph input\n        \"\"\"\n        return self._start_node\n\n    @property\n    def end_node(self) -> EndNode[GraphOutputT]:\n        \"\"\"Get the end node for the graph.\n\n        Returns:\n            The end node that produces the final graph output\n        \"\"\"\n        return self._end_node\n\n    @overload\n    def step(\n        self,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> Callable[[StepFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, OutputT]]: ...\n    @overload\n    def step(\n        self,\n        call: StepFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> Step[StateT, DepsT, InputT, OutputT]: ...\n    def step(\n        self,\n        call: StepFunction[StateT, DepsT, InputT, OutputT] | None = None,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> (\n        Step[StateT, DepsT, InputT, OutputT]\n        | Callable[[StepFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, OutputT]]\n    ):\n        \"\"\"Create a step from a step function.\n\n        This method can be used as a decorator or called directly to create\n        a step node from an async function.\n\n        Args:\n            call: The step function to wrap\n            node_id: Optional ID for the node\n            label: Optional human-readable label\n\n        Returns:\n            Either a Step instance or a decorator function\n        \"\"\"\n        if call is None:\n\n            def decorator(\n                func: StepFunction[StateT, DepsT, InputT, OutputT],\n            ) -> Step[StateT, DepsT, InputT, OutputT]:\n                return self.step(call=func, node_id=node_id, label=label)\n\n            return decorator\n\n        node_id = node_id or get_callable_name(call)\n\n        step = Step[StateT, DepsT, InputT, OutputT](id=NodeID(node_id), call=call, label=label)\n\n        return step\n\n    @overload\n    def stream(\n        self,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> Callable[\n        [StreamFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n    ]: ...\n    @overload\n    def stream(\n        self,\n        call: StreamFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]: ...\n    @overload\n    def stream(\n        self,\n        call: StreamFunction[StateT, DepsT, InputT, OutputT] | None = None,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> (\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n        | Callable[\n            [StreamFunction[StateT, DepsT, InputT, OutputT]],\n            Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n        ]\n    ): ...\n    def stream(\n        self,\n        call: StreamFunction[StateT, DepsT, InputT, OutputT] | None = None,\n        *,\n        node_id: str | None = None,\n        label: str | None = None,\n    ) -> (\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n        | Callable[\n            [StreamFunction[StateT, DepsT, InputT, OutputT]],\n            Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n        ]\n    ):\n        \"\"\"Create a step from an async iterator (which functions like a \"stream\").\n\n        This method can be used as a decorator or called directly to create\n        a step node from an async function.\n\n        Args:\n            call: The step function to wrap\n            node_id: Optional ID for the node\n            label: Optional human-readable label\n\n        Returns:\n            Either a Step instance or a decorator function\n        \"\"\"\n        if call is None:\n\n            def decorator(\n                func: StreamFunction[StateT, DepsT, InputT, OutputT],\n            ) -> Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]:\n                return self.stream(call=func, node_id=node_id, label=label)\n\n            return decorator\n\n        # We need to wrap the call so that we can call `await` even though the result is an async iterator\n        async def wrapper(ctx: StepContext[StateT, DepsT, InputT]):\n            return call(ctx)\n\n        return self.step(call=wrapper, node_id=node_id, label=label)\n\n    @overload\n    def join(\n        self,\n        reducer: ReducerFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        initial: OutputT,\n        node_id: str | None = None,\n        parent_fork_id: str | None = None,\n        preferred_parent_fork: Literal['farthest', 'closest'] = 'farthest',\n    ) -> Join[StateT, DepsT, InputT, OutputT]: ...\n    @overload\n    def join(\n        self,\n        reducer: ReducerFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        initial_factory: Callable[[], OutputT],\n        node_id: str | None = None,\n        parent_fork_id: str | None = None,\n        preferred_parent_fork: Literal['farthest', 'closest'] = 'farthest',\n    ) -> Join[StateT, DepsT, InputT, OutputT]: ...\n\n    def join(\n        self,\n        reducer: ReducerFunction[StateT, DepsT, InputT, OutputT],\n        *,\n        initial: OutputT | Unset = UNSET,\n        initial_factory: Callable[[], OutputT] | Unset = UNSET,\n        node_id: str | None = None,\n        parent_fork_id: str | None = None,\n        preferred_parent_fork: Literal['farthest', 'closest'] = 'farthest',\n    ) -> Join[StateT, DepsT, InputT, OutputT]:\n        if initial_factory is UNSET:\n            initial_factory = lambda: initial  # pyright: ignore[reportAssignmentType]  # noqa: E731\n\n        return Join[StateT, DepsT, InputT, OutputT](\n            id=JoinID(NodeID(node_id or generate_placeholder_node_id(get_callable_name(reducer)))),\n            reducer=reducer,\n            initial_factory=cast(Callable[[], OutputT], initial_factory),\n            parent_fork_id=ForkID(parent_fork_id) if parent_fork_id is not None else None,\n            preferred_parent_fork=preferred_parent_fork,\n        )\n\n    # Edge building\n    def add(self, *edges: EdgePath[StateT, DepsT]) -> None:  # noqa: C901\n        \"\"\"Add one or more edge paths to the graph.\n\n        This method processes edge paths and automatically creates any necessary\n        fork nodes for broadcasts and maps.\n\n        Args:\n            *edges: The edge paths to add to the graph\n        \"\"\"\n\n        def _handle_path(p: Path):\n            \"\"\"Process a path and create necessary fork nodes.\n\n            Args:\n                p: The path to process\n            \"\"\"\n            for item in p.items:\n                if isinstance(item, BroadcastMarker):\n                    new_node = Fork[Any, Any](id=item.fork_id, is_map=False, downstream_join_id=None)\n                    self._insert_node(new_node)\n                    for path in item.paths:\n                        _handle_path(Path(items=[*path.items]))\n                elif isinstance(item, MapMarker):\n                    new_node = Fork[Any, Any](id=item.fork_id, is_map=True, downstream_join_id=item.downstream_join_id)\n                    self._insert_node(new_node)\n                elif isinstance(item, DestinationMarker):\n                    pass\n\n        def _handle_destination_node(d: AnyDestinationNode):\n            if id(d) in destination_ids:\n                return  # prevent infinite recursion if there is a cycle of decisions\n\n            destination_ids.add(id(d))\n            destinations.append(d)\n            self._insert_node(d)\n            if isinstance(d, Decision):\n                for branch in d.branches:\n                    _handle_path(branch.path)\n                    for d2 in branch.destinations:\n                        _handle_destination_node(d2)\n\n        destination_ids = set[int]()\n        destinations: list[AnyDestinationNode] = []\n        for edge in edges:\n            for source_node in edge.sources:\n                self._insert_node(source_node)\n                self._edges_by_source[source_node.id].append(edge.path)\n            for destination_node in edge.destinations:\n                _handle_destination_node(destination_node)\n            _handle_path(edge.path)\n\n        # Automatically create edges from step function return hints including `BaseNode`s\n        for destination in destinations:\n            if not isinstance(destination, Step) or isinstance(destination, NodeStep):\n                continue\n            parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n            type_hints = get_type_hints(destination.call, localns=parent_namespace, include_extras=True)\n            try:\n                return_hint = type_hints['return']\n            except KeyError:\n                pass\n            else:\n                edge = self._edge_from_return_hint(destination, return_hint)\n                if edge is not None:\n                    self.add(edge)\n\n    def add_edge(self, source: Source[T], destination: Destination[T], *, label: str | None = None) -> None:\n        \"\"\"Add a simple edge between two nodes.\n\n        Args:\n            source: The source node\n            destination: The destination node\n            label: Optional label for the edge\n        \"\"\"\n        builder = self.edge_from(source)\n        if label is not None:\n            builder = builder.label(label)\n        self.add(builder.to(destination))\n\n    def add_mapping_edge(\n        self,\n        source: Source[Iterable[T]],\n        map_to: Destination[T],\n        *,\n        pre_map_label: str | None = None,\n        post_map_label: str | None = None,\n        fork_id: ForkID | None = None,\n        downstream_join_id: JoinID | None = None,\n    ) -> None:\n        \"\"\"Add an edge that maps iterable data across parallel paths.\n\n        Args:\n            source: The source node that produces iterable data\n            map_to: The destination node that receives individual items\n            pre_map_label: Optional label before the map operation\n            post_map_label: Optional label after the map operation\n            fork_id: Optional ID for the fork node produced for this map operation\n            downstream_join_id: Optional ID of a join node that will always be downstream of this map.\n                Specifying this ensures correct handling if you try to map an empty iterable.\n        \"\"\"\n        builder = self.edge_from(source)\n        if pre_map_label is not None:\n            builder = builder.label(pre_map_label)\n        builder = builder.map(fork_id=fork_id, downstream_join_id=downstream_join_id)\n        if post_map_label is not None:\n            builder = builder.label(post_map_label)\n        self.add(builder.to(map_to))\n\n    # TODO(DavidM): Support adding subgraphs; I think this behaves like a step with the same inputs/outputs but gets rendered as a subgraph in mermaid\n\n    def edge_from(self, *sources: Source[SourceOutputT]) -> EdgePathBuilder[StateT, DepsT, SourceOutputT]:\n        \"\"\"Create an edge path builder starting from the given source nodes.\n\n        Args:\n            *sources: The source nodes to start the edge path from\n\n        Returns:\n            An EdgePathBuilder for constructing the complete edge path\n        \"\"\"\n        return EdgePathBuilder[StateT, DepsT, SourceOutputT](\n            sources=sources, path_builder=PathBuilder(working_items=[])\n        )\n\n    def decision(self, *, note: str | None = None, node_id: str | None = None) -> Decision[StateT, DepsT, Never]:\n        \"\"\"Create a new decision node.\n\n        Args:\n            note: Optional note to describe the decision logic\n            node_id: Optional ID for the node produced for this decision logic\n\n        Returns:\n            A new Decision node with no branches\n        \"\"\"\n        return Decision(id=NodeID(node_id or generate_placeholder_node_id('decision')), branches=[], note=note)\n\n    def match(\n        self,\n        source: TypeOrTypeExpression[SourceT],\n        *,\n        matches: Callable[[Any], bool] | None = None,\n    ) -> DecisionBranchBuilder[StateT, DepsT, SourceT, SourceT, Never]:\n        \"\"\"Create a decision branch matcher.\n\n        Args:\n            source: The type or type expression to match against\n            matches: Optional custom matching function\n\n        Returns:\n            A DecisionBranchBuilder for constructing the branch\n        \"\"\"\n        # Note, the following node_id really is just a placeholder and shouldn't end up in the final graph\n        # This is why we don't expose a way for end users to override the value used here.\n        node_id = NodeID(generate_placeholder_node_id('match_decision'))\n        decision = Decision[StateT, DepsT, Never](id=node_id, branches=[], note=None)\n        new_path_builder = PathBuilder[StateT, DepsT, SourceT](working_items=[])\n        return DecisionBranchBuilder(decision=decision, source=source, matches=matches, path_builder=new_path_builder)\n\n    def match_node(\n        self,\n        source: type[SourceNodeT],\n        *,\n        matches: Callable[[Any], bool] | None = None,\n    ) -> DecisionBranch[SourceNodeT]:\n        \"\"\"Create a decision branch for BaseNode subclasses.\n\n        This is similar to match() but specifically designed for matching\n        against BaseNode types from the v1 system.\n\n        Args:\n            source: The BaseNode subclass to match against\n            matches: Optional custom matching function\n\n        Returns:\n            A DecisionBranch for the BaseNode type\n        \"\"\"\n        node = NodeStep(source)\n        path = Path(items=[DestinationMarker(node.id)])\n        return DecisionBranch(source=source, matches=matches, path=path, destinations=[node])\n\n    def node(\n        self,\n        node_type: type[BaseNode[StateT, DepsT, GraphOutputT]],\n    ) -> EdgePath[StateT, DepsT]:\n        \"\"\"Create an edge path from a BaseNode class.\n\n        This method integrates v1-style BaseNode classes into the v2 graph\n        system by analyzing their type hints and creating appropriate edges.\n\n        Args:\n            node_type: The BaseNode subclass to integrate\n\n        Returns:\n            An EdgePath representing the node and its connections\n\n        Raises:\n            GraphSetupError: If the node type is missing required type hints\n        \"\"\"\n        parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n        type_hints = get_type_hints(node_type.run, localns=parent_namespace, include_extras=True)\n        try:\n            return_hint = type_hints['return']\n        except KeyError as e:  # pragma: no cover\n            raise exceptions.GraphSetupError(\n                f'Node {node_type} is missing a return type hint on its `run` method'\n            ) from e\n\n        node = NodeStep(node_type)\n\n        edge = self._edge_from_return_hint(node, return_hint)\n        if not edge:  # pragma: no cover\n            raise exceptions.GraphSetupError(f'Node {node_type} is missing a return type hint on its `run` method')\n\n        return edge\n\n    # Helpers\n    def _insert_node(self, node: AnyNode) -> None:\n        \"\"\"Insert a node into the graph, checking for ID conflicts.\n\n        Args:\n            node: The node to insert\n\n        Raises:\n            ValueError: If a different node with the same ID already exists\n        \"\"\"\n        existing = self._nodes.get(node.id)\n        if existing is None:\n            self._nodes[node.id] = node\n        elif isinstance(existing, NodeStep) and isinstance(node, NodeStep) and existing.node_type is node.node_type:\n            pass\n        elif existing is not node:\n            raise GraphBuildingError(\n                f'All nodes must have unique node IDs. {node.id!r} was the ID for {existing} and {node}'\n            )\n\n    def _edge_from_return_hint(\n        self, node: SourceNode[StateT, DepsT, Any], return_hint: TypeOrTypeExpression[Any]\n    ) -> EdgePath[StateT, DepsT] | None:\n        \"\"\"Create edges from a return type hint.\n\n        This method analyzes return type hints from step functions or node methods\n        to automatically create appropriate edges in the graph.\n\n        Args:\n            node: The source node\n            return_hint: The return type hint to analyze\n\n        Returns:\n            An EdgePath if edges can be inferred, None otherwise\n\n        Raises:\n            GraphSetupError: If the return type hint is invalid or incomplete\n        \"\"\"\n        destinations: list[AnyDestinationNode] = []\n        union_args = _utils.get_union_args(return_hint)\n        for return_type in union_args:\n            return_type, annotations = _utils.unpack_annotated(return_type)\n            return_type_origin = get_origin(return_type) or return_type\n            if return_type_origin is End:\n                destinations.append(self.end_node)\n            elif return_type_origin is BaseNode:\n                raise exceptions.GraphSetupError(  # pragma: no cover\n                    f'Node {node} return type hint includes a plain `BaseNode`. '\n                    'Edge inference requires each possible returned `BaseNode` subclass to be listed explicitly.'\n                )\n            elif return_type_origin is StepNode:\n                step = cast(\n                    Step[StateT, DepsT, Any, Any] | None,\n                    next((a for a in annotations if isinstance(a, Step)), None),  # pyright: ignore[reportUnknownArgumentType]\n                )\n                if step is None:\n                    raise exceptions.GraphSetupError(  # pragma: no cover\n                        f'Node {node} return type hint includes a `StepNode` without a `Step` annotation. '\n                        'When returning `my_step.as_node()`, use `Annotated[StepNode[StateT, DepsT], my_step]` as the return type hint.'\n                    )\n                destinations.append(step)\n            elif return_type_origin is JoinNode:\n                join = cast(\n                    Join[StateT, DepsT, Any, Any] | None,\n                    next((a for a in annotations if isinstance(a, Join)), None),  # pyright: ignore[reportUnknownArgumentType]\n                )\n                if join is None:\n                    raise exceptions.GraphSetupError(  # pragma: no cover\n                        f'Node {node} return type hint includes a `JoinNode` without a `Join` annotation. '\n                        'When returning `my_join.as_node()`, use `Annotated[JoinNode[StateT, DepsT], my_join]` as the return type hint.'\n                    )\n                destinations.append(join)\n            elif inspect.isclass(return_type_origin) and issubclass(return_type_origin, BaseNode):\n                destinations.append(NodeStep(return_type))\n\n        if len(destinations) < len(union_args):\n            # Only build edges if all the return types are nodes\n            return None\n\n        edge = self.edge_from(node)\n        if len(destinations) == 1:\n            return edge.to(destinations[0])\n        else:\n            decision = self.decision()\n            for destination in destinations:\n                # We don't actually use this decision mechanism, but we need to build the edges for parent-fork finding\n                decision = decision.branch(self.match(NoneType).to(destination))\n            return edge.to(decision)\n\n    # Graph building\n    def build(self, validate_graph_structure: bool = True) -> Graph[StateT, DepsT, GraphInputT, GraphOutputT]:\n        \"\"\"Build the final executable graph from the accumulated nodes and edges.\n\n        This method performs validation, normalization, and analysis of the graph\n        structure to create a complete, executable graph instance.\n\n        Args:\n            validate_graph_structure: whether to perform validation of the graph structure\n                See the docstring of _validate_graph_structure below for more details.\n\n        Returns:\n            A complete Graph instance ready for execution\n\n        Raises:\n            ValueError: If the graph structure is invalid (e.g., join without parent fork)\n        \"\"\"\n        nodes = self._nodes\n        edges_by_source = self._edges_by_source\n\n        nodes, edges_by_source = _replace_placeholder_node_ids(nodes, edges_by_source)\n        nodes, edges_by_source = _flatten_paths(nodes, edges_by_source)\n        nodes, edges_by_source = _normalize_forks(nodes, edges_by_source)\n        if validate_graph_structure:\n            _validate_graph_structure(nodes, edges_by_source)\n        parent_forks = _collect_dominating_forks(nodes, edges_by_source)\n        intermediate_join_nodes = _compute_intermediate_join_nodes(nodes, parent_forks)\n\n        return Graph[StateT, DepsT, GraphInputT, GraphOutputT](\n            name=self.name,\n            state_type=unpack_type_expression(self.state_type),\n            deps_type=unpack_type_expression(self.deps_type),\n            input_type=unpack_type_expression(self.input_type),\n            output_type=unpack_type_expression(self.output_type),\n            nodes=nodes,\n            edges_by_source=edges_by_source,\n            parent_forks=parent_forks,\n            intermediate_join_nodes=intermediate_join_nodes,\n            auto_instrument=self.auto_instrument,\n        )\n\n```\n\n#### __init__\n\n```python\n__init__(\n    *,\n    name: str | None = None,\n    state_type: TypeOrTypeExpression[StateT] = NoneType,\n    deps_type: TypeOrTypeExpression[DepsT] = NoneType,\n    input_type: TypeOrTypeExpression[\n        GraphInputT\n    ] = NoneType,\n    output_type: TypeOrTypeExpression[\n        GraphOutputT\n    ] = NoneType,\n    auto_instrument: bool = True\n)\n\n```\n\nInitialize a graph builder.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `name` | `str | None` | Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method. | `None` | | `state_type` | `TypeOrTypeExpression[StateT]` | The type of the graph state | `NoneType` | | `deps_type` | `TypeOrTypeExpression[DepsT]` | The type of the dependencies | `NoneType` | | `input_type` | `TypeOrTypeExpression[GraphInputT]` | The type of the graph input data | `NoneType` | | `output_type` | `TypeOrTypeExpression[GraphOutputT]` | The type of the graph output data | `NoneType` | | `auto_instrument` | `bool` | Whether to automatically create instrumentation spans | `True` |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef __init__(\n    self,\n    *,\n    name: str | None = None,\n    state_type: TypeOrTypeExpression[StateT] = NoneType,\n    deps_type: TypeOrTypeExpression[DepsT] = NoneType,\n    input_type: TypeOrTypeExpression[GraphInputT] = NoneType,\n    output_type: TypeOrTypeExpression[GraphOutputT] = NoneType,\n    auto_instrument: bool = True,\n):\n    \"\"\"Initialize a graph builder.\n\n    Args:\n        name: Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\n        state_type: The type of the graph state\n        deps_type: The type of the dependencies\n        input_type: The type of the graph input data\n        output_type: The type of the graph output data\n        auto_instrument: Whether to automatically create instrumentation spans\n    \"\"\"\n    self.name = name\n\n    self.state_type = state_type\n    self.deps_type = deps_type\n    self.input_type = input_type\n    self.output_type = output_type\n\n    self.auto_instrument = auto_instrument\n\n    self._nodes = {}\n    self._edges_by_source = defaultdict(list)\n    self._decision_index = 1\n\n    self._start_node = StartNode[GraphInputT]()\n    self._end_node = EndNode[GraphOutputT]()\n\n```\n\n#### name\n\n```python\nname: str | None = name\n\n```\n\nOptional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\n\n#### state_type\n\n```python\nstate_type: TypeOrTypeExpression[StateT] = state_type\n\n```\n\nThe type of the graph state.\n\n#### deps_type\n\n```python\ndeps_type: TypeOrTypeExpression[DepsT] = deps_type\n\n```\n\nThe type of the dependencies.\n\n#### input_type\n\n```python\ninput_type: TypeOrTypeExpression[GraphInputT] = input_type\n\n```\n\nThe type of the graph input data.\n\n#### output_type\n\n```python\noutput_type: TypeOrTypeExpression[GraphOutputT] = (\n    output_type\n)\n\n```\n\nThe type of the graph output data.\n\n#### auto_instrument\n\n```python\nauto_instrument: bool = auto_instrument\n\n```\n\nWhether to automatically create instrumentation spans.\n\n#### start_node\n\n```python\nstart_node: StartNode[GraphInputT]\n\n```\n\nGet the start node for the graph.\n\nReturns:\n\n| Type | Description | | --- | --- | | `StartNode[GraphInputT]` | The start node that receives the initial graph input |\n\n#### end_node\n\n```python\nend_node: EndNode[GraphOutputT]\n\n```\n\nGet the end node for the graph.\n\nReturns:\n\n| Type | Description | | --- | --- | | `EndNode[GraphOutputT]` | The end node that produces the final graph output |\n\n#### step\n\n```python\nstep(\n    *, node_id: str | None = None, label: str | None = None\n) -> Callable[\n    [StepFunction[StateT, DepsT, InputT, OutputT]],\n    Step[StateT, DepsT, InputT, OutputT],\n]\n\n```\n\n```python\nstep(\n    call: StepFunction[StateT, DepsT, InputT, OutputT],\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> Step[StateT, DepsT, InputT, OutputT]\n\n```\n\n```python\nstep(\n    call: (\n        StepFunction[StateT, DepsT, InputT, OutputT] | None\n    ) = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> (\n    Step[StateT, DepsT, InputT, OutputT]\n    | Callable[\n        [StepFunction[StateT, DepsT, InputT, OutputT]],\n        Step[StateT, DepsT, InputT, OutputT],\n    ]\n)\n\n```\n\nCreate a step from a step function.\n\nThis method can be used as a decorator or called directly to create a step node from an async function.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `call` | `StepFunction[StateT, DepsT, InputT, OutputT] | None` | The step function to wrap | `None` | | `node_id` | `str | None` | Optional ID for the node | `None` | | `label` | `str | None` | Optional human-readable label | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Step[StateT, DepsT, InputT, OutputT] | Callable[[StepFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, OutputT]]` | Either a Step instance or a decorator function |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef step(\n    self,\n    call: StepFunction[StateT, DepsT, InputT, OutputT] | None = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None,\n) -> (\n    Step[StateT, DepsT, InputT, OutputT]\n    | Callable[[StepFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, OutputT]]\n):\n    \"\"\"Create a step from a step function.\n\n    This method can be used as a decorator or called directly to create\n    a step node from an async function.\n\n    Args:\n        call: The step function to wrap\n        node_id: Optional ID for the node\n        label: Optional human-readable label\n\n    Returns:\n        Either a Step instance or a decorator function\n    \"\"\"\n    if call is None:\n\n        def decorator(\n            func: StepFunction[StateT, DepsT, InputT, OutputT],\n        ) -> Step[StateT, DepsT, InputT, OutputT]:\n            return self.step(call=func, node_id=node_id, label=label)\n\n        return decorator\n\n    node_id = node_id or get_callable_name(call)\n\n    step = Step[StateT, DepsT, InputT, OutputT](id=NodeID(node_id), call=call, label=label)\n\n    return step\n\n```\n\n#### stream\n\n```python\nstream(\n    *, node_id: str | None = None, label: str | None = None\n) -> Callable[\n    [StreamFunction[StateT, DepsT, InputT, OutputT]],\n    Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n]\n\n```\n\n```python\nstream(\n    call: StreamFunction[StateT, DepsT, InputT, OutputT],\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n\n```\n\n```python\nstream(\n    call: (\n        StreamFunction[StateT, DepsT, InputT, OutputT]\n        | None\n    ) = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> (\n    Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n    | Callable[\n        [StreamFunction[StateT, DepsT, InputT, OutputT]],\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n    ]\n)\n\n```\n\n```python\nstream(\n    call: (\n        StreamFunction[StateT, DepsT, InputT, OutputT]\n        | None\n    ) = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None\n) -> (\n    Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n    | Callable[\n        [StreamFunction[StateT, DepsT, InputT, OutputT]],\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n    ]\n)\n\n```\n\nCreate a step from an async iterator (which functions like a \"stream\").\n\nThis method can be used as a decorator or called directly to create a step node from an async function.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `call` | `StreamFunction[StateT, DepsT, InputT, OutputT] | None` | The step function to wrap | `None` | | `node_id` | `str | None` | Optional ID for the node | `None` | | `label` | `str | None` | Optional human-readable label | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Step[StateT, DepsT, InputT, AsyncIterable[OutputT]] | Callable[[StreamFunction[StateT, DepsT, InputT, OutputT]], Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]]` | Either a Step instance or a decorator function |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef stream(\n    self,\n    call: StreamFunction[StateT, DepsT, InputT, OutputT] | None = None,\n    *,\n    node_id: str | None = None,\n    label: str | None = None,\n) -> (\n    Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]\n    | Callable[\n        [StreamFunction[StateT, DepsT, InputT, OutputT]],\n        Step[StateT, DepsT, InputT, AsyncIterable[OutputT]],\n    ]\n):\n    \"\"\"Create a step from an async iterator (which functions like a \"stream\").\n\n    This method can be used as a decorator or called directly to create\n    a step node from an async function.\n\n    Args:\n        call: The step function to wrap\n        node_id: Optional ID for the node\n        label: Optional human-readable label\n\n    Returns:\n        Either a Step instance or a decorator function\n    \"\"\"\n    if call is None:\n\n        def decorator(\n            func: StreamFunction[StateT, DepsT, InputT, OutputT],\n        ) -> Step[StateT, DepsT, InputT, AsyncIterable[OutputT]]:\n            return self.stream(call=func, node_id=node_id, label=label)\n\n        return decorator\n\n    # We need to wrap the call so that we can call `await` even though the result is an async iterator\n    async def wrapper(ctx: StepContext[StateT, DepsT, InputT]):\n        return call(ctx)\n\n    return self.step(call=wrapper, node_id=node_id, label=label)\n\n```\n\n#### add\n\n```python\nadd(*edges: EdgePath[StateT, DepsT]) -> None\n\n```\n\nAdd one or more edge paths to the graph.\n\nThis method processes edge paths and automatically creates any necessary fork nodes for broadcasts and maps.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `*edges` | `EdgePath[StateT, DepsT]` | The edge paths to add to the graph | `()` |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef add(self, *edges: EdgePath[StateT, DepsT]) -> None:  # noqa: C901\n    \"\"\"Add one or more edge paths to the graph.\n\n    This method processes edge paths and automatically creates any necessary\n    fork nodes for broadcasts and maps.\n\n    Args:\n        *edges: The edge paths to add to the graph\n    \"\"\"\n\n    def _handle_path(p: Path):\n        \"\"\"Process a path and create necessary fork nodes.\n\n        Args:\n            p: The path to process\n        \"\"\"\n        for item in p.items:\n            if isinstance(item, BroadcastMarker):\n                new_node = Fork[Any, Any](id=item.fork_id, is_map=False, downstream_join_id=None)\n                self._insert_node(new_node)\n                for path in item.paths:\n                    _handle_path(Path(items=[*path.items]))\n            elif isinstance(item, MapMarker):\n                new_node = Fork[Any, Any](id=item.fork_id, is_map=True, downstream_join_id=item.downstream_join_id)\n                self._insert_node(new_node)\n            elif isinstance(item, DestinationMarker):\n                pass\n\n    def _handle_destination_node(d: AnyDestinationNode):\n        if id(d) in destination_ids:\n            return  # prevent infinite recursion if there is a cycle of decisions\n\n        destination_ids.add(id(d))\n        destinations.append(d)\n        self._insert_node(d)\n        if isinstance(d, Decision):\n            for branch in d.branches:\n                _handle_path(branch.path)\n                for d2 in branch.destinations:\n                    _handle_destination_node(d2)\n\n    destination_ids = set[int]()\n    destinations: list[AnyDestinationNode] = []\n    for edge in edges:\n        for source_node in edge.sources:\n            self._insert_node(source_node)\n            self._edges_by_source[source_node.id].append(edge.path)\n        for destination_node in edge.destinations:\n            _handle_destination_node(destination_node)\n        _handle_path(edge.path)\n\n    # Automatically create edges from step function return hints including `BaseNode`s\n    for destination in destinations:\n        if not isinstance(destination, Step) or isinstance(destination, NodeStep):\n            continue\n        parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n        type_hints = get_type_hints(destination.call, localns=parent_namespace, include_extras=True)\n        try:\n            return_hint = type_hints['return']\n        except KeyError:\n            pass\n        else:\n            edge = self._edge_from_return_hint(destination, return_hint)\n            if edge is not None:\n                self.add(edge)\n\n```\n\n#### add_edge\n\n```python\nadd_edge(\n    source: Source[T],\n    destination: Destination[T],\n    *,\n    label: str | None = None\n) -> None\n\n```\n\nAdd a simple edge between two nodes.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `source` | `Source[T]` | The source node | *required* | | `destination` | `Destination[T]` | The destination node | *required* | | `label` | `str | None` | Optional label for the edge | `None` |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef add_edge(self, source: Source[T], destination: Destination[T], *, label: str | None = None) -> None:\n    \"\"\"Add a simple edge between two nodes.\n\n    Args:\n        source: The source node\n        destination: The destination node\n        label: Optional label for the edge\n    \"\"\"\n    builder = self.edge_from(source)\n    if label is not None:\n        builder = builder.label(label)\n    self.add(builder.to(destination))\n\n```\n\n#### add_mapping_edge\n\n```python\nadd_mapping_edge(\n    source: Source[Iterable[T]],\n    map_to: Destination[T],\n    *,\n    pre_map_label: str | None = None,\n    post_map_label: str | None = None,\n    fork_id: ForkID | None = None,\n    downstream_join_id: JoinID | None = None\n) -> None\n\n```\n\nAdd an edge that maps iterable data across parallel paths.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `source` | `Source[Iterable[T]]` | The source node that produces iterable data | *required* | | `map_to` | `Destination[T]` | The destination node that receives individual items | *required* | | `pre_map_label` | `str | None` | Optional label before the map operation | `None` | | `post_map_label` | `str | None` | Optional label after the map operation | `None` | | `fork_id` | `ForkID | None` | Optional ID for the fork node produced for this map operation | `None` | | `downstream_join_id` | `JoinID | None` | Optional ID of a join node that will always be downstream of this map. Specifying this ensures correct handling if you try to map an empty iterable. | `None` |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef add_mapping_edge(\n    self,\n    source: Source[Iterable[T]],\n    map_to: Destination[T],\n    *,\n    pre_map_label: str | None = None,\n    post_map_label: str | None = None,\n    fork_id: ForkID | None = None,\n    downstream_join_id: JoinID | None = None,\n) -> None:\n    \"\"\"Add an edge that maps iterable data across parallel paths.\n\n    Args:\n        source: The source node that produces iterable data\n        map_to: The destination node that receives individual items\n        pre_map_label: Optional label before the map operation\n        post_map_label: Optional label after the map operation\n        fork_id: Optional ID for the fork node produced for this map operation\n        downstream_join_id: Optional ID of a join node that will always be downstream of this map.\n            Specifying this ensures correct handling if you try to map an empty iterable.\n    \"\"\"\n    builder = self.edge_from(source)\n    if pre_map_label is not None:\n        builder = builder.label(pre_map_label)\n    builder = builder.map(fork_id=fork_id, downstream_join_id=downstream_join_id)\n    if post_map_label is not None:\n        builder = builder.label(post_map_label)\n    self.add(builder.to(map_to))\n\n```\n\n#### edge_from\n\n```python\nedge_from(\n    *sources: Source[SourceOutputT],\n) -> EdgePathBuilder[StateT, DepsT, SourceOutputT]\n\n```\n\nCreate an edge path builder starting from the given source nodes.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `*sources` | `Source[SourceOutputT]` | The source nodes to start the edge path from | `()` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `EdgePathBuilder[StateT, DepsT, SourceOutputT]` | An EdgePathBuilder for constructing the complete edge path |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef edge_from(self, *sources: Source[SourceOutputT]) -> EdgePathBuilder[StateT, DepsT, SourceOutputT]:\n    \"\"\"Create an edge path builder starting from the given source nodes.\n\n    Args:\n        *sources: The source nodes to start the edge path from\n\n    Returns:\n        An EdgePathBuilder for constructing the complete edge path\n    \"\"\"\n    return EdgePathBuilder[StateT, DepsT, SourceOutputT](\n        sources=sources, path_builder=PathBuilder(working_items=[])\n    )\n\n```\n\n#### decision\n\n```python\ndecision(\n    *, note: str | None = None, node_id: str | None = None\n) -> Decision[StateT, DepsT, Never]\n\n```\n\nCreate a new decision node.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `note` | `str | None` | Optional note to describe the decision logic | `None` | | `node_id` | `str | None` | Optional ID for the node produced for this decision logic | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Decision[StateT, DepsT, Never]` | A new Decision node with no branches |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef decision(self, *, note: str | None = None, node_id: str | None = None) -> Decision[StateT, DepsT, Never]:\n    \"\"\"Create a new decision node.\n\n    Args:\n        note: Optional note to describe the decision logic\n        node_id: Optional ID for the node produced for this decision logic\n\n    Returns:\n        A new Decision node with no branches\n    \"\"\"\n    return Decision(id=NodeID(node_id or generate_placeholder_node_id('decision')), branches=[], note=note)\n\n```\n\n#### match\n\n```python\nmatch(\n    source: TypeOrTypeExpression[SourceT],\n    *,\n    matches: Callable[[Any], bool] | None = None\n) -> DecisionBranchBuilder[\n    StateT, DepsT, SourceT, SourceT, Never\n]\n\n```\n\nCreate a decision branch matcher.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `source` | `TypeOrTypeExpression[SourceT]` | The type or type expression to match against | *required* | | `matches` | `Callable[[Any], bool] | None` | Optional custom matching function | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `DecisionBranchBuilder[StateT, DepsT, SourceT, SourceT, Never]` | A DecisionBranchBuilder for constructing the branch |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef match(\n    self,\n    source: TypeOrTypeExpression[SourceT],\n    *,\n    matches: Callable[[Any], bool] | None = None,\n) -> DecisionBranchBuilder[StateT, DepsT, SourceT, SourceT, Never]:\n    \"\"\"Create a decision branch matcher.\n\n    Args:\n        source: The type or type expression to match against\n        matches: Optional custom matching function\n\n    Returns:\n        A DecisionBranchBuilder for constructing the branch\n    \"\"\"\n    # Note, the following node_id really is just a placeholder and shouldn't end up in the final graph\n    # This is why we don't expose a way for end users to override the value used here.\n    node_id = NodeID(generate_placeholder_node_id('match_decision'))\n    decision = Decision[StateT, DepsT, Never](id=node_id, branches=[], note=None)\n    new_path_builder = PathBuilder[StateT, DepsT, SourceT](working_items=[])\n    return DecisionBranchBuilder(decision=decision, source=source, matches=matches, path_builder=new_path_builder)\n\n```\n\n#### match_node\n\n```python\nmatch_node(\n    source: type[SourceNodeT],\n    *,\n    matches: Callable[[Any], bool] | None = None\n) -> DecisionBranch[SourceNodeT]\n\n```\n\nCreate a decision branch for BaseNode subclasses.\n\nThis is similar to match() but specifically designed for matching against BaseNode types from the v1 system.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `source` | `type[SourceNodeT]` | The BaseNode subclass to match against | *required* | | `matches` | `Callable[[Any], bool] | None` | Optional custom matching function | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `DecisionBranch[SourceNodeT]` | A DecisionBranch for the BaseNode type |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef match_node(\n    self,\n    source: type[SourceNodeT],\n    *,\n    matches: Callable[[Any], bool] | None = None,\n) -> DecisionBranch[SourceNodeT]:\n    \"\"\"Create a decision branch for BaseNode subclasses.\n\n    This is similar to match() but specifically designed for matching\n    against BaseNode types from the v1 system.\n\n    Args:\n        source: The BaseNode subclass to match against\n        matches: Optional custom matching function\n\n    Returns:\n        A DecisionBranch for the BaseNode type\n    \"\"\"\n    node = NodeStep(source)\n    path = Path(items=[DestinationMarker(node.id)])\n    return DecisionBranch(source=source, matches=matches, path=path, destinations=[node])\n\n```\n\n#### node\n\n```python\nnode(\n    node_type: type[BaseNode[StateT, DepsT, GraphOutputT]],\n) -> EdgePath[StateT, DepsT]\n\n```\n\nCreate an edge path from a BaseNode class.\n\nThis method integrates v1-style BaseNode classes into the v2 graph system by analyzing their type hints and creating appropriate edges.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `node_type` | `type[BaseNode[StateT, DepsT, GraphOutputT]]` | The BaseNode subclass to integrate | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `EdgePath[StateT, DepsT]` | An EdgePath representing the node and its connections |\n\nRaises:\n\n| Type | Description | | --- | --- | | `GraphSetupError` | If the node type is missing required type hints |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef node(\n    self,\n    node_type: type[BaseNode[StateT, DepsT, GraphOutputT]],\n) -> EdgePath[StateT, DepsT]:\n    \"\"\"Create an edge path from a BaseNode class.\n\n    This method integrates v1-style BaseNode classes into the v2 graph\n    system by analyzing their type hints and creating appropriate edges.\n\n    Args:\n        node_type: The BaseNode subclass to integrate\n\n    Returns:\n        An EdgePath representing the node and its connections\n\n    Raises:\n        GraphSetupError: If the node type is missing required type hints\n    \"\"\"\n    parent_namespace = _utils.get_parent_namespace(inspect.currentframe())\n    type_hints = get_type_hints(node_type.run, localns=parent_namespace, include_extras=True)\n    try:\n        return_hint = type_hints['return']\n    except KeyError as e:  # pragma: no cover\n        raise exceptions.GraphSetupError(\n            f'Node {node_type} is missing a return type hint on its `run` method'\n        ) from e\n\n    node = NodeStep(node_type)\n\n    edge = self._edge_from_return_hint(node, return_hint)\n    if not edge:  # pragma: no cover\n        raise exceptions.GraphSetupError(f'Node {node_type} is missing a return type hint on its `run` method')\n\n    return edge\n\n```\n\n#### build\n\n```python\nbuild(\n    validate_graph_structure: bool = True,\n) -> Graph[StateT, DepsT, GraphInputT, GraphOutputT]\n\n```\n\nBuild the final executable graph from the accumulated nodes and edges.\n\nThis method performs validation, normalization, and analysis of the graph structure to create a complete, executable graph instance.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `validate_graph_structure` | `bool` | whether to perform validation of the graph structure See the docstring of \\_validate_graph_structure below for more details. | `True` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Graph[StateT, DepsT, GraphInputT, GraphOutputT]` | A complete Graph instance ready for execution |\n\nRaises:\n\n| Type | Description | | --- | --- | | `ValueError` | If the graph structure is invalid (e.g., join without parent fork) |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph_builder.py`\n\n```python\ndef build(self, validate_graph_structure: bool = True) -> Graph[StateT, DepsT, GraphInputT, GraphOutputT]:\n    \"\"\"Build the final executable graph from the accumulated nodes and edges.\n\n    This method performs validation, normalization, and analysis of the graph\n    structure to create a complete, executable graph instance.\n\n    Args:\n        validate_graph_structure: whether to perform validation of the graph structure\n            See the docstring of _validate_graph_structure below for more details.\n\n    Returns:\n        A complete Graph instance ready for execution\n\n    Raises:\n        ValueError: If the graph structure is invalid (e.g., join without parent fork)\n    \"\"\"\n    nodes = self._nodes\n    edges_by_source = self._edges_by_source\n\n    nodes, edges_by_source = _replace_placeholder_node_ids(nodes, edges_by_source)\n    nodes, edges_by_source = _flatten_paths(nodes, edges_by_source)\n    nodes, edges_by_source = _normalize_forks(nodes, edges_by_source)\n    if validate_graph_structure:\n        _validate_graph_structure(nodes, edges_by_source)\n    parent_forks = _collect_dominating_forks(nodes, edges_by_source)\n    intermediate_join_nodes = _compute_intermediate_join_nodes(nodes, parent_forks)\n\n    return Graph[StateT, DepsT, GraphInputT, GraphOutputT](\n        name=self.name,\n        state_type=unpack_type_expression(self.state_type),\n        deps_type=unpack_type_expression(self.deps_type),\n        input_type=unpack_type_expression(self.input_type),\n        output_type=unpack_type_expression(self.output_type),\n        nodes=nodes,\n        edges_by_source=edges_by_source,\n        parent_forks=parent_forks,\n        intermediate_join_nodes=intermediate_join_nodes,\n        auto_instrument=self.auto_instrument,\n    )\n\n```",
  "content_length": 51423
}