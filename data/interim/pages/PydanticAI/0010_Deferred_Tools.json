{
  "title": "Deferred Tools",
  "source_url": null,
  "content": "There are a few scenarios where the model should be able to call a tool that should not or cannot be executed during the same agent run inside the same Python process:\n\n- it may need to be approved by the user first\n- it may depend on an upstream service, frontend, or user to provide the result\n- the result could take longer to generate than it's reasonable to keep the agent process running\n\nTo support these use cases, Pydantic AI provides the concept of deferred tools, which come in two flavors documented below:\n\n- tools that [require approval](#human-in-the-loop-tool-approval)\n- tools that are [executed externally](#external-tool-execution)\n\nWhen the model calls a deferred tool, the agent run will end with a DeferredToolRequests output object containing information about the deferred tool calls. Once the approvals and/or results are ready, a new agent run can then be started with the original run's [message history](../message-history/) plus a DeferredToolResults object holding results for each tool call in `DeferredToolRequests`, which will continue the original run where it left off.\n\nNote that handling deferred tool calls requires `DeferredToolRequests` to be in the `Agent`'s [`output_type`](../output/#structured-output) so that the possible types of the agent run output are correctly inferred. If your agent can also be used in a context where no deferred tools are available and you don't want to deal with that type everywhere you use the agent, you can instead pass the `output_type` argument when you run the agent using agent.run(), agent.run_sync(), agent.run_stream(), or agent.iter(). Note that the run-time `output_type` overrides the one specified at construction time (for type inference reasons), so you'll need to include the original output type explicitly.\n\n## Human-in-the-Loop Tool Approval\n\nIf a tool function always requires approval, you can pass the `requires_approval=True` argument to the @agent.tool decorator, @agent.tool_plain decorator, Tool class, FunctionToolset.tool decorator, or FunctionToolset.add_function() method. Inside the function, you can then assume that the tool call has been approved.\n\nIf whether a tool function requires approval depends on the tool call arguments or the agent run context (e.g. [dependencies](../dependencies/) or message history), you can raise the ApprovalRequired exception from the tool function. The RunContext.tool_call_approved property will be `True` if the tool call has already been approved.\n\nTo require approval for calls to tools provided by a [toolset](../toolsets/) (like an [MCP server](../mcp/client/)), see the [`ApprovalRequiredToolset` documentation](../toolsets/#requiring-tool-approval).\n\nWhen the model calls a tool that requires approval, the agent run will end with a DeferredToolRequests output object with an `approvals` list holding ToolCallParts containing the tool name, validated arguments, and a unique tool call ID.\n\nOnce you've gathered the user's approvals or denials, you can build a DeferredToolResults object with an `approvals` dictionary that maps each tool call ID to a boolean, a ToolApproved object (with optional `override_args`), or a ToolDenied object (with an optional custom `message` to provide to the model). This `DeferredToolResults` object can then be provided to one of the agent run methods as `deferred_tool_results`, alongside the original run's [message history](../message-history/).\n\nHere's an example that shows how to require approval for all file deletions, and for updates of specific protected files:\n\n[Learn about Gateway](../gateway) tool_requires_approval.py\n\n```python\nfrom pydantic_ai import (\n    Agent,\n    ApprovalRequired,\n    DeferredToolRequests,\n    DeferredToolResults,\n    RunContext,\n    ToolDenied,\n)\n\nagent = Agent('gateway/openai:gpt-5', output_type=[str, DeferredToolRequests])\n\nPROTECTED_FILES = {'.env'}\n\n\n@agent.tool\ndef update_file(ctx: RunContext, path: str, content: str) -> str:\n    if path in PROTECTED_FILES and not ctx.tool_call_approved:\n        raise ApprovalRequired(metadata={'reason': 'protected'})  # (1)!\n    return f'File {path!r} updated: {content!r}'\n\n\n@agent.tool_plain(requires_approval=True)\ndef delete_file(path: str) -> str:\n    return f'File {path!r} deleted'\n\n\nresult = agent.run_sync('Delete `__init__.py`, write `Hello, world!` to `README.md`, and clear `.env`')\nmessages = result.all_messages()\n\nassert isinstance(result.output, DeferredToolRequests)\nrequests = result.output\nprint(requests)\n\"\"\"\nDeferredToolRequests(\n    calls=[],\n    approvals=[\n        ToolCallPart(\n            tool_name='update_file',\n            args={'path': '.env', 'content': ''},\n            tool_call_id='update_file_dotenv',\n        ),\n        ToolCallPart(\n            tool_name='delete_file',\n            args={'path': '__init__.py'},\n            tool_call_id='delete_file',\n        ),\n    ],\n    metadata={'update_file_dotenv': {'reason': 'protected'}},\n)\n\"\"\"\n\nresults = DeferredToolResults()\nfor call in requests.approvals:\n    result = False\n    if call.tool_name == 'update_file':\n        # Approve all updates\n        result = True\n    elif call.tool_name == 'delete_file':\n        # deny all deletes\n        result = ToolDenied('Deleting files is not allowed')\n\n    results.approvals[call.tool_call_id] = result\n\nresult = agent.run_sync(\n    'Now create a backup of README.md',  # (2)!\n    message_history=messages,\n    deferred_tool_results=results,\n)\nprint(result.output)\n\"\"\"\nHere's what I've done:\n- Attempted to delete __init__.py, but deletion is not allowed.\n- Updated README.md with: Hello, world!\n- Cleared .env (set to empty).\n- Created a backup at README.md.bak containing: Hello, world!\n\nIf you want a different backup name or format (e.g., timestamped like README_2025-11-24.bak), let me know.\n\"\"\"\nprint(result.all_messages())\n\"\"\"\n[\n    ModelRequest(\n        parts=[\n            UserPromptPart(\n                content='Delete `__init__.py`, write `Hello, world!` to `README.md`, and clear `.env`',\n                timestamp=datetime.datetime(...),\n            )\n        ],\n        run_id='...',\n    ),\n    ModelResponse(\n        parts=[\n            ToolCallPart(\n                tool_name='delete_file',\n                args={'path': '__init__.py'},\n                tool_call_id='delete_file',\n            ),\n            ToolCallPart(\n                tool_name='update_file',\n                args={'path': 'README.md', 'content': 'Hello, world!'},\n                tool_call_id='update_file_readme',\n            ),\n            ToolCallPart(\n                tool_name='update_file',\n                args={'path': '.env', 'content': ''},\n                tool_call_id='update_file_dotenv',\n            ),\n        ],\n        usage=RequestUsage(input_tokens=63, output_tokens=21),\n        model_name='gpt-5',\n        timestamp=datetime.datetime(...),\n        run_id='...',\n    ),\n    ModelRequest(\n        parts=[\n            ToolReturnPart(\n                tool_name='update_file',\n                content=\"File 'README.md' updated: 'Hello, world!'\",\n                tool_call_id='update_file_readme',\n                timestamp=datetime.datetime(...),\n            )\n        ],\n        run_id='...',\n    ),\n    ModelRequest(\n        parts=[\n            ToolReturnPart(\n                tool_name='update_file',\n                content=\"File '.env' updated: ''\",\n                tool_call_id='update_file_dotenv',\n                timestamp=datetime.datetime(...),\n            ),\n            ToolReturnPart(\n                tool_name='delete_file',\n                content='Deleting files is not allowed',\n                tool_call_id='delete_file',\n                timestamp=datetime.datetime(...),\n            ),\n            UserPromptPart(\n                content='Now create a backup of README.md',\n                timestamp=datetime.datetime(...),\n            ),\n        ],\n        run_id='...',\n    ),\n    ModelResponse(\n        parts=[\n            ToolCallPart(\n                tool_name='update_file',\n                args={'path': 'README.md.bak', 'content': 'Hello, world!'},\n                tool_call_id='update_file_backup',\n            )\n        ],\n        usage=RequestUsage(input_tokens=86, output_tokens=31),\n        model_name='gpt-5',\n        timestamp=datetime.datetime(...),\n        run_id='...',\n    ),\n    ModelRequest(\n        parts=[\n            ToolReturnPart(\n                tool_name='update_file',\n                content=\"File 'README.md.bak' updated: 'Hello, world!'\",\n                tool_call_id='update_file_backup',\n                timestamp=datetime.datetime(...),\n            )\n        ],\n        run_id='...',\n    ),\n    ModelResponse(\n        parts=[\n            TextPart(\n                content=\"Here's what I've done:\\n- Attempted to delete __init__.py, but deletion is not allowed.\\n- Updated README.md with: Hello, world!\\n- Cleared .env (set to empty).\\n- Created a backup at README.md.bak containing: Hello, world!\\n\\nIf you want a different backup name or format (e.g., timestamped like README_2025-11-24.bak), let me know.\"\n            )\n        ],\n        usage=RequestUsage(input_tokens=93, output_tokens=89),\n        model_name='gpt-5',\n        timestamp=datetime.datetime(...),\n        run_id='...',\n    ),\n]\n\"\"\"\n\n```\n\n1. The optional `metadata` parameter can attach arbitrary context to deferred tool calls, accessible in `DeferredToolRequests.metadata` keyed by `tool_call_id`.\n1. This second agent run continues from where the first run left off, providing the tool approval results and optionally a new `user_prompt` to give the model additional instructions alongside the deferred results.\n\ntool_requires_approval.py\n\n```python\nfrom pydantic_ai import (\n    Agent,\n    ApprovalRequired,\n    DeferredToolRequests,\n    DeferredToolResults,\n    RunContext,\n    ToolDenied,\n)\n\nagent = Agent('openai:gpt-5', output_type=[str, DeferredToolRequests])\n\nPROTECTED_FILES = {'.env'}\n\n\n@agent.tool\ndef update_file(ctx: RunContext, path: str, content: str) -> str:\n    if path in PROTECTED_FILES and not ctx.tool_call_approved:\n        raise ApprovalRequired(metadata={'reason': 'protected'})  # (1)!\n    return f'File {path!r} updated: {content!r}'\n\n\n@agent.tool_plain(requires_approval=True)\ndef delete_file(path: str) -> str:\n    return f'File {path!r} deleted'\n\n\nresult = agent.run_sync('Delete `__init__.py`, write `Hello, world!` to `README.md`, and clear `.env`')\nmessages = result.all_messages()\n\nassert isinstance(result.output, DeferredToolRequests)\nrequests = result.output\nprint(requests)\n\"\"\"\nDeferredToolRequests(\n    calls=[],\n    approvals=[\n        ToolCallPart(\n            tool_name='update_file',\n            args={'path': '.env', 'content': ''},\n            tool_call_id='update_file_dotenv',\n        ),\n        ToolCallPart(\n            tool_name='delete_file',\n            args={'path': '__init__.py'},\n            tool_call_id='delete_file',\n        ),\n    ],\n    metadata={'update_file_dotenv': {'reason': 'protected'}},\n)\n\"\"\"\n\nresults = DeferredToolResults()\nfor call in requests.approvals:\n    result = False\n    if call.tool_name == 'update_file':\n        # Approve all updates\n        result = True\n    elif call.tool_name == 'delete_file':\n        # deny all deletes\n        result = ToolDenied('Deleting files is not allowed')\n\n    results.approvals[call.tool_call_id] = result\n\nresult = agent.run_sync(\n    'Now create a backup of README.md',  # (2)!\n    message_history=messages,\n    deferred_tool_results=results,\n)\nprint(result.output)\n\"\"\"\nHere's what I've done:\n- Attempted to delete __init__.py, but deletion is not allowed.\n- Updated README.md with: Hello, world!\n- Cleared .env (set to empty).\n- Created a backup at README.md.bak containing: Hello, world!\n\nIf you want a different backup name or format (e.g., timestamped like README_2025-11-24.bak), let me know.\n\"\"\"\nprint(result.all_messages())\n\"\"\"\n[\n    ModelRequest(\n        parts=[\n            UserPromptPart(\n                content='Delete `__init__.py`, write `Hello, world!` to `README.md`, and clear `.env`',\n                timestamp=datetime.datetime(...),\n            )\n        ],\n        run_id='...',\n    ),\n    ModelResponse(\n        parts=[\n            ToolCallPart(\n                tool_name='delete_file',\n                args={'path': '__init__.py'},\n                tool_call_id='delete_file',\n            ),\n            ToolCallPart(\n                tool_name='update_file',\n                args={'path': 'README.md', 'content': 'Hello, world!'},\n                tool_call_id='update_file_readme',\n            ),\n            ToolCallPart(\n                tool_name='update_file',\n                args={'path': '.env', 'content': ''},\n                tool_call_id='update_file_dotenv',\n            ),\n        ],\n        usage=RequestUsage(input_tokens=63, output_tokens=21),\n        model_name='gpt-5',\n        timestamp=datetime.datetime(...),\n        run_id='...',\n    ),\n    ModelRequest(\n        parts=[\n            ToolReturnPart(\n                tool_name='update_file',\n                content=\"File 'README.md' updated: 'Hello, world!'\",\n                tool_call_id='update_file_readme',\n                timestamp=datetime.datetime(...),\n            )\n        ],\n        run_id='...',\n    ),\n    ModelRequest(\n        parts=[\n            ToolReturnPart(\n                tool_name='update_file',\n                content=\"File '.env' updated: ''\",\n                tool_call_id='update_file_dotenv',\n                timestamp=datetime.datetime(...),\n            ),\n            ToolReturnPart(\n                tool_name='delete_file',\n                content='Deleting files is not allowed',\n                tool_call_id='delete_file',\n                timestamp=datetime.datetime(...),\n            ),\n            UserPromptPart(\n                content='Now create a backup of README.md',\n                timestamp=datetime.datetime(...),\n            ),\n        ],\n        run_id='...',\n    ),\n    ModelResponse(\n        parts=[\n            ToolCallPart(\n                tool_name='update_file',\n                args={'path': 'README.md.bak', 'content': 'Hello, world!'},\n                tool_call_id='update_file_backup',\n            )\n        ],\n        usage=RequestUsage(input_tokens=86, output_tokens=31),\n        model_name='gpt-5',\n        timestamp=datetime.datetime(...),\n        run_id='...',\n    ),\n    ModelRequest(\n        parts=[\n            ToolReturnPart(\n                tool_name='update_file',\n                content=\"File 'README.md.bak' updated: 'Hello, world!'\",\n                tool_call_id='update_file_backup',\n                timestamp=datetime.datetime(...),\n            )\n        ],\n        run_id='...',\n    ),\n    ModelResponse(\n        parts=[\n            TextPart(\n                content=\"Here's what I've done:\\n- Attempted to delete __init__.py, but deletion is not allowed.\\n- Updated README.md with: Hello, world!\\n- Cleared .env (set to empty).\\n- Created a backup at README.md.bak containing: Hello, world!\\n\\nIf you want a different backup name or format (e.g., timestamped like README_2025-11-24.bak), let me know.\"\n            )\n        ],\n        usage=RequestUsage(input_tokens=93, output_tokens=89),\n        model_name='gpt-5',\n        timestamp=datetime.datetime(...),\n        run_id='...',\n    ),\n]\n\"\"\"\n\n```\n\n1. The optional `metadata` parameter can attach arbitrary context to deferred tool calls, accessible in `DeferredToolRequests.metadata` keyed by `tool_call_id`.\n1. This second agent run continues from where the first run left off, providing the tool approval results and optionally a new `user_prompt` to give the model additional instructions alongside the deferred results.\n\n*(This example is complete, it can be run \"as is\")*\n\n## External Tool Execution\n\nWhen the result of a tool call cannot be generated inside the same agent run in which it was called, the tool is considered to be external. Examples of external tools are client-side tools implemented by a web or app frontend, and slow tasks that are passed off to a background worker or external service instead of keeping the agent process running.\n\nIf whether a tool call should be executed externally depends on the tool call arguments, the agent run context (e.g. [dependencies](../dependencies/) or message history), or how long the task is expected to take, you can define a tool function and conditionally raise the CallDeferred exception. Before raising the exception, the tool function would typically schedule some background task and pass along the RunContext.tool_call_id so that the result can be matched to the deferred tool call later.\n\nIf a tool is always executed externally and its definition is provided to your code along with a JSON schema for its arguments, you can use an [`ExternalToolset`](../toolsets/#external-toolset). If the external tools are known up front and you don't have the arguments JSON schema handy, you can also define a tool function with the appropriate signature that does nothing but raise the CallDeferred exception.\n\nWhen the model calls an external tool, the agent run will end with a DeferredToolRequests output object with a `calls` list holding ToolCallParts containing the tool name, validated arguments, and a unique tool call ID.\n\nOnce the tool call results are ready, you can build a DeferredToolResults object with a `calls` dictionary that maps each tool call ID to an arbitrary value to be returned to the model, a [`ToolReturn`](../tools-advanced/#advanced-tool-returns) object, or a ModelRetry exception in case the tool call failed and the model should [try again](../tools-advanced/#tool-retries). This `DeferredToolResults` object can then be provided to one of the agent run methods as `deferred_tool_results`, alongside the original run's [message history](../message-history/).\n\nHere's an example that shows how to move a task that takes a while to complete to the background and return the result to the model once the task is complete:\n\n[Learn about Gateway](../gateway) external_tool.py\n\n```python\nimport asyncio\nfrom dataclasses import dataclass\nfrom typing import Any\n\nfrom pydantic_ai import (\n    Agent,\n    CallDeferred,\n    DeferredToolRequests,\n    DeferredToolResults,\n    ModelRetry,\n    RunContext,\n)\n\n\n@dataclass\nclass TaskResult:\n    task_id: str\n    result: Any\n\n\nasync def calculate_answer_task(task_id: str, question: str) -> TaskResult:\n    await asyncio.sleep(1)\n    return TaskResult(task_id=task_id, result=42)\n\n\nagent = Agent('gateway/openai:gpt-5', output_type=[str, DeferredToolRequests])\n\ntasks: list[asyncio.Task[TaskResult]] = []\n\n\n@agent.tool\nasync def calculate_answer(ctx: RunContext, question: str) -> str:\n    task_id = f'task_{len(tasks)}'  # (1)!\n    task = asyncio.create_task(calculate_answer_task(task_id, question))\n    tasks.append(task)\n\n    raise CallDeferred(metadata={'task_id': task_id})  # (2)!\n\n\nasync def main():\n    result = await agent.run('Calculate the answer to the ultimate question of life, the universe, and everything')\n    messages = result.all_messages()\n\n    assert isinstance(result.output, DeferredToolRequests)\n    requests = result.output\n    print(requests)\n    \"\"\"\n    DeferredToolRequests(\n        calls=[\n            ToolCallPart(\n                tool_name='calculate_answer',\n                args={\n                    'question': 'the ultimate question of life, the universe, and everything'\n                },\n                tool_call_id='pyd_ai_tool_call_id',\n            )\n        ],\n        approvals=[],\n        metadata={'pyd_ai_tool_call_id': {'task_id': 'task_0'}},\n    )\n    \"\"\"\n\n    done, _ = await asyncio.wait(tasks)  # (3)!\n    task_results = [task.result() for task in done]\n    task_results_by_task_id = {result.task_id: result.result for result in task_results}\n\n    results = DeferredToolResults()\n    for call in requests.calls:\n        try:\n            task_id = requests.metadata[call.tool_call_id]['task_id']\n            result = task_results_by_task_id[task_id]\n        except KeyError:\n            result = ModelRetry('No result for this tool call was found.')\n\n        results.calls[call.tool_call_id] = result\n\n    result = await agent.run(message_history=messages, deferred_tool_results=results)\n    print(result.output)\n    #> The answer to the ultimate question of life, the universe, and everything is 42.\n    print(result.all_messages())\n    \"\"\"\n    [\n        ModelRequest(\n            parts=[\n                UserPromptPart(\n                    content='Calculate the answer to the ultimate question of life, the universe, and everything',\n                    timestamp=datetime.datetime(...),\n                )\n            ],\n            run_id='...',\n        ),\n        ModelResponse(\n            parts=[\n                ToolCallPart(\n                    tool_name='calculate_answer',\n                    args={\n                        'question': 'the ultimate question of life, the universe, and everything'\n                    },\n                    tool_call_id='pyd_ai_tool_call_id',\n                )\n            ],\n            usage=RequestUsage(input_tokens=63, output_tokens=13),\n            model_name='gpt-5',\n            timestamp=datetime.datetime(...),\n            run_id='...',\n        ),\n        ModelRequest(\n            parts=[\n                ToolReturnPart(\n                    tool_name='calculate_answer',\n                    content=42,\n                    tool_call_id='pyd_ai_tool_call_id',\n                    timestamp=datetime.datetime(...),\n                )\n            ],\n            run_id='...',\n        ),\n        ModelResponse(\n            parts=[\n                TextPart(\n                    content='The answer to the ultimate question of life, the universe, and everything is 42.'\n                )\n            ],\n            usage=RequestUsage(input_tokens=64, output_tokens=28),\n            model_name='gpt-5',\n            timestamp=datetime.datetime(...),\n            run_id='...',\n        ),\n    ]\n    \"\"\"\n\n```\n\n1. Generate a task ID that can be tracked independently of the tool call ID.\n1. The optional `metadata` parameter passes the `task_id` so it can be matched with results later, accessible in `DeferredToolRequests.metadata` keyed by `tool_call_id`.\n1. In reality, this would typically happen in a separate process that polls for the task status or is notified when all pending tasks are complete.\n\nexternal_tool.py\n\n```python\nimport asyncio\nfrom dataclasses import dataclass\nfrom typing import Any\n\nfrom pydantic_ai import (\n    Agent,\n    CallDeferred,\n    DeferredToolRequests,\n    DeferredToolResults,\n    ModelRetry,\n    RunContext,\n)\n\n\n@dataclass\nclass TaskResult:\n    task_id: str\n    result: Any\n\n\nasync def calculate_answer_task(task_id: str, question: str) -> TaskResult:\n    await asyncio.sleep(1)\n    return TaskResult(task_id=task_id, result=42)\n\n\nagent = Agent('openai:gpt-5', output_type=[str, DeferredToolRequests])\n\ntasks: list[asyncio.Task[TaskResult]] = []\n\n\n@agent.tool\nasync def calculate_answer(ctx: RunContext, question: str) -> str:\n    task_id = f'task_{len(tasks)}'  # (1)!\n    task = asyncio.create_task(calculate_answer_task(task_id, question))\n    tasks.append(task)\n\n    raise CallDeferred(metadata={'task_id': task_id})  # (2)!\n\n\nasync def main():\n    result = await agent.run('Calculate the answer to the ultimate question of life, the universe, and everything')\n    messages = result.all_messages()\n\n    assert isinstance(result.output, DeferredToolRequests)\n    requests = result.output\n    print(requests)\n    \"\"\"\n    DeferredToolRequests(\n        calls=[\n            ToolCallPart(\n                tool_name='calculate_answer',\n                args={\n                    'question': 'the ultimate question of life, the universe, and everything'\n                },\n                tool_call_id='pyd_ai_tool_call_id',\n            )\n        ],\n        approvals=[],\n        metadata={'pyd_ai_tool_call_id': {'task_id': 'task_0'}},\n    )\n    \"\"\"\n\n    done, _ = await asyncio.wait(tasks)  # (3)!\n    task_results = [task.result() for task in done]\n    task_results_by_task_id = {result.task_id: result.result for result in task_results}\n\n    results = DeferredToolResults()\n    for call in requests.calls:\n        try:\n            task_id = requests.metadata[call.tool_call_id]['task_id']\n            result = task_results_by_task_id[task_id]\n        except KeyError:\n            result = ModelRetry('No result for this tool call was found.')\n\n        results.calls[call.tool_call_id] = result\n\n    result = await agent.run(message_history=messages, deferred_tool_results=results)\n    print(result.output)\n    #> The answer to the ultimate question of life, the universe, and everything is 42.\n    print(result.all_messages())\n    \"\"\"\n    [\n        ModelRequest(\n            parts=[\n                UserPromptPart(\n                    content='Calculate the answer to the ultimate question of life, the universe, and everything',\n                    timestamp=datetime.datetime(...),\n                )\n            ],\n            run_id='...',\n        ),\n        ModelResponse(\n            parts=[\n                ToolCallPart(\n                    tool_name='calculate_answer',\n                    args={\n                        'question': 'the ultimate question of life, the universe, and everything'\n                    },\n                    tool_call_id='pyd_ai_tool_call_id',\n                )\n            ],\n            usage=RequestUsage(input_tokens=63, output_tokens=13),\n            model_name='gpt-5',\n            timestamp=datetime.datetime(...),\n            run_id='...',\n        ),\n        ModelRequest(\n            parts=[\n                ToolReturnPart(\n                    tool_name='calculate_answer',\n                    content=42,\n                    tool_call_id='pyd_ai_tool_call_id',\n                    timestamp=datetime.datetime(...),\n                )\n            ],\n            run_id='...',\n        ),\n        ModelResponse(\n            parts=[\n                TextPart(\n                    content='The answer to the ultimate question of life, the universe, and everything is 42.'\n                )\n            ],\n            usage=RequestUsage(input_tokens=64, output_tokens=28),\n            model_name='gpt-5',\n            timestamp=datetime.datetime(...),\n            run_id='...',\n        ),\n    ]\n    \"\"\"\n\n```\n\n1. Generate a task ID that can be tracked independently of the tool call ID.\n1. The optional `metadata` parameter passes the `task_id` so it can be matched with results later, accessible in `DeferredToolRequests.metadata` keyed by `tool_call_id`.\n1. In reality, this would typically happen in a separate process that polls for the task status or is notified when all pending tasks are complete.\n\n*(This example is complete, it can be run \"as is\" â€” you'll need to add `asyncio.run(main())` to run `main`)*\n\n## See Also\n\n- [Function Tools](../tools/) - Basic tool concepts and registration\n- [Advanced Tool Features](../tools-advanced/) - Custom schemas, dynamic tools, and execution details\n- [Toolsets](../toolsets/) - Managing collections of tools, including `ExternalToolset` for external tools\n- [Message History](../message-history/) - Understanding how to work with message history for deferred tools",
  "content_length": 27273
}