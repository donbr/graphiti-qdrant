{
  "title": "`pydantic_graph.beta.decision`",
  "source_url": null,
  "content": "Decision node implementation for conditional branching in graph execution.\n\nThis module provides the Decision node type and related classes for implementing conditional branching logic in parallel control flow graphs. Decision nodes allow the graph to choose different execution paths based on runtime conditions.\n\n### StateT\n\n```python\nStateT = TypeVar('StateT', infer_variance=True)\n\n```\n\nType variable for graph state.\n\n### DepsT\n\n```python\nDepsT = TypeVar('DepsT', infer_variance=True)\n\n```\n\nType variable for graph dependencies.\n\n### HandledT\n\n```python\nHandledT = TypeVar('HandledT', infer_variance=True)\n\n```\n\nType variable used to track types handled by the branches of a Decision.\n\n### T\n\n```python\nT = TypeVar('T', infer_variance=True)\n\n```\n\nGeneric type variable.\n\n### Decision\n\nBases: `Generic[StateT, DepsT, HandledT]`\n\nDecision node for conditional branching in graph execution.\n\nA Decision node evaluates conditions and routes execution to different branches based on the input data type or custom matching logic.\n\nSource code in `pydantic_graph/pydantic_graph/beta/decision.py`\n\n```python\n@dataclass(kw_only=True)\nclass Decision(Generic[StateT, DepsT, HandledT]):\n    \"\"\"Decision node for conditional branching in graph execution.\n\n    A Decision node evaluates conditions and routes execution to different\n    branches based on the input data type or custom matching logic.\n    \"\"\"\n\n    id: NodeID\n    \"\"\"Unique identifier for this decision node.\"\"\"\n\n    branches: list[DecisionBranch[Any]]\n    \"\"\"List of branches that can be taken from this decision.\"\"\"\n\n    note: str | None\n    \"\"\"Optional documentation note for this decision.\"\"\"\n\n    def branch(self, branch: DecisionBranch[T]) -> Decision[StateT, DepsT, HandledT | T]:\n        \"\"\"Add a new branch to this decision.\n\n        Args:\n            branch: The branch to add to this decision.\n\n        Returns:\n            A new Decision with the additional branch.\n        \"\"\"\n        return Decision(id=self.id, branches=self.branches + [branch], note=self.note)\n\n    def _force_handled_contravariant(self, inputs: HandledT) -> Never:  # pragma: no cover\n        \"\"\"Forces this type to be contravariant in the HandledT type variable.\n\n        This is an implementation detail of how we can type-check that all possible input types have\n        been exhaustively covered.\n\n        Args:\n            inputs: Input data of handled types.\n\n        Raises:\n            RuntimeError: Always, as this method should never be executed.\n        \"\"\"\n        raise RuntimeError('This method should never be called, it is just defined for typing purposes.')\n\n```\n\n#### id\n\n```python\nid: NodeID\n\n```\n\nUnique identifier for this decision node.\n\n#### branches\n\n```python\nbranches: list[DecisionBranch[Any]]\n\n```\n\nList of branches that can be taken from this decision.\n\n#### note\n\n```python\nnote: str | None\n\n```\n\nOptional documentation note for this decision.\n\n#### branch\n\n```python\nbranch(\n    branch: DecisionBranch[T],\n) -> Decision[StateT, DepsT, HandledT | T]\n\n```\n\nAdd a new branch to this decision.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `branch` | `DecisionBranch[T]` | The branch to add to this decision. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Decision[StateT, DepsT, HandledT | T]` | A new Decision with the additional branch. |\n\nSource code in `pydantic_graph/pydantic_graph/beta/decision.py`\n\n```python\ndef branch(self, branch: DecisionBranch[T]) -> Decision[StateT, DepsT, HandledT | T]:\n    \"\"\"Add a new branch to this decision.\n\n    Args:\n        branch: The branch to add to this decision.\n\n    Returns:\n        A new Decision with the additional branch.\n    \"\"\"\n    return Decision(id=self.id, branches=self.branches + [branch], note=self.note)\n\n```\n\n### SourceT\n\n```python\nSourceT = TypeVar('SourceT', infer_variance=True)\n\n```\n\nType variable for source data for a DecisionBranch.\n\n### DecisionBranch\n\nBases: `Generic[SourceT]`\n\nRepresents a single branch within a decision node.\n\nEach branch defines the conditions under which it should be taken and the path to follow when those conditions are met.\n\nNote: with the current design, it is actually *critical* that this class is invariant in SourceT for the sake of type-checking that inputs to a Decision are actually handled. See the `# type: ignore` comment in `tests.graph.beta.test_graph_edge_cases.test_decision_no_matching_branch` for an example of how this works.\n\nSource code in `pydantic_graph/pydantic_graph/beta/decision.py`\n\n```python\n@dataclass\nclass DecisionBranch(Generic[SourceT]):\n    \"\"\"Represents a single branch within a decision node.\n\n    Each branch defines the conditions under which it should be taken\n    and the path to follow when those conditions are met.\n\n    Note: with the current design, it is actually _critical_ that this class is invariant in SourceT for the sake\n    of type-checking that inputs to a Decision are actually handled. See the `# type: ignore` comment in\n    `tests.graph.beta.test_graph_edge_cases.test_decision_no_matching_branch` for an example of how this works.\n    \"\"\"\n\n    source: TypeOrTypeExpression[SourceT]\n    \"\"\"The expected type of data for this branch.\n\n    This is necessary for exhaustiveness-checking when handling the inputs to a decision node.\"\"\"\n\n    matches: Callable[[Any], bool] | None\n    \"\"\"An optional predicate function used to determine whether input data matches this branch.\n\n    If `None`, default logic is used which attempts to check the value for type-compatibility with the `source` type:\n    * If `source` is `Any` or `object`, the branch will always match\n    * If `source` is a `Literal` type, this branch will match if the value is one of the parametrizing literal values\n    * If `source` is any other type, the value will be checked for matching using `isinstance`\n\n    Inputs are tested against each branch of a decision node in order, and the path of the first matching branch is\n    used to handle the input value.\n    \"\"\"\n\n    path: Path\n    \"\"\"The execution path to follow when an input value matches this branch of a decision node.\n\n    This can include transforming, mapping, and broadcasting the output before sending to the next node or nodes.\n\n    The path can also include position-aware labels which are used when generating mermaid diagrams.\"\"\"\n\n    destinations: list[AnyDestinationNode]\n    \"\"\"The destination nodes that can be referenced by DestinationMarker in the path.\"\"\"\n\n```\n\n#### source\n\n```python\nsource: TypeOrTypeExpression[SourceT]\n\n```\n\nThe expected type of data for this branch.\n\nThis is necessary for exhaustiveness-checking when handling the inputs to a decision node.\n\n#### matches\n\n```python\nmatches: Callable[[Any], bool] | None\n\n```\n\nAn optional predicate function used to determine whether input data matches this branch.\n\nIf `None`, default logic is used which attempts to check the value for type-compatibility with the `source` type: * If `source` is `Any` or `object`, the branch will always match * If `source` is a `Literal` type, this branch will match if the value is one of the parametrizing literal values * If `source` is any other type, the value will be checked for matching using `isinstance`\n\nInputs are tested against each branch of a decision node in order, and the path of the first matching branch is used to handle the input value.\n\n#### path\n\n```python\npath: Path\n\n```\n\nThe execution path to follow when an input value matches this branch of a decision node.\n\nThis can include transforming, mapping, and broadcasting the output before sending to the next node or nodes.\n\nThe path can also include position-aware labels which are used when generating mermaid diagrams.\n\n#### destinations\n\n```python\ndestinations: list[AnyDestinationNode]\n\n```\n\nThe destination nodes that can be referenced by DestinationMarker in the path.\n\n### OutputT\n\n```python\nOutputT = TypeVar('OutputT', infer_variance=True)\n\n```\n\nType variable for the output data of a node.\n\n### NewOutputT\n\n```python\nNewOutputT = TypeVar('NewOutputT', infer_variance=True)\n\n```\n\nType variable for transformed output.\n\n### DecisionBranchBuilder\n\nBases: `Generic[StateT, DepsT, OutputT, SourceT, HandledT]`\n\nBuilder for constructing decision branches with fluent API.\n\nThis builder provides methods to configure branches with destinations, forks, and transformations in a type-safe manner.\n\nInstances of this class should be created using GraphBuilder.match, not created directly.\n\nSource code in `pydantic_graph/pydantic_graph/beta/decision.py`\n\n```python\n@dataclass(init=False)\nclass DecisionBranchBuilder(Generic[StateT, DepsT, OutputT, SourceT, HandledT]):\n    \"\"\"Builder for constructing decision branches with fluent API.\n\n    This builder provides methods to configure branches with destinations,\n    forks, and transformations in a type-safe manner.\n\n    Instances of this class should be created using [`GraphBuilder.match`][pydantic_graph.beta.graph_builder.GraphBuilder],\n    not created directly.\n    \"\"\"\n\n    _decision: Decision[StateT, DepsT, HandledT]\n    \"\"\"The parent decision node.\"\"\"\n    _source: TypeOrTypeExpression[SourceT]\n    \"\"\"The expected source type for this branch.\"\"\"\n    _matches: Callable[[Any], bool] | None\n    \"\"\"Optional matching predicate.\"\"\"\n\n    _path_builder: PathBuilder[StateT, DepsT, OutputT]\n    \"\"\"Builder for the execution path.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        decision: Decision[StateT, DepsT, HandledT],\n        source: TypeOrTypeExpression[SourceT],\n        matches: Callable[[Any], bool] | None,\n        path_builder: PathBuilder[StateT, DepsT, OutputT],\n    ):\n        # This manually-defined initializer is necessary due to https://github.com/python/mypy/issues/17623.\n        self._decision = decision\n        self._source = source\n        self._matches = matches\n        self._path_builder = path_builder\n\n    def to(\n        self,\n        destination: DestinationNode[StateT, DepsT, OutputT] | type[BaseNode[StateT, DepsT, Any]],\n        /,\n        *extra_destinations: DestinationNode[StateT, DepsT, OutputT] | type[BaseNode[StateT, DepsT, Any]],\n        fork_id: str | None = None,\n    ) -> DecisionBranch[SourceT]:\n        \"\"\"Set the destination(s) for this branch.\n\n        Args:\n            destination: The primary destination node.\n            *extra_destinations: Additional destination nodes.\n            fork_id: Optional node ID to use for the resulting broadcast fork if multiple destinations are provided.\n\n        Returns:\n            A completed DecisionBranch with the specified destinations.\n        \"\"\"\n        destination = get_origin(destination) or destination\n        extra_destinations = tuple(get_origin(d) or d for d in extra_destinations)\n        destinations = [(NodeStep(d) if inspect.isclass(d) else d) for d in (destination, *extra_destinations)]\n        return DecisionBranch(\n            source=self._source,\n            matches=self._matches,\n            path=self._path_builder.to(*destinations, fork_id=fork_id),\n            destinations=destinations,\n        )\n\n    def broadcast(\n        self, get_forks: Callable[[Self], Sequence[DecisionBranch[SourceT]]], /, *, fork_id: str | None = None\n    ) -> DecisionBranch[SourceT]:\n        \"\"\"Broadcast this decision branch into multiple destinations.\n\n        Args:\n            get_forks: The callback that will return a sequence of decision branches to broadcast to.\n            fork_id: Optional node ID to use for the resulting broadcast fork.\n\n        Returns:\n            A completed DecisionBranch with the specified destinations.\n        \"\"\"\n        fork_decision_branches = get_forks(self)\n        new_paths = [b.path for b in fork_decision_branches]\n        if not new_paths:\n            raise GraphBuildingError(f'The call to {get_forks} returned no branches, but must return at least one.')\n        path = self._path_builder.broadcast(new_paths, fork_id=fork_id)\n        destinations = [d for fdp in fork_decision_branches for d in fdp.destinations]\n        return DecisionBranch(source=self._source, matches=self._matches, path=path, destinations=destinations)\n\n    def transform(\n        self, func: TransformFunction[StateT, DepsT, OutputT, NewOutputT], /\n    ) -> DecisionBranchBuilder[StateT, DepsT, NewOutputT, SourceT, HandledT]:\n        \"\"\"Apply a transformation to the branch's output.\n\n        Args:\n            func: Transformation function to apply.\n\n        Returns:\n            A new DecisionBranchBuilder where the provided transform is applied prior to generating the final output.\n        \"\"\"\n        return DecisionBranchBuilder(\n            decision=self._decision,\n            source=self._source,\n            matches=self._matches,\n            path_builder=self._path_builder.transform(func),\n        )\n\n    def map(\n        self: DecisionBranchBuilder[StateT, DepsT, Iterable[T], SourceT, HandledT]\n        | DecisionBranchBuilder[StateT, DepsT, AsyncIterable[T], SourceT, HandledT],\n        *,\n        fork_id: str | None = None,\n        downstream_join_id: str | None = None,\n    ) -> DecisionBranchBuilder[StateT, DepsT, T, SourceT, HandledT]:\n        \"\"\"Spread the branch's output.\n\n        To do this, the current output must be iterable, and any subsequent steps in the path being built for this\n        branch will be applied to each item of the current output in parallel.\n\n        Args:\n            fork_id: Optional ID for the fork, defaults to a generated value\n            downstream_join_id: Optional ID of a downstream join node which is involved when mapping empty iterables\n\n        Returns:\n            A new DecisionBranchBuilder where mapping is performed prior to generating the final output.\n        \"\"\"\n        return DecisionBranchBuilder(\n            decision=self._decision,\n            source=self._source,\n            matches=self._matches,\n            path_builder=self._path_builder.map(fork_id=fork_id, downstream_join_id=downstream_join_id),\n        )\n\n    def label(self, label: str) -> DecisionBranchBuilder[StateT, DepsT, OutputT, SourceT, HandledT]:\n        \"\"\"Apply a label to the branch at the current point in the path being built.\n\n        These labels are only used in generated mermaid diagrams.\n\n        Args:\n            label: The label to apply.\n\n        Returns:\n            A new DecisionBranchBuilder where the label has been applied at the end of the current path being built.\n        \"\"\"\n        return DecisionBranchBuilder(\n            decision=self._decision,\n            source=self._source,\n            matches=self._matches,\n            path_builder=self._path_builder.label(label),\n        )\n\n```\n\n#### to\n\n```python\nto(\n    destination: (\n        DestinationNode[StateT, DepsT, OutputT]\n        | type[BaseNode[StateT, DepsT, Any]]\n    ),\n    /,\n    *extra_destinations: DestinationNode[\n        StateT, DepsT, OutputT\n    ]\n    | type[BaseNode[StateT, DepsT, Any]],\n    fork_id: str | None = None,\n) -> DecisionBranch[SourceT]\n\n```\n\nSet the destination(s) for this branch.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `destination` | `DestinationNode[StateT, DepsT, OutputT] | type[BaseNode[StateT, DepsT, Any]]` | The primary destination node. | *required* | | `*extra_destinations` | `DestinationNode[StateT, DepsT, OutputT] | type[BaseNode[StateT, DepsT, Any]]` | Additional destination nodes. | `()` | | `fork_id` | `str | None` | Optional node ID to use for the resulting broadcast fork if multiple destinations are provided. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `DecisionBranch[SourceT]` | A completed DecisionBranch with the specified destinations. |\n\nSource code in `pydantic_graph/pydantic_graph/beta/decision.py`\n\n```python\ndef to(\n    self,\n    destination: DestinationNode[StateT, DepsT, OutputT] | type[BaseNode[StateT, DepsT, Any]],\n    /,\n    *extra_destinations: DestinationNode[StateT, DepsT, OutputT] | type[BaseNode[StateT, DepsT, Any]],\n    fork_id: str | None = None,\n) -> DecisionBranch[SourceT]:\n    \"\"\"Set the destination(s) for this branch.\n\n    Args:\n        destination: The primary destination node.\n        *extra_destinations: Additional destination nodes.\n        fork_id: Optional node ID to use for the resulting broadcast fork if multiple destinations are provided.\n\n    Returns:\n        A completed DecisionBranch with the specified destinations.\n    \"\"\"\n    destination = get_origin(destination) or destination\n    extra_destinations = tuple(get_origin(d) or d for d in extra_destinations)\n    destinations = [(NodeStep(d) if inspect.isclass(d) else d) for d in (destination, *extra_destinations)]\n    return DecisionBranch(\n        source=self._source,\n        matches=self._matches,\n        path=self._path_builder.to(*destinations, fork_id=fork_id),\n        destinations=destinations,\n    )\n\n```\n\n#### broadcast\n\n```python\nbroadcast(\n    get_forks: Callable[\n        [Self], Sequence[DecisionBranch[SourceT]]\n    ],\n    /,\n    *,\n    fork_id: str | None = None,\n) -> DecisionBranch[SourceT]\n\n```\n\nBroadcast this decision branch into multiple destinations.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `get_forks` | `Callable[[Self], Sequence[DecisionBranch[SourceT]]]` | The callback that will return a sequence of decision branches to broadcast to. | *required* | | `fork_id` | `str | None` | Optional node ID to use for the resulting broadcast fork. | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `DecisionBranch[SourceT]` | A completed DecisionBranch with the specified destinations. |\n\nSource code in `pydantic_graph/pydantic_graph/beta/decision.py`\n\n```python\ndef broadcast(\n    self, get_forks: Callable[[Self], Sequence[DecisionBranch[SourceT]]], /, *, fork_id: str | None = None\n) -> DecisionBranch[SourceT]:\n    \"\"\"Broadcast this decision branch into multiple destinations.\n\n    Args:\n        get_forks: The callback that will return a sequence of decision branches to broadcast to.\n        fork_id: Optional node ID to use for the resulting broadcast fork.\n\n    Returns:\n        A completed DecisionBranch with the specified destinations.\n    \"\"\"\n    fork_decision_branches = get_forks(self)\n    new_paths = [b.path for b in fork_decision_branches]\n    if not new_paths:\n        raise GraphBuildingError(f'The call to {get_forks} returned no branches, but must return at least one.')\n    path = self._path_builder.broadcast(new_paths, fork_id=fork_id)\n    destinations = [d for fdp in fork_decision_branches for d in fdp.destinations]\n    return DecisionBranch(source=self._source, matches=self._matches, path=path, destinations=destinations)\n\n```\n\n#### transform\n\n```python\ntransform(\n    func: TransformFunction[\n        StateT, DepsT, OutputT, NewOutputT\n    ],\n) -> DecisionBranchBuilder[\n    StateT, DepsT, NewOutputT, SourceT, HandledT\n]\n\n```\n\nApply a transformation to the branch's output.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `func` | `TransformFunction[StateT, DepsT, OutputT, NewOutputT]` | Transformation function to apply. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `DecisionBranchBuilder[StateT, DepsT, NewOutputT, SourceT, HandledT]` | A new DecisionBranchBuilder where the provided transform is applied prior to generating the final output. |\n\nSource code in `pydantic_graph/pydantic_graph/beta/decision.py`\n\n```python\ndef transform(\n    self, func: TransformFunction[StateT, DepsT, OutputT, NewOutputT], /\n) -> DecisionBranchBuilder[StateT, DepsT, NewOutputT, SourceT, HandledT]:\n    \"\"\"Apply a transformation to the branch's output.\n\n    Args:\n        func: Transformation function to apply.\n\n    Returns:\n        A new DecisionBranchBuilder where the provided transform is applied prior to generating the final output.\n    \"\"\"\n    return DecisionBranchBuilder(\n        decision=self._decision,\n        source=self._source,\n        matches=self._matches,\n        path_builder=self._path_builder.transform(func),\n    )\n\n```\n\n#### map\n\n```python\nmap(\n    *,\n    fork_id: str | None = None,\n    downstream_join_id: str | None = None\n) -> DecisionBranchBuilder[\n    StateT, DepsT, T, SourceT, HandledT\n]\n\n```\n\nSpread the branch's output.\n\nTo do this, the current output must be iterable, and any subsequent steps in the path being built for this branch will be applied to each item of the current output in parallel.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `fork_id` | `str | None` | Optional ID for the fork, defaults to a generated value | `None` | | `downstream_join_id` | `str | None` | Optional ID of a downstream join node which is involved when mapping empty iterables | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `DecisionBranchBuilder[StateT, DepsT, T, SourceT, HandledT]` | A new DecisionBranchBuilder where mapping is performed prior to generating the final output. |\n\nSource code in `pydantic_graph/pydantic_graph/beta/decision.py`\n\n```python\ndef map(\n    self: DecisionBranchBuilder[StateT, DepsT, Iterable[T], SourceT, HandledT]\n    | DecisionBranchBuilder[StateT, DepsT, AsyncIterable[T], SourceT, HandledT],\n    *,\n    fork_id: str | None = None,\n    downstream_join_id: str | None = None,\n) -> DecisionBranchBuilder[StateT, DepsT, T, SourceT, HandledT]:\n    \"\"\"Spread the branch's output.\n\n    To do this, the current output must be iterable, and any subsequent steps in the path being built for this\n    branch will be applied to each item of the current output in parallel.\n\n    Args:\n        fork_id: Optional ID for the fork, defaults to a generated value\n        downstream_join_id: Optional ID of a downstream join node which is involved when mapping empty iterables\n\n    Returns:\n        A new DecisionBranchBuilder where mapping is performed prior to generating the final output.\n    \"\"\"\n    return DecisionBranchBuilder(\n        decision=self._decision,\n        source=self._source,\n        matches=self._matches,\n        path_builder=self._path_builder.map(fork_id=fork_id, downstream_join_id=downstream_join_id),\n    )\n\n```\n\n#### label\n\n```python\nlabel(\n    label: str,\n) -> DecisionBranchBuilder[\n    StateT, DepsT, OutputT, SourceT, HandledT\n]\n\n```\n\nApply a label to the branch at the current point in the path being built.\n\nThese labels are only used in generated mermaid diagrams.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `label` | `str` | The label to apply. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `DecisionBranchBuilder[StateT, DepsT, OutputT, SourceT, HandledT]` | A new DecisionBranchBuilder where the label has been applied at the end of the current path being built. |\n\nSource code in `pydantic_graph/pydantic_graph/beta/decision.py`\n\n```python\ndef label(self, label: str) -> DecisionBranchBuilder[StateT, DepsT, OutputT, SourceT, HandledT]:\n    \"\"\"Apply a label to the branch at the current point in the path being built.\n\n    These labels are only used in generated mermaid diagrams.\n\n    Args:\n        label: The label to apply.\n\n    Returns:\n        A new DecisionBranchBuilder where the label has been applied at the end of the current path being built.\n    \"\"\"\n    return DecisionBranchBuilder(\n        decision=self._decision,\n        source=self._source,\n        matches=self._matches,\n        path_builder=self._path_builder.label(label),\n    )\n\n```",
  "content_length": 23408
}