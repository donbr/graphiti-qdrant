{
  "title": "Agent-User Interaction (AG-UI) Protocol",
  "source_url": null,
  "content": "The [Agent-User Interaction (AG-UI) Protocol](https://docs.ag-ui.com/introduction) is an open standard introduced by the [CopilotKit](https://webflow.copilotkit.ai/blog/introducing-ag-ui-the-protocol-where-agents-meet-users) team that standardises how frontend applications communicate with AI agents, with support for streaming, frontend tools, shared state, and custom events.\n\nNote\n\nThe AG-UI integration was originally built by the team at [Rocket Science](https://www.rocketscience.gg/) and contributed in collaboration with the Pydantic AI and CopilotKit teams. Thanks Rocket Science!\n\n## Installation\n\nThe only dependencies are:\n\n- [ag-ui-protocol](https://docs.ag-ui.com/introduction): to provide the AG-UI types and encoder.\n- [starlette](https://www.starlette.io): to handle [ASGI](https://asgi.readthedocs.io/en/latest/) requests from a framework like FastAPI.\n\nYou can install Pydantic AI with the `ag-ui` extra to ensure you have all the required AG-UI dependencies:\n\n```bash\npip install 'pydantic-ai-slim[ag-ui]'\n\n```\n\n```bash\nuv add 'pydantic-ai-slim[ag-ui]'\n\n```\n\nTo run the examples you'll also need:\n\n- [uvicorn](https://www.uvicorn.org/) or another ASGI compatible server\n\n```bash\npip install uvicorn\n\n```\n\n```bash\nuv add uvicorn\n\n```\n\n## Usage\n\nThere are three ways to run a Pydantic AI agent based on AG-UI run input with streamed AG-UI events as output, from most to least flexible. If you're using a Starlette-based web framework like FastAPI, you'll typically want to use the second method.\n\n1. The AGUIAdapter.run_stream() method, when called on an AGUIAdapter instantiated with an agent and an AG-UI [`RunAgentInput`](https://docs.ag-ui.com/sdk/python/core/types#runagentinput) object, will run the agent and return a stream of AG-UI events. It also takes optional Agent.iter() arguments including `deps`. Use this if you're using a web framework not based on Starlette (e.g. Django or Flask) or want to modify the input or output some way.\n1. The AGUIAdapter.dispatch_request() class method takes an agent and a Starlette request (e.g. from FastAPI) coming from an AG-UI frontend, and returns a streaming Starlette response of AG-UI events that you can return directly from your endpoint. It also takes optional Agent.iter() arguments including `deps`, that you can vary for each request (e.g. based on the authenticated user). This is a convenience method that combines AGUIAdapter.from_request(), AGUIAdapter.run_stream(), and AGUIAdapter.streaming_response().\n1. AGUIApp represents an ASGI application that handles every AG-UI request by running the agent. It also takes optional Agent.iter() arguments including `deps`, but these will be the same for each request, with the exception of the AG-UI state that's injected as described under [state management](#state-management). This ASGI app can be [mounted](https://fastapi.tiangolo.com/advanced/sub-applications/) at a given path in an existing FastAPI app.\n\n### Handle run input and output directly\n\nThis example uses AGUIAdapter.run_stream() and performs its own request parsing and response generation. This can be modified to work with any web framework.\n\n[Learn about Gateway](../../gateway) run_ag_ui.py\n\n```python\nimport json\nfrom http import HTTPStatus\n\nfrom fastapi import FastAPI\nfrom fastapi.requests import Request\nfrom fastapi.responses import Response, StreamingResponse\nfrom pydantic import ValidationError\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ui import SSE_CONTENT_TYPE\nfrom pydantic_ai.ui.ag_ui import AGUIAdapter\n\nagent = Agent('gateway/openai:gpt-5', instructions='Be fun!')\n\napp = FastAPI()\n\n\n@app.post('/')\nasync def run_agent(request: Request) -> Response:\n    accept = request.headers.get('accept', SSE_CONTENT_TYPE)\n    try:\n        run_input = AGUIAdapter.build_run_input(await request.body())  # (1)\n    except ValidationError as e:\n        return Response(\n            content=json.dumps(e.json()),\n            media_type='application/json',\n            status_code=HTTPStatus.UNPROCESSABLE_ENTITY,\n        )\n\n    adapter = AGUIAdapter(agent=agent, run_input=run_input, accept=accept)\n    event_stream = adapter.run_stream() # (2)\n\n    sse_event_stream = adapter.encode_stream(event_stream)\n    return StreamingResponse(sse_event_stream, media_type=accept) # (3)\n\n```\n\n1. AGUIAdapter.build_run_input() takes the request body as bytes and returns an AG-UI [`RunAgentInput`](https://docs.ag-ui.com/sdk/python/core/types#runagentinput) object. You can also use the AGUIAdapter.from_request() class method to build an adapter directly from a request.\n1. AGUIAdapter.run_stream() runs the agent and returns a stream of AG-UI events. It supports the same optional arguments as [`Agent.run_stream_events()`](../../agents/#running-agents), including `deps`. You can also use AGUIAdapter.run_stream_native() to run the agent and return a stream of Pydantic AI events instead, which can then be transformed into AG-UI events using AGUIAdapter.transform_stream().\n1. AGUIAdapter.encode_stream() encodes the stream of AG-UI events as strings according to the accept header value. You can also use AGUIAdapter.streaming_response() to generate a streaming response directly from the AG-UI event stream returned by `run_stream()`.\n\nrun_ag_ui.py\n\n```python\nimport json\nfrom http import HTTPStatus\n\nfrom fastapi import FastAPI\nfrom fastapi.requests import Request\nfrom fastapi.responses import Response, StreamingResponse\nfrom pydantic import ValidationError\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ui import SSE_CONTENT_TYPE\nfrom pydantic_ai.ui.ag_ui import AGUIAdapter\n\nagent = Agent('openai:gpt-5', instructions='Be fun!')\n\napp = FastAPI()\n\n\n@app.post('/')\nasync def run_agent(request: Request) -> Response:\n    accept = request.headers.get('accept', SSE_CONTENT_TYPE)\n    try:\n        run_input = AGUIAdapter.build_run_input(await request.body())  # (1)\n    except ValidationError as e:\n        return Response(\n            content=json.dumps(e.json()),\n            media_type='application/json',\n            status_code=HTTPStatus.UNPROCESSABLE_ENTITY,\n        )\n\n    adapter = AGUIAdapter(agent=agent, run_input=run_input, accept=accept)\n    event_stream = adapter.run_stream() # (2)\n\n    sse_event_stream = adapter.encode_stream(event_stream)\n    return StreamingResponse(sse_event_stream, media_type=accept) # (3)\n\n```\n\n1. AGUIAdapter.build_run_input() takes the request body as bytes and returns an AG-UI [`RunAgentInput`](https://docs.ag-ui.com/sdk/python/core/types#runagentinput) object. You can also use the AGUIAdapter.from_request() class method to build an adapter directly from a request.\n1. AGUIAdapter.run_stream() runs the agent and returns a stream of AG-UI events. It supports the same optional arguments as [`Agent.run_stream_events()`](../../agents/#running-agents), including `deps`. You can also use AGUIAdapter.run_stream_native() to run the agent and return a stream of Pydantic AI events instead, which can then be transformed into AG-UI events using AGUIAdapter.transform_stream().\n1. AGUIAdapter.encode_stream() encodes the stream of AG-UI events as strings according to the accept header value. You can also use AGUIAdapter.streaming_response() to generate a streaming response directly from the AG-UI event stream returned by `run_stream()`.\n\nSince `app` is an ASGI application, it can be used with any ASGI server:\n\n```shell\nuvicorn run_ag_ui:app\n\n```\n\nThis will expose the agent as an AG-UI server, and your frontend can start sending requests to it.\n\n### Handle a Starlette request\n\nThis example uses AGUIAdapter.dispatch_request() to directly handle a FastAPI request and return a response. Something analogous to this will work with any Starlette-based web framework.\n\n[Learn about Gateway](../../gateway) handle_ag_ui_request.py\n\n```python\nfrom fastapi import FastAPI\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ui.ag_ui import AGUIAdapter\n\nagent = Agent('gateway/openai:gpt-5', instructions='Be fun!')\n\napp = FastAPI()\n\n@app.post('/')\nasync def run_agent(request: Request) -> Response:\n    return await AGUIAdapter.dispatch_request(request, agent=agent) # (1)\n\n```\n\n1. This method essentially does the same as the previous example, but it's more convenient to use when you're already using a Starlette/FastAPI app.\n\nhandle_ag_ui_request.py\n\n```python\nfrom fastapi import FastAPI\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ui.ag_ui import AGUIAdapter\n\nagent = Agent('openai:gpt-5', instructions='Be fun!')\n\napp = FastAPI()\n\n@app.post('/')\nasync def run_agent(request: Request) -> Response:\n    return await AGUIAdapter.dispatch_request(request, agent=agent) # (1)\n\n```\n\n1. This method essentially does the same as the previous example, but it's more convenient to use when you're already using a Starlette/FastAPI app.\n\nSince `app` is an ASGI application, it can be used with any ASGI server:\n\n```shell\nuvicorn handle_ag_ui_request:app\n\n```\n\nThis will expose the agent as an AG-UI server, and your frontend can start sending requests to it.\n\n### Stand-alone ASGI app\n\nThis example uses AGUIApp to turn the agent into a stand-alone ASGI application:\n\n[Learn about Gateway](../../gateway) ag_ui_app.py\n\n```python\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ui.ag_ui.app import AGUIApp\n\nagent = Agent('gateway/openai:gpt-5', instructions='Be fun!')\napp = AGUIApp(agent)\n\n```\n\nag_ui_app.py\n\n```python\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ui.ag_ui.app import AGUIApp\n\nagent = Agent('openai:gpt-5', instructions='Be fun!')\napp = AGUIApp(agent)\n\n```\n\nSince `app` is an ASGI application, it can be used with any ASGI server:\n\n```shell\nuvicorn ag_ui_app:app\n\n```\n\nThis will expose the agent as an AG-UI server, and your frontend can start sending requests to it.\n\n## Design\n\nThe Pydantic AI AG-UI integration supports all features of the spec:\n\n- [Events](https://docs.ag-ui.com/concepts/events)\n- [Messages](https://docs.ag-ui.com/concepts/messages)\n- [State Management](https://docs.ag-ui.com/concepts/state)\n- [Tools](https://docs.ag-ui.com/concepts/tools)\n\nThe integration receives messages in the form of a [`RunAgentInput`](https://docs.ag-ui.com/sdk/python/core/types#runagentinput) object that describes the details of the requested agent run including message history, state, and available tools.\n\nThese are converted to Pydantic AI types and passed to the agent's run method. Events from the agent, including tool calls, are converted to AG-UI events and streamed back to the caller as Server-Sent Events (SSE).\n\nA user request may require multiple round trips between client UI and Pydantic AI server, depending on the tools and events needed.\n\n## Features\n\n### State management\n\nThe integration provides full support for [AG-UI state management](https://docs.ag-ui.com/concepts/state), which enables real-time synchronization between agents and frontend applications.\n\nIn the example below we have document state which is shared between the UI and server using the StateDeps [dependencies type](../../dependencies/) that can be used to automatically validate state contained in [`RunAgentInput.state`](https://docs.ag-ui.com/sdk/js/core/types#runagentinput) using a Pydantic `BaseModel` specified as a generic parameter.\n\nCustom dependencies type with AG-UI state\n\nIf you want to use your own dependencies type to hold AG-UI state as well as other things, it needs to implements the StateHandler protocol, meaning it needs to be a [dataclass](https://docs.python.org/3/library/dataclasses.html) with a non-optional `state` field. This lets Pydantic AI ensure that state is properly isolated between requests by building a new dependencies object each time.\n\nIf the `state` field's type is a Pydantic `BaseModel` subclass, the raw state dictionary on the request is automatically validated. If not, you can validate the raw value yourself in your dependencies dataclass's `__post_init__` method.\n\nIf AG-UI state is provided but your dependencies do not implement StateHandler, Pydantic AI will emit a warning and ignore the state. Use StateDeps or a custom StateHandler implementation to receive and validate the incoming state.\n\n[Learn about Gateway](../../gateway) ag_ui_state.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ui import StateDeps\nfrom pydantic_ai.ui.ag_ui.app import AGUIApp\n\n\nclass DocumentState(BaseModel):\n    \"\"\"State for the document being written.\"\"\"\n\n    document: str = ''\n\n\nagent = Agent(\n    'gateway/openai:gpt-5',\n    instructions='Be fun!',\n    deps_type=StateDeps[DocumentState],\n)\napp = AGUIApp(agent, deps=StateDeps(DocumentState()))\n\n```\n\nag_ui_state.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.ui import StateDeps\nfrom pydantic_ai.ui.ag_ui.app import AGUIApp\n\n\nclass DocumentState(BaseModel):\n    \"\"\"State for the document being written.\"\"\"\n\n    document: str = ''\n\n\nagent = Agent(\n    'openai:gpt-5',\n    instructions='Be fun!',\n    deps_type=StateDeps[DocumentState],\n)\napp = AGUIApp(agent, deps=StateDeps(DocumentState()))\n\n```\n\nSince `app` is an ASGI application, it can be used with any ASGI server:\n\n```bash\nuvicorn ag_ui_state:app --host 0.0.0.0 --port 9000\n\n```\n\n### Tools\n\nAG-UI frontend tools are seamlessly provided to the Pydantic AI agent, enabling rich user experiences with frontend user interfaces.\n\n### Events\n\nPydantic AI tools can send [AG-UI events](https://docs.ag-ui.com/concepts/events) simply by returning a [`ToolReturn`](../../tools-advanced/#advanced-tool-returns) object with a [`BaseEvent`](https://docs.ag-ui.com/sdk/python/core/events#baseevent) (or a list of events) as `metadata`, which allows for custom events and state updates.\n\n[Learn about Gateway](../../gateway) ag_ui_tool_events.py\n\n```python\nfrom ag_ui.core import CustomEvent, EventType, StateSnapshotEvent\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, RunContext, ToolReturn\nfrom pydantic_ai.ui import StateDeps\nfrom pydantic_ai.ui.ag_ui.app import AGUIApp\n\n\nclass DocumentState(BaseModel):\n    \"\"\"State for the document being written.\"\"\"\n\n    document: str = ''\n\n\nagent = Agent(\n    'gateway/openai:gpt-5',\n    instructions='Be fun!',\n    deps_type=StateDeps[DocumentState],\n)\napp = AGUIApp(agent, deps=StateDeps(DocumentState()))\n\n\n@agent.tool\nasync def update_state(ctx: RunContext[StateDeps[DocumentState]]) -> ToolReturn:\n    return ToolReturn(\n        return_value='State updated',\n        metadata=[\n            StateSnapshotEvent(\n                type=EventType.STATE_SNAPSHOT,\n                snapshot=ctx.deps.state,\n            ),\n        ],\n    )\n\n\n@agent.tool_plain\nasync def custom_events() -> ToolReturn:\n    return ToolReturn(\n        return_value='Count events sent',\n        metadata=[\n            CustomEvent(\n                type=EventType.CUSTOM,\n                name='count',\n                value=1,\n            ),\n            CustomEvent(\n                type=EventType.CUSTOM,\n                name='count',\n                value=2,\n            ),\n        ]\n    )\n\n```\n\nag_ui_tool_events.py\n\n```python\nfrom ag_ui.core import CustomEvent, EventType, StateSnapshotEvent\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, RunContext, ToolReturn\nfrom pydantic_ai.ui import StateDeps\nfrom pydantic_ai.ui.ag_ui.app import AGUIApp\n\n\nclass DocumentState(BaseModel):\n    \"\"\"State for the document being written.\"\"\"\n\n    document: str = ''\n\n\nagent = Agent(\n    'openai:gpt-5',\n    instructions='Be fun!',\n    deps_type=StateDeps[DocumentState],\n)\napp = AGUIApp(agent, deps=StateDeps(DocumentState()))\n\n\n@agent.tool\nasync def update_state(ctx: RunContext[StateDeps[DocumentState]]) -> ToolReturn:\n    return ToolReturn(\n        return_value='State updated',\n        metadata=[\n            StateSnapshotEvent(\n                type=EventType.STATE_SNAPSHOT,\n                snapshot=ctx.deps.state,\n            ),\n        ],\n    )\n\n\n@agent.tool_plain\nasync def custom_events() -> ToolReturn:\n    return ToolReturn(\n        return_value='Count events sent',\n        metadata=[\n            CustomEvent(\n                type=EventType.CUSTOM,\n                name='count',\n                value=1,\n            ),\n            CustomEvent(\n                type=EventType.CUSTOM,\n                name='count',\n                value=2,\n            ),\n        ]\n    )\n\n```\n\nSince `app` is an ASGI application, it can be used with any ASGI server:\n\n```bash\nuvicorn ag_ui_tool_events:app --host 0.0.0.0 --port 9000\n\n```\n\n## Examples\n\nFor more examples of how to use AGUIApp see [`pydantic_ai_examples.ag_ui`](https://github.com/pydantic/pydantic-ai/tree/main/examples/pydantic_ai_examples/ag_ui), which includes a server for use with the [AG-UI Dojo](https://docs.ag-ui.com/tutorials/debugging#the-ag-ui-dojo).",
  "content_length": 16897
}