{
  "title": "Multi-agent Applications",
  "source_url": null,
  "content": "There are roughly four levels of complexity when building applications with Pydantic AI:\n\n1. Single agent workflows — what most of the `pydantic_ai` documentation covers\n1. [Agent delegation](#agent-delegation) — agents using another agent via tools\n1. [Programmatic agent hand-off](#programmatic-agent-hand-off) — one agent runs, then application code calls another agent\n1. [Graph based control flow](../graph/) — for the most complex cases, a graph-based state machine can be used to control the execution of multiple agents\n\nOf course, you can combine multiple strategies in a single application.\n\n## Agent delegation\n\n\"Agent delegation\" refers to the scenario where an agent delegates work to another agent, then takes back control when the delegate agent (the agent called from within a tool) finishes. If you want to hand off control to another agent completely, without coming back to the first agent, you can use an [output function](../output/#output-functions).\n\nSince agents are stateless and designed to be global, you do not need to include the agent itself in agent [dependencies](../dependencies/).\n\nYou'll generally want to pass ctx.usage to the usage keyword argument of the delegate agent run so usage within that run counts towards the total usage of the parent agent run.\n\nMultiple models\n\nAgent delegation doesn't need to use the same model for each agent. If you choose to use different models within a run, calculating the monetary cost from the final result.usage() of the run will not be possible, but you can still use UsageLimits — including `request_limit`, `total_tokens_limit`, and `tool_calls_limit` — to avoid unexpected costs or runaway tool loops.\n\n[Learn about Gateway](../gateway) agent_delegation_simple.py\n\n```python\nfrom pydantic_ai import Agent, RunContext, UsageLimits\n\njoke_selection_agent = Agent(  # (1)!\n    'gateway/openai:gpt-5',\n    system_prompt=(\n        'Use the `joke_factory` to generate some jokes, then choose the best. '\n        'You must return just a single joke.'\n    ),\n)\njoke_generation_agent = Agent(  # (2)!\n    'gateway/google-gla:gemini-2.5-flash', output_type=list[str]\n)\n\n\n@joke_selection_agent.tool\nasync def joke_factory(ctx: RunContext[None], count: int) -> list[str]:\n    r = await joke_generation_agent.run(  # (3)!\n        f'Please generate {count} jokes.',\n        usage=ctx.usage,  # (4)!\n    )\n    return r.output  # (5)!\n\n\nresult = joke_selection_agent.run_sync(\n    'Tell me a joke.',\n    usage_limits=UsageLimits(request_limit=5, total_tokens_limit=500),\n)\nprint(result.output)\n#> Did you hear about the toothpaste scandal? They called it Colgate.\nprint(result.usage())\n#> RunUsage(input_tokens=204, output_tokens=24, requests=3, tool_calls=1)\n\n```\n\n1. The \"parent\" or controlling agent.\n1. The \"delegate\" agent, which is called from within a tool of the parent agent.\n1. Call the delegate agent from within a tool of the parent agent.\n1. Pass the usage from the parent agent to the delegate agent so the final result.usage() includes the usage from both agents.\n1. Since the function returns `list[str]`, and the `output_type` of `joke_generation_agent` is also `list[str]`, we can simply return `r.output` from the tool.\n\nagent_delegation_simple.py\n\n```python\nfrom pydantic_ai import Agent, RunContext, UsageLimits\n\njoke_selection_agent = Agent(  # (1)!\n    'openai:gpt-5',\n    system_prompt=(\n        'Use the `joke_factory` to generate some jokes, then choose the best. '\n        'You must return just a single joke.'\n    ),\n)\njoke_generation_agent = Agent(  # (2)!\n    'google-gla:gemini-2.5-flash', output_type=list[str]\n)\n\n\n@joke_selection_agent.tool\nasync def joke_factory(ctx: RunContext[None], count: int) -> list[str]:\n    r = await joke_generation_agent.run(  # (3)!\n        f'Please generate {count} jokes.',\n        usage=ctx.usage,  # (4)!\n    )\n    return r.output  # (5)!\n\n\nresult = joke_selection_agent.run_sync(\n    'Tell me a joke.',\n    usage_limits=UsageLimits(request_limit=5, total_tokens_limit=500),\n)\nprint(result.output)\n#> Did you hear about the toothpaste scandal? They called it Colgate.\nprint(result.usage())\n#> RunUsage(input_tokens=204, output_tokens=24, requests=3, tool_calls=1)\n\n```\n\n1. The \"parent\" or controlling agent.\n1. The \"delegate\" agent, which is called from within a tool of the parent agent.\n1. Call the delegate agent from within a tool of the parent agent.\n1. Pass the usage from the parent agent to the delegate agent so the final result.usage() includes the usage from both agents.\n1. Since the function returns `list[str]`, and the `output_type` of `joke_generation_agent` is also `list[str]`, we can simply return `r.output` from the tool.\n\n*(This example is complete, it can be run \"as is\")*\n\nThe control flow for this example is pretty simple and can be summarised as follows:\n\n```\ngraph TD\n  START --> joke_selection_agent\n  joke_selection_agent --> joke_factory[\"joke_factory (tool)\"]\n  joke_factory --> joke_generation_agent\n  joke_generation_agent --> joke_factory\n  joke_factory --> joke_selection_agent\n  joke_selection_agent --> END\n```\n\n### Agent delegation and dependencies\n\nGenerally the delegate agent needs to either have the same [dependencies](../dependencies/) as the calling agent, or dependencies which are a subset of the calling agent's dependencies.\n\nInitializing dependencies\n\nWe say \"generally\" above since there's nothing to stop you initializing dependencies within a tool call and therefore using interdependencies in a delegate agent that are not available on the parent, this should often be avoided since it can be significantly slower than reusing connections etc. from the parent agent.\n\n[Learn about Gateway](../gateway) agent_delegation_deps.py\n\n```python\nfrom dataclasses import dataclass\n\nimport httpx\n\nfrom pydantic_ai import Agent, RunContext\n\n\n@dataclass\nclass ClientAndKey:  # (1)!\n    http_client: httpx.AsyncClient\n    api_key: str\n\n\njoke_selection_agent = Agent(\n    'gateway/openai:gpt-5',\n    deps_type=ClientAndKey,  # (2)!\n    system_prompt=(\n        'Use the `joke_factory` tool to generate some jokes on the given subject, '\n        'then choose the best. You must return just a single joke.'\n    ),\n)\njoke_generation_agent = Agent(\n    'gateway/google-gla:gemini-2.5-flash',\n    deps_type=ClientAndKey,  # (4)!\n    output_type=list[str],\n    system_prompt=(\n        'Use the \"get_jokes\" tool to get some jokes on the given subject, '\n        'then extract each joke into a list.'\n    ),\n)\n\n\n@joke_selection_agent.tool\nasync def joke_factory(ctx: RunContext[ClientAndKey], count: int) -> list[str]:\n    r = await joke_generation_agent.run(\n        f'Please generate {count} jokes.',\n        deps=ctx.deps,  # (3)!\n        usage=ctx.usage,\n    )\n    return r.output\n\n\n@joke_generation_agent.tool  # (5)!\nasync def get_jokes(ctx: RunContext[ClientAndKey], count: int) -> str:\n    response = await ctx.deps.http_client.get(\n        'https://example.com',\n        params={'count': count},\n        headers={'Authorization': f'Bearer {ctx.deps.api_key}'},\n    )\n    response.raise_for_status()\n    return response.text\n\n\nasync def main():\n    async with httpx.AsyncClient() as client:\n        deps = ClientAndKey(client, 'foobar')\n        result = await joke_selection_agent.run('Tell me a joke.', deps=deps)\n        print(result.output)\n        #> Did you hear about the toothpaste scandal? They called it Colgate.\n        print(result.usage())  # (6)!\n        #> RunUsage(input_tokens=309, output_tokens=32, requests=4, tool_calls=2)\n\n```\n\n1. Define a dataclass to hold the client and API key dependencies.\n1. Set the `deps_type` of the calling agent — `joke_selection_agent` here.\n1. Pass the dependencies to the delegate agent's run method within the tool call.\n1. Also set the `deps_type` of the delegate agent — `joke_generation_agent` here.\n1. Define a tool on the delegate agent that uses the dependencies to make an HTTP request.\n1. Usage now includes 4 requests — 2 from the calling agent and 2 from the delegate agent.\n\nagent_delegation_deps.py\n\n```python\nfrom dataclasses import dataclass\n\nimport httpx\n\nfrom pydantic_ai import Agent, RunContext\n\n\n@dataclass\nclass ClientAndKey:  # (1)!\n    http_client: httpx.AsyncClient\n    api_key: str\n\n\njoke_selection_agent = Agent(\n    'openai:gpt-5',\n    deps_type=ClientAndKey,  # (2)!\n    system_prompt=(\n        'Use the `joke_factory` tool to generate some jokes on the given subject, '\n        'then choose the best. You must return just a single joke.'\n    ),\n)\njoke_generation_agent = Agent(\n    'google-gla:gemini-2.5-flash',\n    deps_type=ClientAndKey,  # (4)!\n    output_type=list[str],\n    system_prompt=(\n        'Use the \"get_jokes\" tool to get some jokes on the given subject, '\n        'then extract each joke into a list.'\n    ),\n)\n\n\n@joke_selection_agent.tool\nasync def joke_factory(ctx: RunContext[ClientAndKey], count: int) -> list[str]:\n    r = await joke_generation_agent.run(\n        f'Please generate {count} jokes.',\n        deps=ctx.deps,  # (3)!\n        usage=ctx.usage,\n    )\n    return r.output\n\n\n@joke_generation_agent.tool  # (5)!\nasync def get_jokes(ctx: RunContext[ClientAndKey], count: int) -> str:\n    response = await ctx.deps.http_client.get(\n        'https://example.com',\n        params={'count': count},\n        headers={'Authorization': f'Bearer {ctx.deps.api_key}'},\n    )\n    response.raise_for_status()\n    return response.text\n\n\nasync def main():\n    async with httpx.AsyncClient() as client:\n        deps = ClientAndKey(client, 'foobar')\n        result = await joke_selection_agent.run('Tell me a joke.', deps=deps)\n        print(result.output)\n        #> Did you hear about the toothpaste scandal? They called it Colgate.\n        print(result.usage())  # (6)!\n        #> RunUsage(input_tokens=309, output_tokens=32, requests=4, tool_calls=2)\n\n```\n\n1. Define a dataclass to hold the client and API key dependencies.\n1. Set the `deps_type` of the calling agent — `joke_selection_agent` here.\n1. Pass the dependencies to the delegate agent's run method within the tool call.\n1. Also set the `deps_type` of the delegate agent — `joke_generation_agent` here.\n1. Define a tool on the delegate agent that uses the dependencies to make an HTTP request.\n1. Usage now includes 4 requests — 2 from the calling agent and 2 from the delegate agent.\n\n*(This example is complete, it can be run \"as is\" — you'll need to add `asyncio.run(main())` to run `main`)*\n\nThis example shows how even a fairly simple agent delegation can lead to a complex control flow:\n\n```\ngraph TD\n  START --> joke_selection_agent\n  joke_selection_agent --> joke_factory[\"joke_factory (tool)\"]\n  joke_factory --> joke_generation_agent\n  joke_generation_agent --> get_jokes[\"get_jokes (tool)\"]\n  get_jokes --> http_request[\"HTTP request\"]\n  http_request --> get_jokes\n  get_jokes --> joke_generation_agent\n  joke_generation_agent --> joke_factory\n  joke_factory --> joke_selection_agent\n  joke_selection_agent --> END\n```\n\n## Programmatic agent hand-off\n\n\"Programmatic agent hand-off\" refers to the scenario where multiple agents are called in succession, with application code and/or a human in the loop responsible for deciding which agent to call next.\n\nHere agents don't need to use the same deps.\n\nHere we show two agents used in succession, the first to find a flight and the second to extract the user's seat preference.\n\nprogrammatic_handoff.py\n\n```python\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field\nfrom rich.prompt import Prompt\n\nfrom pydantic_ai import Agent, ModelMessage, RunContext, RunUsage, UsageLimits\n\n\nclass FlightDetails(BaseModel):\n    flight_number: str\n\n\nclass Failed(BaseModel):\n    \"\"\"Unable to find a satisfactory choice.\"\"\"\n\n\nflight_search_agent = Agent[None, FlightDetails | Failed](  # (1)!\n    'openai:gpt-5',\n    output_type=FlightDetails | Failed,  # type: ignore\n    system_prompt=(\n        'Use the \"flight_search\" tool to find a flight '\n        'from the given origin to the given destination.'\n    ),\n)\n\n\n@flight_search_agent.tool  # (2)!\nasync def flight_search(\n    ctx: RunContext[None], origin: str, destination: str\n) -> FlightDetails | None:\n    # in reality, this would call a flight search API or\n    # use a browser to scrape a flight search website\n    return FlightDetails(flight_number='AK456')\n\n\nusage_limits = UsageLimits(request_limit=15)  # (3)!\n\n\nasync def find_flight(usage: RunUsage) -> FlightDetails | None:  # (4)!\n    message_history: list[ModelMessage] | None = None\n    for _ in range(3):\n        prompt = Prompt.ask(\n            'Where would you like to fly from and to?',\n        )\n        result = await flight_search_agent.run(\n            prompt,\n            message_history=message_history,\n            usage=usage,\n            usage_limits=usage_limits,\n        )\n        if isinstance(result.output, FlightDetails):\n            return result.output\n        else:\n            message_history = result.all_messages(\n                output_tool_return_content='Please try again.'\n            )\n\n\nclass SeatPreference(BaseModel):\n    row: int = Field(ge=1, le=30)\n    seat: Literal['A', 'B', 'C', 'D', 'E', 'F']\n\n\n### This agent is responsible for extracting the user's seat selection\nseat_preference_agent = Agent[None, SeatPreference | Failed](  # (5)!\n    'openai:gpt-5',\n    output_type=SeatPreference | Failed,  # type: ignore\n    system_prompt=(\n        \"Extract the user's seat preference. \"\n        'Seats A and F are window seats. '\n        'Row 1 is the front row and has extra leg room. '\n        'Rows 14, and 20 also have extra leg room. '\n    ),\n)\n\n\nasync def find_seat(usage: RunUsage) -> SeatPreference:  # (6)!\n    message_history: list[ModelMessage] | None = None\n    while True:\n        answer = Prompt.ask('What seat would you like?')\n\n        result = await seat_preference_agent.run(\n            answer,\n            message_history=message_history,\n            usage=usage,\n            usage_limits=usage_limits,\n        )\n        if isinstance(result.output, SeatPreference):\n            return result.output\n        else:\n            print('Could not understand seat preference. Please try again.')\n            message_history = result.all_messages()\n\n\nasync def main():  # (7)!\n    usage: RunUsage = RunUsage()\n\n    opt_flight_details = await find_flight(usage)\n    if opt_flight_details is not None:\n        print(f'Flight found: {opt_flight_details.flight_number}')\n        #> Flight found: AK456\n        seat_preference = await find_seat(usage)\n        print(f'Seat preference: {seat_preference}')\n        #> Seat preference: row=1 seat='A'\n\n```\n\n1. Define the first agent, which finds a flight. We use an explicit type annotation until [PEP-747](https://peps.python.org/pep-0747/) lands, see [structured output](../output/#structured-output). We use a union as the output type so the model can communicate if it's unable to find a satisfactory choice; internally, each member of the union will be registered as a separate tool.\n1. Define a tool on the agent to find a flight. In this simple case we could dispense with the tool and just define the agent to return structured data, then search for a flight, but in more complex scenarios the tool would be necessary.\n1. Define usage limits for the entire app.\n1. Define a function to find a flight, which asks the user for their preferences and then calls the agent to find a flight.\n1. As with `flight_search_agent` above, we use an explicit type annotation to define the agent.\n1. Define a function to find the user's seat preference, which asks the user for their seat preference and then calls the agent to extract the seat preference.\n1. Now that we've put our logic for running each agent into separate functions, our main app becomes very simple.\n\n*(This example is complete, it can be run \"as is\" — you'll need to add `asyncio.run(main())` to run `main`)*\n\nThe control flow for this example can be summarised as follows:\n\n```\ngraph TB\n  START --> ask_user_flight[\"ask user for flight\"]\n\n  subgraph find_flight\n    flight_search_agent --> ask_user_flight\n    ask_user_flight --> flight_search_agent\n  end\n\n  flight_search_agent --> ask_user_seat[\"ask user for seat\"]\n  flight_search_agent --> END\n\n  subgraph find_seat\n    seat_preference_agent --> ask_user_seat\n    ask_user_seat --> seat_preference_agent\n  end\n\n  seat_preference_agent --> END\n```\n\n## Pydantic Graphs\n\nSee the [graph](../graph/) documentation on when and how to use graphs.\n\n## Examples\n\nThe following examples demonstrate how to use dependencies in Pydantic AI:\n\n- [Flight booking](../examples/flight-booking/)\n\n\"Output\" refers to the final value returned from [running an agent](../agents/#running-agents). This can be either plain text, [structured data](#structured-output), an [image](#image-output), or the result of a [function](#output-functions) called with arguments provided by the model.\n\nThe output is wrapped in AgentRunResult or StreamedRunResult so that you can access other data, like usage of the run and [message history](../message-history/#accessing-messages-from-results).\n\nBoth `AgentRunResult` and `StreamedRunResult` are generic in the data they wrap, so typing information about the data returned by the agent is preserved.\n\nA run ends when the model responds with one of the output types, or, if no output type is specified or `str` is one of the allowed options, when a plain text response is received. A run can also be cancelled if usage limits are exceeded, see [Usage Limits](../agents/#usage-limits).\n\nHere's an example using a Pydantic model as the `output_type`, forcing the model to respond with data matching our specification:\n\nolympics.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent\n\n\nclass CityLocation(BaseModel):\n    city: str\n    country: str\n\n\nagent = Agent('google-gla:gemini-2.5-flash', output_type=CityLocation)\nresult = agent.run_sync('Where were the olympics held in 2012?')\nprint(result.output)\n#> city='London' country='United Kingdom'\nprint(result.usage())\n#> RunUsage(input_tokens=57, output_tokens=8, requests=1)\n\n```\n\n*(This example is complete, it can be run \"as is\")*\n\n## Structured output data\n\nThe Agent class constructor takes an `output_type` argument that takes one or more types or [output functions](#output-functions). It supports simple scalar types, list and dict types (including `TypedDict`s and [`StructuredDict`s](#structured-dict)), dataclasses and Pydantic models, as well as type unions -- generally everything supported as type hints in a Pydantic model. You can also pass a list of multiple choices.\n\nBy default, Pydantic AI leverages the model's tool calling capability to make it return structured data. When multiple output types are specified (in a union or list), each member is registered with the model as a separate output tool in order to reduce the complexity of the schema and maximise the chances a model will respond correctly. This has been shown to work well across a wide range of models. If you'd like to change the names of the output tools, use a model's native structured output feature, or pass the output schema to the model in its [instructions](../agents/#instructions), you can use an [output mode](#output-modes) marker class.\n\nWhen no output type is specified, or when `str` is among the output types, any plain text response from the model will be used as the output data. If `str` is not among the output types, the model is forced to return structured data or call an output function.\n\nIf the output type schema is not of type `\"object\"` (e.g. it's `int` or `list[int]`), the output type is wrapped in a single element object, so the schema of all tools registered with the model are object schemas.\n\nStructured outputs (like tools) use Pydantic to build the JSON schema used for the tool, and to validate the data returned by the model.\n\nType checking considerations\n\nThe Agent class is generic in its output type, and this type is carried through to `AgentRunResult.output` and `StreamedRunResult.output` so that your IDE or static type checker can warn you when your code doesn't properly take into account all the possible values those outputs could have.\n\nStatic type checkers like pyright and mypy will do their best to infer the agent's output type from the `output_type` you've specified, but they're not always able to do so correctly when you provide functions or multiple types in a union or list, even though Pydantic AI will behave correctly. When this happens, your type checker will complain even when you're confident you've passed a valid `output_type`, and you'll need to help the type checker by explicitly specifying the generic parameters on the `Agent` constructor. This is shown in the second example below and the output functions example further down.\n\nSpecifically, there are three valid uses of `output_type` where you'll need to do this:\n\n1. When using a union of types, e.g. `output_type=Foo | Bar`. Until [PEP-747](https://peps.python.org/pep-0747/) \"Annotating Type Forms\" lands in Python 3.15, type checkers do not consider these a valid value for `output_type`. In addition to the generic parameters on the `Agent` constructor, you'll need to add `# type: ignore` to the line that passes the union to `output_type`. Alternatively, you can use a list: `output_type=[Foo, Bar]`.\n1. With mypy: When using a list, as a functionally equivalent alternative to a union, or because you're passing in [output functions](#output-functions). Pyright does handle this correctly, and we've filed [an issue](https://github.com/python/mypy/issues/19142) with mypy to try and get this fixed.\n1. With mypy: when using an async output function. Pyright does handle this correctly, and we've filed [an issue](https://github.com/python/mypy/issues/19143) with mypy to try and get this fixed.\n\nHere's an example of returning either text or structured data:\n\n[Learn about Gateway](../gateway) box_or_error.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent\n\n\nclass Box(BaseModel):\n    width: int\n    height: int\n    depth: int\n    units: str\n\n\nagent = Agent(\n    'gateway/openai:gpt-5-mini',\n    output_type=[Box, str], # (1)!\n    system_prompt=(\n        \"Extract me the dimensions of a box, \"\n        \"if you can't extract all data, ask the user to try again.\"\n    ),\n)\n\nresult = agent.run_sync('The box is 10x20x30')\nprint(result.output)\n#> Please provide the units for the dimensions (e.g., cm, in, m).\n\nresult = agent.run_sync('The box is 10x20x30 cm')\nprint(result.output)\n#> width=10 height=20 depth=30 units='cm'\n\n```\n\n1. This could also have been a union: `output_type=Box | str`. However, as explained in the \"Type checking considerations\" section above, that would've required explicitly specifying the generic parameters on the `Agent` constructor and adding `# type: ignore` to this line in order to be type checked correctly.\n\nbox_or_error.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent\n\n\nclass Box(BaseModel):\n    width: int\n    height: int\n    depth: int\n    units: str\n\n\nagent = Agent(\n    'openai:gpt-5-mini',\n    output_type=[Box, str], # (1)!\n    system_prompt=(\n        \"Extract me the dimensions of a box, \"\n        \"if you can't extract all data, ask the user to try again.\"\n    ),\n)\n\nresult = agent.run_sync('The box is 10x20x30')\nprint(result.output)\n#> Please provide the units for the dimensions (e.g., cm, in, m).\n\nresult = agent.run_sync('The box is 10x20x30 cm')\nprint(result.output)\n#> width=10 height=20 depth=30 units='cm'\n\n```\n\n1. This could also have been a union: `output_type=Box | str`. However, as explained in the \"Type checking considerations\" section above, that would've required explicitly specifying the generic parameters on the `Agent` constructor and adding `# type: ignore` to this line in order to be type checked correctly.\n\n*(This example is complete, it can be run \"as is\")*\n\nHere's an example of using a union return type, which will register multiple output tools and wrap non-object schemas in an object:\n\ncolors_or_sizes.py\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent[None, list[str] | list[int]](\n    'openai:gpt-5-mini',\n    output_type=list[str] | list[int],  # type: ignore # (1)!\n    system_prompt='Extract either colors or sizes from the shapes provided.',\n)\n\nresult = agent.run_sync('red square, blue circle, green triangle')\nprint(result.output)\n#> ['red', 'blue', 'green']\n\nresult = agent.run_sync('square size 10, circle size 20, triangle size 30')\nprint(result.output)\n#> [10, 20, 30]\n\n```\n\n1. As explained in the \"Type checking considerations\" section above, using a union rather than a list requires explicitly specifying the generic parameters on the `Agent` constructor and adding `# type: ignore` to this line in order to be type checked correctly.\n\n*(This example is complete, it can be run \"as is\")*\n\n### Output functions\n\nInstead of plain text or structured data, you may want the output of your agent run to be the result of a function called with arguments provided by the model, for example to further process or validate the data provided through the arguments (with the option to tell the model to try again), or to hand off to another agent.\n\nOutput functions are similar to [function tools](../tools/), but the model is forced to call one of them, the call ends the agent run, and the result is not passed back to the model.\n\nAs with tool functions, output function arguments provided by the model are validated using Pydantic (with optional [validation context](#validation-context)), can optionally take RunContext as the first argument, and can raise ModelRetry to ask the model to try again with modified arguments (or with a different output type).\n\nTo specify output functions, you set the agent's `output_type` to either a single function (or bound instance method), or a list of functions. The list can also contain other output types like simple scalars or entire Pydantic models. You typically do not want to also register your output function as a tool (using the `@agent.tool` decorator or `tools` argument), as this could confuse the model about which it should be calling.\n\nHere's an example of all of these features in action:\n\noutput_functions.py\n\n```python\nimport re\n\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, ModelRetry, RunContext, UnexpectedModelBehavior\n\n\nclass Row(BaseModel):\n    name: str\n    country: str\n\n\ntables = {\n    'capital_cities': [\n        Row(name='Amsterdam', country='Netherlands'),\n        Row(name='Mexico City', country='Mexico'),\n    ]\n}\n\n\nclass SQLFailure(BaseModel):\n    \"\"\"An unrecoverable failure. Only use this when you can't change the query to make it work.\"\"\"\n\n    explanation: str\n\n\ndef run_sql_query(query: str) -> list[Row]:\n    \"\"\"Run a SQL query on the database.\"\"\"\n\n    select_table = re.match(r'SELECT (.+) FROM (\\w+)', query)\n    if select_table:\n        column_names = select_table.group(1)\n        if column_names != '*':\n            raise ModelRetry(\"Only 'SELECT *' is supported, you'll have to do column filtering manually.\")\n\n        table_name = select_table.group(2)\n        if table_name not in tables:\n            raise ModelRetry(\n                f\"Unknown table '{table_name}' in query '{query}'. Available tables: {', '.join(tables.keys())}.\"\n            )\n\n        return tables[table_name]\n\n    raise ModelRetry(f\"Unsupported query: '{query}'.\")\n\n\nsql_agent = Agent[None, list[Row] | SQLFailure](\n    'openai:gpt-5',\n    output_type=[run_sql_query, SQLFailure],\n    instructions='You are a SQL agent that can run SQL queries on a database.',\n)\n\n\nasync def hand_off_to_sql_agent(ctx: RunContext, query: str) -> list[Row]:\n    \"\"\"I take natural language queries, turn them into SQL, and run them on a database.\"\"\"\n\n    # Drop the final message with the output tool call, as it shouldn't be passed on to the SQL agent\n    messages = ctx.messages[:-1]\n    try:\n        result = await sql_agent.run(query, message_history=messages)\n        output = result.output\n        if isinstance(output, SQLFailure):\n            raise ModelRetry(f'SQL agent failed: {output.explanation}')\n        return output\n    except UnexpectedModelBehavior as e:\n        # Bubble up potentially retryable errors to the router agent\n        if (cause := e.__cause__) and isinstance(cause, ModelRetry):\n            raise ModelRetry(f'SQL agent failed: {cause.message}') from e\n        else:\n            raise\n\n\nclass RouterFailure(BaseModel):\n    \"\"\"Use me when no appropriate agent is found or the used agent failed.\"\"\"\n\n    explanation: str\n\n\nrouter_agent = Agent[None, list[Row] | RouterFailure](\n    'openai:gpt-5',\n    output_type=[hand_off_to_sql_agent, RouterFailure],\n    instructions='You are a router to other agents. Never try to solve a problem yourself, just pass it on.',\n)\n\nresult = router_agent.run_sync('Select the names and countries of all capitals')\nprint(result.output)\n\"\"\"\n[\n    Row(name='Amsterdam', country='Netherlands'),\n    Row(name='Mexico City', country='Mexico'),\n]\n\"\"\"\n\nresult = router_agent.run_sync('Select all pets')\nprint(repr(result.output))\n\"\"\"\nRouterFailure(explanation=\"The requested table 'pets' does not exist in the database. The only available table is 'capital_cities', which does not contain data about pets.\")\n\"\"\"\n\nresult = router_agent.run_sync('How do I fly from Amsterdam to Mexico City?')\nprint(repr(result.output))\n\"\"\"\nRouterFailure(explanation='I am not equipped to provide travel information, such as flights from Amsterdam to Mexico City.')\n\"\"\"\n\n```\n\n#### Text output\n\nIf you provide an output function that takes a string, Pydantic AI will by default create an output tool like for any other output function. If instead you'd like the model to provide the string using plain text output, you can wrap the function in the TextOutput marker class. If desired, this marker class can be used alongside one or more [`ToolOutput`](#tool-output) marker classes (or unmarked types or functions) in a list provided to `output_type`.\n\n[Learn about Gateway](../gateway) text_output_function.py\n\n```python\nfrom pydantic_ai import Agent, TextOutput\n\n\ndef split_into_words(text: str) -> list[str]:\n    return text.split()\n\n\nagent = Agent(\n    'gateway/openai:gpt-5',\n    output_type=TextOutput(split_into_words),\n)\nresult = agent.run_sync('Who was Albert Einstein?')\nprint(result.output)\n#> ['Albert', 'Einstein', 'was', 'a', 'German-born', 'theoretical', 'physicist.']\n\n```\n\ntext_output_function.py\n\n```python\nfrom pydantic_ai import Agent, TextOutput\n\n\ndef split_into_words(text: str) -> list[str]:\n    return text.split()\n\n\nagent = Agent(\n    'openai:gpt-5',\n    output_type=TextOutput(split_into_words),\n)\nresult = agent.run_sync('Who was Albert Einstein?')\nprint(result.output)\n#> ['Albert', 'Einstein', 'was', 'a', 'German-born', 'theoretical', 'physicist.']\n\n```\n\n*(This example is complete, it can be run \"as is\")*\n\n### Output modes\n\nPydantic AI implements three different methods to get a model to output structured data:\n\n1. [Tool Output](#tool-output), where tool calls are used to produce the output.\n1. [Native Output](#native-output), where the model is required to produce text content compliant with a provided JSON schema.\n1. [Prompted Output](#prompted-output), where a prompt is injected into the model instructions including the desired JSON schema, and we attempt to parse the model's plain-text response as appropriate.\n\n#### Tool Output\n\nIn the default Tool Output mode, the output JSON schema of each output type (or function) is provided to the model as the parameters schema of a special output tool. This is the default as it's supported by virtually all models and has been shown to work very well.\n\nIf you'd like to change the name of the output tool, pass a custom description to aid the model, or turn on or off strict mode, you can wrap the type(s) in the ToolOutput marker class and provide the appropriate arguments. Note that by default, the description is taken from the docstring specified on a Pydantic model or output function, so specifying it using the marker class is typically not necessary.\n\nTo dynamically modify or filter the available output tools during an agent run, you can define an agent-wide `prepare_output_tools` function that will be called ahead of each step of a run. This function should be of type ToolsPrepareFunc, which takes the RunContext and a list of ToolDefinition, and returns a new list of tool definitions (or `None` to disable all tools for that step). This is analogous to the [`prepare_tools` function](../tools-advanced/#prepare-tools) for non-output tools.\n\n[Learn about Gateway](../gateway) tool_output.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, ToolOutput\n\n\nclass Fruit(BaseModel):\n    name: str\n    color: str\n\n\nclass Vehicle(BaseModel):\n    name: str\n    wheels: int\n\n\nagent = Agent(\n    'gateway/openai:gpt-5',\n    output_type=[ # (1)!\n        ToolOutput(Fruit, name='return_fruit'),\n        ToolOutput(Vehicle, name='return_vehicle'),\n    ],\n)\nresult = agent.run_sync('What is a banana?')\nprint(repr(result.output))\n#> Fruit(name='banana', color='yellow')\n\n```\n\n1. If we were passing just `Fruit` and `Vehicle` without custom tool names, we could have used a union: `output_type=Fruit | Vehicle`. However, as `ToolOutput` is an object rather than a type, we have to use a list.\n\ntool_output.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, ToolOutput\n\n\nclass Fruit(BaseModel):\n    name: str\n    color: str\n\n\nclass Vehicle(BaseModel):\n    name: str\n    wheels: int\n\n\nagent = Agent(\n    'openai:gpt-5',\n    output_type=[ # (1)!\n        ToolOutput(Fruit, name='return_fruit'),\n        ToolOutput(Vehicle, name='return_vehicle'),\n    ],\n)\nresult = agent.run_sync('What is a banana?')\nprint(repr(result.output))\n#> Fruit(name='banana', color='yellow')\n\n```\n\n1. If we were passing just `Fruit` and `Vehicle` without custom tool names, we could have used a union: `output_type=Fruit | Vehicle`. However, as `ToolOutput` is an object rather than a type, we have to use a list.\n\n*(This example is complete, it can be run \"as is\")*\n\n#### Native Output\n\nNative Output mode uses a model's native \"Structured Outputs\" feature (aka \"JSON Schema response format\"), where the model is forced to only output text matching the provided JSON schema. Note that this is not supported by all models, and sometimes comes with restrictions. For example, Gemini cannot use tools at the same time as structured output, and attempting to do so will result in an error.\n\nTo use this mode, you can wrap the output type(s) in the NativeOutput marker class that also lets you specify a `name` and `description` if the name and docstring of the type or function are not sufficient.\n\n[Learn about Gateway](../gateway) native_output.py\n\n```python\nfrom pydantic_ai import Agent, NativeOutput\n\nfrom tool_output import Fruit, Vehicle\n\nagent = Agent(\n    'gateway/openai:gpt-5',\n    output_type=NativeOutput(\n        [Fruit, Vehicle], # (1)!\n        name='Fruit_or_vehicle',\n        description='Return a fruit or vehicle.'\n    ),\n)\nresult = agent.run_sync('What is a Ford Explorer?')\nprint(repr(result.output))\n#> Vehicle(name='Ford Explorer', wheels=4)\n\n```\n\n1. This could also have been a union: `output_type=Fruit | Vehicle`. However, as explained in the \"Type checking considerations\" section above, that would've required explicitly specifying the generic parameters on the `Agent` constructor and adding `# type: ignore` to this line in order to be type checked correctly.\n\nnative_output.py\n\n```python\nfrom pydantic_ai import Agent, NativeOutput\n\nfrom tool_output import Fruit, Vehicle\n\nagent = Agent(\n    'openai:gpt-5',\n    output_type=NativeOutput(\n        [Fruit, Vehicle], # (1)!\n        name='Fruit_or_vehicle',\n        description='Return a fruit or vehicle.'\n    ),\n)\nresult = agent.run_sync('What is a Ford Explorer?')\nprint(repr(result.output))\n#> Vehicle(name='Ford Explorer', wheels=4)\n\n```\n\n1. This could also have been a union: `output_type=Fruit | Vehicle`. However, as explained in the \"Type checking considerations\" section above, that would've required explicitly specifying the generic parameters on the `Agent` constructor and adding `# type: ignore` to this line in order to be type checked correctly.\n\n*(This example is complete, it can be run \"as is\")*\n\n#### Prompted Output\n\nIn this mode, the model is prompted to output text matching the provided JSON schema through its [instructions](../agents/#instructions) and it's up to the model to interpret those instructions correctly. This is usable with all models, but is often the least reliable approach as the model is not forced to match the schema.\n\nWhile we would generally suggest starting with tool or native output, in some cases this mode may result in higher quality outputs, and for models without native tool calling or structured output support it is the only option for producing structured outputs.\n\nIf the model API supports the \"JSON Mode\" feature (aka \"JSON Object response format\") to force the model to output valid JSON, this is enabled, but it's still up to the model to abide by the schema. Pydantic AI will validate the returned structured data and tell the model to try again if validation fails, but if the model is not intelligent enough this may not be sufficient.\n\nTo use this mode, you can wrap the output type(s) in the PromptedOutput marker class that also lets you specify a `name` and `description` if the name and docstring of the type or function are not sufficient. Additionally, it supports an `template` argument lets you specify a custom instructions template to be used instead of the default.\n\n[Learn about Gateway](../gateway) prompted_output.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, PromptedOutput\n\nfrom tool_output import Vehicle\n\n\nclass Device(BaseModel):\n    name: str\n    kind: str\n\n\nagent = Agent(\n    'gateway/openai:gpt-5',\n    output_type=PromptedOutput(\n        [Vehicle, Device], # (1)!\n        name='Vehicle or device',\n        description='Return a vehicle or device.'\n    ),\n)\nresult = agent.run_sync('What is a MacBook?')\nprint(repr(result.output))\n#> Device(name='MacBook', kind='laptop')\n\nagent = Agent(\n    'gateway/openai:gpt-5',\n    output_type=PromptedOutput(\n        [Vehicle, Device],\n        template='Gimme some JSON: {schema}'\n    ),\n)\nresult = agent.run_sync('What is a Ford Explorer?')\nprint(repr(result.output))\n#> Vehicle(name='Ford Explorer', wheels=4)\n\n```\n\n1. This could also have been a union: `output_type=Vehicle | Device`. However, as explained in the \"Type checking considerations\" section above, that would've required explicitly specifying the generic parameters on the `Agent` constructor and adding `# type: ignore` to this line in order to be type checked correctly.\n\nprompted_output.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, PromptedOutput\n\nfrom tool_output import Vehicle\n\n\nclass Device(BaseModel):\n    name: str\n    kind: str\n\n\nagent = Agent(\n    'openai:gpt-5',\n    output_type=PromptedOutput(\n        [Vehicle, Device], # (1)!\n        name='Vehicle or device',\n        description='Return a vehicle or device.'\n    ),\n)\nresult = agent.run_sync('What is a MacBook?')\nprint(repr(result.output))\n#> Device(name='MacBook', kind='laptop')\n\nagent = Agent(\n    'openai:gpt-5',\n    output_type=PromptedOutput(\n        [Vehicle, Device],\n        template='Gimme some JSON: {schema}'\n    ),\n)\nresult = agent.run_sync('What is a Ford Explorer?')\nprint(repr(result.output))\n#> Vehicle(name='Ford Explorer', wheels=4)\n\n```\n\n1. This could also have been a union: `output_type=Vehicle | Device`. However, as explained in the \"Type checking considerations\" section above, that would've required explicitly specifying the generic parameters on the `Agent` constructor and adding `# type: ignore` to this line in order to be type checked correctly.\n\n*(This example is complete, it can be run \"as is\")*\n\n### Custom JSON schema\n\nIf it's not feasible to define your desired structured output object using a Pydantic `BaseModel`, dataclass, or `TypedDict`, for example when you get a JSON schema from an external source or generate it dynamically, you can use the StructuredDict() helper function to generate a `dict[str, Any]` subclass with a JSON schema attached that Pydantic AI will pass to the model.\n\nNote that Pydantic AI will not perform any validation of the received JSON object and it's up to the model to correctly interpret the schema and any constraints expressed in it, like required fields or integer value ranges.\n\nThe output type will be a `dict[str, Any]` and it's up to your code to defensively read from it in case the model made a mistake. You can use an [output validator](#output-validator-functions) to reflect validation errors back to the model and get it to try again.\n\nAlong with the JSON schema, you can optionally pass `name` and `description` arguments to provide additional context to the model:\n\n[Learn about Gateway](../gateway)\n\n```python\nfrom pydantic_ai import Agent, StructuredDict\n\nHumanDict = StructuredDict(\n    {\n        'type': 'object',\n        'properties': {\n            'name': {'type': 'string'},\n            'age': {'type': 'integer'}\n        },\n        'required': ['name', 'age']\n    },\n    name='Human',\n    description='A human with a name and age',\n)\n\nagent = Agent('gateway/openai:gpt-5', output_type=HumanDict)\nresult = agent.run_sync('Create a person')\n#> {'name': 'John Doe', 'age': 30}\n\n```\n\n```python\nfrom pydantic_ai import Agent, StructuredDict\n\nHumanDict = StructuredDict(\n    {\n        'type': 'object',\n        'properties': {\n            'name': {'type': 'string'},\n            'age': {'type': 'integer'}\n        },\n        'required': ['name', 'age']\n    },\n    name='Human',\n    description='A human with a name and age',\n)\n\nagent = Agent('openai:gpt-5', output_type=HumanDict)\nresult = agent.run_sync('Create a person')\n#> {'name': 'John Doe', 'age': 30}\n\n```\n\n### Validation context\n\nSome validation relies on an extra Pydantic [context](https://docs.pydantic.dev/latest/concepts/validators/#validation-context) object. You can pass such an object to an `Agent` at definition-time via its validation_context parameter. It will be used in the validation of both structured outputs and [tool arguments](../tools-advanced/#tool-retries).\n\nThis validation context can be either:\n\n- the context object itself (`Any`), used as-is to validate outputs, or\n- a function that takes the RunContext and returns a context object (`Any`). This function will be called automatically before each validation, allowing you to build a dynamic validation context.\n\nDon't confuse this *validation* context with the *LLM* context\n\nThis Pydantic validation context object is only used internally by Pydantic AI for tool arg and output validation. In particular, it is **not** included in the prompts or messages sent to the language model.\n\nvalidation_context.py\n\n```python\nfrom dataclasses import dataclass\n\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\nfrom pydantic_ai import Agent\n\n\nclass Value(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def increment_value(cls, value: int, info: ValidationInfo):\n        return value + (info.context or 0)\n\n\nagent = Agent(\n    'google-gla:gemini-2.5-flash',\n    output_type=Value,\n    validation_context=10,\n)\nresult = agent.run_sync('Give me a value of 5.')\nprint(repr(result.output))  # 5 from the model + 10 from the validation context\n#> Value(x=15)\n\n\n@dataclass\nclass Deps:\n    increment: int\n\n\nagent = Agent(\n    'google-gla:gemini-2.5-flash',\n    output_type=Value,\n    deps_type=Deps,\n    validation_context=lambda ctx: ctx.deps.increment,\n)\nresult = agent.run_sync('Give me a value of 5.', deps=Deps(increment=10))\nprint(repr(result.output))  # 5 from the model + 10 from the validation context\n#> Value(x=15)\n\n```\n\n*(This example is complete, it can be run \"as is\")*\n\n### Output validators\n\nSome validation is inconvenient or impossible to do in Pydantic validators, in particular when the validation requires IO and is asynchronous. Pydantic AI provides a way to add validation functions via the agent.output_validator decorator.\n\nIf you want to implement separate validation logic for different output types, it's recommended to use [output functions](#output-functions) instead, to save you from having to do `isinstance` checks inside the output validator. If you want the model to output plain text, do your own processing or validation, and then have the agent's final output be the result of your function, it's recommended to use an [output function](#output-functions) with the [`TextOutput` marker class](#text-output).\n\nHere's a simplified variant of the [SQL Generation example](../examples/sql-gen/):\n\nsql_gen.py\n\n```python\nfrom fake_database import DatabaseConn, QueryError\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, RunContext, ModelRetry\n\n\nclass Success(BaseModel):\n    sql_query: str\n\n\nclass InvalidRequest(BaseModel):\n    error_message: str\n\n\nOutput = Success | InvalidRequest\nagent = Agent[DatabaseConn, Output](\n    'google-gla:gemini-2.5-flash',\n    output_type=Output,  # type: ignore\n    deps_type=DatabaseConn,\n    system_prompt='Generate PostgreSQL flavored SQL queries based on user input.',\n)\n\n\n@agent.output_validator\nasync def validate_sql(ctx: RunContext[DatabaseConn], output: Output) -> Output:\n    if isinstance(output, InvalidRequest):\n        return output\n    try:\n        await ctx.deps.execute(f'EXPLAIN {output.sql_query}')\n    except QueryError as e:\n        raise ModelRetry(f'Invalid query: {e}') from e\n    else:\n        return output\n\n\nresult = agent.run_sync(\n    'get me users who were last active yesterday.', deps=DatabaseConn()\n)\nprint(result.output)\n#> sql_query='SELECT * FROM users WHERE last_active::date = today() - interval 1 day'\n\n```\n\n*(This example is complete, it can be run \"as is\")*\n\n#### Handling partial output in output validators\n\nYou can use the `partial_output` field on `RunContext` to handle validation differently for partial outputs during streaming (e.g. skip validation altogether).\n\n[Learn about Gateway](../gateway) partial_validation_streaming.py\n\n```python\nfrom pydantic_ai import Agent, ModelRetry, RunContext\n\nagent = Agent('gateway/openai:gpt-5')\n\n@agent.output_validator\ndef validate_output(ctx: RunContext, output: str) -> str:\n    if ctx.partial_output:\n        return output\n    else:\n        if len(output) < 50:\n            raise ModelRetry('Output is too short.')\n        return output\n\n\nasync def main():\n    async with agent.run_stream('Write a long story about a cat') as result:\n        async for message in result.stream_text():\n            print(message)\n            #> Once upon a\n            #> Once upon a time, there was\n            #> Once upon a time, there was a curious cat\n            #> Once upon a time, there was a curious cat named Whiskers who\n            #> Once upon a time, there was a curious cat named Whiskers who loved to explore\n            #> Once upon a time, there was a curious cat named Whiskers who loved to explore the world around\n            #> Once upon a time, there was a curious cat named Whiskers who loved to explore the world around him...\n\n```\n\npartial_validation_streaming.py\n\n```python\nfrom pydantic_ai import Agent, ModelRetry, RunContext\n\nagent = Agent('openai:gpt-5')\n\n@agent.output_validator\ndef validate_output(ctx: RunContext, output: str) -> str:\n    if ctx.partial_output:\n        return output\n    else:\n        if len(output) < 50:\n            raise ModelRetry('Output is too short.')\n        return output\n\n\nasync def main():\n    async with agent.run_stream('Write a long story about a cat') as result:\n        async for message in result.stream_text():\n            print(message)\n            #> Once upon a\n            #> Once upon a time, there was\n            #> Once upon a time, there was a curious cat\n            #> Once upon a time, there was a curious cat named Whiskers who\n            #> Once upon a time, there was a curious cat named Whiskers who loved to explore\n            #> Once upon a time, there was a curious cat named Whiskers who loved to explore the world around\n            #> Once upon a time, there was a curious cat named Whiskers who loved to explore the world around him...\n\n```\n\n*(This example is complete, it can be run \"as is\" — you'll need to add `asyncio.run(main())` to run `main`)*\n\n## Image output\n\nSome models can generate images as part of their response, for example those that support the [Image Generation built-in tool](../builtin-tools/#image-generation-tool) and OpenAI models using the [Code Execution built-in tool](../builtin-tools/#code-execution-tool) when told to generate a chart.\n\nTo use the generated image as the output of the agent run, you can set `output_type` to BinaryImage. If no image-generating built-in tool is explicitly specified, the ImageGenerationTool will be enabled automatically.\n\n[Learn about Gateway](../gateway) image_output.py\n\n```python\nfrom pydantic_ai import Agent, BinaryImage\n\nagent = Agent('gateway/openai-responses:gpt-5', output_type=BinaryImage)\n\nresult = agent.run_sync('Generate an image of an axolotl.')\nassert isinstance(result.output, BinaryImage)\n\n```\n\nimage_output.py\n\n```python\nfrom pydantic_ai import Agent, BinaryImage\n\nagent = Agent('openai-responses:gpt-5', output_type=BinaryImage)\n\nresult = agent.run_sync('Generate an image of an axolotl.')\nassert isinstance(result.output, BinaryImage)\n\n```\n\n*(This example is complete, it can be run \"as is\")*\n\nIf an agent does not need to always generate an image, you can use a union of `BinaryImage` and `str`. If the model generates both, the image will take precedence as output and the text will be available on ModelResponse.text:\n\n[Learn about Gateway](../gateway) image_output_union.py\n\n```python\nfrom pydantic_ai import Agent, BinaryImage\n\nagent = Agent('gateway/openai-responses:gpt-5', output_type=BinaryImage | str)\n\nresult = agent.run_sync('Tell me a two-sentence story about an axolotl, no image please.')\nprint(result.output)\n\"\"\"\nOnce upon a time, in a hidden underwater cave, lived a curious axolotl named Pip who loved to explore. One day, while venturing further than usual, Pip discovered a shimmering, ancient coin that granted wishes!\n\"\"\"\n\nresult = agent.run_sync('Tell me a two-sentence story about an axolotl with an illustration.')\nassert isinstance(result.output, BinaryImage)\nprint(result.response.text)\n\"\"\"\nOnce upon a time, in a hidden underwater cave, lived a curious axolotl named Pip who loved to explore. One day, while venturing further than usual, Pip discovered a shimmering, ancient coin that granted wishes!\n\"\"\"\n\n```\n\nimage_output_union.py\n\n```python\nfrom pydantic_ai import Agent, BinaryImage\n\nagent = Agent('openai-responses:gpt-5', output_type=BinaryImage | str)\n\nresult = agent.run_sync('Tell me a two-sentence story about an axolotl, no image please.')\nprint(result.output)\n\"\"\"\nOnce upon a time, in a hidden underwater cave, lived a curious axolotl named Pip who loved to explore. One day, while venturing further than usual, Pip discovered a shimmering, ancient coin that granted wishes!\n\"\"\"\n\nresult = agent.run_sync('Tell me a two-sentence story about an axolotl with an illustration.')\nassert isinstance(result.output, BinaryImage)\nprint(result.response.text)\n\"\"\"\nOnce upon a time, in a hidden underwater cave, lived a curious axolotl named Pip who loved to explore. One day, while venturing further than usual, Pip discovered a shimmering, ancient coin that granted wishes!\n\"\"\"\n\n```\n\n## Streamed Results\n\nThere two main challenges with streamed results:\n\n1. Validating structured responses before they're complete, this is achieved by \"partial validation\" which was recently added to Pydantic in [pydantic/pydantic#10748](https://github.com/pydantic/pydantic/pull/10748).\n1. When receiving a response, we don't know if it's the final response without starting to stream it and peeking at the content. Pydantic AI streams just enough of the response to sniff out if it's a tool call or an output, then streams the whole thing and calls tools, or returns the stream as a StreamedRunResult.\n\nNote\n\nAs the `run_stream()` method will consider the first output matching the `output_type` to be the final output, it will stop running the agent graph and will not execute any tool calls made by the model after this \"final\" output.\n\nIf you want to always run the agent graph to completion and stream all events from the model's streaming response and the agent's execution of tools, use agent.run_stream_events() ([docs](../agents/#streaming-all-events)) or agent.iter() ([docs](../agents/#streaming-all-events-and-output)) instead.\n\n### Streaming Text\n\nExample of streamed text output:\n\nstreamed_hello_world.py\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('google-gla:gemini-2.5-flash')  # (1)!\n\n\nasync def main():\n    async with agent.run_stream('Where does \"hello world\" come from?') as result:  # (2)!\n        async for message in result.stream_text():  # (3)!\n            print(message)\n            #> The first known\n            #> The first known use of \"hello,\n            #> The first known use of \"hello, world\" was in\n            #> The first known use of \"hello, world\" was in a 1974 textbook\n            #> The first known use of \"hello, world\" was in a 1974 textbook about the C\n            #> The first known use of \"hello, world\" was in a 1974 textbook about the C programming language.\n\n```\n\n1. Streaming works with the standard Agent class, and doesn't require any special setup, just a model that supports streaming (currently all models support streaming).\n1. The Agent.run_stream() method is used to start a streamed run, this method returns a context manager so the connection can be closed when the stream completes.\n1. Each item yield by StreamedRunResult.stream_text() is the complete text response, extended as new data is received.\n\n*(This example is complete, it can be run \"as is\" — you'll need to add `asyncio.run(main())` to run `main`)*\n\nWe can also stream text as deltas rather than the entire text in each item:\n\nstreamed_delta_hello_world.py\n\n```python\nfrom pydantic_ai import Agent\n\nagent = Agent('google-gla:gemini-2.5-flash')\n\n\nasync def main():\n    async with agent.run_stream('Where does \"hello world\" come from?') as result:\n        async for message in result.stream_text(delta=True):  # (1)!\n            print(message)\n            #> The first known\n            #> use of \"hello,\n            #> world\" was in\n            #> a 1974 textbook\n            #> about the C\n            #> programming language.\n\n```\n\n1. stream_text will error if the response is not text.\n\n*(This example is complete, it can be run \"as is\" — you'll need to add `asyncio.run(main())` to run `main`)*\n\nOutput message not included in `messages`\n\nThe final output message will **NOT** be added to result messages if you use `.stream_text(delta=True)`, see [Messages and chat history](../message-history/) for more information.\n\n### Streaming Structured Output\n\nHere's an example of streaming a user profile as it's built:\n\n[Learn about Gateway](../gateway) streamed_user_profile.py\n\n```python\nfrom datetime import date\n\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic_ai import Agent\n\n\nclass UserProfile(TypedDict):\n    name: str\n    dob: NotRequired[date]\n    bio: NotRequired[str]\n\n\nagent = Agent(\n    'gateway/openai:gpt-5',\n    output_type=UserProfile,\n    system_prompt='Extract a user profile from the input',\n)\n\n\nasync def main():\n    user_input = 'My name is Ben, I was born on January 28th 1990, I like the chain the dog and the pyramid.'\n    async with agent.run_stream(user_input) as result:\n        async for profile in result.stream_output():\n            print(profile)\n            #> {'name': 'Ben'}\n            #> {'name': 'Ben'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the '}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyr'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyramid'}\n\n```\n\nstreamed_user_profile.py\n\n```python\nfrom datetime import date\n\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic_ai import Agent\n\n\nclass UserProfile(TypedDict):\n    name: str\n    dob: NotRequired[date]\n    bio: NotRequired[str]\n\n\nagent = Agent(\n    'openai:gpt-5',\n    output_type=UserProfile,\n    system_prompt='Extract a user profile from the input',\n)\n\n\nasync def main():\n    user_input = 'My name is Ben, I was born on January 28th 1990, I like the chain the dog and the pyramid.'\n    async with agent.run_stream(user_input) as result:\n        async for profile in result.stream_output():\n            print(profile)\n            #> {'name': 'Ben'}\n            #> {'name': 'Ben'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the '}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyr'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyramid'}\n\n```\n\n*(This example is complete, it can be run \"as is\" — you'll need to add `asyncio.run(main())` to run `main`)*\n\nAs setting an `output_type` uses the [Tool Output](#tool-output) mode by default, this will only work if the model supports streaming tool arguments. For models that don't, like Gemini, try [Native Output](#native-output) or [Prompted Output](#prompted-output) instead.\n\n### Streaming Model Responses\n\nIf you want fine-grained control of validation, you can use the following pattern to get the entire partial ModelResponse:\n\n[Learn about Gateway](../gateway) streamed_user_profile.py\n\n```python\nfrom datetime import date\n\nfrom pydantic import ValidationError\nfrom typing_extensions import TypedDict\n\nfrom pydantic_ai import Agent\n\n\nclass UserProfile(TypedDict, total=False):\n    name: str\n    dob: date\n    bio: str\n\n\nagent = Agent('gateway/openai:gpt-5', output_type=UserProfile)\n\n\nasync def main():\n    user_input = 'My name is Ben, I was born on January 28th 1990, I like the chain the dog and the pyramid.'\n    async with agent.run_stream(user_input) as result:\n        async for message, last in result.stream_responses(debounce_by=0.01):  # (1)!\n            try:\n                profile = await result.validate_response_output(  # (2)!\n                    message,\n                    allow_partial=not last,\n                )\n            except ValidationError:\n                continue\n            print(profile)\n            #> {'name': 'Ben'}\n            #> {'name': 'Ben'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the '}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyr'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyramid'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyramid'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyramid'}\n\n```\n\n1. stream_responses streams the data as ModelResponse objects, thus iteration can't fail with a `ValidationError`.\n1. validate_response_output validates the data, `allow_partial=True` enables pydantic's experimental_allow_partial flag on TypeAdapter.\n\nstreamed_user_profile.py\n\n```python\nfrom datetime import date\n\nfrom pydantic import ValidationError\nfrom typing_extensions import TypedDict\n\nfrom pydantic_ai import Agent\n\n\nclass UserProfile(TypedDict, total=False):\n    name: str\n    dob: date\n    bio: str\n\n\nagent = Agent('openai:gpt-5', output_type=UserProfile)\n\n\nasync def main():\n    user_input = 'My name is Ben, I was born on January 28th 1990, I like the chain the dog and the pyramid.'\n    async with agent.run_stream(user_input) as result:\n        async for message, last in result.stream_responses(debounce_by=0.01):  # (1)!\n            try:\n                profile = await result.validate_response_output(  # (2)!\n                    message,\n                    allow_partial=not last,\n                )\n            except ValidationError:\n                continue\n            print(profile)\n            #> {'name': 'Ben'}\n            #> {'name': 'Ben'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the '}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyr'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyramid'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyramid'}\n            #> {'name': 'Ben', 'dob': date(1990, 1, 28), 'bio': 'Likes the chain the dog and the pyramid'}\n\n```\n\n1. stream_responses streams the data as ModelResponse objects, thus iteration can't fail with a `ValidationError`.\n1. validate_response_output validates the data, `allow_partial=True` enables pydantic's experimental_allow_partial flag on TypeAdapter.\n\n*(This example is complete, it can be run \"as is\" — you'll need to add `asyncio.run(main())` to run `main`)*\n\n## Examples\n\nThe following examples demonstrate how to use streamed responses in Pydantic AI:\n\n- [Stream markdown](../examples/stream-markdown/)\n- [Stream Whales](../examples/stream-whales/)",
  "content_length": 61806
}