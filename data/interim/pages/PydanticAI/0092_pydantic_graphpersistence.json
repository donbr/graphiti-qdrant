{
  "title": "`pydantic_graph.persistence`",
  "source_url": null,
  "content": "### SnapshotStatus\n\n```python\nSnapshotStatus = Literal[\n    \"created\", \"pending\", \"running\", \"success\", \"error\"\n]\n\n```\n\nThe status of a snapshot.\n\n- `'created'`: The snapshot has been created but not yet run.\n- `'pending'`: The snapshot has been retrieved with load_next but not yet run.\n- `'running'`: The snapshot is currently running.\n- `'success'`: The snapshot has been run successfully.\n- `'error'`: The snapshot has been run but an error occurred.\n\n### NodeSnapshot\n\nBases: `Generic[StateT, RunEndT]`\n\nHistory step describing the execution of a node in a graph.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\n@dataclass(kw_only=True)\nclass NodeSnapshot(Generic[StateT, RunEndT]):\n    \"\"\"History step describing the execution of a node in a graph.\"\"\"\n\n    state: StateT\n    \"\"\"The state of the graph before the node is run.\"\"\"\n    node: Annotated[BaseNode[StateT, Any, RunEndT], _utils.CustomNodeSchema()]\n    \"\"\"The node to run next.\"\"\"\n    start_ts: datetime | None = None\n    \"\"\"The timestamp when the node started running, `None` until the run starts.\"\"\"\n    duration: float | None = None\n    \"\"\"The duration of the node run in seconds, if the node has been run.\"\"\"\n    status: SnapshotStatus = 'created'\n    \"\"\"The status of the snapshot.\"\"\"\n    kind: Literal['node'] = 'node'\n    \"\"\"The kind of history step, can be used as a discriminator when deserializing history.\"\"\"\n\n    id: str = UNSET_SNAPSHOT_ID\n    \"\"\"Unique ID of the snapshot.\"\"\"\n\n    def __post_init__(self) -> None:\n        if self.id == UNSET_SNAPSHOT_ID:\n            self.id = self.node.get_snapshot_id()\n\n```\n\n#### state\n\n```python\nstate: StateT\n\n```\n\nThe state of the graph before the node is run.\n\n#### node\n\n```python\nnode: Annotated[\n    BaseNode[StateT, Any, RunEndT], CustomNodeSchema()\n]\n\n```\n\nThe node to run next.\n\n#### start_ts\n\n```python\nstart_ts: datetime | None = None\n\n```\n\nThe timestamp when the node started running, `None` until the run starts.\n\n#### duration\n\n```python\nduration: float | None = None\n\n```\n\nThe duration of the node run in seconds, if the node has been run.\n\n#### status\n\n```python\nstatus: SnapshotStatus = 'created'\n\n```\n\nThe status of the snapshot.\n\n#### kind\n\n```python\nkind: Literal['node'] = 'node'\n\n```\n\nThe kind of history step, can be used as a discriminator when deserializing history.\n\n#### id\n\n```python\nid: str = UNSET_SNAPSHOT_ID\n\n```\n\nUnique ID of the snapshot.\n\n### EndSnapshot\n\nBases: `Generic[StateT, RunEndT]`\n\nHistory step describing the end of a graph run.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\n@dataclass(kw_only=True)\nclass EndSnapshot(Generic[StateT, RunEndT]):\n    \"\"\"History step describing the end of a graph run.\"\"\"\n\n    state: StateT\n    \"\"\"The state of the graph at the end of the run.\"\"\"\n    result: End[RunEndT]\n    \"\"\"The result of the graph run.\"\"\"\n    ts: datetime = field(default_factory=_utils.now_utc)\n    \"\"\"The timestamp when the graph run ended.\"\"\"\n    kind: Literal['end'] = 'end'\n    \"\"\"The kind of history step, can be used as a discriminator when deserializing history.\"\"\"\n\n    id: str = UNSET_SNAPSHOT_ID\n    \"\"\"Unique ID of the snapshot.\"\"\"\n\n    def __post_init__(self) -> None:\n        if self.id == UNSET_SNAPSHOT_ID:\n            self.id = self.node.get_snapshot_id()\n\n    @property\n    def node(self) -> End[RunEndT]:\n        \"\"\"Shim to get the [`result`][pydantic_graph.persistence.EndSnapshot.result].\n\n        Useful to allow `[snapshot.node for snapshot in persistence.history]`.\n        \"\"\"\n        return self.result\n\n```\n\n#### state\n\n```python\nstate: StateT\n\n```\n\nThe state of the graph at the end of the run.\n\n#### result\n\n```python\nresult: End[RunEndT]\n\n```\n\nThe result of the graph run.\n\n#### ts\n\n```python\nts: datetime = field(default_factory=now_utc)\n\n```\n\nThe timestamp when the graph run ended.\n\n#### kind\n\n```python\nkind: Literal['end'] = 'end'\n\n```\n\nThe kind of history step, can be used as a discriminator when deserializing history.\n\n#### id\n\n```python\nid: str = UNSET_SNAPSHOT_ID\n\n```\n\nUnique ID of the snapshot.\n\n#### node\n\n```python\nnode: End[RunEndT]\n\n```\n\nShim to get the result.\n\nUseful to allow `[snapshot.node for snapshot in persistence.history]`.\n\n### Snapshot\n\n```python\nSnapshot = (\n    NodeSnapshot[StateT, RunEndT]\n    | EndSnapshot[StateT, RunEndT]\n)\n\n```\n\nA step in the history of a graph run.\n\nGraph.run returns a list of these steps describing the execution of the graph, together with the run return value.\n\n### BaseStatePersistence\n\nBases: `ABC`, `Generic[StateT, RunEndT]`\n\nAbstract base class for storing the state of a graph run.\n\nEach instance of a `BaseStatePersistence` subclass should be used for a single graph run.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\nclass BaseStatePersistence(ABC, Generic[StateT, RunEndT]):\n    \"\"\"Abstract base class for storing the state of a graph run.\n\n    Each instance of a `BaseStatePersistence` subclass should be used for a single graph run.\n    \"\"\"\n\n    @abstractmethod\n    async def snapshot_node(self, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]) -> None:\n        \"\"\"Snapshot the state of a graph, when the next step is to run a node.\n\n        This method should add a [`NodeSnapshot`][pydantic_graph.persistence.NodeSnapshot] to persistence.\n\n        Args:\n            state: The state of the graph.\n            next_node: The next node to run.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def snapshot_node_if_new(\n        self, snapshot_id: str, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]\n    ) -> None:\n        \"\"\"Snapshot the state of a graph if the snapshot ID doesn't already exist in persistence.\n\n        This method will generally call [`snapshot_node`][pydantic_graph.persistence.BaseStatePersistence.snapshot_node]\n        but should do so in an atomic way.\n\n        Args:\n            snapshot_id: The ID of the snapshot to check.\n            state: The state of the graph.\n            next_node: The next node to run.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def snapshot_end(self, state: StateT, end: End[RunEndT]) -> None:\n        \"\"\"Snapshot the state of a graph when the graph has ended.\n\n        This method should add an [`EndSnapshot`][pydantic_graph.persistence.EndSnapshot] to persistence.\n\n        Args:\n            state: The state of the graph.\n            end: data from the end of the run.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def record_run(self, snapshot_id: str) -> AbstractAsyncContextManager[None]:\n        \"\"\"Record the run of the node, or error if the node is already running.\n\n        Args:\n            snapshot_id: The ID of the snapshot to record.\n\n        Raises:\n            GraphNodeRunningError: if the node status it not `'created'` or `'pending'`.\n            LookupError: if the snapshot ID is not found in persistence.\n\n        Returns:\n            An async context manager that records the run of the node.\n\n        In particular this should set:\n\n        - [`NodeSnapshot.status`][pydantic_graph.persistence.NodeSnapshot.status] to `'running'` and\n          [`NodeSnapshot.start_ts`][pydantic_graph.persistence.NodeSnapshot.start_ts] when the run starts.\n        - [`NodeSnapshot.status`][pydantic_graph.persistence.NodeSnapshot.status] to `'success'` or `'error'` and\n          [`NodeSnapshot.duration`][pydantic_graph.persistence.NodeSnapshot.duration] when the run finishes.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def load_next(self) -> NodeSnapshot[StateT, RunEndT] | None:\n        \"\"\"Retrieve a node snapshot with status `'created`' and set its status to `'pending'`.\n\n        This is used by [`Graph.iter_from_persistence`][pydantic_graph.graph.Graph.iter_from_persistence]\n        to get the next node to run.\n\n        Returns: The snapshot, or `None` if no snapshot with status `'created`' exists.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def load_all(self) -> list[Snapshot[StateT, RunEndT]]:\n        \"\"\"Load the entire history of snapshots.\n\n        `load_all` is not used by pydantic-graph itself, instead it's provided to make it convenient to\n        get all [snapshots][pydantic_graph.persistence.Snapshot] from persistence.\n\n        Returns: The list of snapshots.\n        \"\"\"\n        raise NotImplementedError\n\n    def set_graph_types(self, graph: Graph[StateT, Any, RunEndT]) -> None:\n        \"\"\"Set the types of the state and run end from a graph.\n\n        You generally won't need to customise this method, instead implement\n        [`set_types`][pydantic_graph.persistence.BaseStatePersistence.set_types] and\n        [`should_set_types`][pydantic_graph.persistence.BaseStatePersistence.should_set_types].\n        \"\"\"\n        if self.should_set_types():\n            with _utils.set_nodes_type_context(graph.get_nodes()):\n                self.set_types(*graph.inferred_types)\n\n    def should_set_types(self) -> bool:\n        \"\"\"Whether types need to be set.\n\n        Implementations should override this method to return `True` when types have not been set if they are needed.\n        \"\"\"\n        return False\n\n    def set_types(self, state_type: type[StateT], run_end_type: type[RunEndT]) -> None:\n        \"\"\"Set the types of the state and run end.\n\n        This can be used to create [type adapters][pydantic.TypeAdapter] for serializing and deserializing snapshots,\n        e.g. with [`build_snapshot_list_type_adapter`][pydantic_graph.persistence.build_snapshot_list_type_adapter].\n\n        Args:\n            state_type: The state type.\n            run_end_type: The run end type.\n        \"\"\"\n        pass\n\n```\n\n#### snapshot_node\n\n```python\nsnapshot_node(\n    state: StateT, next_node: BaseNode[StateT, Any, RunEndT]\n) -> None\n\n```\n\nSnapshot the state of a graph, when the next step is to run a node.\n\nThis method should add a NodeSnapshot to persistence.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `state` | `StateT` | The state of the graph. | *required* | | `next_node` | `BaseNode[StateT, Any, RunEndT]` | The next node to run. | *required* |\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\n@abstractmethod\nasync def snapshot_node(self, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]) -> None:\n    \"\"\"Snapshot the state of a graph, when the next step is to run a node.\n\n    This method should add a [`NodeSnapshot`][pydantic_graph.persistence.NodeSnapshot] to persistence.\n\n    Args:\n        state: The state of the graph.\n        next_node: The next node to run.\n    \"\"\"\n    raise NotImplementedError\n\n```\n\n#### snapshot_node_if_new\n\n```python\nsnapshot_node_if_new(\n    snapshot_id: str,\n    state: StateT,\n    next_node: BaseNode[StateT, Any, RunEndT],\n) -> None\n\n```\n\nSnapshot the state of a graph if the snapshot ID doesn't already exist in persistence.\n\nThis method will generally call snapshot_node but should do so in an atomic way.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `snapshot_id` | `str` | The ID of the snapshot to check. | *required* | | `state` | `StateT` | The state of the graph. | *required* | | `next_node` | `BaseNode[StateT, Any, RunEndT]` | The next node to run. | *required* |\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\n@abstractmethod\nasync def snapshot_node_if_new(\n    self, snapshot_id: str, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]\n) -> None:\n    \"\"\"Snapshot the state of a graph if the snapshot ID doesn't already exist in persistence.\n\n    This method will generally call [`snapshot_node`][pydantic_graph.persistence.BaseStatePersistence.snapshot_node]\n    but should do so in an atomic way.\n\n    Args:\n        snapshot_id: The ID of the snapshot to check.\n        state: The state of the graph.\n        next_node: The next node to run.\n    \"\"\"\n    raise NotImplementedError\n\n```\n\n#### snapshot_end\n\n```python\nsnapshot_end(state: StateT, end: End[RunEndT]) -> None\n\n```\n\nSnapshot the state of a graph when the graph has ended.\n\nThis method should add an EndSnapshot to persistence.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `state` | `StateT` | The state of the graph. | *required* | | `end` | `End[RunEndT]` | data from the end of the run. | *required* |\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\n@abstractmethod\nasync def snapshot_end(self, state: StateT, end: End[RunEndT]) -> None:\n    \"\"\"Snapshot the state of a graph when the graph has ended.\n\n    This method should add an [`EndSnapshot`][pydantic_graph.persistence.EndSnapshot] to persistence.\n\n    Args:\n        state: The state of the graph.\n        end: data from the end of the run.\n    \"\"\"\n    raise NotImplementedError\n\n```\n\n#### record_run\n\n```python\nrecord_run(\n    snapshot_id: str,\n) -> AbstractAsyncContextManager[None]\n\n```\n\nRecord the run of the node, or error if the node is already running.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `snapshot_id` | `str` | The ID of the snapshot to record. | *required* |\n\nRaises:\n\n| Type | Description | | --- | --- | | `GraphNodeRunningError` | if the node status it not 'created' or 'pending'. | | `LookupError` | if the snapshot ID is not found in persistence. |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AbstractAsyncContextManager[None]` | An async context manager that records the run of the node. |\n\nIn particular this should set:\n\n- NodeSnapshot.status to `'running'` and NodeSnapshot.start_ts when the run starts.\n- NodeSnapshot.status to `'success'` or `'error'` and NodeSnapshot.duration when the run finishes.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\n@abstractmethod\ndef record_run(self, snapshot_id: str) -> AbstractAsyncContextManager[None]:\n    \"\"\"Record the run of the node, or error if the node is already running.\n\n    Args:\n        snapshot_id: The ID of the snapshot to record.\n\n    Raises:\n        GraphNodeRunningError: if the node status it not `'created'` or `'pending'`.\n        LookupError: if the snapshot ID is not found in persistence.\n\n    Returns:\n        An async context manager that records the run of the node.\n\n    In particular this should set:\n\n    - [`NodeSnapshot.status`][pydantic_graph.persistence.NodeSnapshot.status] to `'running'` and\n      [`NodeSnapshot.start_ts`][pydantic_graph.persistence.NodeSnapshot.start_ts] when the run starts.\n    - [`NodeSnapshot.status`][pydantic_graph.persistence.NodeSnapshot.status] to `'success'` or `'error'` and\n      [`NodeSnapshot.duration`][pydantic_graph.persistence.NodeSnapshot.duration] when the run finishes.\n    \"\"\"\n    raise NotImplementedError\n\n```\n\n#### load_next\n\n```python\nload_next() -> NodeSnapshot[StateT, RunEndT] | None\n\n```\n\nRetrieve a node snapshot with status `'created`' and set its status to `'pending'`.\n\nThis is used by Graph.iter_from_persistence to get the next node to run.\n\nReturns: The snapshot, or `None` if no snapshot with status `'created`' exists.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\n@abstractmethod\nasync def load_next(self) -> NodeSnapshot[StateT, RunEndT] | None:\n    \"\"\"Retrieve a node snapshot with status `'created`' and set its status to `'pending'`.\n\n    This is used by [`Graph.iter_from_persistence`][pydantic_graph.graph.Graph.iter_from_persistence]\n    to get the next node to run.\n\n    Returns: The snapshot, or `None` if no snapshot with status `'created`' exists.\n    \"\"\"\n    raise NotImplementedError\n\n```\n\n#### load_all\n\n```python\nload_all() -> list[Snapshot[StateT, RunEndT]]\n\n```\n\nLoad the entire history of snapshots.\n\n`load_all` is not used by pydantic-graph itself, instead it's provided to make it convenient to get all snapshots from persistence.\n\nReturns: The list of snapshots.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\n@abstractmethod\nasync def load_all(self) -> list[Snapshot[StateT, RunEndT]]:\n    \"\"\"Load the entire history of snapshots.\n\n    `load_all` is not used by pydantic-graph itself, instead it's provided to make it convenient to\n    get all [snapshots][pydantic_graph.persistence.Snapshot] from persistence.\n\n    Returns: The list of snapshots.\n    \"\"\"\n    raise NotImplementedError\n\n```\n\n#### set_graph_types\n\n```python\nset_graph_types(graph: Graph[StateT, Any, RunEndT]) -> None\n\n```\n\nSet the types of the state and run end from a graph.\n\nYou generally won't need to customise this method, instead implement set_types and should_set_types.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\ndef set_graph_types(self, graph: Graph[StateT, Any, RunEndT]) -> None:\n    \"\"\"Set the types of the state and run end from a graph.\n\n    You generally won't need to customise this method, instead implement\n    [`set_types`][pydantic_graph.persistence.BaseStatePersistence.set_types] and\n    [`should_set_types`][pydantic_graph.persistence.BaseStatePersistence.should_set_types].\n    \"\"\"\n    if self.should_set_types():\n        with _utils.set_nodes_type_context(graph.get_nodes()):\n            self.set_types(*graph.inferred_types)\n\n```\n\n#### should_set_types\n\n```python\nshould_set_types() -> bool\n\n```\n\nWhether types need to be set.\n\nImplementations should override this method to return `True` when types have not been set if they are needed.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\ndef should_set_types(self) -> bool:\n    \"\"\"Whether types need to be set.\n\n    Implementations should override this method to return `True` when types have not been set if they are needed.\n    \"\"\"\n    return False\n\n```\n\n#### set_types\n\n```python\nset_types(\n    state_type: type[StateT], run_end_type: type[RunEndT]\n) -> None\n\n```\n\nSet the types of the state and run end.\n\nThis can be used to create type adapters for serializing and deserializing snapshots, e.g. with build_snapshot_list_type_adapter.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `state_type` | `type[StateT]` | The state type. | *required* | | `run_end_type` | `type[RunEndT]` | The run end type. | *required* |\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\ndef set_types(self, state_type: type[StateT], run_end_type: type[RunEndT]) -> None:\n    \"\"\"Set the types of the state and run end.\n\n    This can be used to create [type adapters][pydantic.TypeAdapter] for serializing and deserializing snapshots,\n    e.g. with [`build_snapshot_list_type_adapter`][pydantic_graph.persistence.build_snapshot_list_type_adapter].\n\n    Args:\n        state_type: The state type.\n        run_end_type: The run end type.\n    \"\"\"\n    pass\n\n```\n\n### build_snapshot_list_type_adapter\n\n```python\nbuild_snapshot_list_type_adapter(\n    state_t: type[StateT], run_end_t: type[RunEndT]\n) -> TypeAdapter[list[Snapshot[StateT, RunEndT]]]\n\n```\n\nBuild a type adapter for a list of snapshots.\n\nThis method should be called from within set_types where context variables will be set such that Pydantic can create a schema for NodeSnapshot.node.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/__init__.py`\n\n```python\ndef build_snapshot_list_type_adapter(\n    state_t: type[StateT], run_end_t: type[RunEndT]\n) -> pydantic.TypeAdapter[list[Snapshot[StateT, RunEndT]]]:\n    \"\"\"Build a type adapter for a list of snapshots.\n\n    This method should be called from within\n    [`set_types`][pydantic_graph.persistence.BaseStatePersistence.set_types]\n    where context variables will be set such that Pydantic can create a schema for\n    [`NodeSnapshot.node`][pydantic_graph.persistence.NodeSnapshot.node].\n    \"\"\"\n    return pydantic.TypeAdapter(list[Annotated[Snapshot[state_t, run_end_t], pydantic.Discriminator('kind')]])\n\n```\n\nIn memory state persistence.\n\nThis module provides simple in memory state persistence for graphs.\n\n### SimpleStatePersistence\n\nBases: `BaseStatePersistence[StateT, RunEndT]`\n\nSimple in memory state persistence that just hold the latest snapshot.\n\nIf no state persistence implementation is provided when running a graph, this is used by default.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/in_mem.py`\n\n```python\n@dataclass\nclass SimpleStatePersistence(BaseStatePersistence[StateT, RunEndT]):\n    \"\"\"Simple in memory state persistence that just hold the latest snapshot.\n\n    If no state persistence implementation is provided when running a graph, this is used by default.\n    \"\"\"\n\n    last_snapshot: Snapshot[StateT, RunEndT] | None = None\n    \"\"\"The last snapshot.\"\"\"\n\n    async def snapshot_node(self, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]) -> None:\n        self.last_snapshot = NodeSnapshot(state=state, node=next_node)\n\n    async def snapshot_node_if_new(\n        self, snapshot_id: str, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]\n    ) -> None:\n        if self.last_snapshot and self.last_snapshot.id == snapshot_id:\n            return  # pragma: no cover\n        else:\n            await self.snapshot_node(state, next_node)\n\n    async def snapshot_end(self, state: StateT, end: End[RunEndT]) -> None:\n        self.last_snapshot = EndSnapshot(state=state, result=end)\n\n    @asynccontextmanager\n    async def record_run(self, snapshot_id: str) -> AsyncIterator[None]:\n        if self.last_snapshot is None or snapshot_id != self.last_snapshot.id:\n            raise LookupError(f'No snapshot found with id={snapshot_id!r}')\n\n        assert isinstance(self.last_snapshot, NodeSnapshot), 'Only NodeSnapshot can be recorded'\n        exceptions.GraphNodeStatusError.check(self.last_snapshot.status)\n        self.last_snapshot.status = 'running'\n        self.last_snapshot.start_ts = _utils.now_utc()\n\n        start = perf_counter()\n        try:\n            yield\n        except Exception:  # pragma: no cover\n            self.last_snapshot.duration = perf_counter() - start\n            self.last_snapshot.status = 'error'\n            raise\n        else:\n            self.last_snapshot.duration = perf_counter() - start\n            self.last_snapshot.status = 'success'\n\n    async def load_next(self) -> NodeSnapshot[StateT, RunEndT] | None:\n        if isinstance(self.last_snapshot, NodeSnapshot) and self.last_snapshot.status == 'created':\n            self.last_snapshot.status = 'pending'\n            return copy.deepcopy(self.last_snapshot)\n\n    async def load_all(self) -> list[Snapshot[StateT, RunEndT]]:\n        raise NotImplementedError('load is not supported for SimpleStatePersistence')\n\n```\n\n#### last_snapshot\n\n```python\nlast_snapshot: Snapshot[StateT, RunEndT] | None = None\n\n```\n\nThe last snapshot.\n\n### FullStatePersistence\n\nBases: `BaseStatePersistence[StateT, RunEndT]`\n\nIn memory state persistence that hold a list of snapshots.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/in_mem.py`\n\n```python\n@dataclass\nclass FullStatePersistence(BaseStatePersistence[StateT, RunEndT]):\n    \"\"\"In memory state persistence that hold a list of snapshots.\"\"\"\n\n    deep_copy: bool = True\n    \"\"\"Whether to deep copy the state and nodes when storing them.\n\n    Defaults to `True` so even if nodes or state are modified after the snapshot is taken,\n    the persistence history will record the value at the time of the snapshot.\n    \"\"\"\n    history: list[Snapshot[StateT, RunEndT]] = field(default_factory=list)\n    \"\"\"List of snapshots taken during the graph run.\"\"\"\n    _snapshots_type_adapter: pydantic.TypeAdapter[list[Snapshot[StateT, RunEndT]]] | None = field(\n        default=None, init=False, repr=False\n    )\n\n    async def snapshot_node(self, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]) -> None:\n        snapshot = NodeSnapshot(\n            state=self._prep_state(state),\n            node=next_node.deep_copy() if self.deep_copy else next_node,\n        )\n        self.history.append(snapshot)\n\n    async def snapshot_node_if_new(\n        self, snapshot_id: str, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]\n    ) -> None:\n        if not any(s.id == snapshot_id for s in self.history):\n            await self.snapshot_node(state, next_node)\n\n    async def snapshot_end(self, state: StateT, end: End[RunEndT]) -> None:\n        snapshot = EndSnapshot(\n            state=self._prep_state(state),\n            result=end.deep_copy_data() if self.deep_copy else end,\n        )\n        self.history.append(snapshot)\n\n    @asynccontextmanager\n    async def record_run(self, snapshot_id: str) -> AsyncIterator[None]:\n        try:\n            snapshot = next(s for s in self.history if s.id == snapshot_id)\n        except StopIteration as e:\n            raise LookupError(f'No snapshot found with id={snapshot_id!r}') from e\n\n        assert isinstance(snapshot, NodeSnapshot), 'Only NodeSnapshot can be recorded'\n        exceptions.GraphNodeStatusError.check(snapshot.status)\n        snapshot.status = 'running'\n        snapshot.start_ts = _utils.now_utc()\n        start = perf_counter()\n        try:\n            yield\n        except Exception:\n            snapshot.duration = perf_counter() - start\n            snapshot.status = 'error'\n            raise\n        else:\n            snapshot.duration = perf_counter() - start\n            snapshot.status = 'success'\n\n    async def load_next(self) -> NodeSnapshot[StateT, RunEndT] | None:\n        if snapshot := next((s for s in self.history if isinstance(s, NodeSnapshot) and s.status == 'created'), None):\n            snapshot.status = 'pending'\n            return copy.deepcopy(snapshot)\n\n    async def load_all(self) -> list[Snapshot[StateT, RunEndT]]:\n        return self.history\n\n    def should_set_types(self) -> bool:\n        return self._snapshots_type_adapter is None\n\n    def set_types(self, state_type: type[StateT], run_end_type: type[RunEndT]) -> None:\n        self._snapshots_type_adapter = build_snapshot_list_type_adapter(state_type, run_end_type)\n\n    def dump_json(self, *, indent: int | None = None) -> bytes:\n        \"\"\"Dump the history to JSON bytes.\"\"\"\n        assert self._snapshots_type_adapter is not None, 'type adapter must be set to use `dump_json`'\n        return self._snapshots_type_adapter.dump_json(self.history, indent=indent)\n\n    def load_json(self, json_data: str | bytes | bytearray) -> None:\n        \"\"\"Load the history from JSON.\"\"\"\n        assert self._snapshots_type_adapter is not None, 'type adapter must be set to use `load_json`'\n        self.history = self._snapshots_type_adapter.validate_json(json_data)\n\n    def _prep_state(self, state: StateT) -> StateT:\n        \"\"\"Prepare state for snapshot, uses [`copy.deepcopy`][copy.deepcopy] by default.\"\"\"\n        if not self.deep_copy or state is None:\n            return state\n        else:\n            return copy.deepcopy(state)\n\n```\n\n#### deep_copy\n\n```python\ndeep_copy: bool = True\n\n```\n\nWhether to deep copy the state and nodes when storing them.\n\nDefaults to `True` so even if nodes or state are modified after the snapshot is taken, the persistence history will record the value at the time of the snapshot.\n\n#### history\n\n```python\nhistory: list[Snapshot[StateT, RunEndT]] = field(\n    default_factory=list\n)\n\n```\n\nList of snapshots taken during the graph run.\n\n#### dump_json\n\n```python\ndump_json(*, indent: int | None = None) -> bytes\n\n```\n\nDump the history to JSON bytes.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/in_mem.py`\n\n```python\ndef dump_json(self, *, indent: int | None = None) -> bytes:\n    \"\"\"Dump the history to JSON bytes.\"\"\"\n    assert self._snapshots_type_adapter is not None, 'type adapter must be set to use `dump_json`'\n    return self._snapshots_type_adapter.dump_json(self.history, indent=indent)\n\n```\n\n#### load_json\n\n```python\nload_json(json_data: str | bytes | bytearray) -> None\n\n```\n\nLoad the history from JSON.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/in_mem.py`\n\n```python\ndef load_json(self, json_data: str | bytes | bytearray) -> None:\n    \"\"\"Load the history from JSON.\"\"\"\n    assert self._snapshots_type_adapter is not None, 'type adapter must be set to use `load_json`'\n    self.history = self._snapshots_type_adapter.validate_json(json_data)\n\n```\n\n### FileStatePersistence\n\nBases: `BaseStatePersistence[StateT, RunEndT]`\n\nFile based state persistence that hold graph run state in a JSON file.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/file.py`\n\n````python\n@dataclass\nclass FileStatePersistence(BaseStatePersistence[StateT, RunEndT]):\n    \"\"\"File based state persistence that hold graph run state in a JSON file.\"\"\"\n\n    json_file: Path\n    \"\"\"Path to the JSON file where the snapshots are stored.\n\n    You should use a different file for each graph run, but a single file should be reused for multiple\n    steps of the same run.\n\n    For example if you have a run ID of the form `run_123abc`, you might create a `FileStatePersistence` thus:\n\n    ```py\n    from pathlib import Path\n\n    from pydantic_graph import FullStatePersistence\n\n    run_id = 'run_123abc'\n    persistence = FullStatePersistence(Path('runs') / f'{run_id}.json')\n    ```\n    \"\"\"\n    _snapshots_type_adapter: pydantic.TypeAdapter[list[Snapshot[StateT, RunEndT]]] | None = field(\n        default=None, init=False, repr=False\n    )\n\n    async def snapshot_node(self, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]) -> None:\n        await self._append_save(NodeSnapshot(state=state, node=next_node))\n\n    async def snapshot_node_if_new(\n        self, snapshot_id: str, state: StateT, next_node: BaseNode[StateT, Any, RunEndT]\n    ) -> None:\n        async with self._lock():\n            snapshots = await self.load_all()\n            if not any(s.id == snapshot_id for s in snapshots):  # pragma: no branch\n                await self._append_save(NodeSnapshot(state=state, node=next_node), lock=False)\n\n    async def snapshot_end(self, state: StateT, end: End[RunEndT]) -> None:\n        await self._append_save(EndSnapshot(state=state, result=end))\n\n    @asynccontextmanager\n    async def record_run(self, snapshot_id: str) -> AsyncIterator[None]:\n        async with self._lock():\n            snapshots = await self.load_all()\n            try:\n                snapshot = next(s for s in snapshots if s.id == snapshot_id)\n            except StopIteration as e:\n                raise LookupError(f'No snapshot found with id={snapshot_id!r}') from e\n\n            assert isinstance(snapshot, NodeSnapshot), 'Only NodeSnapshot can be recorded'\n            exceptions.GraphNodeStatusError.check(snapshot.status)\n            snapshot.status = 'running'\n            snapshot.start_ts = _utils.now_utc()\n            await self._save(snapshots)\n\n        start = perf_counter()\n        try:\n            yield\n        except Exception:\n            duration = perf_counter() - start\n            async with self._lock():\n                await _graph_utils.run_in_executor(self._after_run_sync, snapshot_id, duration, 'error')\n            raise\n        else:\n            snapshot.duration = perf_counter() - start\n            async with self._lock():\n                await _graph_utils.run_in_executor(self._after_run_sync, snapshot_id, snapshot.duration, 'success')\n\n    async def load_next(self) -> NodeSnapshot[StateT, RunEndT] | None:\n        async with self._lock():\n            snapshots = await self.load_all()\n            if snapshot := next((s for s in snapshots if isinstance(s, NodeSnapshot) and s.status == 'created'), None):\n                snapshot.status = 'pending'\n                await self._save(snapshots)\n                return snapshot\n\n    def should_set_types(self) -> bool:\n        \"\"\"Whether types need to be set.\"\"\"\n        return self._snapshots_type_adapter is None\n\n    def set_types(self, state_type: type[StateT], run_end_type: type[RunEndT]) -> None:\n        self._snapshots_type_adapter = build_snapshot_list_type_adapter(state_type, run_end_type)\n\n    async def load_all(self) -> list[Snapshot[StateT, RunEndT]]:\n        return await _graph_utils.run_in_executor(self._load_sync)\n\n    def _load_sync(self) -> list[Snapshot[StateT, RunEndT]]:\n        assert self._snapshots_type_adapter is not None, 'snapshots type adapter must be set'\n        try:\n            content = self.json_file.read_bytes()\n        except FileNotFoundError:\n            return []\n        else:\n            return self._snapshots_type_adapter.validate_json(content)\n\n    def _after_run_sync(self, snapshot_id: str, duration: float, status: SnapshotStatus) -> None:\n        snapshots = self._load_sync()\n        snapshot = next(s for s in snapshots if s.id == snapshot_id)\n        assert isinstance(snapshot, NodeSnapshot), 'Only NodeSnapshot can be recorded'\n        snapshot.duration = duration\n        snapshot.status = status\n        self._save_sync(snapshots)\n\n    async def _save(self, snapshots: list[Snapshot[StateT, RunEndT]]) -> None:\n        await _graph_utils.run_in_executor(self._save_sync, snapshots)\n\n    def _save_sync(self, snapshots: list[Snapshot[StateT, RunEndT]]) -> None:\n        assert self._snapshots_type_adapter is not None, 'snapshots type adapter must be set'\n        self.json_file.write_bytes(self._snapshots_type_adapter.dump_json(snapshots, indent=2))\n\n    async def _append_save(self, snapshot: Snapshot[StateT, RunEndT], *, lock: bool = True) -> None:\n        assert self._snapshots_type_adapter is not None, 'snapshots type adapter must be set'\n        async with AsyncExitStack() as stack:\n            if lock:\n                await stack.enter_async_context(self._lock())\n            snapshots = await self.load_all()\n            snapshots.append(snapshot)\n            await self._save(snapshots)\n\n    @asynccontextmanager\n    async def _lock(self, *, timeout: float = 1.0) -> AsyncIterator[None]:\n        \"\"\"Lock a file by checking and writing a `.pydantic-graph-persistence-lock` to it.\n\n        Args:\n            timeout: how long to wait for the lock\n\n        Returns: an async context manager that holds the lock\n        \"\"\"\n        lock_file = self.json_file.parent / f'{self.json_file.name}.pydantic-graph-persistence-lock'\n        lock_id = secrets.token_urlsafe().encode()\n\n        with anyio.fail_after(timeout):\n            while not await _file_append_check(lock_file, lock_id):\n                await anyio.sleep(0.01)\n\n        try:\n            yield\n        finally:\n            await _graph_utils.run_in_executor(lock_file.unlink, missing_ok=True)\n\n````\n\n#### json_file\n\n```python\njson_file: Path\n\n```\n\nPath to the JSON file where the snapshots are stored.\n\nYou should use a different file for each graph run, but a single file should be reused for multiple steps of the same run.\n\nFor example if you have a run ID of the form `run_123abc`, you might create a `FileStatePersistence` thus:\n\n```py\nfrom pathlib import Path\n\nfrom pydantic_graph import FullStatePersistence\n\nrun_id = 'run_123abc'\npersistence = FullStatePersistence(Path('runs') / f'{run_id}.json')\n\n```\n\n#### should_set_types\n\n```python\nshould_set_types() -> bool\n\n```\n\nWhether types need to be set.\n\nSource code in `pydantic_graph/pydantic_graph/persistence/file.py`\n\n```python\ndef should_set_types(self) -> bool:\n    \"\"\"Whether types need to be set.\"\"\"\n    return self._snapshots_type_adapter is None\n\n```",
  "content_length": 35388
}