{
  "title": "pydantic_ai.models.fallback",
  "source_url": null,
  "content": "### FallbackModel\n\nBases: `Model`\n\nA model that uses one or more fallback models upon failure.\n\nApart from `__init__`, all methods are private or match those of the base class.\n\nSource code in `pydantic_ai_slim/pydantic_ai/models/fallback.py`\n\n```python\n@dataclass(init=False)\nclass FallbackModel(Model):\n    \"\"\"A model that uses one or more fallback models upon failure.\n\n    Apart from `__init__`, all methods are private or match those of the base class.\n    \"\"\"\n\n    models: list[Model]\n\n    _model_name: str = field(repr=False)\n    _fallback_on: Callable[[Exception], bool]\n\n    def __init__(\n        self,\n        default_model: Model | KnownModelName | str,\n        *fallback_models: Model | KnownModelName | str,\n        fallback_on: Callable[[Exception], bool] | tuple[type[Exception], ...] = (ModelAPIError,),\n    ):\n        \"\"\"Initialize a fallback model instance.\n\n        Args:\n            default_model: The name or instance of the default model to use.\n            fallback_models: The names or instances of the fallback models to use upon failure.\n            fallback_on: A callable or tuple of exceptions that should trigger a fallback.\n        \"\"\"\n        super().__init__()\n        self.models = [infer_model(default_model), *[infer_model(m) for m in fallback_models]]\n\n        if isinstance(fallback_on, tuple):\n            self._fallback_on = _default_fallback_condition_factory(fallback_on)\n        else:\n            self._fallback_on = fallback_on\n\n    @property\n    def model_name(self) -> str:\n        \"\"\"The model name.\"\"\"\n        return f'fallback:{\",\".join(model.model_name for model in self.models)}'\n\n    @property\n    def system(self) -> str:\n        return f'fallback:{\",\".join(model.system for model in self.models)}'\n\n    @property\n    def base_url(self) -> str | None:\n        return self.models[0].base_url\n\n    async def request(\n        self,\n        messages: list[ModelMessage],\n        model_settings: ModelSettings | None,\n        model_request_parameters: ModelRequestParameters,\n    ) -> ModelResponse:\n        \"\"\"Try each model in sequence until one succeeds.\n\n        In case of failure, raise a FallbackExceptionGroup with all exceptions.\n        \"\"\"\n        exceptions: list[Exception] = []\n\n        for model in self.models:\n            try:\n                _, prepared_parameters = model.prepare_request(model_settings, model_request_parameters)\n                response = await model.request(messages, model_settings, model_request_parameters)\n            except Exception as exc:\n                if self._fallback_on(exc):\n                    exceptions.append(exc)\n                    continue\n                raise exc\n\n            self._set_span_attributes(model, prepared_parameters)\n            return response\n\n        raise FallbackExceptionGroup('All models from FallbackModel failed', exceptions)\n\n    @asynccontextmanager\n    async def request_stream(\n        self,\n        messages: list[ModelMessage],\n        model_settings: ModelSettings | None,\n        model_request_parameters: ModelRequestParameters,\n        run_context: RunContext[Any] | None = None,\n    ) -> AsyncIterator[StreamedResponse]:\n        \"\"\"Try each model in sequence until one succeeds.\"\"\"\n        exceptions: list[Exception] = []\n\n        for model in self.models:\n            async with AsyncExitStack() as stack:\n                try:\n                    _, prepared_parameters = model.prepare_request(model_settings, model_request_parameters)\n                    response = await stack.enter_async_context(\n                        model.request_stream(messages, model_settings, model_request_parameters, run_context)\n                    )\n                except Exception as exc:\n                    if self._fallback_on(exc):\n                        exceptions.append(exc)\n                        continue\n                    raise exc  # pragma: no cover\n\n                self._set_span_attributes(model, prepared_parameters)\n                yield response\n                return\n\n        raise FallbackExceptionGroup('All models from FallbackModel failed', exceptions)\n\n    @cached_property\n    def profile(self) -> ModelProfile:\n        raise NotImplementedError('FallbackModel does not have its own model profile.')\n\n    def customize_request_parameters(self, model_request_parameters: ModelRequestParameters) -> ModelRequestParameters:\n        return model_request_parameters  # pragma: no cover\n\n    def prepare_request(\n        self, model_settings: ModelSettings | None, model_request_parameters: ModelRequestParameters\n    ) -> tuple[ModelSettings | None, ModelRequestParameters]:\n        return model_settings, model_request_parameters\n\n    def _set_span_attributes(self, model: Model, model_request_parameters: ModelRequestParameters):\n        with suppress(Exception):\n            span = get_current_span()\n            if span.is_recording():\n                attributes = getattr(span, 'attributes', {})\n                if attributes.get('gen_ai.request.model') == self.model_name:  # pragma: no branch\n                    span.set_attributes(\n                        {\n                            **InstrumentedModel.model_attributes(model),\n                            **InstrumentedModel.model_request_parameters_attributes(model_request_parameters),\n                        }\n                    )\n\n```\n\n#### __init__\n\n```python\n__init__(\n    default_model: Model | KnownModelName | str,\n    *fallback_models: Model | KnownModelName | str,\n    fallback_on: (\n        Callable[[Exception], bool]\n        | tuple[type[Exception], ...]\n    ) = (ModelAPIError,)\n)\n\n```\n\nInitialize a fallback model instance.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `default_model` | `Model | KnownModelName | str` | The name or instance of the default model to use. | *required* | | `fallback_models` | `Model | KnownModelName | str` | The names or instances of the fallback models to use upon failure. | `()` | | `fallback_on` | `Callable[[Exception], bool] | tuple[type[Exception], ...]` | A callable or tuple of exceptions that should trigger a fallback. | `(ModelAPIError,)` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/models/fallback.py`\n\n```python\ndef __init__(\n    self,\n    default_model: Model | KnownModelName | str,\n    *fallback_models: Model | KnownModelName | str,\n    fallback_on: Callable[[Exception], bool] | tuple[type[Exception], ...] = (ModelAPIError,),\n):\n    \"\"\"Initialize a fallback model instance.\n\n    Args:\n        default_model: The name or instance of the default model to use.\n        fallback_models: The names or instances of the fallback models to use upon failure.\n        fallback_on: A callable or tuple of exceptions that should trigger a fallback.\n    \"\"\"\n    super().__init__()\n    self.models = [infer_model(default_model), *[infer_model(m) for m in fallback_models]]\n\n    if isinstance(fallback_on, tuple):\n        self._fallback_on = _default_fallback_condition_factory(fallback_on)\n    else:\n        self._fallback_on = fallback_on\n\n```\n\n#### model_name\n\n```python\nmodel_name: str\n\n```\n\nThe model name.\n\n#### request\n\n```python\nrequest(\n    messages: list[ModelMessage],\n    model_settings: ModelSettings | None,\n    model_request_parameters: ModelRequestParameters,\n) -> ModelResponse\n\n```\n\nTry each model in sequence until one succeeds.\n\nIn case of failure, raise a FallbackExceptionGroup with all exceptions.\n\nSource code in `pydantic_ai_slim/pydantic_ai/models/fallback.py`\n\n```python\nasync def request(\n    self,\n    messages: list[ModelMessage],\n    model_settings: ModelSettings | None,\n    model_request_parameters: ModelRequestParameters,\n) -> ModelResponse:\n    \"\"\"Try each model in sequence until one succeeds.\n\n    In case of failure, raise a FallbackExceptionGroup with all exceptions.\n    \"\"\"\n    exceptions: list[Exception] = []\n\n    for model in self.models:\n        try:\n            _, prepared_parameters = model.prepare_request(model_settings, model_request_parameters)\n            response = await model.request(messages, model_settings, model_request_parameters)\n        except Exception as exc:\n            if self._fallback_on(exc):\n                exceptions.append(exc)\n                continue\n            raise exc\n\n        self._set_span_attributes(model, prepared_parameters)\n        return response\n\n    raise FallbackExceptionGroup('All models from FallbackModel failed', exceptions)\n\n```\n\n#### request_stream\n\n```python\nrequest_stream(\n    messages: list[ModelMessage],\n    model_settings: ModelSettings | None,\n    model_request_parameters: ModelRequestParameters,\n    run_context: RunContext[Any] | None = None,\n) -> AsyncIterator[StreamedResponse]\n\n```\n\nTry each model in sequence until one succeeds.\n\nSource code in `pydantic_ai_slim/pydantic_ai/models/fallback.py`\n\n```python\n@asynccontextmanager\nasync def request_stream(\n    self,\n    messages: list[ModelMessage],\n    model_settings: ModelSettings | None,\n    model_request_parameters: ModelRequestParameters,\n    run_context: RunContext[Any] | None = None,\n) -> AsyncIterator[StreamedResponse]:\n    \"\"\"Try each model in sequence until one succeeds.\"\"\"\n    exceptions: list[Exception] = []\n\n    for model in self.models:\n        async with AsyncExitStack() as stack:\n            try:\n                _, prepared_parameters = model.prepare_request(model_settings, model_request_parameters)\n                response = await stack.enter_async_context(\n                    model.request_stream(messages, model_settings, model_request_parameters, run_context)\n                )\n            except Exception as exc:\n                if self._fallback_on(exc):\n                    exceptions.append(exc)\n                    continue\n                raise exc  # pragma: no cover\n\n            self._set_span_attributes(model, prepared_parameters)\n            yield response\n            return\n\n    raise FallbackExceptionGroup('All models from FallbackModel failed', exceptions)\n\n```",
  "content_length": 9987
}