{
  "title": "`pydantic_graph.nodes`",
  "source_url": null,
  "content": "### StateT\n\n```python\nStateT = TypeVar('StateT', default=None)\n\n```\n\nType variable for the state in a graph.\n\n### GraphRunContext\n\nBases: `Generic[StateT, DepsT]`\n\nContext for a graph.\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\n@dataclass(kw_only=True)\nclass GraphRunContext(Generic[StateT, DepsT]):\n    \"\"\"Context for a graph.\"\"\"\n\n    state: StateT\n    \"\"\"The state of the graph.\"\"\"\n    deps: DepsT\n    \"\"\"Dependencies for the graph.\"\"\"\n\n```\n\n#### state\n\n```python\nstate: StateT\n\n```\n\nThe state of the graph.\n\n#### deps\n\n```python\ndeps: DepsT\n\n```\n\nDependencies for the graph.\n\n### BaseNode\n\nBases: `ABC`, `Generic[StateT, DepsT, NodeRunEndT]`\n\nBase class for a node.\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\nclass BaseNode(ABC, Generic[StateT, DepsT, NodeRunEndT]):\n    \"\"\"Base class for a node.\"\"\"\n\n    docstring_notes: ClassVar[bool] = False\n    \"\"\"Set to `True` to generate mermaid diagram notes from the class's docstring.\n\n    While this can add valuable information to the diagram, it can make diagrams harder to view, hence\n    it is disabled by default. You can also customise notes overriding the\n    [`get_note`][pydantic_graph.nodes.BaseNode.get_note] method.\n    \"\"\"\n\n    @abstractmethod\n    async def run(self, ctx: GraphRunContext[StateT, DepsT]) -> BaseNode[StateT, DepsT, Any] | End[NodeRunEndT]:\n        \"\"\"Run the node.\n\n        This is an abstract method that must be implemented by subclasses.\n\n        !!! note \"Return types used at runtime\"\n            The return type of this method are read by `pydantic_graph` at runtime and used to define which\n            nodes can be called next in the graph. This is displayed in [mermaid diagrams](mermaid.md)\n            and enforced when running the graph.\n\n        Args:\n            ctx: The graph context.\n\n        Returns:\n            The next node to run or [`End`][pydantic_graph.nodes.End] to signal the end of the graph.\n        \"\"\"\n        ...\n\n    def get_snapshot_id(self) -> str:\n        if snapshot_id := getattr(self, '__snapshot_id', None):\n            return snapshot_id\n        else:\n            self.__dict__['__snapshot_id'] = snapshot_id = generate_snapshot_id(self.get_node_id())\n            return snapshot_id\n\n    def set_snapshot_id(self, snapshot_id: str) -> None:\n        self.__dict__['__snapshot_id'] = snapshot_id\n\n    @classmethod\n    @cache\n    def get_node_id(cls) -> str:\n        \"\"\"Get the ID of the node.\"\"\"\n        return cls.__name__\n\n    @classmethod\n    def get_note(cls) -> str | None:\n        \"\"\"Get a note about the node to render on mermaid charts.\n\n        By default, this returns a note only if [`docstring_notes`][pydantic_graph.nodes.BaseNode.docstring_notes]\n        is `True`. You can override this method to customise the node notes.\n        \"\"\"\n        if not cls.docstring_notes:\n            return None\n        docstring = cls.__doc__\n        # dataclasses get an automatic docstring which is just their signature, we don't want that\n        if docstring and is_dataclass(cls) and docstring.startswith(f'{cls.__name__}('):\n            docstring = None  # pragma: no cover\n        if docstring:  # pragma: no branch\n            # remove indentation from docstring\n            import inspect\n\n            docstring = inspect.cleandoc(docstring)\n        return docstring\n\n    @classmethod\n    def get_node_def(cls, local_ns: dict[str, Any] | None) -> NodeDef[StateT, DepsT, NodeRunEndT]:\n        \"\"\"Get the node definition.\"\"\"\n        type_hints = get_type_hints(cls.run, localns=local_ns, include_extras=True)\n        try:\n            return_hint = type_hints['return']\n        except KeyError as e:\n            raise exceptions.GraphSetupError(f'Node {cls} is missing a return type hint on its `run` method') from e\n\n        next_node_edges: dict[str, Edge] = {}\n        end_edge: Edge | None = None\n        returns_base_node: bool = False\n        for return_type in _utils.get_union_args(return_hint):\n            return_type, annotations = _utils.unpack_annotated(return_type)\n            edge = next((a for a in annotations if isinstance(a, Edge)), Edge(None))\n            return_type_origin = get_origin(return_type) or return_type\n            if return_type_origin is End:\n                end_edge = edge\n            elif return_type_origin is BaseNode:\n                returns_base_node = True\n            elif issubclass(return_type_origin, BaseNode):\n                next_node_edges[return_type.get_node_id()] = edge\n            else:\n                raise exceptions.GraphSetupError(f'Invalid return type: {return_type}')\n\n        return NodeDef(\n            node=cls,\n            node_id=cls.get_node_id(),\n            note=cls.get_note(),\n            next_node_edges=next_node_edges,\n            end_edge=end_edge,\n            returns_base_node=returns_base_node,\n        )\n\n    def deep_copy(self) -> Self:\n        \"\"\"Returns a deep copy of the node.\"\"\"\n        return copy.deepcopy(self)\n\n```\n\n#### docstring_notes\n\n```python\ndocstring_notes: bool = False\n\n```\n\nSet to `True` to generate mermaid diagram notes from the class's docstring.\n\nWhile this can add valuable information to the diagram, it can make diagrams harder to view, hence it is disabled by default. You can also customise notes overriding the get_note method.\n\n#### run\n\n```python\nrun(\n    ctx: GraphRunContext[StateT, DepsT],\n) -> BaseNode[StateT, DepsT, Any] | End[NodeRunEndT]\n\n```\n\nRun the node.\n\nThis is an abstract method that must be implemented by subclasses.\n\nReturn types used at runtime\n\nThe return type of this method are read by `pydantic_graph` at runtime and used to define which nodes can be called next in the graph. This is displayed in [mermaid diagrams](../mermaid/) and enforced when running the graph.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `ctx` | `GraphRunContext[StateT, DepsT]` | The graph context. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `BaseNode[StateT, DepsT, Any] | End[NodeRunEndT]` | The next node to run or End to signal the end of the graph. |\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\n@abstractmethod\nasync def run(self, ctx: GraphRunContext[StateT, DepsT]) -> BaseNode[StateT, DepsT, Any] | End[NodeRunEndT]:\n    \"\"\"Run the node.\n\n    This is an abstract method that must be implemented by subclasses.\n\n    !!! note \"Return types used at runtime\"\n        The return type of this method are read by `pydantic_graph` at runtime and used to define which\n        nodes can be called next in the graph. This is displayed in [mermaid diagrams](mermaid.md)\n        and enforced when running the graph.\n\n    Args:\n        ctx: The graph context.\n\n    Returns:\n        The next node to run or [`End`][pydantic_graph.nodes.End] to signal the end of the graph.\n    \"\"\"\n    ...\n\n```\n\n#### get_node_id\n\n```python\nget_node_id() -> str\n\n```\n\nGet the ID of the node.\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\n@classmethod\n@cache\ndef get_node_id(cls) -> str:\n    \"\"\"Get the ID of the node.\"\"\"\n    return cls.__name__\n\n```\n\n#### get_note\n\n```python\nget_note() -> str | None\n\n```\n\nGet a note about the node to render on mermaid charts.\n\nBy default, this returns a note only if docstring_notes is `True`. You can override this method to customise the node notes.\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\n@classmethod\ndef get_note(cls) -> str | None:\n    \"\"\"Get a note about the node to render on mermaid charts.\n\n    By default, this returns a note only if [`docstring_notes`][pydantic_graph.nodes.BaseNode.docstring_notes]\n    is `True`. You can override this method to customise the node notes.\n    \"\"\"\n    if not cls.docstring_notes:\n        return None\n    docstring = cls.__doc__\n    # dataclasses get an automatic docstring which is just their signature, we don't want that\n    if docstring and is_dataclass(cls) and docstring.startswith(f'{cls.__name__}('):\n        docstring = None  # pragma: no cover\n    if docstring:  # pragma: no branch\n        # remove indentation from docstring\n        import inspect\n\n        docstring = inspect.cleandoc(docstring)\n    return docstring\n\n```\n\n#### get_node_def\n\n```python\nget_node_def(\n    local_ns: dict[str, Any] | None,\n) -> NodeDef[StateT, DepsT, NodeRunEndT]\n\n```\n\nGet the node definition.\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\n@classmethod\ndef get_node_def(cls, local_ns: dict[str, Any] | None) -> NodeDef[StateT, DepsT, NodeRunEndT]:\n    \"\"\"Get the node definition.\"\"\"\n    type_hints = get_type_hints(cls.run, localns=local_ns, include_extras=True)\n    try:\n        return_hint = type_hints['return']\n    except KeyError as e:\n        raise exceptions.GraphSetupError(f'Node {cls} is missing a return type hint on its `run` method') from e\n\n    next_node_edges: dict[str, Edge] = {}\n    end_edge: Edge | None = None\n    returns_base_node: bool = False\n    for return_type in _utils.get_union_args(return_hint):\n        return_type, annotations = _utils.unpack_annotated(return_type)\n        edge = next((a for a in annotations if isinstance(a, Edge)), Edge(None))\n        return_type_origin = get_origin(return_type) or return_type\n        if return_type_origin is End:\n            end_edge = edge\n        elif return_type_origin is BaseNode:\n            returns_base_node = True\n        elif issubclass(return_type_origin, BaseNode):\n            next_node_edges[return_type.get_node_id()] = edge\n        else:\n            raise exceptions.GraphSetupError(f'Invalid return type: {return_type}')\n\n    return NodeDef(\n        node=cls,\n        node_id=cls.get_node_id(),\n        note=cls.get_note(),\n        next_node_edges=next_node_edges,\n        end_edge=end_edge,\n        returns_base_node=returns_base_node,\n    )\n\n```\n\n#### deep_copy\n\n```python\ndeep_copy() -> Self\n\n```\n\nReturns a deep copy of the node.\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\ndef deep_copy(self) -> Self:\n    \"\"\"Returns a deep copy of the node.\"\"\"\n    return copy.deepcopy(self)\n\n```\n\n### End\n\nBases: `Generic[RunEndT]`\n\nType to return from a node to signal the end of the graph.\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\n@dataclass\nclass End(Generic[RunEndT]):\n    \"\"\"Type to return from a node to signal the end of the graph.\"\"\"\n\n    data: RunEndT\n    \"\"\"Data to return from the graph.\"\"\"\n\n    def deep_copy_data(self) -> End[RunEndT]:\n        \"\"\"Returns a deep copy of the end of the run.\"\"\"\n        if self.data is None:\n            return self\n        else:\n            end = End(copy.deepcopy(self.data))\n            end.set_snapshot_id(self.get_snapshot_id())\n            return end\n\n    def get_snapshot_id(self) -> str:\n        if snapshot_id := getattr(self, '__snapshot_id', None):\n            return snapshot_id\n        else:\n            self.__dict__['__snapshot_id'] = snapshot_id = generate_snapshot_id('end')\n            return snapshot_id\n\n    def set_snapshot_id(self, set_id: str) -> None:\n        self.__dict__['__snapshot_id'] = set_id\n\n```\n\n#### data\n\n```python\ndata: RunEndT\n\n```\n\nData to return from the graph.\n\n#### deep_copy_data\n\n```python\ndeep_copy_data() -> End[RunEndT]\n\n```\n\nReturns a deep copy of the end of the run.\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\ndef deep_copy_data(self) -> End[RunEndT]:\n    \"\"\"Returns a deep copy of the end of the run.\"\"\"\n    if self.data is None:\n        return self\n    else:\n        end = End(copy.deepcopy(self.data))\n        end.set_snapshot_id(self.get_snapshot_id())\n        return end\n\n```\n\n### Edge\n\nAnnotation to apply a label to an edge in a graph.\n\nSource code in `pydantic_graph/pydantic_graph/nodes.py`\n\n```python\n@dataclass(frozen=True)\nclass Edge:\n    \"\"\"Annotation to apply a label to an edge in a graph.\"\"\"\n\n    label: str | None\n    \"\"\"Label for the edge.\"\"\"\n\n```\n\n#### label\n\n```python\nlabel: str | None\n\n```\n\nLabel for the edge.\n\n### DepsT\n\n```python\nDepsT = TypeVar('DepsT', default=None, contravariant=True)\n\n```\n\nType variable for the dependencies of a graph and node.\n\n### RunEndT\n\n```python\nRunEndT = TypeVar('RunEndT', covariant=True, default=None)\n\n```\n\nCovariant type variable for the return type of a graph run.\n\n### NodeRunEndT\n\n```python\nNodeRunEndT = TypeVar(\n    \"NodeRunEndT\", covariant=True, default=Never\n)\n\n```\n\nCovariant type variable for the return type of a node run.",
  "content_length": 12425
}