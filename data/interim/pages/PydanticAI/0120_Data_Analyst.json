{
  "title": "Data Analyst",
  "source_url": null,
  "content": "Sometimes in an agent workflow, the agent does not need to know the exact tool output, but still needs to process the tool output in some ways. This is especially common in data analytics: the agent needs to know that the result of a query tool is a `DataFrame` with certain named columns, but not necessarily the content of every single row.\n\nWith Pydantic AI, you can use a [dependencies object](../../dependencies/) to store the result from one tool and use it in another tool.\n\nIn this example, we'll build an agent that analyzes the [Rotten Tomatoes movie review dataset from Cornell](https://huggingface.co/datasets/cornell-movie-review-data/rotten_tomatoes).\n\nDemonstrates:\n\n- [agent dependencies](../../dependencies/)\n\n## Running the Example\n\nWith [dependencies installed and environment variables set](../setup/#usage), run:\n\n```bash\npython -m pydantic_ai_examples.data_analyst\n\n```\n\n```bash\nuv run -m pydantic_ai_examples.data_analyst\n\n```\n\nOutput (debug):\n\n> Based on my analysis of the Cornell Movie Review dataset (rotten_tomatoes), there are **4,265 negative comments** in the training split. These are the reviews labeled as 'neg' (represented by 0 in the dataset).\n\n## Example Code\n\n[Learn about Gateway](../../gateway) [data_analyst.py](https://github.com/pydantic/pydantic-ai/blob/main/examples/pydantic_ai_examples/data_analyst.py)\n\n```python\nfrom dataclasses import dataclass, field\n\nimport datasets\nimport duckdb\nimport pandas as pd\n\nfrom pydantic_ai import Agent, ModelRetry, RunContext\n\n\n@dataclass\nclass AnalystAgentDeps:\n    output: dict[str, pd.DataFrame] = field(default_factory=dict)\n\n    def store(self, value: pd.DataFrame) -> str:\n        \"\"\"Store the output in deps and return the reference such as Out[1] to be used by the LLM.\"\"\"\n        ref = f'Out[{len(self.output) + 1}]'\n        self.output[ref] = value\n        return ref\n\n    def get(self, ref: str) -> pd.DataFrame:\n        if ref not in self.output:\n            raise ModelRetry(\n                f'Error: {ref} is not a valid variable reference. Check the previous messages and try again.'\n            )\n        return self.output[ref]\n\n\nanalyst_agent = Agent(\n    'gateway/openai:gpt-5',\n    deps_type=AnalystAgentDeps,\n    instructions='You are a data analyst and your job is to analyze the data according to the user request.',\n)\n\n\n@analyst_agent.tool\ndef load_dataset(\n    ctx: RunContext[AnalystAgentDeps],\n    path: str,\n    split: str = 'train',\n) -> str:\n    \"\"\"Load the `split` of dataset `dataset_name` from huggingface.\n\n    Args:\n        ctx: Pydantic AI agent RunContext\n        path: name of the dataset in the form of `<user_name>/<dataset_name>`\n        split: load the split of the dataset (default: \"train\")\n    \"\"\"\n    # begin load data from hf\n    builder = datasets.load_dataset_builder(path)  # pyright: ignore[reportUnknownMemberType]\n    splits: dict[str, datasets.SplitInfo] = builder.info.splits or {}  # pyright: ignore[reportUnknownMemberType]\n    if split not in splits:\n        raise ModelRetry(\n            f'{split} is not valid for dataset {path}. Valid splits are {\",\".join(splits.keys())}'\n        )\n\n    builder.download_and_prepare()  # pyright: ignore[reportUnknownMemberType]\n    dataset = builder.as_dataset(split=split)\n    assert isinstance(dataset, datasets.Dataset)\n    dataframe = dataset.to_pandas()\n    assert isinstance(dataframe, pd.DataFrame)\n    # end load data from hf\n\n    # store the dataframe in the deps and get a ref like \"Out[1]\"\n    ref = ctx.deps.store(dataframe)\n    # construct a summary of the loaded dataset\n    output = [\n        f'Loaded the dataset as `{ref}`.',\n        f'Description: {dataset.info.description}'\n        if dataset.info.description\n        else None,\n        f'Features: {dataset.info.features!r}' if dataset.info.features else None,\n    ]\n    return '\\n'.join(filter(None, output))\n\n\n@analyst_agent.tool\ndef run_duckdb(ctx: RunContext[AnalystAgentDeps], dataset: str, sql: str) -> str:\n    \"\"\"Run DuckDB SQL query on the DataFrame.\n\n    Note that the virtual table name used in DuckDB SQL must be `dataset`.\n\n    Args:\n        ctx: Pydantic AI agent RunContext\n        dataset: reference string to the DataFrame\n        sql: the query to be executed using DuckDB\n    \"\"\"\n    data = ctx.deps.get(dataset)\n    result = duckdb.query_df(df=data, virtual_table_name='dataset', sql_query=sql)\n    # pass the result as ref (because DuckDB SQL can select many rows, creating another huge dataframe)\n    ref = ctx.deps.store(result.df())  # pyright: ignore[reportUnknownMemberType]\n    return f'Executed SQL, result is `{ref}`'\n\n\n@analyst_agent.tool\ndef display(ctx: RunContext[AnalystAgentDeps], name: str) -> str:\n    \"\"\"Display at most 5 rows of the dataframe.\"\"\"\n    dataset = ctx.deps.get(name)\n    return dataset.head().to_string()  # pyright: ignore[reportUnknownMemberType]\n\n\nif __name__ == '__main__':\n    deps = AnalystAgentDeps()\n    result = analyst_agent.run_sync(\n        user_prompt='Count how many negative comments are there in the dataset `cornell-movie-review-data/rotten_tomatoes`',\n        deps=deps,\n    )\n    print(result.output)\n\n```\n\n[data_analyst.py](https://github.com/pydantic/pydantic-ai/blob/main/examples/pydantic_ai_examples/data_analyst.py)\n\n```python\nfrom dataclasses import dataclass, field\n\nimport datasets\nimport duckdb\nimport pandas as pd\n\nfrom pydantic_ai import Agent, ModelRetry, RunContext\n\n\n@dataclass\nclass AnalystAgentDeps:\n    output: dict[str, pd.DataFrame] = field(default_factory=dict)\n\n    def store(self, value: pd.DataFrame) -> str:\n        \"\"\"Store the output in deps and return the reference such as Out[1] to be used by the LLM.\"\"\"\n        ref = f'Out[{len(self.output) + 1}]'\n        self.output[ref] = value\n        return ref\n\n    def get(self, ref: str) -> pd.DataFrame:\n        if ref not in self.output:\n            raise ModelRetry(\n                f'Error: {ref} is not a valid variable reference. Check the previous messages and try again.'\n            )\n        return self.output[ref]\n\n\nanalyst_agent = Agent(\n    'openai:gpt-5',\n    deps_type=AnalystAgentDeps,\n    instructions='You are a data analyst and your job is to analyze the data according to the user request.',\n)\n\n\n@analyst_agent.tool\ndef load_dataset(\n    ctx: RunContext[AnalystAgentDeps],\n    path: str,\n    split: str = 'train',\n) -> str:\n    \"\"\"Load the `split` of dataset `dataset_name` from huggingface.\n\n    Args:\n        ctx: Pydantic AI agent RunContext\n        path: name of the dataset in the form of `<user_name>/<dataset_name>`\n        split: load the split of the dataset (default: \"train\")\n    \"\"\"\n    # begin load data from hf\n    builder = datasets.load_dataset_builder(path)  # pyright: ignore[reportUnknownMemberType]\n    splits: dict[str, datasets.SplitInfo] = builder.info.splits or {}  # pyright: ignore[reportUnknownMemberType]\n    if split not in splits:\n        raise ModelRetry(\n            f'{split} is not valid for dataset {path}. Valid splits are {\",\".join(splits.keys())}'\n        )\n\n    builder.download_and_prepare()  # pyright: ignore[reportUnknownMemberType]\n    dataset = builder.as_dataset(split=split)\n    assert isinstance(dataset, datasets.Dataset)\n    dataframe = dataset.to_pandas()\n    assert isinstance(dataframe, pd.DataFrame)\n    # end load data from hf\n\n    # store the dataframe in the deps and get a ref like \"Out[1]\"\n    ref = ctx.deps.store(dataframe)\n    # construct a summary of the loaded dataset\n    output = [\n        f'Loaded the dataset as `{ref}`.',\n        f'Description: {dataset.info.description}'\n        if dataset.info.description\n        else None,\n        f'Features: {dataset.info.features!r}' if dataset.info.features else None,\n    ]\n    return '\\n'.join(filter(None, output))\n\n\n@analyst_agent.tool\ndef run_duckdb(ctx: RunContext[AnalystAgentDeps], dataset: str, sql: str) -> str:\n    \"\"\"Run DuckDB SQL query on the DataFrame.\n\n    Note that the virtual table name used in DuckDB SQL must be `dataset`.\n\n    Args:\n        ctx: Pydantic AI agent RunContext\n        dataset: reference string to the DataFrame\n        sql: the query to be executed using DuckDB\n    \"\"\"\n    data = ctx.deps.get(dataset)\n    result = duckdb.query_df(df=data, virtual_table_name='dataset', sql_query=sql)\n    # pass the result as ref (because DuckDB SQL can select many rows, creating another huge dataframe)\n    ref = ctx.deps.store(result.df())  # pyright: ignore[reportUnknownMemberType]\n    return f'Executed SQL, result is `{ref}`'\n\n\n@analyst_agent.tool\ndef display(ctx: RunContext[AnalystAgentDeps], name: str) -> str:\n    \"\"\"Display at most 5 rows of the dataframe.\"\"\"\n    dataset = ctx.deps.get(name)\n    return dataset.head().to_string()  # pyright: ignore[reportUnknownMemberType]\n\n\nif __name__ == '__main__':\n    deps = AnalystAgentDeps()\n    result = analyst_agent.run_sync(\n        user_prompt='Count how many negative comments are there in the dataset `cornell-movie-review-data/rotten_tomatoes`',\n        deps=deps,\n    )\n    print(result.output)\n\n```\n\n## Appendix\n\n### Choosing a Model\n\nThis example requires using a model that understands DuckDB SQL. You can check with `clai`:\n\n```sh\n> clai -m bedrock:us.anthropic.claude-3-7-sonnet-20250219-v1:0\nclai - Pydantic AI CLI v0.0.1.dev920+41dd069 with bedrock:us.anthropic.claude-3-7-sonnet-20250219-v1:0\nclai ➤ do you understand duckdb sql?\n### DuckDB SQL\n\nYes, I understand DuckDB SQL. DuckDB is an in-process analytical SQL database\nthat uses syntax similar to PostgreSQL. It specializes in analytical queries\nand is designed for high-performance analysis of structured data.\n\nSome key features of DuckDB SQL include:\n\n • OLAP (Online Analytical Processing) optimized\n • Columnar-vectorized query execution\n • Standard SQL support with PostgreSQL compatibility\n • Support for complex analytical queries\n • Efficient handling of CSV/Parquet/JSON files\n\nI can help you with DuckDB SQL queries, schema design, optimization, or other\nDuckDB-related questions.\n\n```\n\nExample of a multi-agent flow where one agent delegates work to another, then hands off control to a third agent.\n\nDemonstrates:\n\n- [agent delegation](../../multi-agent-applications/#agent-delegation)\n- [programmatic agent hand-off](../../multi-agent-applications/#programmatic-agent-hand-off)\n- [usage limits](../../agents/#usage-limits)\n\nIn this scenario, a group of agents work together to find the best flight for a user.\n\nThe control flow for this example can be summarised as follows:\n\n```\ngraph TD\n  START --> search_agent(\"search agent\")\n  search_agent --> extraction_agent(\"extraction agent\")\n  extraction_agent --> search_agent\n  search_agent --> human_confirm(\"human confirm\")\n  human_confirm --> search_agent\n  search_agent --> FAILED\n  human_confirm --> find_seat_function(\"find seat function\")\n  find_seat_function --> human_seat_choice(\"human seat choice\")\n  human_seat_choice --> find_seat_agent(\"find seat agent\")\n  find_seat_agent --> find_seat_function\n  find_seat_function --> buy_flights(\"buy flights\")\n  buy_flights --> SUCCESS\n```\n\n## Running the Example\n\nWith [dependencies installed and environment variables set](../setup/#usage), run:\n\n```bash\npython -m pydantic_ai_examples.flight_booking\n\n```\n\n```bash\nuv run -m pydantic_ai_examples.flight_booking\n\n```\n\n## Example Code\n\n[Learn about Gateway](../../gateway) [flight_booking.py](https://github.com/pydantic/pydantic-ai/blob/main/examples/pydantic_ai_examples/flight_booking.py)\n\n```python\n\"\"\"Example of a multi-agent flow where one agent delegates work to another.\n\nIn this scenario, a group of agents work together to find flights for a user.\n\"\"\"\n\nimport datetime\nfrom dataclasses import dataclass\nfrom typing import Literal\n\nimport logfire\nfrom pydantic import BaseModel, Field\nfrom rich.prompt import Prompt\n\nfrom pydantic_ai import (\n    Agent,\n    ModelMessage,\n    ModelRetry,\n    RunContext,\n    RunUsage,\n    UsageLimits,\n)\n\n### 'if-token-present' means nothing will be sent (and the example will work) if you don't have logfire configured\nlogfire.configure(send_to_logfire='if-token-present')\nlogfire.instrument_pydantic_ai()\n\n\nclass FlightDetails(BaseModel):\n    \"\"\"Details of the most suitable flight.\"\"\"\n\n    flight_number: str\n    price: int\n    origin: str = Field(description='Three-letter airport code')\n    destination: str = Field(description='Three-letter airport code')\n    date: datetime.date\n\n\nclass NoFlightFound(BaseModel):\n    \"\"\"When no valid flight is found.\"\"\"\n\n\n@dataclass\nclass Deps:\n    web_page_text: str\n    req_origin: str\n    req_destination: str\n    req_date: datetime.date\n\n\n### This agent is responsible for controlling the flow of the conversation.\nsearch_agent = Agent[Deps, FlightDetails | NoFlightFound](\n    'openai:gpt-5',\n    output_type=FlightDetails | NoFlightFound,  # type: ignore\n    retries=4,\n    system_prompt=(\n        'Your job is to find the cheapest flight for the user on the given date. '\n    ),\n)\n\n\n### This agent is responsible for extracting flight details from web page text.\nextraction_agent = Agent(\n    'gateway/openai:gpt-5',\n    output_type=list[FlightDetails],\n    system_prompt='Extract all the flight details from the given text.',\n)\n\n\n@search_agent.tool\nasync def extract_flights(ctx: RunContext[Deps]) -> list[FlightDetails]:\n    \"\"\"Get details of all flights.\"\"\"\n    # we pass the usage to the search agent so requests within this agent are counted\n    result = await extraction_agent.run(ctx.deps.web_page_text, usage=ctx.usage)\n    logfire.info('found {flight_count} flights', flight_count=len(result.output))\n    return result.output\n\n\n@search_agent.output_validator\nasync def validate_output(\n    ctx: RunContext[Deps], output: FlightDetails | NoFlightFound\n) -> FlightDetails | NoFlightFound:\n    \"\"\"Procedural validation that the flight meets the constraints.\"\"\"\n    if isinstance(output, NoFlightFound):\n        return output\n\n    errors: list[str] = []\n    if output.origin != ctx.deps.req_origin:\n        errors.append(\n            f'Flight should have origin {ctx.deps.req_origin}, not {output.origin}'\n        )\n    if output.destination != ctx.deps.req_destination:\n        errors.append(\n            f'Flight should have destination {ctx.deps.req_destination}, not {output.destination}'\n        )\n    if output.date != ctx.deps.req_date:\n        errors.append(f'Flight should be on {ctx.deps.req_date}, not {output.date}')\n\n    if errors:\n        raise ModelRetry('\\n'.join(errors))\n    else:\n        return output\n\n\nclass SeatPreference(BaseModel):\n    row: int = Field(ge=1, le=30)\n    seat: Literal['A', 'B', 'C', 'D', 'E', 'F']\n\n\nclass Failed(BaseModel):\n    \"\"\"Unable to extract a seat selection.\"\"\"\n\n\n### This agent is responsible for extracting the user's seat selection\nseat_preference_agent = Agent[None, SeatPreference | Failed](\n    'openai:gpt-5',\n    output_type=SeatPreference | Failed,\n    system_prompt=(\n        \"Extract the user's seat preference. \"\n        'Seats A and F are window seats. '\n        'Row 1 is the front row and has extra leg room. '\n        'Rows 14, and 20 also have extra leg room. '\n    ),\n)\n\n\n### in reality this would be downloaded from a booking site,\n### potentially using another agent to navigate the site\nflights_web_page = \"\"\"\n1. Flight SFO-AK123\n- Price: $350\n- Origin: San Francisco International Airport (SFO)\n- Destination: Ted Stevens Anchorage International Airport (ANC)\n- Date: January 10, 2025\n\n2. Flight SFO-AK456\n- Price: $370\n- Origin: San Francisco International Airport (SFO)\n- Destination: Fairbanks International Airport (FAI)\n- Date: January 10, 2025\n\n3. Flight SFO-AK789\n- Price: $400\n- Origin: San Francisco International Airport (SFO)\n- Destination: Juneau International Airport (JNU)\n- Date: January 20, 2025\n\n4. Flight NYC-LA101\n- Price: $250\n- Origin: San Francisco International Airport (SFO)\n- Destination: Ted Stevens Anchorage International Airport (ANC)\n- Date: January 10, 2025\n\n5. Flight CHI-MIA202\n- Price: $200\n- Origin: Chicago O'Hare International Airport (ORD)\n- Destination: Miami International Airport (MIA)\n- Date: January 12, 2025\n\n6. Flight BOS-SEA303\n- Price: $120\n- Origin: Boston Logan International Airport (BOS)\n- Destination: Ted Stevens Anchorage International Airport (ANC)\n- Date: January 12, 2025\n\n7. Flight DFW-DEN404\n- Price: $150\n- Origin: Dallas/Fort Worth International Airport (DFW)\n- Destination: Denver International Airport (DEN)\n- Date: January 10, 2025\n\n8. Flight ATL-HOU505\n- Price: $180\n- Origin: Hartsfield-Jackson Atlanta International Airport (ATL)\n- Destination: George Bush Intercontinental Airport (IAH)\n- Date: January 10, 2025\n\"\"\"\n\n### restrict how many requests this app can make to the LLM\nusage_limits = UsageLimits(request_limit=15)\n\n\nasync def main():\n    deps = Deps(\n        web_page_text=flights_web_page,\n        req_origin='SFO',\n        req_destination='ANC',\n        req_date=datetime.date(2025, 1, 10),\n    )\n    message_history: list[ModelMessage] | None = None\n    usage: RunUsage = RunUsage()\n    # run the agent until a satisfactory flight is found\n    while True:\n        result = await search_agent.run(\n            f'Find me a flight from {deps.req_origin} to {deps.req_destination} on {deps.req_date}',\n            deps=deps,\n            usage=usage,\n            message_history=message_history,\n            usage_limits=usage_limits,\n        )\n        if isinstance(result.output, NoFlightFound):\n            print('No flight found')\n            break\n        else:\n            flight = result.output\n            print(f'Flight found: {flight}')\n            answer = Prompt.ask(\n                'Do you want to buy this flight, or keep searching? (buy/*search)',\n                choices=['buy', 'search', ''],\n                show_choices=False,\n            )\n            if answer == 'buy':\n                seat = await find_seat(usage)\n                await buy_tickets(flight, seat)\n                break\n            else:\n                message_history = result.all_messages(\n                    output_tool_return_content='Please suggest another flight'\n                )\n\n\nasync def find_seat(usage: RunUsage) -> SeatPreference:\n    message_history: list[ModelMessage] | None = None\n    while True:\n        answer = Prompt.ask('What seat would you like?')\n\n        result = await seat_preference_agent.run(\n            answer,\n            message_history=message_history,\n            usage=usage,\n            usage_limits=usage_limits,\n        )\n        if isinstance(result.output, SeatPreference):\n            return result.output\n        else:\n            print('Could not understand seat preference. Please try again.')\n            message_history = result.all_messages()\n\n\nasync def buy_tickets(flight_details: FlightDetails, seat: SeatPreference):\n    print(f'Purchasing flight {flight_details=!r} {seat=!r}...')\n\n\nif __name__ == '__main__':\n    import asyncio\n\n    asyncio.run(main())\n\n```\n\n[flight_booking.py](https://github.com/pydantic/pydantic-ai/blob/main/examples/pydantic_ai_examples/flight_booking.py)\n\n```python\n\"\"\"Example of a multi-agent flow where one agent delegates work to another.\n\nIn this scenario, a group of agents work together to find flights for a user.\n\"\"\"\n\nimport datetime\nfrom dataclasses import dataclass\nfrom typing import Literal\n\nimport logfire\nfrom pydantic import BaseModel, Field\nfrom rich.prompt import Prompt\n\nfrom pydantic_ai import (\n    Agent,\n    ModelMessage,\n    ModelRetry,\n    RunContext,\n    RunUsage,\n    UsageLimits,\n)\n\n### 'if-token-present' means nothing will be sent (and the example will work) if you don't have logfire configured\nlogfire.configure(send_to_logfire='if-token-present')\nlogfire.instrument_pydantic_ai()\n\n\nclass FlightDetails(BaseModel):\n    \"\"\"Details of the most suitable flight.\"\"\"\n\n    flight_number: str\n    price: int\n    origin: str = Field(description='Three-letter airport code')\n    destination: str = Field(description='Three-letter airport code')\n    date: datetime.date\n\n\nclass NoFlightFound(BaseModel):\n    \"\"\"When no valid flight is found.\"\"\"\n\n\n@dataclass\nclass Deps:\n    web_page_text: str\n    req_origin: str\n    req_destination: str\n    req_date: datetime.date\n\n\n### This agent is responsible for controlling the flow of the conversation.\nsearch_agent = Agent[Deps, FlightDetails | NoFlightFound](\n    'openai:gpt-5',\n    output_type=FlightDetails | NoFlightFound,  # type: ignore\n    retries=4,\n    system_prompt=(\n        'Your job is to find the cheapest flight for the user on the given date. '\n    ),\n)\n\n\n### This agent is responsible for extracting flight details from web page text.\nextraction_agent = Agent(\n    'openai:gpt-5',\n    output_type=list[FlightDetails],\n    system_prompt='Extract all the flight details from the given text.',\n)\n\n\n@search_agent.tool\nasync def extract_flights(ctx: RunContext[Deps]) -> list[FlightDetails]:\n    \"\"\"Get details of all flights.\"\"\"\n    # we pass the usage to the search agent so requests within this agent are counted\n    result = await extraction_agent.run(ctx.deps.web_page_text, usage=ctx.usage)\n    logfire.info('found {flight_count} flights', flight_count=len(result.output))\n    return result.output\n\n\n@search_agent.output_validator\nasync def validate_output(\n    ctx: RunContext[Deps], output: FlightDetails | NoFlightFound\n) -> FlightDetails | NoFlightFound:\n    \"\"\"Procedural validation that the flight meets the constraints.\"\"\"\n    if isinstance(output, NoFlightFound):\n        return output\n\n    errors: list[str] = []\n    if output.origin != ctx.deps.req_origin:\n        errors.append(\n            f'Flight should have origin {ctx.deps.req_origin}, not {output.origin}'\n        )\n    if output.destination != ctx.deps.req_destination:\n        errors.append(\n            f'Flight should have destination {ctx.deps.req_destination}, not {output.destination}'\n        )\n    if output.date != ctx.deps.req_date:\n        errors.append(f'Flight should be on {ctx.deps.req_date}, not {output.date}')\n\n    if errors:\n        raise ModelRetry('\\n'.join(errors))\n    else:\n        return output\n\n\nclass SeatPreference(BaseModel):\n    row: int = Field(ge=1, le=30)\n    seat: Literal['A', 'B', 'C', 'D', 'E', 'F']\n\n\nclass Failed(BaseModel):\n    \"\"\"Unable to extract a seat selection.\"\"\"\n\n\n### This agent is responsible for extracting the user's seat selection\nseat_preference_agent = Agent[None, SeatPreference | Failed](\n    'openai:gpt-5',\n    output_type=SeatPreference | Failed,\n    system_prompt=(\n        \"Extract the user's seat preference. \"\n        'Seats A and F are window seats. '\n        'Row 1 is the front row and has extra leg room. '\n        'Rows 14, and 20 also have extra leg room. '\n    ),\n)\n\n\n### in reality this would be downloaded from a booking site,\n### potentially using another agent to navigate the site\nflights_web_page = \"\"\"\n1. Flight SFO-AK123\n- Price: $350\n- Origin: San Francisco International Airport (SFO)\n- Destination: Ted Stevens Anchorage International Airport (ANC)\n- Date: January 10, 2025\n\n2. Flight SFO-AK456\n- Price: $370\n- Origin: San Francisco International Airport (SFO)\n- Destination: Fairbanks International Airport (FAI)\n- Date: January 10, 2025\n\n3. Flight SFO-AK789\n- Price: $400\n- Origin: San Francisco International Airport (SFO)\n- Destination: Juneau International Airport (JNU)\n- Date: January 20, 2025\n\n4. Flight NYC-LA101\n- Price: $250\n- Origin: San Francisco International Airport (SFO)\n- Destination: Ted Stevens Anchorage International Airport (ANC)\n- Date: January 10, 2025\n\n5. Flight CHI-MIA202\n- Price: $200\n- Origin: Chicago O'Hare International Airport (ORD)\n- Destination: Miami International Airport (MIA)\n- Date: January 12, 2025\n\n6. Flight BOS-SEA303\n- Price: $120\n- Origin: Boston Logan International Airport (BOS)\n- Destination: Ted Stevens Anchorage International Airport (ANC)\n- Date: January 12, 2025\n\n7. Flight DFW-DEN404\n- Price: $150\n- Origin: Dallas/Fort Worth International Airport (DFW)\n- Destination: Denver International Airport (DEN)\n- Date: January 10, 2025\n\n8. Flight ATL-HOU505\n- Price: $180\n- Origin: Hartsfield-Jackson Atlanta International Airport (ATL)\n- Destination: George Bush Intercontinental Airport (IAH)\n- Date: January 10, 2025\n\"\"\"\n\n### restrict how many requests this app can make to the LLM\nusage_limits = UsageLimits(request_limit=15)\n\n\nasync def main():\n    deps = Deps(\n        web_page_text=flights_web_page,\n        req_origin='SFO',\n        req_destination='ANC',\n        req_date=datetime.date(2025, 1, 10),\n    )\n    message_history: list[ModelMessage] | None = None\n    usage: RunUsage = RunUsage()\n    # run the agent until a satisfactory flight is found\n    while True:\n        result = await search_agent.run(\n            f'Find me a flight from {deps.req_origin} to {deps.req_destination} on {deps.req_date}',\n            deps=deps,\n            usage=usage,\n            message_history=message_history,\n            usage_limits=usage_limits,\n        )\n        if isinstance(result.output, NoFlightFound):\n            print('No flight found')\n            break\n        else:\n            flight = result.output\n            print(f'Flight found: {flight}')\n            answer = Prompt.ask(\n                'Do you want to buy this flight, or keep searching? (buy/*search)',\n                choices=['buy', 'search', ''],\n                show_choices=False,\n            )\n            if answer == 'buy':\n                seat = await find_seat(usage)\n                await buy_tickets(flight, seat)\n                break\n            else:\n                message_history = result.all_messages(\n                    output_tool_return_content='Please suggest another flight'\n                )\n\n\nasync def find_seat(usage: RunUsage) -> SeatPreference:\n    message_history: list[ModelMessage] | None = None\n    while True:\n        answer = Prompt.ask('What seat would you like?')\n\n        result = await seat_preference_agent.run(\n            answer,\n            message_history=message_history,\n            usage=usage,\n            usage_limits=usage_limits,\n        )\n        if isinstance(result.output, SeatPreference):\n            return result.output\n        else:\n            print('Could not understand seat preference. Please try again.')\n            message_history = result.all_messages()\n\n\nasync def buy_tickets(flight_details: FlightDetails, seat: SeatPreference):\n    print(f'Purchasing flight {flight_details=!r} {seat=!r}...')\n\n\nif __name__ == '__main__':\n    import asyncio\n\n    asyncio.run(main())\n\n```",
  "content_length": 26445
}