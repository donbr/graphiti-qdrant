{
  "title": "Chat App with FastAPI",
  "source_url": null,
  "content": "Simple chat app example build with FastAPI.\n\nDemonstrates:\n\n- [reusing chat history](../../message-history/)\n- [serializing messages](../../message-history/#accessing-messages-from-results)\n- [streaming responses](../../output/#streamed-results)\n\nThis demonstrates storing chat history between requests and using it to give the model context for new responses.\n\nMost of the complex logic here is between `chat_app.py` which streams the response to the browser, and `chat_app.ts` which renders messages in the browser.\n\n## Running the Example\n\nWith [dependencies installed and environment variables set](../setup/#usage), run:\n\n```bash\npython -m pydantic_ai_examples.chat_app\n\n```\n\n```bash\nuv run -m pydantic_ai_examples.chat_app\n\n```\n\nThen open the app at [localhost:8000](http://localhost:8000).\n\n## Example Code\n\nPython code that runs the chat app:\n\n[Learn about Gateway](../../gateway) [chat_app.py](https://github.com/pydantic/pydantic-ai/blob/main/examples/pydantic_ai_examples/chat_app.py)\n\n```python\n\"\"\"Simple chat app example build with FastAPI.\n\nRun with:\n\n    uv run -m pydantic_ai_examples.chat_app\n\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport asyncio\nimport json\nimport sqlite3\nfrom collections.abc import AsyncIterator, Callable\nfrom concurrent.futures.thread import ThreadPoolExecutor\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Annotated, Any, Literal, TypeVar\n\nimport fastapi\nimport logfire\nfrom fastapi import Depends, Request\nfrom fastapi.responses import FileResponse, Response, StreamingResponse\nfrom typing_extensions import LiteralString, ParamSpec, TypedDict\n\nfrom pydantic_ai import (\n    Agent,\n    ModelMessage,\n    ModelMessagesTypeAdapter,\n    ModelRequest,\n    ModelResponse,\n    TextPart,\n    UnexpectedModelBehavior,\n    UserPromptPart,\n)\n\n### 'if-token-present' means nothing will be sent (and the example will work) if you don't have logfire configured\nlogfire.configure(send_to_logfire='if-token-present')\nlogfire.instrument_pydantic_ai()\n\nagent = Agent('gateway/openai:gpt-5')\nTHIS_DIR = Path(__file__).parent\n\n\n@asynccontextmanager\nasync def lifespan(_app: fastapi.FastAPI):\n    async with Database.connect() as db:\n        yield {'db': db}\n\n\napp = fastapi.FastAPI(lifespan=lifespan)\nlogfire.instrument_fastapi(app)\n\n\n@app.get('/')\nasync def index() -> FileResponse:\n    return FileResponse((THIS_DIR / 'chat_app.html'), media_type='text/html')\n\n\n@app.get('/chat_app.ts')\nasync def main_ts() -> FileResponse:\n    \"\"\"Get the raw typescript code, it's compiled in the browser, forgive me.\"\"\"\n    return FileResponse((THIS_DIR / 'chat_app.ts'), media_type='text/plain')\n\n\nasync def get_db(request: Request) -> Database:\n    return request.state.db\n\n\n@app.get('/chat/')\nasync def get_chat(database: Database = Depends(get_db)) -> Response:\n    msgs = await database.get_messages()\n    return Response(\n        b'\\n'.join(json.dumps(to_chat_message(m)).encode('utf-8') for m in msgs),\n        media_type='text/plain',\n    )\n\n\nclass ChatMessage(TypedDict):\n    \"\"\"Format of messages sent to the browser.\"\"\"\n\n    role: Literal['user', 'model']\n    timestamp: str\n    content: str\n\n\ndef to_chat_message(m: ModelMessage) -> ChatMessage:\n    first_part = m.parts[0]\n    if isinstance(m, ModelRequest):\n        if isinstance(first_part, UserPromptPart):\n            assert isinstance(first_part.content, str)\n            return {\n                'role': 'user',\n                'timestamp': first_part.timestamp.isoformat(),\n                'content': first_part.content,\n            }\n    elif isinstance(m, ModelResponse):\n        if isinstance(first_part, TextPart):\n            return {\n                'role': 'model',\n                'timestamp': m.timestamp.isoformat(),\n                'content': first_part.content,\n            }\n    raise UnexpectedModelBehavior(f'Unexpected message type for chat app: {m}')\n\n\n@app.post('/chat/')\nasync def post_chat(\n    prompt: Annotated[str, fastapi.Form()], database: Database = Depends(get_db)\n) -> StreamingResponse:\n    async def stream_messages():\n        \"\"\"Streams new line delimited JSON `Message`s to the client.\"\"\"\n        # stream the user prompt so that can be displayed straight away\n        yield (\n            json.dumps(\n                {\n                    'role': 'user',\n                    'timestamp': datetime.now(tz=timezone.utc).isoformat(),\n                    'content': prompt,\n                }\n            ).encode('utf-8')\n            + b'\\n'\n        )\n        # get the chat history so far to pass as context to the agent\n        messages = await database.get_messages()\n        # run the agent with the user prompt and the chat history\n        async with agent.run_stream(prompt, message_history=messages) as result:\n            async for text in result.stream_output(debounce_by=0.01):\n                # text here is a `str` and the frontend wants\n                # JSON encoded ModelResponse, so we create one\n                m = ModelResponse(parts=[TextPart(text)], timestamp=result.timestamp())\n                yield json.dumps(to_chat_message(m)).encode('utf-8') + b'\\n'\n\n        # add new messages (e.g. the user prompt and the agent response in this case) to the database\n        await database.add_messages(result.new_messages_json())\n\n    return StreamingResponse(stream_messages(), media_type='text/plain')\n\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\n\n@dataclass\nclass Database:\n    \"\"\"Rudimentary database to store chat messages in SQLite.\n\n    The SQLite standard library package is synchronous, so we\n    use a thread pool executor to run queries asynchronously.\n    \"\"\"\n\n    con: sqlite3.Connection\n    _loop: asyncio.AbstractEventLoop\n    _executor: ThreadPoolExecutor\n\n    @classmethod\n    @asynccontextmanager\n    async def connect(\n        cls, file: Path = THIS_DIR / '.chat_app_messages.sqlite'\n    ) -> AsyncIterator[Database]:\n        with logfire.span('connect to DB'):\n            loop = asyncio.get_event_loop()\n            executor = ThreadPoolExecutor(max_workers=1)\n            con = await loop.run_in_executor(executor, cls._connect, file)\n            slf = cls(con, loop, executor)\n        try:\n            yield slf\n        finally:\n            await slf._asyncify(con.close)\n\n    @staticmethod\n    def _connect(file: Path) -> sqlite3.Connection:\n        con = sqlite3.connect(str(file))\n        con = logfire.instrument_sqlite3(con)\n        cur = con.cursor()\n        cur.execute(\n            'CREATE TABLE IF NOT EXISTS messages (id INT PRIMARY KEY, message_list TEXT);'\n        )\n        con.commit()\n        return con\n\n    async def add_messages(self, messages: bytes):\n        await self._asyncify(\n            self._execute,\n            'INSERT INTO messages (message_list) VALUES (?);',\n            messages,\n            commit=True,\n        )\n        await self._asyncify(self.con.commit)\n\n    async def get_messages(self) -> list[ModelMessage]:\n        c = await self._asyncify(\n            self._execute, 'SELECT message_list FROM messages order by id'\n        )\n        rows = await self._asyncify(c.fetchall)\n        messages: list[ModelMessage] = []\n        for row in rows:\n            messages.extend(ModelMessagesTypeAdapter.validate_json(row[0]))\n        return messages\n\n    def _execute(\n        self, sql: LiteralString, *args: Any, commit: bool = False\n    ) -> sqlite3.Cursor:\n        cur = self.con.cursor()\n        cur.execute(sql, args)\n        if commit:\n            self.con.commit()\n        return cur\n\n    async def _asyncify(\n        self, func: Callable[P, R], *args: P.args, **kwargs: P.kwargs\n    ) -> R:\n        return await self._loop.run_in_executor(  # type: ignore\n            self._executor,\n            partial(func, **kwargs),\n            *args,  # type: ignore\n        )\n\n\nif __name__ == '__main__':\n    import uvicorn\n\n    uvicorn.run(\n        'pydantic_ai_examples.chat_app:app', reload=True, reload_dirs=[str(THIS_DIR)]\n    )\n\n```\n\n[chat_app.py](https://github.com/pydantic/pydantic-ai/blob/main/examples/pydantic_ai_examples/chat_app.py)\n\n```python\n\"\"\"Simple chat app example build with FastAPI.\n\nRun with:\n\n    uv run -m pydantic_ai_examples.chat_app\n\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport asyncio\nimport json\nimport sqlite3\nfrom collections.abc import AsyncIterator, Callable\nfrom concurrent.futures.thread import ThreadPoolExecutor\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import Annotated, Any, Literal, TypeVar\n\nimport fastapi\nimport logfire\nfrom fastapi import Depends, Request\nfrom fastapi.responses import FileResponse, Response, StreamingResponse\nfrom typing_extensions import LiteralString, ParamSpec, TypedDict\n\nfrom pydantic_ai import (\n    Agent,\n    ModelMessage,\n    ModelMessagesTypeAdapter,\n    ModelRequest,\n    ModelResponse,\n    TextPart,\n    UnexpectedModelBehavior,\n    UserPromptPart,\n)\n\n### 'if-token-present' means nothing will be sent (and the example will work) if you don't have logfire configured\nlogfire.configure(send_to_logfire='if-token-present')\nlogfire.instrument_pydantic_ai()\n\nagent = Agent('openai:gpt-5')\nTHIS_DIR = Path(__file__).parent\n\n\n@asynccontextmanager\nasync def lifespan(_app: fastapi.FastAPI):\n    async with Database.connect() as db:\n        yield {'db': db}\n\n\napp = fastapi.FastAPI(lifespan=lifespan)\nlogfire.instrument_fastapi(app)\n\n\n@app.get('/')\nasync def index() -> FileResponse:\n    return FileResponse((THIS_DIR / 'chat_app.html'), media_type='text/html')\n\n\n@app.get('/chat_app.ts')\nasync def main_ts() -> FileResponse:\n    \"\"\"Get the raw typescript code, it's compiled in the browser, forgive me.\"\"\"\n    return FileResponse((THIS_DIR / 'chat_app.ts'), media_type='text/plain')\n\n\nasync def get_db(request: Request) -> Database:\n    return request.state.db\n\n\n@app.get('/chat/')\nasync def get_chat(database: Database = Depends(get_db)) -> Response:\n    msgs = await database.get_messages()\n    return Response(\n        b'\\n'.join(json.dumps(to_chat_message(m)).encode('utf-8') for m in msgs),\n        media_type='text/plain',\n    )\n\n\nclass ChatMessage(TypedDict):\n    \"\"\"Format of messages sent to the browser.\"\"\"\n\n    role: Literal['user', 'model']\n    timestamp: str\n    content: str\n\n\ndef to_chat_message(m: ModelMessage) -> ChatMessage:\n    first_part = m.parts[0]\n    if isinstance(m, ModelRequest):\n        if isinstance(first_part, UserPromptPart):\n            assert isinstance(first_part.content, str)\n            return {\n                'role': 'user',\n                'timestamp': first_part.timestamp.isoformat(),\n                'content': first_part.content,\n            }\n    elif isinstance(m, ModelResponse):\n        if isinstance(first_part, TextPart):\n            return {\n                'role': 'model',\n                'timestamp': m.timestamp.isoformat(),\n                'content': first_part.content,\n            }\n    raise UnexpectedModelBehavior(f'Unexpected message type for chat app: {m}')\n\n\n@app.post('/chat/')\nasync def post_chat(\n    prompt: Annotated[str, fastapi.Form()], database: Database = Depends(get_db)\n) -> StreamingResponse:\n    async def stream_messages():\n        \"\"\"Streams new line delimited JSON `Message`s to the client.\"\"\"\n        # stream the user prompt so that can be displayed straight away\n        yield (\n            json.dumps(\n                {\n                    'role': 'user',\n                    'timestamp': datetime.now(tz=timezone.utc).isoformat(),\n                    'content': prompt,\n                }\n            ).encode('utf-8')\n            + b'\\n'\n        )\n        # get the chat history so far to pass as context to the agent\n        messages = await database.get_messages()\n        # run the agent with the user prompt and the chat history\n        async with agent.run_stream(prompt, message_history=messages) as result:\n            async for text in result.stream_output(debounce_by=0.01):\n                # text here is a `str` and the frontend wants\n                # JSON encoded ModelResponse, so we create one\n                m = ModelResponse(parts=[TextPart(text)], timestamp=result.timestamp())\n                yield json.dumps(to_chat_message(m)).encode('utf-8') + b'\\n'\n\n        # add new messages (e.g. the user prompt and the agent response in this case) to the database\n        await database.add_messages(result.new_messages_json())\n\n    return StreamingResponse(stream_messages(), media_type='text/plain')\n\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\n\n@dataclass\nclass Database:\n    \"\"\"Rudimentary database to store chat messages in SQLite.\n\n    The SQLite standard library package is synchronous, so we\n    use a thread pool executor to run queries asynchronously.\n    \"\"\"\n\n    con: sqlite3.Connection\n    _loop: asyncio.AbstractEventLoop\n    _executor: ThreadPoolExecutor\n\n    @classmethod\n    @asynccontextmanager\n    async def connect(\n        cls, file: Path = THIS_DIR / '.chat_app_messages.sqlite'\n    ) -> AsyncIterator[Database]:\n        with logfire.span('connect to DB'):\n            loop = asyncio.get_event_loop()\n            executor = ThreadPoolExecutor(max_workers=1)\n            con = await loop.run_in_executor(executor, cls._connect, file)\n            slf = cls(con, loop, executor)\n        try:\n            yield slf\n        finally:\n            await slf._asyncify(con.close)\n\n    @staticmethod\n    def _connect(file: Path) -> sqlite3.Connection:\n        con = sqlite3.connect(str(file))\n        con = logfire.instrument_sqlite3(con)\n        cur = con.cursor()\n        cur.execute(\n            'CREATE TABLE IF NOT EXISTS messages (id INT PRIMARY KEY, message_list TEXT);'\n        )\n        con.commit()\n        return con\n\n    async def add_messages(self, messages: bytes):\n        await self._asyncify(\n            self._execute,\n            'INSERT INTO messages (message_list) VALUES (?);',\n            messages,\n            commit=True,\n        )\n        await self._asyncify(self.con.commit)\n\n    async def get_messages(self) -> list[ModelMessage]:\n        c = await self._asyncify(\n            self._execute, 'SELECT message_list FROM messages order by id'\n        )\n        rows = await self._asyncify(c.fetchall)\n        messages: list[ModelMessage] = []\n        for row in rows:\n            messages.extend(ModelMessagesTypeAdapter.validate_json(row[0]))\n        return messages\n\n    def _execute(\n        self, sql: LiteralString, *args: Any, commit: bool = False\n    ) -> sqlite3.Cursor:\n        cur = self.con.cursor()\n        cur.execute(sql, args)\n        if commit:\n            self.con.commit()\n        return cur\n\n    async def _asyncify(\n        self, func: Callable[P, R], *args: P.args, **kwargs: P.kwargs\n    ) -> R:\n        return await self._loop.run_in_executor(  # type: ignore\n            self._executor,\n            partial(func, **kwargs),\n            *args,  # type: ignore\n        )\n\n\nif __name__ == '__main__':\n    import uvicorn\n\n    uvicorn.run(\n        'pydantic_ai_examples.chat_app:app', reload=True, reload_dirs=[str(THIS_DIR)]\n    )\n\n```\n\nSimple HTML page to render the app:\n\n[chat_app.html](https://github.com/pydantic/pydantic-ai/blob/main/examples/pydantic_ai_examples/chat_app.html)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Chat App</title>\n  <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n  <style>\n    main {\n      max-width: 700px;\n    }\n    #conversation .user::before {\n      content: 'You asked: ';\n      font-weight: bold;\n      display: block;\n    }\n    #conversation .model::before {\n      content: 'AI Response: ';\n      font-weight: bold;\n      display: block;\n    }\n    #spinner {\n      opacity: 0;\n      transition: opacity 500ms ease-in;\n      width: 30px;\n      height: 30px;\n      border: 3px solid #222;\n      border-bottom-color: transparent;\n      border-radius: 50%;\n      animation: rotation 1s linear infinite;\n    }\n    @keyframes rotation {\n      0% { transform: rotate(0deg); }\n      100% { transform: rotate(360deg); }\n    }\n    #spinner.active {\n      opacity: 1;\n    }\n  </style>\n</head>\n<body>\n  <main class=\"border rounded mx-auto my-5 p-4\">\n    <h1>Chat App</h1>\n    <p>Ask me anything...</p>\n    <div id=\"conversation\" class=\"px-2\"></div>\n    <div class=\"d-flex justify-content-center mb-3\">\n      <div id=\"spinner\"></div>\n    </div>\n    <form method=\"post\">\n      <input id=\"prompt-input\" name=\"prompt\" class=\"form-control\"/>\n      <div class=\"d-flex justify-content-end\">\n        <button class=\"btn btn-primary mt-2\">Send</button>\n      </div>\n    </form>\n    <div id=\"error\" class=\"d-none text-danger\">\n      Error occurred, check the browser developer console for more information.\n    </div>\n  </main>\n</body>\n</html>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/typescript/5.6.3/typescript.min.js\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n<script type=\"module\">\n  // to let me write TypeScript, without adding the burden of npm we do a dirty, non-production-ready hack\n  // and transpile the TypeScript code in the browser\n  // this is (arguably) A neat demo trick, but not suitable for production!\n  async function loadTs() {\n    const response = await fetch('/chat_app.ts');\n    const tsCode = await response.text();\n    const jsCode = window.ts.transpile(tsCode, { target: \"es2015\" });\n    let script = document.createElement('script');\n    script.type = 'module';\n    script.text = jsCode;\n    document.body.appendChild(script);\n  }\n\n  loadTs().catch((e) => {\n    console.error(e);\n    document.getElementById('error').classList.remove('d-none');\n    document.getElementById('spinner').classList.remove('active');\n  });\n</script>\n\n```\n\nTypeScript to handle rendering the messages, to keep this simple (and at the risk of offending frontend developers) the typescript code is passed to the browser as plain text and transpiled in the browser.\n\n[chat_app.ts](https://github.com/pydantic/pydantic-ai/blob/main/examples/pydantic_ai_examples/chat_app.ts)\n\n```ts\n// BIG FAT WARNING: to avoid the complexity of npm, this typescript is compiled in the browser\n// there's currently no static type checking\n\nimport { marked } from 'https://cdnjs.cloudflare.com/ajax/libs/marked/15.0.0/lib/marked.esm.js'\nconst convElement = document.getElementById('conversation')\n\nconst promptInput = document.getElementById('prompt-input') as HTMLInputElement\nconst spinner = document.getElementById('spinner')\n\n// stream the response and render messages as each chunk is received\n// data is sent as newline-delimited JSON\nasync function onFetchResponse(response: Response): Promise<void> {\n  let text = ''\n  let decoder = new TextDecoder()\n  if (response.ok) {\n    const reader = response.body.getReader()\n    while (true) {\n      const {done, value} = await reader.read()\n      if (done) {\n        break\n      }\n      text += decoder.decode(value)\n      addMessages(text)\n      spinner.classList.remove('active')\n    }\n    addMessages(text)\n    promptInput.disabled = false\n    promptInput.focus()\n  } else {\n    const text = await response.text()\n    console.error(`Unexpected response: ${response.status}`, {response, text})\n    throw new Error(`Unexpected response: ${response.status}`)\n  }\n}\n\n// The format of messages, this matches pydantic-ai both for brevity and understanding\n// in production, you might not want to keep this format all the way to the frontend\ninterface Message {\n  role: string\n  content: string\n  timestamp: string\n}\n\n// take raw response text and render messages into the `#conversation` element\n// Message timestamp is assumed to be a unique identifier of a message, and is used to deduplicate\n// hence you can send data about the same message multiple times, and it will be updated\n// instead of creating a new message elements\nfunction addMessages(responseText: string) {\n  const lines = responseText.split('\\n')\n  const messages: Message[] = lines.filter(line => line.length > 1).map(j => JSON.parse(j))\n  for (const message of messages) {\n    // we use the timestamp as a crude element id\n    const {timestamp, role, content} = message\n    const id = `msg-${timestamp}`\n    let msgDiv = document.getElementById(id)\n    if (!msgDiv) {\n      msgDiv = document.createElement('div')\n      msgDiv.id = id\n      msgDiv.title = `${role} at ${timestamp}`\n      msgDiv.classList.add('border-top', 'pt-2', role)\n      convElement.appendChild(msgDiv)\n    }\n    msgDiv.innerHTML = marked.parse(content)\n  }\n  window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' })\n}\n\nfunction onError(error: any) {\n  console.error(error)\n  document.getElementById('error').classList.remove('d-none')\n  document.getElementById('spinner').classList.remove('active')\n}\n\nasync function onSubmit(e: SubmitEvent): Promise<void> {\n  e.preventDefault()\n  spinner.classList.add('active')\n  const body = new FormData(e.target as HTMLFormElement)\n\n  promptInput.value = ''\n  promptInput.disabled = true\n\n  const response = await fetch('/chat/', {method: 'POST', body})\n  await onFetchResponse(response)\n}\n\n// call onSubmit when the form is submitted (e.g. user clicks the send button or hits Enter)\ndocument.querySelector('form').addEventListener('submit', (e) => onSubmit(e).catch(onError))\n\n// load messages on page load\nfetch('/chat/').then(onFetchResponse).catch(onError)\n\n```",
  "content_length": 21630
}