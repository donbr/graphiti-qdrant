{
  "title": "`pydantic_ai.retries`",
  "source_url": null,
  "content": "Retries utilities based on tenacity, especially for HTTP requests.\n\nThis module provides HTTP transport wrappers and wait strategies that integrate with the tenacity library to add retry capabilities to HTTP requests. The transports can be used with HTTP clients that support custom transports (such as httpx), while the wait strategies can be used with any tenacity retry decorator.\n\nThe module includes:\n\n- TenacityTransport: Synchronous HTTP transport with retry capabilities\n- AsyncTenacityTransport: Asynchronous HTTP transport with retry capabilities\n- wait_retry_after: Wait strategy that respects HTTP Retry-After headers\n\n### RetryConfig\n\nBases: `TypedDict`\n\nThe configuration for tenacity-based retrying.\n\nThese are precisely the arguments to the tenacity `retry` decorator, and they are generally used internally by passing them to that decorator via `@retry(**config)` or similar.\n\nAll fields are optional, and if not provided, the default values from the `tenacity.retry` decorator will be used.\n\nSource code in `pydantic_ai_slim/pydantic_ai/retries.py`\n\n```python\nclass RetryConfig(TypedDict, total=False):\n    \"\"\"The configuration for tenacity-based retrying.\n\n    These are precisely the arguments to the tenacity `retry` decorator, and they are generally\n    used internally by passing them to that decorator via `@retry(**config)` or similar.\n\n    All fields are optional, and if not provided, the default values from the `tenacity.retry` decorator will be used.\n    \"\"\"\n\n    sleep: Callable[[int | float], None | Awaitable[None]]\n    \"\"\"A sleep strategy to use for sleeping between retries.\n\n    Tenacity's default for this argument is `tenacity.nap.sleep`.\"\"\"\n\n    stop: StopBaseT\n    \"\"\"\n    A stop strategy to determine when to stop retrying.\n\n    Tenacity's default for this argument is `tenacity.stop.stop_never`.\"\"\"\n\n    wait: WaitBaseT\n    \"\"\"\n    A wait strategy to determine how long to wait between retries.\n\n    Tenacity's default for this argument is `tenacity.wait.wait_none`.\"\"\"\n\n    retry: SyncRetryBaseT | RetryBaseT\n    \"\"\"A retry strategy to determine which exceptions should trigger a retry.\n\n    Tenacity's default for this argument is `tenacity.retry.retry_if_exception_type()`.\"\"\"\n\n    before: Callable[[RetryCallState], None | Awaitable[None]]\n    \"\"\"\n    A callable that is called before each retry attempt.\n\n    Tenacity's default for this argument is `tenacity.before.before_nothing`.\"\"\"\n\n    after: Callable[[RetryCallState], None | Awaitable[None]]\n    \"\"\"\n    A callable that is called after each retry attempt.\n\n    Tenacity's default for this argument is `tenacity.after.after_nothing`.\"\"\"\n\n    before_sleep: Callable[[RetryCallState], None | Awaitable[None]] | None\n    \"\"\"\n    An optional callable that is called before sleeping between retries.\n\n    Tenacity's default for this argument is `None`.\"\"\"\n\n    reraise: bool\n    \"\"\"Whether to reraise the last exception if the retry attempts are exhausted, or raise a RetryError instead.\n\n    Tenacity's default for this argument is `False`.\"\"\"\n\n    retry_error_cls: type[RetryError]\n    \"\"\"The exception class to raise when the retry attempts are exhausted and `reraise` is False.\n\n    Tenacity's default for this argument is `tenacity.RetryError`.\"\"\"\n\n    retry_error_callback: Callable[[RetryCallState], Any | Awaitable[Any]] | None\n    \"\"\"An optional callable that is called when the retry attempts are exhausted and `reraise` is False.\n\n    Tenacity's default for this argument is `None`.\"\"\"\n\n```\n\n#### sleep\n\n```python\nsleep: Callable[[int | float], None | Awaitable[None]]\n\n```\n\nA sleep strategy to use for sleeping between retries.\n\nTenacity's default for this argument is `tenacity.nap.sleep`.\n\n#### stop\n\n```python\nstop: StopBaseT\n\n```\n\nA stop strategy to determine when to stop retrying.\n\nTenacity's default for this argument is `tenacity.stop.stop_never`.\n\n#### wait\n\n```python\nwait: WaitBaseT\n\n```\n\nA wait strategy to determine how long to wait between retries.\n\nTenacity's default for this argument is `tenacity.wait.wait_none`.\n\n#### retry\n\n```python\nretry: RetryBaseT | RetryBaseT\n\n```\n\nA retry strategy to determine which exceptions should trigger a retry.\n\nTenacity's default for this argument is `tenacity.retry.retry_if_exception_type()`.\n\n#### before\n\n```python\nbefore: Callable[[RetryCallState], None | Awaitable[None]]\n\n```\n\nA callable that is called before each retry attempt.\n\nTenacity's default for this argument is `tenacity.before.before_nothing`.\n\n#### after\n\n```python\nafter: Callable[[RetryCallState], None | Awaitable[None]]\n\n```\n\nA callable that is called after each retry attempt.\n\nTenacity's default for this argument is `tenacity.after.after_nothing`.\n\n#### before_sleep\n\n```python\nbefore_sleep: (\n    Callable[[RetryCallState], None | Awaitable[None]]\n    | None\n)\n\n```\n\nAn optional callable that is called before sleeping between retries.\n\nTenacity's default for this argument is `None`.\n\n#### reraise\n\n```python\nreraise: bool\n\n```\n\nWhether to reraise the last exception if the retry attempts are exhausted, or raise a RetryError instead.\n\nTenacity's default for this argument is `False`.\n\n#### retry_error_cls\n\n```python\nretry_error_cls: type[RetryError]\n\n```\n\nThe exception class to raise when the retry attempts are exhausted and `reraise` is False.\n\nTenacity's default for this argument is `tenacity.RetryError`.\n\n#### retry_error_callback\n\n```python\nretry_error_callback: (\n    Callable[[RetryCallState], Any | Awaitable[Any]] | None\n)\n\n```\n\nAn optional callable that is called when the retry attempts are exhausted and `reraise` is False.\n\nTenacity's default for this argument is `None`.\n\n### TenacityTransport\n\nBases: `BaseTransport`\n\nSynchronous HTTP transport with tenacity-based retry functionality.\n\nThis transport wraps another BaseTransport and adds retry capabilities using the tenacity library. It can be configured to retry requests based on various conditions such as specific exception types, response status codes, or custom validation logic.\n\nThe transport works by intercepting HTTP requests and responses, allowing the tenacity controller to determine when and how to retry failed requests. The validate_response function can be used to convert HTTP responses into exceptions that trigger retries.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `wrapped` | `BaseTransport | None` | The underlying transport to wrap and add retry functionality to. | `None` | | `config` | `RetryConfig` | The arguments to use for the tenacity retry decorator, including retry conditions, wait strategy, stop conditions, etc. See the tenacity docs for more info. | *required* | | `validate_response` | `Callable[[Response], Any] | None` | Optional callable that takes a Response and can raise an exception to be handled by the controller if the response should trigger a retry. Common use case is to raise exceptions for certain HTTP status codes. If None, no response validation is performed. | `None` |\n\nExample\n\n```python\nfrom httpx import Client, HTTPStatusError, HTTPTransport\nfrom tenacity import retry_if_exception_type, stop_after_attempt\n\nfrom pydantic_ai.retries import RetryConfig, TenacityTransport, wait_retry_after\n\ntransport = TenacityTransport(\n    RetryConfig(\n        retry=retry_if_exception_type(HTTPStatusError),\n        wait=wait_retry_after(max_wait=300),\n        stop=stop_after_attempt(5),\n        reraise=True\n    ),\n    HTTPTransport(),\n    validate_response=lambda r: r.raise_for_status()\n)\nclient = Client(transport=transport)\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/retries.py`\n\n````python\nclass TenacityTransport(BaseTransport):\n    \"\"\"Synchronous HTTP transport with tenacity-based retry functionality.\n\n    This transport wraps another BaseTransport and adds retry capabilities using the tenacity library.\n    It can be configured to retry requests based on various conditions such as specific exception types,\n    response status codes, or custom validation logic.\n\n    The transport works by intercepting HTTP requests and responses, allowing the tenacity controller\n    to determine when and how to retry failed requests. The validate_response function can be used\n    to convert HTTP responses into exceptions that trigger retries.\n\n    Args:\n        wrapped: The underlying transport to wrap and add retry functionality to.\n        config: The arguments to use for the tenacity `retry` decorator, including retry conditions,\n            wait strategy, stop conditions, etc. See the tenacity docs for more info.\n        validate_response: Optional callable that takes a Response and can raise an exception\n            to be handled by the controller if the response should trigger a retry.\n            Common use case is to raise exceptions for certain HTTP status codes.\n            If None, no response validation is performed.\n\n    Example:\n        ```python\n        from httpx import Client, HTTPStatusError, HTTPTransport\n        from tenacity import retry_if_exception_type, stop_after_attempt\n\n        from pydantic_ai.retries import RetryConfig, TenacityTransport, wait_retry_after\n\n        transport = TenacityTransport(\n            RetryConfig(\n                retry=retry_if_exception_type(HTTPStatusError),\n                wait=wait_retry_after(max_wait=300),\n                stop=stop_after_attempt(5),\n                reraise=True\n            ),\n            HTTPTransport(),\n            validate_response=lambda r: r.raise_for_status()\n        )\n        client = Client(transport=transport)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        config: RetryConfig,\n        wrapped: BaseTransport | None = None,\n        validate_response: Callable[[Response], Any] | None = None,\n    ):\n        self.config = config\n        self.wrapped = wrapped or HTTPTransport()\n        self.validate_response = validate_response\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"Handle an HTTP request with retry logic.\n\n        Args:\n            request: The HTTP request to handle.\n\n        Returns:\n            The HTTP response.\n\n        Raises:\n            RuntimeError: If the retry controller did not make any attempts.\n            Exception: Any exception raised by the wrapped transport or validation function.\n        \"\"\"\n\n        @retry(**self.config)\n        def handle_request(req: Request) -> Response:\n            response = self.wrapped.handle_request(req)\n\n            # this is normally set by httpx _after_ calling this function, but we want the request in the validator:\n            response.request = req\n\n            if self.validate_response:\n                try:\n                    self.validate_response(response)\n                except Exception:\n                    response.close()\n                    raise\n            return response\n\n        return handle_request(request)\n\n    def __enter__(self) -> TenacityTransport:\n        self.wrapped.__enter__()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None = None,\n        exc_value: BaseException | None = None,\n        traceback: TracebackType | None = None,\n    ) -> None:\n        self.wrapped.__exit__(exc_type, exc_value, traceback)\n\n    def close(self) -> None:\n        self.wrapped.close()  # pragma: no cover\n\n````\n\n#### handle_request\n\n```python\nhandle_request(request: Request) -> Response\n\n```\n\nHandle an HTTP request with retry logic.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `request` | `Request` | The HTTP request to handle. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Response` | The HTTP response. |\n\nRaises:\n\n| Type | Description | | --- | --- | | `RuntimeError` | If the retry controller did not make any attempts. | | `Exception` | Any exception raised by the wrapped transport or validation function. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/retries.py`\n\n```python\ndef handle_request(self, request: Request) -> Response:\n    \"\"\"Handle an HTTP request with retry logic.\n\n    Args:\n        request: The HTTP request to handle.\n\n    Returns:\n        The HTTP response.\n\n    Raises:\n        RuntimeError: If the retry controller did not make any attempts.\n        Exception: Any exception raised by the wrapped transport or validation function.\n    \"\"\"\n\n    @retry(**self.config)\n    def handle_request(req: Request) -> Response:\n        response = self.wrapped.handle_request(req)\n\n        # this is normally set by httpx _after_ calling this function, but we want the request in the validator:\n        response.request = req\n\n        if self.validate_response:\n            try:\n                self.validate_response(response)\n            except Exception:\n                response.close()\n                raise\n        return response\n\n    return handle_request(request)\n\n```\n\n### AsyncTenacityTransport\n\nBases: `AsyncBaseTransport`\n\nAsynchronous HTTP transport with tenacity-based retry functionality.\n\nThis transport wraps another AsyncBaseTransport and adds retry capabilities using the tenacity library. It can be configured to retry requests based on various conditions such as specific exception types, response status codes, or custom validation logic.\n\nThe transport works by intercepting HTTP requests and responses, allowing the tenacity controller to determine when and how to retry failed requests. The validate_response function can be used to convert HTTP responses into exceptions that trigger retries.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `wrapped` | `AsyncBaseTransport | None` | The underlying async transport to wrap and add retry functionality to. | `None` | | `config` | `RetryConfig` | The arguments to use for the tenacity retry decorator, including retry conditions, wait strategy, stop conditions, etc. See the tenacity docs for more info. | *required* | | `validate_response` | `Callable[[Response], Any] | None` | Optional callable that takes a Response and can raise an exception to be handled by the controller if the response should trigger a retry. Common use case is to raise exceptions for certain HTTP status codes. If None, no response validation is performed. | `None` |\n\nExample\n\n```python\nfrom httpx import AsyncClient, HTTPStatusError\nfrom tenacity import retry_if_exception_type, stop_after_attempt\n\nfrom pydantic_ai.retries import AsyncTenacityTransport, RetryConfig, wait_retry_after\n\ntransport = AsyncTenacityTransport(\n    RetryConfig(\n        retry=retry_if_exception_type(HTTPStatusError),\n        wait=wait_retry_after(max_wait=300),\n        stop=stop_after_attempt(5),\n        reraise=True\n    ),\n    validate_response=lambda r: r.raise_for_status()\n)\nclient = AsyncClient(transport=transport)\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/retries.py`\n\n````python\nclass AsyncTenacityTransport(AsyncBaseTransport):\n    \"\"\"Asynchronous HTTP transport with tenacity-based retry functionality.\n\n    This transport wraps another AsyncBaseTransport and adds retry capabilities using the tenacity library.\n    It can be configured to retry requests based on various conditions such as specific exception types,\n    response status codes, or custom validation logic.\n\n    The transport works by intercepting HTTP requests and responses, allowing the tenacity controller\n    to determine when and how to retry failed requests. The validate_response function can be used\n    to convert HTTP responses into exceptions that trigger retries.\n\n    Args:\n        wrapped: The underlying async transport to wrap and add retry functionality to.\n        config: The arguments to use for the tenacity `retry` decorator, including retry conditions,\n            wait strategy, stop conditions, etc. See the tenacity docs for more info.\n        validate_response: Optional callable that takes a Response and can raise an exception\n            to be handled by the controller if the response should trigger a retry.\n            Common use case is to raise exceptions for certain HTTP status codes.\n            If None, no response validation is performed.\n\n    Example:\n        ```python\n        from httpx import AsyncClient, HTTPStatusError\n        from tenacity import retry_if_exception_type, stop_after_attempt\n\n        from pydantic_ai.retries import AsyncTenacityTransport, RetryConfig, wait_retry_after\n\n        transport = AsyncTenacityTransport(\n            RetryConfig(\n                retry=retry_if_exception_type(HTTPStatusError),\n                wait=wait_retry_after(max_wait=300),\n                stop=stop_after_attempt(5),\n                reraise=True\n            ),\n            validate_response=lambda r: r.raise_for_status()\n        )\n        client = AsyncClient(transport=transport)\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        config: RetryConfig,\n        wrapped: AsyncBaseTransport | None = None,\n        validate_response: Callable[[Response], Any] | None = None,\n    ):\n        self.config = config\n        self.wrapped = wrapped or AsyncHTTPTransport()\n        self.validate_response = validate_response\n\n    async def handle_async_request(self, request: Request) -> Response:\n        \"\"\"Handle an async HTTP request with retry logic.\n\n        Args:\n            request: The HTTP request to handle.\n\n        Returns:\n            The HTTP response.\n\n        Raises:\n            RuntimeError: If the retry controller did not make any attempts.\n            Exception: Any exception raised by the wrapped transport or validation function.\n        \"\"\"\n\n        @retry(**self.config)\n        async def handle_async_request(req: Request) -> Response:\n            response = await self.wrapped.handle_async_request(req)\n\n            # this is normally set by httpx _after_ calling this function, but we want the request in the validator:\n            response.request = req\n\n            if self.validate_response:\n                try:\n                    self.validate_response(response)\n                except Exception:\n                    await response.aclose()\n                    raise\n            return response\n\n        return await handle_async_request(request)\n\n    async def __aenter__(self) -> AsyncTenacityTransport:\n        await self.wrapped.__aenter__()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None = None,\n        exc_value: BaseException | None = None,\n        traceback: TracebackType | None = None,\n    ) -> None:\n        await self.wrapped.__aexit__(exc_type, exc_value, traceback)\n\n    async def aclose(self) -> None:\n        await self.wrapped.aclose()\n\n````\n\n#### handle_async_request\n\n```python\nhandle_async_request(request: Request) -> Response\n\n```\n\nHandle an async HTTP request with retry logic.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `request` | `Request` | The HTTP request to handle. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Response` | The HTTP response. |\n\nRaises:\n\n| Type | Description | | --- | --- | | `RuntimeError` | If the retry controller did not make any attempts. | | `Exception` | Any exception raised by the wrapped transport or validation function. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/retries.py`\n\n```python\nasync def handle_async_request(self, request: Request) -> Response:\n    \"\"\"Handle an async HTTP request with retry logic.\n\n    Args:\n        request: The HTTP request to handle.\n\n    Returns:\n        The HTTP response.\n\n    Raises:\n        RuntimeError: If the retry controller did not make any attempts.\n        Exception: Any exception raised by the wrapped transport or validation function.\n    \"\"\"\n\n    @retry(**self.config)\n    async def handle_async_request(req: Request) -> Response:\n        response = await self.wrapped.handle_async_request(req)\n\n        # this is normally set by httpx _after_ calling this function, but we want the request in the validator:\n        response.request = req\n\n        if self.validate_response:\n            try:\n                self.validate_response(response)\n            except Exception:\n                await response.aclose()\n                raise\n        return response\n\n    return await handle_async_request(request)\n\n```\n\n### wait_retry_after\n\n```python\nwait_retry_after(\n    fallback_strategy: (\n        Callable[[RetryCallState], float] | None\n    ) = None,\n    max_wait: float = 300,\n) -> Callable[[RetryCallState], float]\n\n```\n\nCreate a tenacity-compatible wait strategy that respects HTTP Retry-After headers.\n\nThis wait strategy checks if the exception contains an HTTPStatusError with a Retry-After header, and if so, waits for the time specified in the header. If no header is present or parsing fails, it falls back to the provided strategy.\n\nThe Retry-After header can be in two formats:\n\n- An integer representing seconds to wait\n- An HTTP date string representing when to retry\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `fallback_strategy` | `Callable[[RetryCallState], float] | None` | Wait strategy to use when no Retry-After header is present or parsing fails. Defaults to exponential backoff with max 60s. | `None` | | `max_wait` | `float` | Maximum time to wait in seconds, regardless of header value. Defaults to 300 (5 minutes). | `300` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Callable[[RetryCallState], float]` | A wait function that can be used with tenacity retry decorators. |\n\nExample\n\n```python\nfrom httpx import AsyncClient, HTTPStatusError\nfrom tenacity import retry_if_exception_type, stop_after_attempt\n\nfrom pydantic_ai.retries import AsyncTenacityTransport, RetryConfig, wait_retry_after\n\ntransport = AsyncTenacityTransport(\n    RetryConfig(\n        retry=retry_if_exception_type(HTTPStatusError),\n        wait=wait_retry_after(max_wait=120),\n        stop=stop_after_attempt(5),\n        reraise=True\n    ),\n    validate_response=lambda r: r.raise_for_status()\n)\nclient = AsyncClient(transport=transport)\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/retries.py`\n\n````python\ndef wait_retry_after(\n    fallback_strategy: Callable[[RetryCallState], float] | None = None, max_wait: float = 300\n) -> Callable[[RetryCallState], float]:\n    \"\"\"Create a tenacity-compatible wait strategy that respects HTTP Retry-After headers.\n\n    This wait strategy checks if the exception contains an HTTPStatusError with a\n    Retry-After header, and if so, waits for the time specified in the header.\n    If no header is present or parsing fails, it falls back to the provided strategy.\n\n    The Retry-After header can be in two formats:\n    - An integer representing seconds to wait\n    - An HTTP date string representing when to retry\n\n    Args:\n        fallback_strategy: Wait strategy to use when no Retry-After header is present\n                          or parsing fails. Defaults to exponential backoff with max 60s.\n        max_wait: Maximum time to wait in seconds, regardless of header value.\n                 Defaults to 300 (5 minutes).\n\n    Returns:\n        A wait function that can be used with tenacity retry decorators.\n\n    Example:\n        ```python\n        from httpx import AsyncClient, HTTPStatusError\n        from tenacity import retry_if_exception_type, stop_after_attempt\n\n        from pydantic_ai.retries import AsyncTenacityTransport, RetryConfig, wait_retry_after\n\n        transport = AsyncTenacityTransport(\n            RetryConfig(\n                retry=retry_if_exception_type(HTTPStatusError),\n                wait=wait_retry_after(max_wait=120),\n                stop=stop_after_attempt(5),\n                reraise=True\n            ),\n            validate_response=lambda r: r.raise_for_status()\n        )\n        client = AsyncClient(transport=transport)\n        ```\n    \"\"\"\n    if fallback_strategy is None:\n        fallback_strategy = wait_exponential(multiplier=1, max=60)\n\n    def wait_func(state: RetryCallState) -> float:\n        exc = state.outcome.exception() if state.outcome else None\n        if isinstance(exc, HTTPStatusError):\n            retry_after = exc.response.headers.get('retry-after')\n            if retry_after:\n                try:\n                    # Try parsing as seconds first\n                    wait_seconds = int(retry_after)\n                    return min(float(wait_seconds), max_wait)\n                except ValueError:\n                    # Try parsing as HTTP date\n                    try:\n                        retry_time = cast(datetime, parsedate_to_datetime(retry_after))\n                        assert isinstance(retry_time, datetime)\n                        now = datetime.now(timezone.utc)\n                        wait_seconds = (retry_time - now).total_seconds()\n\n                        if wait_seconds > 0:\n                            return min(wait_seconds, max_wait)\n                    except (ValueError, TypeError, AssertionError):\n                        # If date parsing fails, fall back to fallback strategy\n                        pass\n\n        # Use fallback strategy\n        return fallback_strategy(state)\n\n    return wait_func\n\n````",
  "content_length": 25123
}