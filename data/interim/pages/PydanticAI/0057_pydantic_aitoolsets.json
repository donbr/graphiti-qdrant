{
  "title": "`pydantic_ai.toolsets`",
  "source_url": null,
  "content": "### AbstractToolset\n\nBases: `ABC`, `Generic[AgentDepsT]`\n\nA toolset is a collection of tools that can be used by an agent.\n\nIt is responsible for:\n\n- Listing the tools it contains\n- Validating the arguments of the tools\n- Calling the tools\n\nSee [toolset docs](../../toolsets/) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\nclass AbstractToolset(ABC, Generic[AgentDepsT]):\n    \"\"\"A toolset is a collection of tools that can be used by an agent.\n\n    It is responsible for:\n\n    - Listing the tools it contains\n    - Validating the arguments of the tools\n    - Calling the tools\n\n    See [toolset docs](../toolsets.md) for more information.\n    \"\"\"\n\n    @property\n    @abstractmethod\n    def id(self) -> str | None:\n        \"\"\"An ID for the toolset that is unique among all toolsets registered with the same agent.\n\n        If you're implementing a concrete implementation that users can instantiate more than once, you should let them optionally pass a custom ID to the constructor and return that here.\n\n        A toolset needs to have an ID in order to be used in a durable execution environment like Temporal, in which case the ID will be used to identify the toolset's activities within the workflow.\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def label(self) -> str:\n        \"\"\"The name of the toolset for use in error messages.\"\"\"\n        label = self.__class__.__name__\n        if self.id:  # pragma: no branch\n            label += f' {self.id!r}'\n        return label\n\n    @property\n    def tool_name_conflict_hint(self) -> str:\n        \"\"\"A hint for how to avoid name conflicts with other toolsets for use in error messages.\"\"\"\n        return 'Rename the tool or wrap the toolset in a `PrefixedToolset` to avoid name conflicts.'\n\n    async def __aenter__(self) -> Self:\n        \"\"\"Enter the toolset context.\n\n        This is where you can set up network connections in a concrete implementation.\n        \"\"\"\n        return self\n\n    async def __aexit__(self, *args: Any) -> bool | None:\n        \"\"\"Exit the toolset context.\n\n        This is where you can tear down network connections in a concrete implementation.\n        \"\"\"\n        return None\n\n    @abstractmethod\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        \"\"\"The tools that are available in this toolset.\"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def call_tool(\n        self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n    ) -> Any:\n        \"\"\"Call a tool with the given arguments.\n\n        Args:\n            name: The name of the tool to call.\n            tool_args: The arguments to pass to the tool.\n            ctx: The run context.\n            tool: The tool definition returned by [`get_tools`][pydantic_ai.toolsets.AbstractToolset.get_tools] that was called.\n        \"\"\"\n        raise NotImplementedError()\n\n    def apply(self, visitor: Callable[[AbstractToolset[AgentDepsT]], None]) -> None:\n        \"\"\"Run a visitor function on all \"leaf\" toolsets (i.e. those that implement their own tool listing and calling).\"\"\"\n        visitor(self)\n\n    def visit_and_replace(\n        self, visitor: Callable[[AbstractToolset[AgentDepsT]], AbstractToolset[AgentDepsT]]\n    ) -> AbstractToolset[AgentDepsT]:\n        \"\"\"Run a visitor function on all \"leaf\" toolsets (i.e. those that implement their own tool listing and calling) and replace them in the hierarchy with the result of the function.\"\"\"\n        return visitor(self)\n\n    def filtered(\n        self, filter_func: Callable[[RunContext[AgentDepsT], ToolDefinition], bool]\n    ) -> FilteredToolset[AgentDepsT]:\n        \"\"\"Returns a new toolset that filters this toolset's tools using a filter function that takes the agent context and the tool definition.\n\n        See [toolset docs](../toolsets.md#filtering-tools) for more information.\n        \"\"\"\n        from .filtered import FilteredToolset\n\n        return FilteredToolset(self, filter_func)\n\n    def prefixed(self, prefix: str) -> PrefixedToolset[AgentDepsT]:\n        \"\"\"Returns a new toolset that prefixes the names of this toolset's tools.\n\n        See [toolset docs](../toolsets.md#prefixing-tool-names) for more information.\n        \"\"\"\n        from .prefixed import PrefixedToolset\n\n        return PrefixedToolset(self, prefix)\n\n    def prepared(self, prepare_func: ToolsPrepareFunc[AgentDepsT]) -> PreparedToolset[AgentDepsT]:\n        \"\"\"Returns a new toolset that prepares this toolset's tools using a prepare function that takes the agent context and the original tool definitions.\n\n        See [toolset docs](../toolsets.md#preparing-tool-definitions) for more information.\n        \"\"\"\n        from .prepared import PreparedToolset\n\n        return PreparedToolset(self, prepare_func)\n\n    def renamed(self, name_map: dict[str, str]) -> RenamedToolset[AgentDepsT]:\n        \"\"\"Returns a new toolset that renames this toolset's tools using a dictionary mapping new names to original names.\n\n        See [toolset docs](../toolsets.md#renaming-tools) for more information.\n        \"\"\"\n        from .renamed import RenamedToolset\n\n        return RenamedToolset(self, name_map)\n\n    def approval_required(\n        self,\n        approval_required_func: Callable[[RunContext[AgentDepsT], ToolDefinition, dict[str, Any]], bool] = (\n            lambda ctx, tool_def, tool_args: True\n        ),\n    ) -> ApprovalRequiredToolset[AgentDepsT]:\n        \"\"\"Returns a new toolset that requires (some) calls to tools it contains to be approved.\n\n        See [toolset docs](../toolsets.md#requiring-tool-approval) for more information.\n        \"\"\"\n        from .approval_required import ApprovalRequiredToolset\n\n        return ApprovalRequiredToolset(self, approval_required_func)\n\n```\n\n#### id\n\n```python\nid: str | None\n\n```\n\nAn ID for the toolset that is unique among all toolsets registered with the same agent.\n\nIf you're implementing a concrete implementation that users can instantiate more than once, you should let them optionally pass a custom ID to the constructor and return that here.\n\nA toolset needs to have an ID in order to be used in a durable execution environment like Temporal, in which case the ID will be used to identify the toolset's activities within the workflow.\n\n#### label\n\n```python\nlabel: str\n\n```\n\nThe name of the toolset for use in error messages.\n\n#### tool_name_conflict_hint\n\n```python\ntool_name_conflict_hint: str\n\n```\n\nA hint for how to avoid name conflicts with other toolsets for use in error messages.\n\n#### __aenter__\n\n```python\n__aenter__() -> Self\n\n```\n\nEnter the toolset context.\n\nThis is where you can set up network connections in a concrete implementation.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\nasync def __aenter__(self) -> Self:\n    \"\"\"Enter the toolset context.\n\n    This is where you can set up network connections in a concrete implementation.\n    \"\"\"\n    return self\n\n```\n\n#### __aexit__\n\n```python\n__aexit__(*args: Any) -> bool | None\n\n```\n\nExit the toolset context.\n\nThis is where you can tear down network connections in a concrete implementation.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\nasync def __aexit__(self, *args: Any) -> bool | None:\n    \"\"\"Exit the toolset context.\n\n    This is where you can tear down network connections in a concrete implementation.\n    \"\"\"\n    return None\n\n```\n\n#### get_tools\n\n```python\nget_tools(\n    ctx: RunContext[AgentDepsT],\n) -> dict[str, ToolsetTool[AgentDepsT]]\n\n```\n\nThe tools that are available in this toolset.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\n@abstractmethod\nasync def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n    \"\"\"The tools that are available in this toolset.\"\"\"\n    raise NotImplementedError()\n\n```\n\n#### call_tool\n\n```python\ncall_tool(\n    name: str,\n    tool_args: dict[str, Any],\n    ctx: RunContext[AgentDepsT],\n    tool: ToolsetTool[AgentDepsT],\n) -> Any\n\n```\n\nCall a tool with the given arguments.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `name` | `str` | The name of the tool to call. | *required* | | `tool_args` | `dict[str, Any]` | The arguments to pass to the tool. | *required* | | `ctx` | `RunContext[AgentDepsT]` | The run context. | *required* | | `tool` | `ToolsetTool[AgentDepsT]` | The tool definition returned by get_tools that was called. | *required* |\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\n@abstractmethod\nasync def call_tool(\n    self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n) -> Any:\n    \"\"\"Call a tool with the given arguments.\n\n    Args:\n        name: The name of the tool to call.\n        tool_args: The arguments to pass to the tool.\n        ctx: The run context.\n        tool: The tool definition returned by [`get_tools`][pydantic_ai.toolsets.AbstractToolset.get_tools] that was called.\n    \"\"\"\n    raise NotImplementedError()\n\n```\n\n#### apply\n\n```python\napply(\n    visitor: Callable[[AbstractToolset[AgentDepsT]], None],\n) -> None\n\n```\n\nRun a visitor function on all \"leaf\" toolsets (i.e. those that implement their own tool listing and calling).\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\ndef apply(self, visitor: Callable[[AbstractToolset[AgentDepsT]], None]) -> None:\n    \"\"\"Run a visitor function on all \"leaf\" toolsets (i.e. those that implement their own tool listing and calling).\"\"\"\n    visitor(self)\n\n```\n\n#### visit_and_replace\n\n```python\nvisit_and_replace(\n    visitor: Callable[\n        [AbstractToolset[AgentDepsT]],\n        AbstractToolset[AgentDepsT],\n    ],\n) -> AbstractToolset[AgentDepsT]\n\n```\n\nRun a visitor function on all \"leaf\" toolsets (i.e. those that implement their own tool listing and calling) and replace them in the hierarchy with the result of the function.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\ndef visit_and_replace(\n    self, visitor: Callable[[AbstractToolset[AgentDepsT]], AbstractToolset[AgentDepsT]]\n) -> AbstractToolset[AgentDepsT]:\n    \"\"\"Run a visitor function on all \"leaf\" toolsets (i.e. those that implement their own tool listing and calling) and replace them in the hierarchy with the result of the function.\"\"\"\n    return visitor(self)\n\n```\n\n#### filtered\n\n```python\nfiltered(\n    filter_func: Callable[\n        [RunContext[AgentDepsT], ToolDefinition], bool\n    ],\n) -> FilteredToolset[AgentDepsT]\n\n```\n\nReturns a new toolset that filters this toolset's tools using a filter function that takes the agent context and the tool definition.\n\nSee [toolset docs](../../toolsets/#filtering-tools) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\ndef filtered(\n    self, filter_func: Callable[[RunContext[AgentDepsT], ToolDefinition], bool]\n) -> FilteredToolset[AgentDepsT]:\n    \"\"\"Returns a new toolset that filters this toolset's tools using a filter function that takes the agent context and the tool definition.\n\n    See [toolset docs](../toolsets.md#filtering-tools) for more information.\n    \"\"\"\n    from .filtered import FilteredToolset\n\n    return FilteredToolset(self, filter_func)\n\n```\n\n#### prefixed\n\n```python\nprefixed(prefix: str) -> PrefixedToolset[AgentDepsT]\n\n```\n\nReturns a new toolset that prefixes the names of this toolset's tools.\n\nSee [toolset docs](../../toolsets/#prefixing-tool-names) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\ndef prefixed(self, prefix: str) -> PrefixedToolset[AgentDepsT]:\n    \"\"\"Returns a new toolset that prefixes the names of this toolset's tools.\n\n    See [toolset docs](../toolsets.md#prefixing-tool-names) for more information.\n    \"\"\"\n    from .prefixed import PrefixedToolset\n\n    return PrefixedToolset(self, prefix)\n\n```\n\n#### prepared\n\n```python\nprepared(\n    prepare_func: ToolsPrepareFunc[AgentDepsT],\n) -> PreparedToolset[AgentDepsT]\n\n```\n\nReturns a new toolset that prepares this toolset's tools using a prepare function that takes the agent context and the original tool definitions.\n\nSee [toolset docs](../../toolsets/#preparing-tool-definitions) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\ndef prepared(self, prepare_func: ToolsPrepareFunc[AgentDepsT]) -> PreparedToolset[AgentDepsT]:\n    \"\"\"Returns a new toolset that prepares this toolset's tools using a prepare function that takes the agent context and the original tool definitions.\n\n    See [toolset docs](../toolsets.md#preparing-tool-definitions) for more information.\n    \"\"\"\n    from .prepared import PreparedToolset\n\n    return PreparedToolset(self, prepare_func)\n\n```\n\n#### renamed\n\n```python\nrenamed(\n    name_map: dict[str, str],\n) -> RenamedToolset[AgentDepsT]\n\n```\n\nReturns a new toolset that renames this toolset's tools using a dictionary mapping new names to original names.\n\nSee [toolset docs](../../toolsets/#renaming-tools) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\ndef renamed(self, name_map: dict[str, str]) -> RenamedToolset[AgentDepsT]:\n    \"\"\"Returns a new toolset that renames this toolset's tools using a dictionary mapping new names to original names.\n\n    See [toolset docs](../toolsets.md#renaming-tools) for more information.\n    \"\"\"\n    from .renamed import RenamedToolset\n\n    return RenamedToolset(self, name_map)\n\n```\n\n#### approval_required\n\n```python\napproval_required(\n    approval_required_func: Callable[\n        [\n            RunContext[AgentDepsT],\n            ToolDefinition,\n            dict[str, Any],\n        ],\n        bool,\n    ] = lambda ctx, tool_def, tool_args: True\n) -> ApprovalRequiredToolset[AgentDepsT]\n\n```\n\nReturns a new toolset that requires (some) calls to tools it contains to be approved.\n\nSee [toolset docs](../../toolsets/#requiring-tool-approval) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/abstract.py`\n\n```python\ndef approval_required(\n    self,\n    approval_required_func: Callable[[RunContext[AgentDepsT], ToolDefinition, dict[str, Any]], bool] = (\n        lambda ctx, tool_def, tool_args: True\n    ),\n) -> ApprovalRequiredToolset[AgentDepsT]:\n    \"\"\"Returns a new toolset that requires (some) calls to tools it contains to be approved.\n\n    See [toolset docs](../toolsets.md#requiring-tool-approval) for more information.\n    \"\"\"\n    from .approval_required import ApprovalRequiredToolset\n\n    return ApprovalRequiredToolset(self, approval_required_func)\n\n```\n\n### CombinedToolset\n\nBases: `AbstractToolset[AgentDepsT]`\n\nA toolset that combines multiple toolsets.\n\nSee [toolset docs](../../toolsets/#combining-toolsets) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/combined.py`\n\n```python\n@dataclass\nclass CombinedToolset(AbstractToolset[AgentDepsT]):\n    \"\"\"A toolset that combines multiple toolsets.\n\n    See [toolset docs](../toolsets.md#combining-toolsets) for more information.\n    \"\"\"\n\n    toolsets: Sequence[AbstractToolset[AgentDepsT]]\n\n    _enter_lock: Lock = field(compare=False, init=False, default_factory=Lock)\n    _entered_count: int = field(init=False, default=0)\n    _exit_stack: AsyncExitStack | None = field(init=False, default=None)\n\n    @property\n    def id(self) -> str | None:\n        return None  # pragma: no cover\n\n    @property\n    def label(self) -> str:\n        return f'{self.__class__.__name__}({\", \".join(toolset.label for toolset in self.toolsets)})'  # pragma: no cover\n\n    async def __aenter__(self) -> Self:\n        async with self._enter_lock:\n            if self._entered_count == 0:\n                async with AsyncExitStack() as exit_stack:\n                    for toolset in self.toolsets:\n                        await exit_stack.enter_async_context(toolset)\n                    self._exit_stack = exit_stack.pop_all()\n            self._entered_count += 1\n        return self\n\n    async def __aexit__(self, *args: Any) -> bool | None:\n        async with self._enter_lock:\n            self._entered_count -= 1\n            if self._entered_count == 0 and self._exit_stack is not None:\n                await self._exit_stack.aclose()\n                self._exit_stack = None\n\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        toolsets_tools = await asyncio.gather(*(toolset.get_tools(ctx) for toolset in self.toolsets))\n        all_tools: dict[str, ToolsetTool[AgentDepsT]] = {}\n\n        for toolset, tools in zip(self.toolsets, toolsets_tools):\n            for name, tool in tools.items():\n                tool_toolset = tool.toolset\n                if existing_tool := all_tools.get(name):\n                    capitalized_toolset_label = tool_toolset.label[0].upper() + tool_toolset.label[1:]\n                    raise UserError(\n                        f'{capitalized_toolset_label} defines a tool whose name conflicts with existing tool from {existing_tool.toolset.label}: {name!r}. {toolset.tool_name_conflict_hint}'\n                    )\n\n                all_tools[name] = _CombinedToolsetTool(\n                    toolset=tool_toolset,\n                    tool_def=tool.tool_def,\n                    max_retries=tool.max_retries,\n                    args_validator=tool.args_validator,\n                    source_toolset=toolset,\n                    source_tool=tool,\n                )\n        return all_tools\n\n    async def call_tool(\n        self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n    ) -> Any:\n        assert isinstance(tool, _CombinedToolsetTool)\n        return await tool.source_toolset.call_tool(name, tool_args, ctx, tool.source_tool)\n\n    def apply(self, visitor: Callable[[AbstractToolset[AgentDepsT]], None]) -> None:\n        for toolset in self.toolsets:\n            toolset.apply(visitor)\n\n    def visit_and_replace(\n        self, visitor: Callable[[AbstractToolset[AgentDepsT]], AbstractToolset[AgentDepsT]]\n    ) -> AbstractToolset[AgentDepsT]:\n        return replace(self, toolsets=[toolset.visit_and_replace(visitor) for toolset in self.toolsets])\n\n```\n\n### ExternalToolset\n\nBases: `AbstractToolset[AgentDepsT]`\n\nA toolset that holds tools whose results will be produced outside of the Pydantic AI agent run in which they were called.\n\nSee [toolset docs](../../toolsets/#external-toolset) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/external.py`\n\n```python\nclass ExternalToolset(AbstractToolset[AgentDepsT]):\n    \"\"\"A toolset that holds tools whose results will be produced outside of the Pydantic AI agent run in which they were called.\n\n    See [toolset docs](../toolsets.md#external-toolset) for more information.\n    \"\"\"\n\n    tool_defs: list[ToolDefinition]\n    _id: str | None\n\n    def __init__(self, tool_defs: list[ToolDefinition], *, id: str | None = None):\n        self.tool_defs = tool_defs\n        self._id = id\n\n    @property\n    def id(self) -> str | None:\n        return self._id\n\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        return {\n            tool_def.name: ToolsetTool(\n                toolset=self,\n                tool_def=replace(tool_def, kind='external'),\n                max_retries=0,\n                args_validator=TOOL_SCHEMA_VALIDATOR,\n            )\n            for tool_def in self.tool_defs\n        }\n\n    async def call_tool(\n        self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n    ) -> Any:\n        raise NotImplementedError('External tools cannot be called directly')\n\n```\n\n### ApprovalRequiredToolset\n\nBases: `WrapperToolset[AgentDepsT]`\n\nA toolset that requires (some) calls to tools it contains to be approved.\n\nSee [toolset docs](../../toolsets/#requiring-tool-approval) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/approval_required.py`\n\n```python\n@dataclass\nclass ApprovalRequiredToolset(WrapperToolset[AgentDepsT]):\n    \"\"\"A toolset that requires (some) calls to tools it contains to be approved.\n\n    See [toolset docs](../toolsets.md#requiring-tool-approval) for more information.\n    \"\"\"\n\n    approval_required_func: Callable[[RunContext[AgentDepsT], ToolDefinition, dict[str, Any]], bool] = (\n        lambda ctx, tool_def, tool_args: True\n    )\n\n    async def call_tool(\n        self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n    ) -> Any:\n        if not ctx.tool_call_approved and self.approval_required_func(ctx, tool.tool_def, tool_args):\n            raise ApprovalRequired\n\n        return await super().call_tool(name, tool_args, ctx, tool)\n\n```\n\n### FilteredToolset\n\nBases: `WrapperToolset[AgentDepsT]`\n\nA toolset that filters the tools it contains using a filter function that takes the agent context and the tool definition.\n\nSee [toolset docs](../../toolsets/#filtering-tools) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/filtered.py`\n\n```python\n@dataclass\nclass FilteredToolset(WrapperToolset[AgentDepsT]):\n    \"\"\"A toolset that filters the tools it contains using a filter function that takes the agent context and the tool definition.\n\n    See [toolset docs](../toolsets.md#filtering-tools) for more information.\n    \"\"\"\n\n    filter_func: Callable[[RunContext[AgentDepsT], ToolDefinition], bool]\n\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        return {\n            name: tool for name, tool in (await super().get_tools(ctx)).items() if self.filter_func(ctx, tool.tool_def)\n        }\n\n```\n\n### FunctionToolset\n\nBases: `AbstractToolset[AgentDepsT]`\n\nA toolset that lets Python functions be used as tools.\n\nSee [toolset docs](../../toolsets/#function-toolset) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`\n\n````python\nclass FunctionToolset(AbstractToolset[AgentDepsT]):\n    \"\"\"A toolset that lets Python functions be used as tools.\n\n    See [toolset docs](../toolsets.md#function-toolset) for more information.\n    \"\"\"\n\n    tools: dict[str, Tool[Any]]\n    max_retries: int\n    _id: str | None\n    docstring_format: DocstringFormat\n    require_parameter_descriptions: bool\n    schema_generator: type[GenerateJsonSchema]\n\n    def __init__(\n        self,\n        tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] = [],\n        *,\n        max_retries: int = 1,\n        docstring_format: DocstringFormat = 'auto',\n        require_parameter_descriptions: bool = False,\n        schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n        strict: bool | None = None,\n        sequential: bool = False,\n        requires_approval: bool = False,\n        metadata: dict[str, Any] | None = None,\n        id: str | None = None,\n    ):\n        \"\"\"Build a new function toolset.\n\n        Args:\n            tools: The tools to add to the toolset.\n            max_retries: The maximum number of retries for each tool during a run.\n                Applies to all tools, unless overridden when adding a tool.\n            docstring_format: Format of tool docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n                Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.\n                Applies to all tools, unless overridden when adding a tool.\n            require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.\n                Applies to all tools, unless overridden when adding a tool.\n            schema_generator: The JSON schema generator class to use for this tool. Defaults to `GenerateToolJsonSchema`.\n                Applies to all tools, unless overridden when adding a tool.\n            strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n                See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n            sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n                Applies to all tools, unless overridden when adding a tool.\n            requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n                See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n                Applies to all tools, unless overridden when adding a tool.\n            metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n                Applies to all tools, unless overridden when adding a tool, which will be merged with the toolset's metadata.\n            id: An optional unique ID for the toolset. A toolset needs to have an ID in order to be used in a durable execution environment like Temporal,\n                in which case the ID will be used to identify the toolset's activities within the workflow.\n        \"\"\"\n        self.max_retries = max_retries\n        self._id = id\n        self.docstring_format = docstring_format\n        self.require_parameter_descriptions = require_parameter_descriptions\n        self.schema_generator = schema_generator\n        self.strict = strict\n        self.sequential = sequential\n        self.requires_approval = requires_approval\n        self.metadata = metadata\n\n        self.tools = {}\n        for tool in tools:\n            if isinstance(tool, Tool):\n                self.add_tool(tool)\n            else:\n                self.add_function(tool)\n\n    @property\n    def id(self) -> str | None:\n        return self._id\n\n    @overload\n    def tool(self, func: ToolFuncEither[AgentDepsT, ToolParams], /) -> ToolFuncEither[AgentDepsT, ToolParams]: ...\n\n    @overload\n    def tool(\n        self,\n        /,\n        *,\n        name: str | None = None,\n        description: str | None = None,\n        retries: int | None = None,\n        prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n        docstring_format: DocstringFormat | None = None,\n        require_parameter_descriptions: bool | None = None,\n        schema_generator: type[GenerateJsonSchema] | None = None,\n        strict: bool | None = None,\n        sequential: bool | None = None,\n        requires_approval: bool | None = None,\n        metadata: dict[str, Any] | None = None,\n    ) -> Callable[[ToolFuncEither[AgentDepsT, ToolParams]], ToolFuncEither[AgentDepsT, ToolParams]]: ...\n\n    def tool(\n        self,\n        func: ToolFuncEither[AgentDepsT, ToolParams] | None = None,\n        /,\n        *,\n        name: str | None = None,\n        description: str | None = None,\n        retries: int | None = None,\n        prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n        docstring_format: DocstringFormat | None = None,\n        require_parameter_descriptions: bool | None = None,\n        schema_generator: type[GenerateJsonSchema] | None = None,\n        strict: bool | None = None,\n        sequential: bool | None = None,\n        requires_approval: bool | None = None,\n        metadata: dict[str, Any] | None = None,\n    ) -> Any:\n        \"\"\"Decorator to register a tool function which takes [`RunContext`][pydantic_ai.tools.RunContext] as its first argument.\n\n        Can decorate a sync or async functions.\n\n        The docstring is inspected to extract both the tool description and description of each parameter,\n        [learn more](../tools.md#function-tools-and-schema).\n\n        We can't add overloads for every possible signature of tool, since the return type is a recursive union\n        so the signature of functions decorated with `@toolset.tool` is obscured.\n\n        Example:\n        ```python\n        from pydantic_ai import Agent, FunctionToolset, RunContext\n\n        toolset = FunctionToolset()\n\n        @toolset.tool\n        def foobar(ctx: RunContext[int], x: int) -> int:\n            return ctx.deps + x\n\n        @toolset.tool(retries=2)\n        async def spam(ctx: RunContext[str], y: float) -> float:\n            return ctx.deps + y\n\n        agent = Agent('test', toolsets=[toolset], deps_type=int)\n        result = agent.run_sync('foobar', deps=1)\n        print(result.output)\n        #> {\"foobar\":1,\"spam\":1.0}\n        ```\n\n        Args:\n            func: The tool function to register.\n            name: The name of the tool, defaults to the function name.\n            description: The description of the tool,defaults to the function docstring.\n            retries: The number of retries to allow for this tool, defaults to the agent's default retries,\n                which defaults to 1.\n            prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n                tool from a given step. This is useful if you want to customise a tool at call time,\n                or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n            docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n                If `None`, the default value is determined by the toolset.\n            require_parameter_descriptions: If True, raise an error if a parameter description is missing.\n                If `None`, the default value is determined by the toolset.\n            schema_generator: The JSON schema generator class to use for this tool.\n                If `None`, the default value is determined by the toolset.\n            strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n                See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n                If `None`, the default value is determined by the toolset.\n            sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n                If `None`, the default value is determined by the toolset.\n            requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n                See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n                If `None`, the default value is determined by the toolset.\n            metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n                If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata.\n        \"\"\"\n\n        def tool_decorator(\n            func_: ToolFuncEither[AgentDepsT, ToolParams],\n        ) -> ToolFuncEither[AgentDepsT, ToolParams]:\n            # noinspection PyTypeChecker\n            self.add_function(\n                func=func_,\n                takes_ctx=None,\n                name=name,\n                description=description,\n                retries=retries,\n                prepare=prepare,\n                docstring_format=docstring_format,\n                require_parameter_descriptions=require_parameter_descriptions,\n                schema_generator=schema_generator,\n                strict=strict,\n                sequential=sequential,\n                requires_approval=requires_approval,\n                metadata=metadata,\n            )\n            return func_\n\n        return tool_decorator if func is None else tool_decorator(func)\n\n    def add_function(\n        self,\n        func: ToolFuncEither[AgentDepsT, ToolParams],\n        takes_ctx: bool | None = None,\n        name: str | None = None,\n        description: str | None = None,\n        retries: int | None = None,\n        prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n        docstring_format: DocstringFormat | None = None,\n        require_parameter_descriptions: bool | None = None,\n        schema_generator: type[GenerateJsonSchema] | None = None,\n        strict: bool | None = None,\n        sequential: bool | None = None,\n        requires_approval: bool | None = None,\n        metadata: dict[str, Any] | None = None,\n    ) -> None:\n        \"\"\"Add a function as a tool to the toolset.\n\n        Can take a sync or async function.\n\n        The docstring is inspected to extract both the tool description and description of each parameter,\n        [learn more](../tools.md#function-tools-and-schema).\n\n        Args:\n            func: The tool function to register.\n            takes_ctx: Whether the function takes a [`RunContext`][pydantic_ai.tools.RunContext] as its first argument. If `None`, this is inferred from the function signature.\n            name: The name of the tool, defaults to the function name.\n            description: The description of the tool, defaults to the function docstring.\n            retries: The number of retries to allow for this tool, defaults to the agent's default retries,\n                which defaults to 1.\n            prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n                tool from a given step. This is useful if you want to customise a tool at call time,\n                or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n            docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n                If `None`, the default value is determined by the toolset.\n            require_parameter_descriptions: If True, raise an error if a parameter description is missing.\n                If `None`, the default value is determined by the toolset.\n            schema_generator: The JSON schema generator class to use for this tool.\n                If `None`, the default value is determined by the toolset.\n            strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n                See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n                If `None`, the default value is determined by the toolset.\n            sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n                If `None`, the default value is determined by the toolset.\n            requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n                See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n                If `None`, the default value is determined by the toolset.\n            metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n                If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata.\n        \"\"\"\n        if docstring_format is None:\n            docstring_format = self.docstring_format\n        if require_parameter_descriptions is None:\n            require_parameter_descriptions = self.require_parameter_descriptions\n        if schema_generator is None:\n            schema_generator = self.schema_generator\n        if strict is None:\n            strict = self.strict\n        if sequential is None:\n            sequential = self.sequential\n        if requires_approval is None:\n            requires_approval = self.requires_approval\n\n        tool = Tool[AgentDepsT](\n            func,\n            takes_ctx=takes_ctx,\n            name=name,\n            description=description,\n            max_retries=retries,\n            prepare=prepare,\n            docstring_format=docstring_format,\n            require_parameter_descriptions=require_parameter_descriptions,\n            schema_generator=schema_generator,\n            strict=strict,\n            sequential=sequential,\n            requires_approval=requires_approval,\n            metadata=metadata,\n        )\n        self.add_tool(tool)\n\n    def add_tool(self, tool: Tool[AgentDepsT]) -> None:\n        \"\"\"Add a tool to the toolset.\n\n        Args:\n            tool: The tool to add.\n        \"\"\"\n        if tool.name in self.tools:\n            raise UserError(f'Tool name conflicts with existing tool: {tool.name!r}')\n        if tool.max_retries is None:\n            tool.max_retries = self.max_retries\n        if self.metadata is not None:\n            tool.metadata = self.metadata | (tool.metadata or {})\n        self.tools[tool.name] = tool\n\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        tools: dict[str, ToolsetTool[AgentDepsT]] = {}\n        for original_name, tool in self.tools.items():\n            max_retries = tool.max_retries if tool.max_retries is not None else self.max_retries\n            run_context = replace(\n                ctx,\n                tool_name=original_name,\n                retry=ctx.retries.get(original_name, 0),\n                max_retries=max_retries,\n            )\n            tool_def = await tool.prepare_tool_def(run_context)\n            if not tool_def:\n                continue\n\n            new_name = tool_def.name\n            if new_name in tools:\n                if new_name != original_name:\n                    raise UserError(f'Renaming tool {original_name!r} to {new_name!r} conflicts with existing tool.')\n                else:\n                    raise UserError(f'Tool name conflicts with previously renamed tool: {new_name!r}.')\n\n            tools[new_name] = FunctionToolsetTool(\n                toolset=self,\n                tool_def=tool_def,\n                max_retries=max_retries,\n                args_validator=tool.function_schema.validator,\n                call_func=tool.function_schema.call,\n                is_async=tool.function_schema.is_async,\n            )\n        return tools\n\n    async def call_tool(\n        self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n    ) -> Any:\n        assert isinstance(tool, FunctionToolsetTool)\n        return await tool.call_func(tool_args, ctx)\n\n````\n\n#### __init__\n\n```python\n__init__(\n    tools: Sequence[\n        Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]\n    ] = [],\n    *,\n    max_retries: int = 1,\n    docstring_format: DocstringFormat = \"auto\",\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None,\n    id: str | None = None\n)\n\n```\n\nBuild a new function toolset.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `tools` | `Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]]` | The tools to add to the toolset. | `[]` | | `max_retries` | `int` | The maximum number of retries for each tool during a run. Applies to all tools, unless overridden when adding a tool. | `1` | | `docstring_format` | `DocstringFormat` | Format of tool docstring, see DocstringFormat. Defaults to 'auto', such that the format is inferred from the structure of the docstring. Applies to all tools, unless overridden when adding a tool. | `'auto'` | | `require_parameter_descriptions` | `bool` | If True, raise an error if a parameter description is missing. Defaults to False. Applies to all tools, unless overridden when adding a tool. | `False` | | `schema_generator` | `type[GenerateJsonSchema]` | The JSON schema generator class to use for this tool. Defaults to GenerateToolJsonSchema. Applies to all tools, unless overridden when adding a tool. | `GenerateToolJsonSchema` | | `strict` | `bool | None` | Whether to enforce JSON schema compliance (only affects OpenAI). See ToolDefinition for more info. | `None` | | `sequential` | `bool` | Whether the function requires a sequential/serial execution environment. Defaults to False. Applies to all tools, unless overridden when adding a tool. | `False` | | `requires_approval` | `bool` | Whether this tool requires human-in-the-loop approval. Defaults to False. See the tools documentation for more info. Applies to all tools, unless overridden when adding a tool. | `False` | | `metadata` | `dict[str, Any] | None` | Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization. Applies to all tools, unless overridden when adding a tool, which will be merged with the toolset's metadata. | `None` | | `id` | `str | None` | An optional unique ID for the toolset. A toolset needs to have an ID in order to be used in a durable execution environment like Temporal, in which case the ID will be used to identify the toolset's activities within the workflow. | `None` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`\n\n```python\ndef __init__(\n    self,\n    tools: Sequence[Tool[AgentDepsT] | ToolFuncEither[AgentDepsT, ...]] = [],\n    *,\n    max_retries: int = 1,\n    docstring_format: DocstringFormat = 'auto',\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None,\n    id: str | None = None,\n):\n    \"\"\"Build a new function toolset.\n\n    Args:\n        tools: The tools to add to the toolset.\n        max_retries: The maximum number of retries for each tool during a run.\n            Applies to all tools, unless overridden when adding a tool.\n        docstring_format: Format of tool docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n            Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.\n            Applies to all tools, unless overridden when adding a tool.\n        require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.\n            Applies to all tools, unless overridden when adding a tool.\n        schema_generator: The JSON schema generator class to use for this tool. Defaults to `GenerateToolJsonSchema`.\n            Applies to all tools, unless overridden when adding a tool.\n        strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n            See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n        sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n            Applies to all tools, unless overridden when adding a tool.\n        requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n            See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n            Applies to all tools, unless overridden when adding a tool.\n        metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n            Applies to all tools, unless overridden when adding a tool, which will be merged with the toolset's metadata.\n        id: An optional unique ID for the toolset. A toolset needs to have an ID in order to be used in a durable execution environment like Temporal,\n            in which case the ID will be used to identify the toolset's activities within the workflow.\n    \"\"\"\n    self.max_retries = max_retries\n    self._id = id\n    self.docstring_format = docstring_format\n    self.require_parameter_descriptions = require_parameter_descriptions\n    self.schema_generator = schema_generator\n    self.strict = strict\n    self.sequential = sequential\n    self.requires_approval = requires_approval\n    self.metadata = metadata\n\n    self.tools = {}\n    for tool in tools:\n        if isinstance(tool, Tool):\n            self.add_tool(tool)\n        else:\n            self.add_function(tool)\n\n```\n\n#### tool\n\n```python\ntool(\n    func: ToolFuncEither[AgentDepsT, ToolParams],\n) -> ToolFuncEither[AgentDepsT, ToolParams]\n\n```\n\n```python\ntool(\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat | None = None,\n    require_parameter_descriptions: bool | None = None,\n    schema_generator: (\n        type[GenerateJsonSchema] | None\n    ) = None,\n    strict: bool | None = None,\n    sequential: bool | None = None,\n    requires_approval: bool | None = None,\n    metadata: dict[str, Any] | None = None\n) -> Callable[\n    [ToolFuncEither[AgentDepsT, ToolParams]],\n    ToolFuncEither[AgentDepsT, ToolParams],\n]\n\n```\n\n```python\ntool(\n    func: (\n        ToolFuncEither[AgentDepsT, ToolParams] | None\n    ) = None,\n    /,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat | None = None,\n    require_parameter_descriptions: bool | None = None,\n    schema_generator: (\n        type[GenerateJsonSchema] | None\n    ) = None,\n    strict: bool | None = None,\n    sequential: bool | None = None,\n    requires_approval: bool | None = None,\n    metadata: dict[str, Any] | None = None,\n) -> Any\n\n```\n\nDecorator to register a tool function which takes RunContext as its first argument.\n\nCan decorate a sync or async functions.\n\nThe docstring is inspected to extract both the tool description and description of each parameter, [learn more](../../tools/#function-tools-and-schema).\n\nWe can't add overloads for every possible signature of tool, since the return type is a recursive union so the signature of functions decorated with `@toolset.tool` is obscured.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent, FunctionToolset, RunContext\n\ntoolset = FunctionToolset()\n\n@toolset.tool\ndef foobar(ctx: RunContext[int], x: int) -> int:\n    return ctx.deps + x\n\n@toolset.tool(retries=2)\nasync def spam(ctx: RunContext[str], y: float) -> float:\n    return ctx.deps + y\n\nagent = Agent('test', toolsets=[toolset], deps_type=int)\nresult = agent.run_sync('foobar', deps=1)\nprint(result.output)\n#> {\"foobar\":1,\"spam\":1.0}\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `func` | `ToolFuncEither[AgentDepsT, ToolParams] | None` | The tool function to register. | `None` | | `name` | `str | None` | The name of the tool, defaults to the function name. | `None` | | `description` | `str | None` | The description of the tool,defaults to the function docstring. | `None` | | `retries` | `int | None` | The number of retries to allow for this tool, defaults to the agent's default retries, which defaults to 1. | `None` | | `prepare` | `ToolPrepareFunc[AgentDepsT] | None` | custom method to prepare the tool definition for each step, return None to omit this tool from a given step. This is useful if you want to customise a tool at call time, or omit it completely from a step. See ToolPrepareFunc. | `None` | | `docstring_format` | `DocstringFormat | None` | The format of the docstring, see DocstringFormat. If None, the default value is determined by the toolset. | `None` | | `require_parameter_descriptions` | `bool | None` | If True, raise an error if a parameter description is missing. If None, the default value is determined by the toolset. | `None` | | `schema_generator` | `type[GenerateJsonSchema] | None` | The JSON schema generator class to use for this tool. If None, the default value is determined by the toolset. | `None` | | `strict` | `bool | None` | Whether to enforce JSON schema compliance (only affects OpenAI). See ToolDefinition for more info. If None, the default value is determined by the toolset. | `None` | | `sequential` | `bool | None` | Whether the function requires a sequential/serial execution environment. Defaults to False. If None, the default value is determined by the toolset. | `None` | | `requires_approval` | `bool | None` | Whether this tool requires human-in-the-loop approval. Defaults to False. See the tools documentation for more info. If None, the default value is determined by the toolset. | `None` | | `metadata` | `dict[str, Any] | None` | Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization. If None, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata. | `None` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`\n\n````python\ndef tool(\n    self,\n    func: ToolFuncEither[AgentDepsT, ToolParams] | None = None,\n    /,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat | None = None,\n    require_parameter_descriptions: bool | None = None,\n    schema_generator: type[GenerateJsonSchema] | None = None,\n    strict: bool | None = None,\n    sequential: bool | None = None,\n    requires_approval: bool | None = None,\n    metadata: dict[str, Any] | None = None,\n) -> Any:\n    \"\"\"Decorator to register a tool function which takes [`RunContext`][pydantic_ai.tools.RunContext] as its first argument.\n\n    Can decorate a sync or async functions.\n\n    The docstring is inspected to extract both the tool description and description of each parameter,\n    [learn more](../tools.md#function-tools-and-schema).\n\n    We can't add overloads for every possible signature of tool, since the return type is a recursive union\n    so the signature of functions decorated with `@toolset.tool` is obscured.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent, FunctionToolset, RunContext\n\n    toolset = FunctionToolset()\n\n    @toolset.tool\n    def foobar(ctx: RunContext[int], x: int) -> int:\n        return ctx.deps + x\n\n    @toolset.tool(retries=2)\n    async def spam(ctx: RunContext[str], y: float) -> float:\n        return ctx.deps + y\n\n    agent = Agent('test', toolsets=[toolset], deps_type=int)\n    result = agent.run_sync('foobar', deps=1)\n    print(result.output)\n    #> {\"foobar\":1,\"spam\":1.0}\n    ```\n\n    Args:\n        func: The tool function to register.\n        name: The name of the tool, defaults to the function name.\n        description: The description of the tool,defaults to the function docstring.\n        retries: The number of retries to allow for this tool, defaults to the agent's default retries,\n            which defaults to 1.\n        prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n            tool from a given step. This is useful if you want to customise a tool at call time,\n            or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n        docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n            If `None`, the default value is determined by the toolset.\n        require_parameter_descriptions: If True, raise an error if a parameter description is missing.\n            If `None`, the default value is determined by the toolset.\n        schema_generator: The JSON schema generator class to use for this tool.\n            If `None`, the default value is determined by the toolset.\n        strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n            See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n            If `None`, the default value is determined by the toolset.\n        sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n            If `None`, the default value is determined by the toolset.\n        requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n            See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n            If `None`, the default value is determined by the toolset.\n        metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n            If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata.\n    \"\"\"\n\n    def tool_decorator(\n        func_: ToolFuncEither[AgentDepsT, ToolParams],\n    ) -> ToolFuncEither[AgentDepsT, ToolParams]:\n        # noinspection PyTypeChecker\n        self.add_function(\n            func=func_,\n            takes_ctx=None,\n            name=name,\n            description=description,\n            retries=retries,\n            prepare=prepare,\n            docstring_format=docstring_format,\n            require_parameter_descriptions=require_parameter_descriptions,\n            schema_generator=schema_generator,\n            strict=strict,\n            sequential=sequential,\n            requires_approval=requires_approval,\n            metadata=metadata,\n        )\n        return func_\n\n    return tool_decorator if func is None else tool_decorator(func)\n\n````\n\n#### add_function\n\n```python\nadd_function(\n    func: ToolFuncEither[AgentDepsT, ToolParams],\n    takes_ctx: bool | None = None,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat | None = None,\n    require_parameter_descriptions: bool | None = None,\n    schema_generator: (\n        type[GenerateJsonSchema] | None\n    ) = None,\n    strict: bool | None = None,\n    sequential: bool | None = None,\n    requires_approval: bool | None = None,\n    metadata: dict[str, Any] | None = None,\n) -> None\n\n```\n\nAdd a function as a tool to the toolset.\n\nCan take a sync or async function.\n\nThe docstring is inspected to extract both the tool description and description of each parameter, [learn more](../../tools/#function-tools-and-schema).\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `func` | `ToolFuncEither[AgentDepsT, ToolParams]` | The tool function to register. | *required* | | `takes_ctx` | `bool | None` | Whether the function takes a RunContext as its first argument. If None, this is inferred from the function signature. | `None` | | `name` | `str | None` | The name of the tool, defaults to the function name. | `None` | | `description` | `str | None` | The description of the tool, defaults to the function docstring. | `None` | | `retries` | `int | None` | The number of retries to allow for this tool, defaults to the agent's default retries, which defaults to 1. | `None` | | `prepare` | `ToolPrepareFunc[AgentDepsT] | None` | custom method to prepare the tool definition for each step, return None to omit this tool from a given step. This is useful if you want to customise a tool at call time, or omit it completely from a step. See ToolPrepareFunc. | `None` | | `docstring_format` | `DocstringFormat | None` | The format of the docstring, see DocstringFormat. If None, the default value is determined by the toolset. | `None` | | `require_parameter_descriptions` | `bool | None` | If True, raise an error if a parameter description is missing. If None, the default value is determined by the toolset. | `None` | | `schema_generator` | `type[GenerateJsonSchema] | None` | The JSON schema generator class to use for this tool. If None, the default value is determined by the toolset. | `None` | | `strict` | `bool | None` | Whether to enforce JSON schema compliance (only affects OpenAI). See ToolDefinition for more info. If None, the default value is determined by the toolset. | `None` | | `sequential` | `bool | None` | Whether the function requires a sequential/serial execution environment. Defaults to False. If None, the default value is determined by the toolset. | `None` | | `requires_approval` | `bool | None` | Whether this tool requires human-in-the-loop approval. Defaults to False. See the tools documentation for more info. If None, the default value is determined by the toolset. | `None` | | `metadata` | `dict[str, Any] | None` | Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization. If None, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata. | `None` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`\n\n```python\ndef add_function(\n    self,\n    func: ToolFuncEither[AgentDepsT, ToolParams],\n    takes_ctx: bool | None = None,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n    prepare: ToolPrepareFunc[AgentDepsT] | None = None,\n    docstring_format: DocstringFormat | None = None,\n    require_parameter_descriptions: bool | None = None,\n    schema_generator: type[GenerateJsonSchema] | None = None,\n    strict: bool | None = None,\n    sequential: bool | None = None,\n    requires_approval: bool | None = None,\n    metadata: dict[str, Any] | None = None,\n) -> None:\n    \"\"\"Add a function as a tool to the toolset.\n\n    Can take a sync or async function.\n\n    The docstring is inspected to extract both the tool description and description of each parameter,\n    [learn more](../tools.md#function-tools-and-schema).\n\n    Args:\n        func: The tool function to register.\n        takes_ctx: Whether the function takes a [`RunContext`][pydantic_ai.tools.RunContext] as its first argument. If `None`, this is inferred from the function signature.\n        name: The name of the tool, defaults to the function name.\n        description: The description of the tool, defaults to the function docstring.\n        retries: The number of retries to allow for this tool, defaults to the agent's default retries,\n            which defaults to 1.\n        prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n            tool from a given step. This is useful if you want to customise a tool at call time,\n            or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n        docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n            If `None`, the default value is determined by the toolset.\n        require_parameter_descriptions: If True, raise an error if a parameter description is missing.\n            If `None`, the default value is determined by the toolset.\n        schema_generator: The JSON schema generator class to use for this tool.\n            If `None`, the default value is determined by the toolset.\n        strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n            See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n            If `None`, the default value is determined by the toolset.\n        sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n            If `None`, the default value is determined by the toolset.\n        requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n            See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n            If `None`, the default value is determined by the toolset.\n        metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n            If `None`, the default value is determined by the toolset. If provided, it will be merged with the toolset's metadata.\n    \"\"\"\n    if docstring_format is None:\n        docstring_format = self.docstring_format\n    if require_parameter_descriptions is None:\n        require_parameter_descriptions = self.require_parameter_descriptions\n    if schema_generator is None:\n        schema_generator = self.schema_generator\n    if strict is None:\n        strict = self.strict\n    if sequential is None:\n        sequential = self.sequential\n    if requires_approval is None:\n        requires_approval = self.requires_approval\n\n    tool = Tool[AgentDepsT](\n        func,\n        takes_ctx=takes_ctx,\n        name=name,\n        description=description,\n        max_retries=retries,\n        prepare=prepare,\n        docstring_format=docstring_format,\n        require_parameter_descriptions=require_parameter_descriptions,\n        schema_generator=schema_generator,\n        strict=strict,\n        sequential=sequential,\n        requires_approval=requires_approval,\n        metadata=metadata,\n    )\n    self.add_tool(tool)\n\n```\n\n#### add_tool\n\n```python\nadd_tool(tool: Tool[AgentDepsT]) -> None\n\n```\n\nAdd a tool to the toolset.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `tool` | `Tool[AgentDepsT]` | The tool to add. | *required* |\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/function.py`\n\n```python\ndef add_tool(self, tool: Tool[AgentDepsT]) -> None:\n    \"\"\"Add a tool to the toolset.\n\n    Args:\n        tool: The tool to add.\n    \"\"\"\n    if tool.name in self.tools:\n        raise UserError(f'Tool name conflicts with existing tool: {tool.name!r}')\n    if tool.max_retries is None:\n        tool.max_retries = self.max_retries\n    if self.metadata is not None:\n        tool.metadata = self.metadata | (tool.metadata or {})\n    self.tools[tool.name] = tool\n\n```\n\n### PrefixedToolset\n\nBases: `WrapperToolset[AgentDepsT]`\n\nA toolset that prefixes the names of the tools it contains.\n\nSee [toolset docs](../../toolsets/#prefixing-tool-names) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/prefixed.py`\n\n```python\n@dataclass\nclass PrefixedToolset(WrapperToolset[AgentDepsT]):\n    \"\"\"A toolset that prefixes the names of the tools it contains.\n\n    See [toolset docs](../toolsets.md#prefixing-tool-names) for more information.\n    \"\"\"\n\n    prefix: str\n\n    @property\n    def tool_name_conflict_hint(self) -> str:\n        return 'Change the `prefix` attribute to avoid name conflicts.'\n\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        return {\n            new_name: replace(\n                tool,\n                toolset=self,\n                tool_def=replace(tool.tool_def, name=new_name),\n            )\n            for name, tool in (await super().get_tools(ctx)).items()\n            if (new_name := f'{self.prefix}_{name}')\n        }\n\n    async def call_tool(\n        self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n    ) -> Any:\n        original_name = name.removeprefix(self.prefix + '_')\n        ctx = replace(ctx, tool_name=original_name)\n        tool = replace(tool, tool_def=replace(tool.tool_def, name=original_name))\n        return await super().call_tool(original_name, tool_args, ctx, tool)\n\n```\n\n### RenamedToolset\n\nBases: `WrapperToolset[AgentDepsT]`\n\nA toolset that renames the tools it contains using a dictionary mapping new names to original names.\n\nSee [toolset docs](../../toolsets/#renaming-tools) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/renamed.py`\n\n```python\n@dataclass\nclass RenamedToolset(WrapperToolset[AgentDepsT]):\n    \"\"\"A toolset that renames the tools it contains using a dictionary mapping new names to original names.\n\n    See [toolset docs](../toolsets.md#renaming-tools) for more information.\n    \"\"\"\n\n    name_map: dict[str, str]\n\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        original_to_new_name_map = {v: k for k, v in self.name_map.items()}\n        original_tools = await super().get_tools(ctx)\n        tools: dict[str, ToolsetTool[AgentDepsT]] = {}\n        for original_name, tool in original_tools.items():\n            new_name = original_to_new_name_map.get(original_name, None)\n            if new_name:\n                tools[new_name] = replace(\n                    tool,\n                    toolset=self,\n                    tool_def=replace(tool.tool_def, name=new_name),\n                )\n            else:\n                tools[original_name] = tool\n        return tools\n\n    async def call_tool(\n        self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n    ) -> Any:\n        original_name = self.name_map.get(name, name)\n        ctx = replace(ctx, tool_name=original_name)\n        tool = replace(tool, tool_def=replace(tool.tool_def, name=original_name))\n        return await super().call_tool(original_name, tool_args, ctx, tool)\n\n```\n\n### PreparedToolset\n\nBases: `WrapperToolset[AgentDepsT]`\n\nA toolset that prepares the tools it contains using a prepare function that takes the agent context and the original tool definitions.\n\nSee [toolset docs](../../toolsets/#preparing-tool-definitions) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/prepared.py`\n\n```python\n@dataclass\nclass PreparedToolset(WrapperToolset[AgentDepsT]):\n    \"\"\"A toolset that prepares the tools it contains using a prepare function that takes the agent context and the original tool definitions.\n\n    See [toolset docs](../toolsets.md#preparing-tool-definitions) for more information.\n    \"\"\"\n\n    prepare_func: ToolsPrepareFunc[AgentDepsT]\n\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        original_tools = await super().get_tools(ctx)\n        original_tool_defs = [tool.tool_def for tool in original_tools.values()]\n        prepared_tool_defs_by_name = {\n            tool_def.name: tool_def for tool_def in (await self.prepare_func(ctx, original_tool_defs) or [])\n        }\n\n        if len(prepared_tool_defs_by_name.keys() - original_tools.keys()) > 0:\n            raise UserError(\n                'Prepare function cannot add or rename tools. Use `FunctionToolset.add_function()` or `RenamedToolset` instead.'\n            )\n\n        return {\n            name: replace(original_tools[name], tool_def=tool_def)\n            for name, tool_def in prepared_tool_defs_by_name.items()\n        }\n\n```\n\n### WrapperToolset\n\nBases: `AbstractToolset[AgentDepsT]`\n\nA toolset that wraps another toolset and delegates to it.\n\nSee [toolset docs](../../toolsets/#wrapping-a-toolset) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/wrapper.py`\n\n```python\n@dataclass\nclass WrapperToolset(AbstractToolset[AgentDepsT]):\n    \"\"\"A toolset that wraps another toolset and delegates to it.\n\n    See [toolset docs](../toolsets.md#wrapping-a-toolset) for more information.\n    \"\"\"\n\n    wrapped: AbstractToolset[AgentDepsT]\n\n    @property\n    def id(self) -> str | None:\n        return None  # pragma: no cover\n\n    @property\n    def label(self) -> str:\n        return f'{self.__class__.__name__}({self.wrapped.label})'\n\n    async def __aenter__(self) -> Self:\n        await self.wrapped.__aenter__()\n        return self\n\n    async def __aexit__(self, *args: Any) -> bool | None:\n        return await self.wrapped.__aexit__(*args)\n\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        return await self.wrapped.get_tools(ctx)\n\n    async def call_tool(\n        self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n    ) -> Any:\n        return await self.wrapped.call_tool(name, tool_args, ctx, tool)\n\n    def apply(self, visitor: Callable[[AbstractToolset[AgentDepsT]], None]) -> None:\n        self.wrapped.apply(visitor)\n\n    def visit_and_replace(\n        self, visitor: Callable[[AbstractToolset[AgentDepsT]], AbstractToolset[AgentDepsT]]\n    ) -> AbstractToolset[AgentDepsT]:\n        return replace(self, wrapped=self.wrapped.visit_and_replace(visitor))\n\n```\n\n### ToolsetFunc\n\n```python\nToolsetFunc: TypeAlias = Callable[\n    [RunContext[AgentDepsT]],\n    AbstractToolset[AgentDepsT]\n    | None\n    | Awaitable[AbstractToolset[AgentDepsT] | None],\n]\n\n```\n\nA sync/async function which takes a run context and returns a toolset.\n\n### FastMCPToolset\n\nBases: `AbstractToolset[AgentDepsT]`\n\nA FastMCP Toolset that uses the FastMCP Client to call tools from a local or remote MCP Server.\n\nThe Toolset can accept a FastMCP Client, a FastMCP Transport, or any other object which a FastMCP Transport can be created from.\n\nSee https://gofastmcp.com/clients/transports for a full list of transports available.\n\nSource code in `pydantic_ai_slim/pydantic_ai/toolsets/fastmcp.py`\n\n```python\n@dataclass(init=False)\nclass FastMCPToolset(AbstractToolset[AgentDepsT]):\n    \"\"\"A FastMCP Toolset that uses the FastMCP Client to call tools from a local or remote MCP Server.\n\n    The Toolset can accept a FastMCP Client, a FastMCP Transport, or any other object which a FastMCP Transport can be created from.\n\n    See https://gofastmcp.com/clients/transports for a full list of transports available.\n    \"\"\"\n\n    client: Client[Any]\n    \"\"\"The FastMCP client to use.\"\"\"\n\n    _: KW_ONLY\n\n    tool_error_behavior: Literal['model_retry', 'error']\n    \"\"\"The behavior to take when a tool error occurs.\"\"\"\n\n    max_retries: int\n    \"\"\"The maximum number of retries to attempt if a tool call fails.\"\"\"\n\n    _id: str | None\n\n    def __init__(\n        self,\n        client: Client[Any]\n        | ClientTransport\n        | FastMCP\n        | FastMCP1Server\n        | AnyUrl\n        | Path\n        | MCPConfig\n        | dict[str, Any]\n        | str,\n        *,\n        max_retries: int = 1,\n        tool_error_behavior: Literal['model_retry', 'error'] = 'model_retry',\n        id: str | None = None,\n    ) -> None:\n        if isinstance(client, Client):\n            self.client = client\n        else:\n            self.client = Client[Any](transport=client)\n\n        self._id = id\n        self.max_retries = max_retries\n        self.tool_error_behavior = tool_error_behavior\n\n        self._enter_lock: Lock = Lock()\n        self._running_count: int = 0\n        self._exit_stack: AsyncExitStack | None = None\n\n    @property\n    def id(self) -> str | None:\n        return self._id\n\n    async def __aenter__(self) -> Self:\n        async with self._enter_lock:\n            if self._running_count == 0:\n                self._exit_stack = AsyncExitStack()\n                await self._exit_stack.enter_async_context(self.client)\n\n            self._running_count += 1\n\n        return self\n\n    async def __aexit__(self, *args: Any) -> bool | None:\n        async with self._enter_lock:\n            self._running_count -= 1\n            if self._running_count == 0 and self._exit_stack:\n                await self._exit_stack.aclose()\n                self._exit_stack = None\n\n        return None\n\n    async def get_tools(self, ctx: RunContext[AgentDepsT]) -> dict[str, ToolsetTool[AgentDepsT]]:\n        async with self:\n            return {\n                mcp_tool.name: self.tool_for_tool_def(\n                    ToolDefinition(\n                        name=mcp_tool.name,\n                        description=mcp_tool.description,\n                        parameters_json_schema=mcp_tool.inputSchema,\n                        metadata={\n                            'meta': mcp_tool.meta,\n                            'annotations': mcp_tool.annotations.model_dump() if mcp_tool.annotations else None,\n                            'output_schema': mcp_tool.outputSchema or None,\n                        },\n                    )\n                )\n                for mcp_tool in await self.client.list_tools()\n            }\n\n    async def call_tool(\n        self, name: str, tool_args: dict[str, Any], ctx: RunContext[AgentDepsT], tool: ToolsetTool[AgentDepsT]\n    ) -> Any:\n        async with self:\n            try:\n                call_tool_result: CallToolResult = await self.client.call_tool(name=name, arguments=tool_args)\n            except ToolError as e:\n                if self.tool_error_behavior == 'model_retry':\n                    raise ModelRetry(message=str(e)) from e\n                else:\n                    raise e\n\n        # If we have structured content, return that\n        if call_tool_result.structured_content:\n            return call_tool_result.structured_content\n\n        # Otherwise, return the content\n        return _map_fastmcp_tool_results(parts=call_tool_result.content)\n\n    def tool_for_tool_def(self, tool_def: ToolDefinition) -> ToolsetTool[AgentDepsT]:\n        return ToolsetTool[AgentDepsT](\n            tool_def=tool_def,\n            toolset=self,\n            max_retries=self.max_retries,\n            args_validator=TOOL_SCHEMA_VALIDATOR,\n        )\n\n```\n\n#### client\n\n```python\nclient: Client[Any]\n\n```\n\nThe FastMCP client to use.\n\n#### max_retries\n\n```python\nmax_retries: int = max_retries\n\n```\n\nThe maximum number of retries to attempt if a tool call fails.\n\n#### tool_error_behavior\n\n```python\ntool_error_behavior: Literal[\"model_retry\", \"error\"] = (\n    tool_error_behavior\n)\n\n```\n\nThe behavior to take when a tool error occurs.",
  "content_length": 73109
}