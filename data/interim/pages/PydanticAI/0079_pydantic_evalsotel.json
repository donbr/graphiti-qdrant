{
  "title": "`pydantic_evals.otel`",
  "source_url": null,
  "content": "### SpanNode\n\nA node in the span tree; provides references to parents/children for easy traversal and queries.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\n@dataclass(repr=False, kw_only=True)\nclass SpanNode:\n    \"\"\"A node in the span tree; provides references to parents/children for easy traversal and queries.\"\"\"\n\n    name: str\n    trace_id: int\n    span_id: int\n    parent_span_id: int | None\n    start_timestamp: datetime\n    end_timestamp: datetime\n    attributes: dict[str, AttributeValue]\n\n    @property\n    def duration(self) -> timedelta:\n        \"\"\"Return the span's duration as a timedelta, or None if start/end not set.\"\"\"\n        return self.end_timestamp - self.start_timestamp\n\n    @property\n    def children(self) -> list[SpanNode]:\n        return list(self.children_by_id.values())\n\n    @property\n    def descendants(self) -> list[SpanNode]:\n        \"\"\"Return all descendants of this node in DFS order.\"\"\"\n        return self.find_descendants(lambda _: True)\n\n    @property\n    def ancestors(self) -> list[SpanNode]:\n        \"\"\"Return all ancestors of this node.\"\"\"\n        return self.find_ancestors(lambda _: True)\n\n    @property\n    def node_key(self) -> str:\n        return f'{self.trace_id:032x}:{self.span_id:016x}'\n\n    @property\n    def parent_node_key(self) -> str | None:\n        return None if self.parent_span_id is None else f'{self.trace_id:032x}:{self.parent_span_id:016x}'\n\n    # -------------------------------------------------------------------------\n    # Construction\n    # -------------------------------------------------------------------------\n    def __post_init__(self):\n        self.parent: SpanNode | None = None\n        self.children_by_id: dict[str, SpanNode] = {}\n\n    @staticmethod\n    def from_readable_span(span: ReadableSpan) -> SpanNode:\n        assert span.context is not None, 'Span has no context'\n        assert span.start_time is not None, 'Span has no start time'\n        assert span.end_time is not None, 'Span has no end time'\n        return SpanNode(\n            name=span.name,\n            trace_id=span.context.trace_id,\n            span_id=span.context.span_id,\n            parent_span_id=span.parent.span_id if span.parent else None,\n            start_timestamp=datetime.fromtimestamp(span.start_time / 1e9, tz=timezone.utc),\n            end_timestamp=datetime.fromtimestamp(span.end_time / 1e9, tz=timezone.utc),\n            attributes=dict(span.attributes or {}),\n        )\n\n    def add_child(self, child: SpanNode) -> None:\n        \"\"\"Attach a child node to this node's list of children.\"\"\"\n        assert child.trace_id == self.trace_id, f\"traces don't match: {child.trace_id:032x} != {self.trace_id:032x}\"\n        assert child.parent_span_id == self.span_id, (\n            f'parent span mismatch: {child.parent_span_id:016x} != {self.span_id:016x}'\n        )\n        self.children_by_id[child.node_key] = child\n        child.parent = self\n\n    # -------------------------------------------------------------------------\n    # Child queries\n    # -------------------------------------------------------------------------\n    def find_children(self, predicate: SpanQuery | SpanPredicate) -> list[SpanNode]:\n        \"\"\"Return all immediate children that satisfy the given predicate.\"\"\"\n        return list(self._filter_children(predicate))\n\n    def first_child(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:\n        \"\"\"Return the first immediate child that satisfies the given predicate, or None if none match.\"\"\"\n        return next(self._filter_children(predicate), None)\n\n    def any_child(self, predicate: SpanQuery | SpanPredicate) -> bool:\n        \"\"\"Returns True if there is at least one child that satisfies the predicate.\"\"\"\n        return self.first_child(predicate) is not None\n\n    def _filter_children(self, predicate: SpanQuery | SpanPredicate) -> Iterator[SpanNode]:\n        return (child for child in self.children if child.matches(predicate))\n\n    # -------------------------------------------------------------------------\n    # Descendant queries (DFS)\n    # -------------------------------------------------------------------------\n    def find_descendants(\n        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n    ) -> list[SpanNode]:\n        \"\"\"Return all descendant nodes that satisfy the given predicate in DFS order.\"\"\"\n        return list(self._filter_descendants(predicate, stop_recursing_when))\n\n    def first_descendant(\n        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n    ) -> SpanNode | None:\n        \"\"\"DFS: Return the first descendant (in DFS order) that satisfies the given predicate, or `None` if none match.\"\"\"\n        return next(self._filter_descendants(predicate, stop_recursing_when), None)\n\n    def any_descendant(\n        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n    ) -> bool:\n        \"\"\"Returns `True` if there is at least one descendant that satisfies the predicate.\"\"\"\n        return self.first_descendant(predicate, stop_recursing_when) is not None\n\n    def _filter_descendants(\n        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None\n    ) -> Iterator[SpanNode]:\n        stack = list(self.children)\n        while stack:\n            node = stack.pop()\n            if node.matches(predicate):\n                yield node\n            if stop_recursing_when is not None and node.matches(stop_recursing_when):\n                continue\n            stack.extend(node.children)\n\n    # -------------------------------------------------------------------------\n    # Ancestor queries (DFS \"up\" the chain)\n    # -------------------------------------------------------------------------\n    def find_ancestors(\n        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n    ) -> list[SpanNode]:\n        \"\"\"Return all ancestors that satisfy the given predicate.\"\"\"\n        return list(self._filter_ancestors(predicate, stop_recursing_when))\n\n    def first_ancestor(\n        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n    ) -> SpanNode | None:\n        \"\"\"Return the closest ancestor that satisfies the given predicate, or `None` if none match.\"\"\"\n        return next(self._filter_ancestors(predicate, stop_recursing_when), None)\n\n    def any_ancestor(\n        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n    ) -> bool:\n        \"\"\"Returns True if any ancestor satisfies the predicate.\"\"\"\n        return self.first_ancestor(predicate, stop_recursing_when) is not None\n\n    def _filter_ancestors(\n        self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None\n    ) -> Iterator[SpanNode]:\n        node = self.parent\n        while node:\n            if node.matches(predicate):\n                yield node\n            if stop_recursing_when is not None and node.matches(stop_recursing_when):\n                break\n            node = node.parent\n\n    # -------------------------------------------------------------------------\n    # Query matching\n    # -------------------------------------------------------------------------\n    def matches(self, query: SpanQuery | SpanPredicate) -> bool:\n        \"\"\"Check if the span node matches the query conditions or predicate.\"\"\"\n        if callable(query):\n            return query(self)\n\n        return self._matches_query(query)\n\n    def _matches_query(self, query: SpanQuery) -> bool:  # noqa: C901\n        \"\"\"Check if the span matches the query conditions.\"\"\"\n        # Logical combinations\n        if or_ := query.get('or_'):\n            if len(query) > 1:\n                raise ValueError(\"Cannot combine 'or_' conditions with other conditions at the same level\")\n            return any(self._matches_query(q) for q in or_)\n        if not_ := query.get('not_'):\n            if self._matches_query(not_):\n                return False\n        if and_ := query.get('and_'):\n            results = [self._matches_query(q) for q in and_]\n            if not all(results):\n                return False\n        # At this point, all existing ANDs and no existing ORs have passed, so it comes down to this condition\n\n        # Name conditions\n        if (name_equals := query.get('name_equals')) and self.name != name_equals:\n            return False\n        if (name_contains := query.get('name_contains')) and name_contains not in self.name:\n            return False\n        if (name_matches_regex := query.get('name_matches_regex')) and not re.match(name_matches_regex, self.name):\n            return False\n\n        # Attribute conditions\n        if (has_attributes := query.get('has_attributes')) and not all(\n            self.attributes.get(key) == value for key, value in has_attributes.items()\n        ):\n            return False\n        if (has_attributes_keys := query.get('has_attribute_keys')) and not all(\n            key in self.attributes for key in has_attributes_keys\n        ):\n            return False\n\n        # Timing conditions\n        if (min_duration := query.get('min_duration')) is not None:\n            if not isinstance(min_duration, timedelta):\n                min_duration = timedelta(seconds=min_duration)\n            if self.duration < min_duration:\n                return False\n        if (max_duration := query.get('max_duration')) is not None:\n            if not isinstance(max_duration, timedelta):\n                max_duration = timedelta(seconds=max_duration)\n            if self.duration > max_duration:\n                return False\n\n        # Children conditions\n        if (min_child_count := query.get('min_child_count')) and len(self.children) < min_child_count:\n            return False\n        if (max_child_count := query.get('max_child_count')) and len(self.children) > max_child_count:\n            return False\n        if (some_child_has := query.get('some_child_has')) and not any(\n            child._matches_query(some_child_has) for child in self.children\n        ):\n            return False\n        if (all_children_have := query.get('all_children_have')) and not all(\n            child._matches_query(all_children_have) for child in self.children\n        ):\n            return False\n        if (no_child_has := query.get('no_child_has')) and any(\n            child._matches_query(no_child_has) for child in self.children\n        ):\n            return False\n\n        # Descendant conditions\n        # The following local functions with cache decorators are used to avoid repeatedly evaluating these properties\n        @cache\n        def descendants():\n            return self.descendants\n\n        @cache\n        def pruned_descendants():\n            stop_recursing_when = query.get('stop_recursing_when')\n            return (\n                self._filter_descendants(lambda _: True, stop_recursing_when) if stop_recursing_when else descendants()\n            )\n\n        if (min_descendant_count := query.get('min_descendant_count')) and len(descendants()) < min_descendant_count:\n            return False\n        if (max_descendant_count := query.get('max_descendant_count')) and len(descendants()) > max_descendant_count:\n            return False\n        if (some_descendant_has := query.get('some_descendant_has')) and not any(\n            descendant._matches_query(some_descendant_has) for descendant in pruned_descendants()\n        ):\n            return False\n        if (all_descendants_have := query.get('all_descendants_have')) and not all(\n            descendant._matches_query(all_descendants_have) for descendant in pruned_descendants()\n        ):\n            return False\n        if (no_descendant_has := query.get('no_descendant_has')) and any(\n            descendant._matches_query(no_descendant_has) for descendant in pruned_descendants()\n        ):\n            return False\n\n        # Ancestor conditions\n        # The following local functions with cache decorators are used to avoid repeatedly evaluating these properties\n        @cache\n        def ancestors():\n            return self.ancestors\n\n        @cache\n        def pruned_ancestors():\n            stop_recursing_when = query.get('stop_recursing_when')\n            return self._filter_ancestors(lambda _: True, stop_recursing_when) if stop_recursing_when else ancestors()\n\n        if (min_depth := query.get('min_depth')) and len(ancestors()) < min_depth:\n            return False\n        if (max_depth := query.get('max_depth')) and len(ancestors()) > max_depth:\n            return False\n        if (some_ancestor_has := query.get('some_ancestor_has')) and not any(\n            ancestor._matches_query(some_ancestor_has) for ancestor in pruned_ancestors()\n        ):\n            return False\n        if (all_ancestors_have := query.get('all_ancestors_have')) and not all(\n            ancestor._matches_query(all_ancestors_have) for ancestor in pruned_ancestors()\n        ):\n            return False\n        if (no_ancestor_has := query.get('no_ancestor_has')) and any(\n            ancestor._matches_query(no_ancestor_has) for ancestor in pruned_ancestors()\n        ):\n            return False\n\n        return True\n\n    # -------------------------------------------------------------------------\n    # String representation\n    # -------------------------------------------------------------------------\n    def repr_xml(\n        self,\n        include_children: bool = True,\n        include_trace_id: bool = False,\n        include_span_id: bool = False,\n        include_start_timestamp: bool = False,\n        include_duration: bool = False,\n    ) -> str:\n        \"\"\"Return an XML-like string representation of the node.\n\n        Optionally includes children, trace_id, span_id, start_timestamp, and duration.\n        \"\"\"\n        first_line_parts = [f'<SpanNode name={self.name!r}']\n        if include_trace_id:\n            first_line_parts.append(f\"trace_id='{self.trace_id:032x}'\")\n        if include_span_id:\n            first_line_parts.append(f\"span_id='{self.span_id:016x}'\")\n        if include_start_timestamp:\n            first_line_parts.append(f'start_timestamp={self.start_timestamp.isoformat()!r}')\n        if include_duration:\n            first_line_parts.append(f\"duration='{self.duration}'\")\n\n        extra_lines: list[str] = []\n        if include_children and self.children:\n            first_line_parts.append('>')\n            for child in self.children:\n                extra_lines.append(\n                    indent(\n                        child.repr_xml(\n                            include_children=include_children,\n                            include_trace_id=include_trace_id,\n                            include_span_id=include_span_id,\n                            include_start_timestamp=include_start_timestamp,\n                            include_duration=include_duration,\n                        ),\n                        '  ',\n                    )\n                )\n            extra_lines.append('</SpanNode>')\n        else:\n            if self.children:\n                first_line_parts.append('children=...')\n            first_line_parts.append('/>')\n        return '\\n'.join([' '.join(first_line_parts), *extra_lines])\n\n    def __str__(self) -> str:\n        if self.children:\n            return f\"<SpanNode name={self.name!r} span_id='{self.span_id:016x}'>...</SpanNode>\"\n        else:\n            return f\"<SpanNode name={self.name!r} span_id='{self.span_id:016x}' />\"\n\n    def __repr__(self) -> str:\n        return self.repr_xml()\n\n```\n\n#### duration\n\n```python\nduration: timedelta\n\n```\n\nReturn the span's duration as a timedelta, or None if start/end not set.\n\n#### descendants\n\n```python\ndescendants: list[SpanNode]\n\n```\n\nReturn all descendants of this node in DFS order.\n\n#### ancestors\n\n```python\nancestors: list[SpanNode]\n\n```\n\nReturn all ancestors of this node.\n\n#### add_child\n\n```python\nadd_child(child: SpanNode) -> None\n\n```\n\nAttach a child node to this node's list of children.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef add_child(self, child: SpanNode) -> None:\n    \"\"\"Attach a child node to this node's list of children.\"\"\"\n    assert child.trace_id == self.trace_id, f\"traces don't match: {child.trace_id:032x} != {self.trace_id:032x}\"\n    assert child.parent_span_id == self.span_id, (\n        f'parent span mismatch: {child.parent_span_id:016x} != {self.span_id:016x}'\n    )\n    self.children_by_id[child.node_key] = child\n    child.parent = self\n\n```\n\n#### find_children\n\n```python\nfind_children(\n    predicate: SpanQuery | SpanPredicate,\n) -> list[SpanNode]\n\n```\n\nReturn all immediate children that satisfy the given predicate.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef find_children(self, predicate: SpanQuery | SpanPredicate) -> list[SpanNode]:\n    \"\"\"Return all immediate children that satisfy the given predicate.\"\"\"\n    return list(self._filter_children(predicate))\n\n```\n\n#### first_child\n\n```python\nfirst_child(\n    predicate: SpanQuery | SpanPredicate,\n) -> SpanNode | None\n\n```\n\nReturn the first immediate child that satisfies the given predicate, or None if none match.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef first_child(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:\n    \"\"\"Return the first immediate child that satisfies the given predicate, or None if none match.\"\"\"\n    return next(self._filter_children(predicate), None)\n\n```\n\n#### any_child\n\n```python\nany_child(predicate: SpanQuery | SpanPredicate) -> bool\n\n```\n\nReturns True if there is at least one child that satisfies the predicate.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef any_child(self, predicate: SpanQuery | SpanPredicate) -> bool:\n    \"\"\"Returns True if there is at least one child that satisfies the predicate.\"\"\"\n    return self.first_child(predicate) is not None\n\n```\n\n#### find_descendants\n\n```python\nfind_descendants(\n    predicate: SpanQuery | SpanPredicate,\n    stop_recursing_when: (\n        SpanQuery | SpanPredicate | None\n    ) = None,\n) -> list[SpanNode]\n\n```\n\nReturn all descendant nodes that satisfy the given predicate in DFS order.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef find_descendants(\n    self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n) -> list[SpanNode]:\n    \"\"\"Return all descendant nodes that satisfy the given predicate in DFS order.\"\"\"\n    return list(self._filter_descendants(predicate, stop_recursing_when))\n\n```\n\n#### first_descendant\n\n```python\nfirst_descendant(\n    predicate: SpanQuery | SpanPredicate,\n    stop_recursing_when: (\n        SpanQuery | SpanPredicate | None\n    ) = None,\n) -> SpanNode | None\n\n```\n\nDFS: Return the first descendant (in DFS order) that satisfies the given predicate, or `None` if none match.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef first_descendant(\n    self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n) -> SpanNode | None:\n    \"\"\"DFS: Return the first descendant (in DFS order) that satisfies the given predicate, or `None` if none match.\"\"\"\n    return next(self._filter_descendants(predicate, stop_recursing_when), None)\n\n```\n\n#### any_descendant\n\n```python\nany_descendant(\n    predicate: SpanQuery | SpanPredicate,\n    stop_recursing_when: (\n        SpanQuery | SpanPredicate | None\n    ) = None,\n) -> bool\n\n```\n\nReturns `True` if there is at least one descendant that satisfies the predicate.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef any_descendant(\n    self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n) -> bool:\n    \"\"\"Returns `True` if there is at least one descendant that satisfies the predicate.\"\"\"\n    return self.first_descendant(predicate, stop_recursing_when) is not None\n\n```\n\n#### find_ancestors\n\n```python\nfind_ancestors(\n    predicate: SpanQuery | SpanPredicate,\n    stop_recursing_when: (\n        SpanQuery | SpanPredicate | None\n    ) = None,\n) -> list[SpanNode]\n\n```\n\nReturn all ancestors that satisfy the given predicate.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef find_ancestors(\n    self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n) -> list[SpanNode]:\n    \"\"\"Return all ancestors that satisfy the given predicate.\"\"\"\n    return list(self._filter_ancestors(predicate, stop_recursing_when))\n\n```\n\n#### first_ancestor\n\n```python\nfirst_ancestor(\n    predicate: SpanQuery | SpanPredicate,\n    stop_recursing_when: (\n        SpanQuery | SpanPredicate | None\n    ) = None,\n) -> SpanNode | None\n\n```\n\nReturn the closest ancestor that satisfies the given predicate, or `None` if none match.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef first_ancestor(\n    self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n) -> SpanNode | None:\n    \"\"\"Return the closest ancestor that satisfies the given predicate, or `None` if none match.\"\"\"\n    return next(self._filter_ancestors(predicate, stop_recursing_when), None)\n\n```\n\n#### any_ancestor\n\n```python\nany_ancestor(\n    predicate: SpanQuery | SpanPredicate,\n    stop_recursing_when: (\n        SpanQuery | SpanPredicate | None\n    ) = None,\n) -> bool\n\n```\n\nReturns True if any ancestor satisfies the predicate.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef any_ancestor(\n    self, predicate: SpanQuery | SpanPredicate, stop_recursing_when: SpanQuery | SpanPredicate | None = None\n) -> bool:\n    \"\"\"Returns True if any ancestor satisfies the predicate.\"\"\"\n    return self.first_ancestor(predicate, stop_recursing_when) is not None\n\n```\n\n#### matches\n\n```python\nmatches(query: SpanQuery | SpanPredicate) -> bool\n\n```\n\nCheck if the span node matches the query conditions or predicate.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef matches(self, query: SpanQuery | SpanPredicate) -> bool:\n    \"\"\"Check if the span node matches the query conditions or predicate.\"\"\"\n    if callable(query):\n        return query(self)\n\n    return self._matches_query(query)\n\n```\n\n#### repr_xml\n\n```python\nrepr_xml(\n    include_children: bool = True,\n    include_trace_id: bool = False,\n    include_span_id: bool = False,\n    include_start_timestamp: bool = False,\n    include_duration: bool = False,\n) -> str\n\n```\n\nReturn an XML-like string representation of the node.\n\nOptionally includes children, trace_id, span_id, start_timestamp, and duration.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef repr_xml(\n    self,\n    include_children: bool = True,\n    include_trace_id: bool = False,\n    include_span_id: bool = False,\n    include_start_timestamp: bool = False,\n    include_duration: bool = False,\n) -> str:\n    \"\"\"Return an XML-like string representation of the node.\n\n    Optionally includes children, trace_id, span_id, start_timestamp, and duration.\n    \"\"\"\n    first_line_parts = [f'<SpanNode name={self.name!r}']\n    if include_trace_id:\n        first_line_parts.append(f\"trace_id='{self.trace_id:032x}'\")\n    if include_span_id:\n        first_line_parts.append(f\"span_id='{self.span_id:016x}'\")\n    if include_start_timestamp:\n        first_line_parts.append(f'start_timestamp={self.start_timestamp.isoformat()!r}')\n    if include_duration:\n        first_line_parts.append(f\"duration='{self.duration}'\")\n\n    extra_lines: list[str] = []\n    if include_children and self.children:\n        first_line_parts.append('>')\n        for child in self.children:\n            extra_lines.append(\n                indent(\n                    child.repr_xml(\n                        include_children=include_children,\n                        include_trace_id=include_trace_id,\n                        include_span_id=include_span_id,\n                        include_start_timestamp=include_start_timestamp,\n                        include_duration=include_duration,\n                    ),\n                    '  ',\n                )\n            )\n        extra_lines.append('</SpanNode>')\n    else:\n        if self.children:\n            first_line_parts.append('children=...')\n        first_line_parts.append('/>')\n    return '\\n'.join([' '.join(first_line_parts), *extra_lines])\n\n```\n\n### SpanQuery\n\nBases: `TypedDict`\n\nA serializable query for filtering SpanNodes based on various conditions.\n\nAll fields are optional and combined with AND logic by default.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\nclass SpanQuery(TypedDict, total=False):\n    \"\"\"A serializable query for filtering SpanNodes based on various conditions.\n\n    All fields are optional and combined with AND logic by default.\n    \"\"\"\n\n    # These fields are ordered to match the implementation of SpanNode.matches_query for easy review.\n    # * Individual span conditions come first because these are generally the cheapest to evaluate\n    # * Logical combinations come next because they may just be combinations of individual span conditions\n    # * Related-span conditions come last because they may require the most work to evaluate\n\n    # Individual span conditions\n    ## Name conditions\n    name_equals: str\n    name_contains: str\n    name_matches_regex: str  # regex pattern\n\n    ## Attribute conditions\n    has_attributes: dict[str, Any]\n    has_attribute_keys: list[str]\n\n    ## Timing conditions\n    min_duration: timedelta | float\n    max_duration: timedelta | float\n\n    # Logical combinations of conditions\n    not_: SpanQuery\n    and_: list[SpanQuery]\n    or_: list[SpanQuery]\n\n    # Child conditions\n    min_child_count: int\n    max_child_count: int\n    some_child_has: SpanQuery\n    all_children_have: SpanQuery\n    no_child_has: SpanQuery\n\n    # Recursive conditions\n    stop_recursing_when: SpanQuery\n    \"\"\"If present, stop recursing through ancestors or descendants at nodes that match this condition.\"\"\"\n\n    ## Descendant conditions\n    min_descendant_count: int\n    max_descendant_count: int\n    some_descendant_has: SpanQuery\n    all_descendants_have: SpanQuery\n    no_descendant_has: SpanQuery\n\n    ## Ancestor conditions\n    min_depth: int  # depth is equivalent to ancestor count; roots have depth 0\n    max_depth: int\n    some_ancestor_has: SpanQuery\n    all_ancestors_have: SpanQuery\n    no_ancestor_has: SpanQuery\n\n```\n\n#### stop_recursing_when\n\n```python\nstop_recursing_when: SpanQuery\n\n```\n\nIf present, stop recursing through ancestors or descendants at nodes that match this condition.\n\n### SpanTree\n\nA container that builds a hierarchy of SpanNode objects from a list of finished spans.\n\nYou can then search or iterate the tree to make your assertions (using DFS for traversal).\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\n@dataclass(repr=False, kw_only=True)\nclass SpanTree:\n    \"\"\"A container that builds a hierarchy of SpanNode objects from a list of finished spans.\n\n    You can then search or iterate the tree to make your assertions (using DFS for traversal).\n    \"\"\"\n\n    roots: list[SpanNode] = field(default_factory=list)\n    nodes_by_id: dict[str, SpanNode] = field(default_factory=dict)\n\n    # -------------------------------------------------------------------------\n    # Construction\n    # -------------------------------------------------------------------------\n    def __post_init__(self):\n        self._rebuild_tree()\n\n    def add_spans(self, spans: list[SpanNode]) -> None:\n        \"\"\"Add a list of spans to the tree, rebuilding the tree structure.\"\"\"\n        for span in spans:\n            self.nodes_by_id[span.node_key] = span\n        self._rebuild_tree()\n\n    def add_readable_spans(self, readable_spans: list[ReadableSpan]):\n        self.add_spans([SpanNode.from_readable_span(span) for span in readable_spans])\n\n    def _rebuild_tree(self):\n        # Ensure spans are ordered by start_timestamp so that roots and children end up in the right order\n        nodes = list(self.nodes_by_id.values())\n        nodes.sort(key=lambda node: node.start_timestamp or datetime.min)\n        self.nodes_by_id = {node.node_key: node for node in nodes}\n\n        # Build the parent/child relationships\n        for node in self.nodes_by_id.values():\n            parent_node_key = node.parent_node_key\n            if parent_node_key is not None:\n                parent_node = self.nodes_by_id.get(parent_node_key)\n                if parent_node is not None:\n                    parent_node.add_child(node)\n\n        # Determine the roots\n        # A node is a \"root\" if its parent is None or if its parent's span_id is not in the current set of spans.\n        self.roots = []\n        for node in self.nodes_by_id.values():\n            parent_node_key = node.parent_node_key\n            if parent_node_key is None or parent_node_key not in self.nodes_by_id:\n                self.roots.append(node)\n\n    # -------------------------------------------------------------------------\n    # Node filtering and iteration\n    # -------------------------------------------------------------------------\n    def find(self, predicate: SpanQuery | SpanPredicate) -> list[SpanNode]:\n        \"\"\"Find all nodes in the entire tree that match the predicate, scanning from each root in DFS order.\"\"\"\n        return list(self._filter(predicate))\n\n    def first(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:\n        \"\"\"Find the first node that matches a predicate, scanning from each root in DFS order. Returns `None` if not found.\"\"\"\n        return next(self._filter(predicate), None)\n\n    def any(self, predicate: SpanQuery | SpanPredicate) -> bool:\n        \"\"\"Returns True if any node in the tree matches the predicate.\"\"\"\n        return self.first(predicate) is not None\n\n    def _filter(self, predicate: SpanQuery | SpanPredicate) -> Iterator[SpanNode]:\n        for node in self:\n            if node.matches(predicate):\n                yield node\n\n    def __iter__(self) -> Iterator[SpanNode]:\n        \"\"\"Return an iterator over all nodes in the tree.\"\"\"\n        return iter(self.nodes_by_id.values())\n\n    # -------------------------------------------------------------------------\n    # String representation\n    # -------------------------------------------------------------------------\n    def repr_xml(\n        self,\n        include_children: bool = True,\n        include_trace_id: bool = False,\n        include_span_id: bool = False,\n        include_start_timestamp: bool = False,\n        include_duration: bool = False,\n    ) -> str:\n        \"\"\"Return an XML-like string representation of the tree, optionally including children, trace_id, span_id, duration, and timestamps.\"\"\"\n        if not self.roots:\n            return '<SpanTree />'\n        repr_parts = [\n            '<SpanTree>',\n            *[\n                indent(\n                    root.repr_xml(\n                        include_children=include_children,\n                        include_trace_id=include_trace_id,\n                        include_span_id=include_span_id,\n                        include_start_timestamp=include_start_timestamp,\n                        include_duration=include_duration,\n                    ),\n                    '  ',\n                )\n                for root in self.roots\n            ],\n            '</SpanTree>',\n        ]\n        return '\\n'.join(repr_parts)\n\n    def __str__(self):\n        return f'<SpanTree num_roots={len(self.roots)} total_spans={len(self.nodes_by_id)} />'\n\n    def __repr__(self):\n        return self.repr_xml()\n\n```\n\n#### add_spans\n\n```python\nadd_spans(spans: list[SpanNode]) -> None\n\n```\n\nAdd a list of spans to the tree, rebuilding the tree structure.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef add_spans(self, spans: list[SpanNode]) -> None:\n    \"\"\"Add a list of spans to the tree, rebuilding the tree structure.\"\"\"\n    for span in spans:\n        self.nodes_by_id[span.node_key] = span\n    self._rebuild_tree()\n\n```\n\n#### find\n\n```python\nfind(\n    predicate: SpanQuery | SpanPredicate,\n) -> list[SpanNode]\n\n```\n\nFind all nodes in the entire tree that match the predicate, scanning from each root in DFS order.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef find(self, predicate: SpanQuery | SpanPredicate) -> list[SpanNode]:\n    \"\"\"Find all nodes in the entire tree that match the predicate, scanning from each root in DFS order.\"\"\"\n    return list(self._filter(predicate))\n\n```\n\n#### first\n\n```python\nfirst(\n    predicate: SpanQuery | SpanPredicate,\n) -> SpanNode | None\n\n```\n\nFind the first node that matches a predicate, scanning from each root in DFS order. Returns `None` if not found.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef first(self, predicate: SpanQuery | SpanPredicate) -> SpanNode | None:\n    \"\"\"Find the first node that matches a predicate, scanning from each root in DFS order. Returns `None` if not found.\"\"\"\n    return next(self._filter(predicate), None)\n\n```\n\n#### any\n\n```python\nany(predicate: SpanQuery | SpanPredicate) -> bool\n\n```\n\nReturns True if any node in the tree matches the predicate.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef any(self, predicate: SpanQuery | SpanPredicate) -> bool:\n    \"\"\"Returns True if any node in the tree matches the predicate.\"\"\"\n    return self.first(predicate) is not None\n\n```\n\n#### __iter__\n\n```python\n__iter__() -> Iterator[SpanNode]\n\n```\n\nReturn an iterator over all nodes in the tree.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef __iter__(self) -> Iterator[SpanNode]:\n    \"\"\"Return an iterator over all nodes in the tree.\"\"\"\n    return iter(self.nodes_by_id.values())\n\n```\n\n#### repr_xml\n\n```python\nrepr_xml(\n    include_children: bool = True,\n    include_trace_id: bool = False,\n    include_span_id: bool = False,\n    include_start_timestamp: bool = False,\n    include_duration: bool = False,\n) -> str\n\n```\n\nReturn an XML-like string representation of the tree, optionally including children, trace_id, span_id, duration, and timestamps.\n\nSource code in `pydantic_evals/pydantic_evals/otel/span_tree.py`\n\n```python\ndef repr_xml(\n    self,\n    include_children: bool = True,\n    include_trace_id: bool = False,\n    include_span_id: bool = False,\n    include_start_timestamp: bool = False,\n    include_duration: bool = False,\n) -> str:\n    \"\"\"Return an XML-like string representation of the tree, optionally including children, trace_id, span_id, duration, and timestamps.\"\"\"\n    if not self.roots:\n        return '<SpanTree />'\n    repr_parts = [\n        '<SpanTree>',\n        *[\n            indent(\n                root.repr_xml(\n                    include_children=include_children,\n                    include_trace_id=include_trace_id,\n                    include_span_id=include_span_id,\n                    include_start_timestamp=include_start_timestamp,\n                    include_duration=include_duration,\n                ),\n                '  ',\n            )\n            for root in self.roots\n        ],\n        '</SpanTree>',\n    ]\n    return '\\n'.join(repr_parts)\n\n```",
  "content_length": 35595
}