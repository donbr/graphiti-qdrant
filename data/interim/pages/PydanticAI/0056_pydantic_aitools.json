{
  "title": "`pydantic_ai.tools`",
  "source_url": null,
  "content": "### AgentDepsT\n\n```python\nAgentDepsT = TypeVar(\n    \"AgentDepsT\", default=None, contravariant=True\n)\n\n```\n\nType variable for agent dependencies.\n\n### RunContext\n\nBases: `Generic[RunContextAgentDepsT]`\n\nInformation about the current call.\n\nSource code in `pydantic_ai_slim/pydantic_ai/_run_context.py`\n\n```python\n@dataclasses.dataclass(repr=False, kw_only=True)\nclass RunContext(Generic[RunContextAgentDepsT]):\n    \"\"\"Information about the current call.\"\"\"\n\n    deps: RunContextAgentDepsT\n    \"\"\"Dependencies for the agent.\"\"\"\n    model: Model\n    \"\"\"The model used in this run.\"\"\"\n    usage: RunUsage\n    \"\"\"LLM usage associated with the run.\"\"\"\n    prompt: str | Sequence[_messages.UserContent] | None = None\n    \"\"\"The original user prompt passed to the run.\"\"\"\n    messages: list[_messages.ModelMessage] = field(default_factory=list)\n    \"\"\"Messages exchanged in the conversation so far.\"\"\"\n    validation_context: Any = None\n    \"\"\"Pydantic [validation context](https://docs.pydantic.dev/latest/concepts/validators/#validation-context) for tool args and run outputs.\"\"\"\n    tracer: Tracer = field(default_factory=NoOpTracer)\n    \"\"\"The tracer to use for tracing the run.\"\"\"\n    trace_include_content: bool = False\n    \"\"\"Whether to include the content of the messages in the trace.\"\"\"\n    instrumentation_version: int = DEFAULT_INSTRUMENTATION_VERSION\n    \"\"\"Instrumentation settings version, if instrumentation is enabled.\"\"\"\n    retries: dict[str, int] = field(default_factory=dict)\n    \"\"\"Number of retries for each tool so far.\"\"\"\n    tool_call_id: str | None = None\n    \"\"\"The ID of the tool call.\"\"\"\n    tool_name: str | None = None\n    \"\"\"Name of the tool being called.\"\"\"\n    retry: int = 0\n    \"\"\"Number of retries of this tool so far.\"\"\"\n    max_retries: int = 0\n    \"\"\"The maximum number of retries of this tool.\"\"\"\n    run_step: int = 0\n    \"\"\"The current step in the run.\"\"\"\n    tool_call_approved: bool = False\n    \"\"\"Whether a tool call that required approval has now been approved.\"\"\"\n    partial_output: bool = False\n    \"\"\"Whether the output passed to an output validator is partial.\"\"\"\n    run_id: str | None = None\n    \"\"\"\"Unique identifier for the agent run.\"\"\"\n\n    @property\n    def last_attempt(self) -> bool:\n        \"\"\"Whether this is the last attempt at running this tool before an error is raised.\"\"\"\n        return self.retry == self.max_retries\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### deps\n\n```python\ndeps: RunContextAgentDepsT\n\n```\n\nDependencies for the agent.\n\n#### model\n\n```python\nmodel: Model\n\n```\n\nThe model used in this run.\n\n#### usage\n\n```python\nusage: RunUsage\n\n```\n\nLLM usage associated with the run.\n\n#### prompt\n\n```python\nprompt: str | Sequence[UserContent] | None = None\n\n```\n\nThe original user prompt passed to the run.\n\n#### messages\n\n```python\nmessages: list[ModelMessage] = field(default_factory=list)\n\n```\n\nMessages exchanged in the conversation so far.\n\n#### validation_context\n\n```python\nvalidation_context: Any = None\n\n```\n\nPydantic [validation context](https://docs.pydantic.dev/latest/concepts/validators/#validation-context) for tool args and run outputs.\n\n#### tracer\n\n```python\ntracer: Tracer = field(default_factory=NoOpTracer)\n\n```\n\nThe tracer to use for tracing the run.\n\n#### trace_include_content\n\n```python\ntrace_include_content: bool = False\n\n```\n\nWhether to include the content of the messages in the trace.\n\n#### instrumentation_version\n\n```python\ninstrumentation_version: int = (\n    DEFAULT_INSTRUMENTATION_VERSION\n)\n\n```\n\nInstrumentation settings version, if instrumentation is enabled.\n\n#### retries\n\n```python\nretries: dict[str, int] = field(default_factory=dict)\n\n```\n\nNumber of retries for each tool so far.\n\n#### tool_call_id\n\n```python\ntool_call_id: str | None = None\n\n```\n\nThe ID of the tool call.\n\n#### tool_name\n\n```python\ntool_name: str | None = None\n\n```\n\nName of the tool being called.\n\n#### retry\n\n```python\nretry: int = 0\n\n```\n\nNumber of retries of this tool so far.\n\n#### max_retries\n\n```python\nmax_retries: int = 0\n\n```\n\nThe maximum number of retries of this tool.\n\n#### run_step\n\n```python\nrun_step: int = 0\n\n```\n\nThe current step in the run.\n\n#### tool_call_approved\n\n```python\ntool_call_approved: bool = False\n\n```\n\nWhether a tool call that required approval has now been approved.\n\n#### partial_output\n\n```python\npartial_output: bool = False\n\n```\n\nWhether the output passed to an output validator is partial.\n\n#### run_id\n\n```python\nrun_id: str | None = None\n\n```\n\n\"Unique identifier for the agent run.\n\n#### last_attempt\n\n```python\nlast_attempt: bool\n\n```\n\nWhether this is the last attempt at running this tool before an error is raised.\n\n### ToolParams\n\n```python\nToolParams = ParamSpec('ToolParams', default=...)\n\n```\n\nRetrieval function param spec.\n\n### SystemPromptFunc\n\n```python\nSystemPromptFunc: TypeAlias = (\n    Callable[[RunContext[AgentDepsT]], str]\n    | Callable[[RunContext[AgentDepsT]], Awaitable[str]]\n    | Callable[[], str]\n    | Callable[[], Awaitable[str]]\n)\n\n```\n\nA function that may or maybe not take `RunContext` as an argument, and may or may not be async.\n\nUsage `SystemPromptFunc[AgentDepsT]`.\n\n### ToolFuncContext\n\n```python\nToolFuncContext: TypeAlias = Callable[\n    Concatenate[RunContext[AgentDepsT], ToolParams], Any\n]\n\n```\n\nA tool function that takes `RunContext` as the first argument.\n\nUsage `ToolContextFunc[AgentDepsT, ToolParams]`.\n\n### ToolFuncPlain\n\n```python\nToolFuncPlain: TypeAlias = Callable[ToolParams, Any]\n\n```\n\nA tool function that does not take `RunContext` as the first argument.\n\nUsage `ToolPlainFunc[ToolParams]`.\n\n### ToolFuncEither\n\n```python\nToolFuncEither: TypeAlias = (\n    ToolFuncContext[AgentDepsT, ToolParams]\n    | ToolFuncPlain[ToolParams]\n)\n\n```\n\nEither kind of tool function.\n\nThis is just a union of ToolFuncContext and ToolFuncPlain.\n\nUsage `ToolFuncEither[AgentDepsT, ToolParams]`.\n\n### ToolPrepareFunc\n\n```python\nToolPrepareFunc: TypeAlias = Callable[\n    [RunContext[AgentDepsT], \"ToolDefinition\"],\n    Awaitable[\"ToolDefinition | None\"],\n]\n\n```\n\nDefinition of a function that can prepare a tool definition at call time.\n\nSee [tool docs](../../tools-advanced/#tool-prepare) for more information.\n\nExample — here `only_if_42` is valid as a `ToolPrepareFunc`:\n\n```python\nfrom pydantic_ai import RunContext, Tool\nfrom pydantic_ai.tools import ToolDefinition\n\nasync def only_if_42(\n    ctx: RunContext[int], tool_def: ToolDefinition\n) -> ToolDefinition | None:\n    if ctx.deps == 42:\n        return tool_def\n\ndef hitchhiker(ctx: RunContext[int], answer: str) -> str:\n    return f'{ctx.deps} {answer}'\n\nhitchhiker = Tool(hitchhiker, prepare=only_if_42)\n\n```\n\nUsage `ToolPrepareFunc[AgentDepsT]`.\n\n### ToolsPrepareFunc\n\n```python\nToolsPrepareFunc: TypeAlias = Callable[\n    [RunContext[AgentDepsT], list[\"ToolDefinition\"]],\n    Awaitable[\"list[ToolDefinition] | None\"],\n]\n\n```\n\nDefinition of a function that can prepare the tool definition of all tools for each step. This is useful if you want to customize the definition of multiple tools or you want to register a subset of tools for a given step.\n\nExample — here `turn_on_strict_if_openai` is valid as a `ToolsPrepareFunc`:\n\n```python\nfrom dataclasses import replace\n\nfrom pydantic_ai import Agent, RunContext\nfrom pydantic_ai.tools import ToolDefinition\n\n\nasync def turn_on_strict_if_openai(\n    ctx: RunContext[None], tool_defs: list[ToolDefinition]\n) -> list[ToolDefinition] | None:\n    if ctx.model.system == 'openai':\n        return [replace(tool_def, strict=True) for tool_def in tool_defs]\n    return tool_defs\n\nagent = Agent('openai:gpt-4o', prepare_tools=turn_on_strict_if_openai)\n\n```\n\nUsage `ToolsPrepareFunc[AgentDepsT]`.\n\n### DocstringFormat\n\n```python\nDocstringFormat: TypeAlias = Literal[\n    \"google\", \"numpy\", \"sphinx\", \"auto\"\n]\n\n```\n\nSupported docstring formats.\n\n- `'google'` — [Google-style](https://google.github.io/styleguide/pyguide.html#381-docstrings) docstrings.\n- `'numpy'` — [Numpy-style](https://numpydoc.readthedocs.io/en/latest/format.html) docstrings.\n- `'sphinx'` — [Sphinx-style](https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html#the-sphinx-docstring-format) docstrings.\n- `'auto'` — Automatically infer the format based on the structure of the docstring.\n\n### DeferredToolRequests\n\nTool calls that require approval or external execution.\n\nThis can be used as an agent's `output_type` and will be used as the output of the agent run if the model called any deferred tools.\n\nResults can be passed to the next agent run using a DeferredToolResults object with the same tool call IDs.\n\nSee [deferred tools docs](../../deferred-tools/#deferred-tools) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n```python\n@dataclass(kw_only=True)\nclass DeferredToolRequests:\n    \"\"\"Tool calls that require approval or external execution.\n\n    This can be used as an agent's `output_type` and will be used as the output of the agent run if the model called any deferred tools.\n\n    Results can be passed to the next agent run using a [`DeferredToolResults`][pydantic_ai.tools.DeferredToolResults] object with the same tool call IDs.\n\n    See [deferred tools docs](../deferred-tools.md#deferred-tools) for more information.\n    \"\"\"\n\n    calls: list[ToolCallPart] = field(default_factory=list)\n    \"\"\"Tool calls that require external execution.\"\"\"\n    approvals: list[ToolCallPart] = field(default_factory=list)\n    \"\"\"Tool calls that require human-in-the-loop approval.\"\"\"\n    metadata: dict[str, dict[str, Any]] = field(default_factory=dict)\n    \"\"\"Metadata for deferred tool calls, keyed by `tool_call_id`.\"\"\"\n\n```\n\n#### calls\n\n```python\ncalls: list[ToolCallPart] = field(default_factory=list)\n\n```\n\nTool calls that require external execution.\n\n#### approvals\n\n```python\napprovals: list[ToolCallPart] = field(default_factory=list)\n\n```\n\nTool calls that require human-in-the-loop approval.\n\n#### metadata\n\n```python\nmetadata: dict[str, dict[str, Any]] = field(\n    default_factory=dict\n)\n\n```\n\nMetadata for deferred tool calls, keyed by `tool_call_id`.\n\n### ToolApproved\n\nIndicates that a tool call has been approved and that the tool function should be executed.\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n```python\n@dataclass(kw_only=True)\nclass ToolApproved:\n    \"\"\"Indicates that a tool call has been approved and that the tool function should be executed.\"\"\"\n\n    override_args: dict[str, Any] | None = None\n    \"\"\"Optional tool call arguments to use instead of the original arguments.\"\"\"\n\n    kind: Literal['tool-approved'] = 'tool-approved'\n\n```\n\n#### override_args\n\n```python\noverride_args: dict[str, Any] | None = None\n\n```\n\nOptional tool call arguments to use instead of the original arguments.\n\n### ToolDenied\n\nIndicates that a tool call has been denied and that a denial message should be returned to the model.\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n```python\n@dataclass\nclass ToolDenied:\n    \"\"\"Indicates that a tool call has been denied and that a denial message should be returned to the model.\"\"\"\n\n    message: str = 'The tool call was denied.'\n    \"\"\"The message to return to the model.\"\"\"\n\n    _: KW_ONLY\n\n    kind: Literal['tool-denied'] = 'tool-denied'\n\n```\n\n#### message\n\n```python\nmessage: str = 'The tool call was denied.'\n\n```\n\nThe message to return to the model.\n\n### DeferredToolResults\n\nResults for deferred tool calls from a previous run that required approval or external execution.\n\nThe tool call IDs need to match those from the DeferredToolRequests output object from the previous run.\n\nSee [deferred tools docs](../../deferred-tools/#deferred-tools) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n```python\n@dataclass(kw_only=True)\nclass DeferredToolResults:\n    \"\"\"Results for deferred tool calls from a previous run that required approval or external execution.\n\n    The tool call IDs need to match those from the [`DeferredToolRequests`][pydantic_ai.output.DeferredToolRequests] output object from the previous run.\n\n    See [deferred tools docs](../deferred-tools.md#deferred-tools) for more information.\n    \"\"\"\n\n    calls: dict[str, DeferredToolCallResult | Any] = field(default_factory=dict)\n    \"\"\"Map of tool call IDs to results for tool calls that required external execution.\"\"\"\n    approvals: dict[str, bool | DeferredToolApprovalResult] = field(default_factory=dict)\n    \"\"\"Map of tool call IDs to results for tool calls that required human-in-the-loop approval.\"\"\"\n\n```\n\n#### calls\n\n```python\ncalls: dict[str, DeferredToolCallResult | Any] = field(\n    default_factory=dict\n)\n\n```\n\nMap of tool call IDs to results for tool calls that required external execution.\n\n#### approvals\n\n```python\napprovals: dict[str, bool | DeferredToolApprovalResult] = (\n    field(default_factory=dict)\n)\n\n```\n\nMap of tool call IDs to results for tool calls that required human-in-the-loop approval.\n\n### Tool\n\nBases: `Generic[ToolAgentDepsT]`\n\nA tool function for an agent.\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n````python\n@dataclass(init=False)\nclass Tool(Generic[ToolAgentDepsT]):\n    \"\"\"A tool function for an agent.\"\"\"\n\n    function: ToolFuncEither[ToolAgentDepsT]\n    takes_ctx: bool\n    max_retries: int | None\n    name: str\n    description: str | None\n    prepare: ToolPrepareFunc[ToolAgentDepsT] | None\n    docstring_format: DocstringFormat\n    require_parameter_descriptions: bool\n    strict: bool | None\n    sequential: bool\n    requires_approval: bool\n    metadata: dict[str, Any] | None\n    function_schema: _function_schema.FunctionSchema\n    \"\"\"\n    The base JSON schema for the tool's parameters.\n\n    This schema may be modified by the `prepare` function or by the Model class prior to including it in an API request.\n    \"\"\"\n\n    def __init__(\n        self,\n        function: ToolFuncEither[ToolAgentDepsT],\n        *,\n        takes_ctx: bool | None = None,\n        max_retries: int | None = None,\n        name: str | None = None,\n        description: str | None = None,\n        prepare: ToolPrepareFunc[ToolAgentDepsT] | None = None,\n        docstring_format: DocstringFormat = 'auto',\n        require_parameter_descriptions: bool = False,\n        schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n        strict: bool | None = None,\n        sequential: bool = False,\n        requires_approval: bool = False,\n        metadata: dict[str, Any] | None = None,\n        function_schema: _function_schema.FunctionSchema | None = None,\n    ):\n        \"\"\"Create a new tool instance.\n\n        Example usage:\n\n        ```python {noqa=\"I001\"}\n        from pydantic_ai import Agent, RunContext, Tool\n\n        async def my_tool(ctx: RunContext[int], x: int, y: int) -> str:\n            return f'{ctx.deps} {x} {y}'\n\n        agent = Agent('test', tools=[Tool(my_tool)])\n        ```\n\n        or with a custom prepare method:\n\n        ```python {noqa=\"I001\"}\n\n        from pydantic_ai import Agent, RunContext, Tool\n        from pydantic_ai.tools import ToolDefinition\n\n        async def my_tool(ctx: RunContext[int], x: int, y: int) -> str:\n            return f'{ctx.deps} {x} {y}'\n\n        async def prep_my_tool(\n            ctx: RunContext[int], tool_def: ToolDefinition\n        ) -> ToolDefinition | None:\n            # only register the tool if `deps == 42`\n            if ctx.deps == 42:\n                return tool_def\n\n        agent = Agent('test', tools=[Tool(my_tool, prepare=prep_my_tool)])\n        ```\n\n\n        Args:\n            function: The Python function to call as the tool.\n            takes_ctx: Whether the function takes a [`RunContext`][pydantic_ai.tools.RunContext] first argument,\n                this is inferred if unset.\n            max_retries: Maximum number of retries allowed for this tool, set to the agent default if `None`.\n            name: Name of the tool, inferred from the function if `None`.\n            description: Description of the tool, inferred from the function if `None`.\n            prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n                tool from a given step. This is useful if you want to customise a tool at call time,\n                or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n            docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n                Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.\n            require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.\n            schema_generator: The JSON schema generator class to use. Defaults to `GenerateToolJsonSchema`.\n            strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n                See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n            sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n            requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n                See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n            metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n            function_schema: The function schema to use for the tool. If not provided, it will be generated.\n        \"\"\"\n        self.function = function\n        self.function_schema = function_schema or _function_schema.function_schema(\n            function,\n            schema_generator,\n            takes_ctx=takes_ctx,\n            docstring_format=docstring_format,\n            require_parameter_descriptions=require_parameter_descriptions,\n        )\n        self.takes_ctx = self.function_schema.takes_ctx\n        self.max_retries = max_retries\n        self.name = name or function.__name__\n        self.description = description or self.function_schema.description\n        self.prepare = prepare\n        self.docstring_format = docstring_format\n        self.require_parameter_descriptions = require_parameter_descriptions\n        self.strict = strict\n        self.sequential = sequential\n        self.requires_approval = requires_approval\n        self.metadata = metadata\n\n    @classmethod\n    def from_schema(\n        cls,\n        function: Callable[..., Any],\n        name: str,\n        description: str | None,\n        json_schema: JsonSchemaValue,\n        takes_ctx: bool = False,\n        sequential: bool = False,\n    ) -> Self:\n        \"\"\"Creates a Pydantic tool from a function and a JSON schema.\n\n        Args:\n            function: The function to call.\n                This will be called with keywords only, and no validation of\n                the arguments will be performed.\n            name: The unique name of the tool that clearly communicates its purpose\n            description: Used to tell the model how/when/why to use the tool.\n                You can provide few-shot examples as a part of the description.\n            json_schema: The schema for the function arguments\n            takes_ctx: An optional boolean parameter indicating whether the function\n                accepts the context object as an argument.\n            sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n\n        Returns:\n            A Pydantic tool that calls the function\n        \"\"\"\n        function_schema = _function_schema.FunctionSchema(\n            function=function,\n            description=description,\n            validator=SchemaValidator(schema=core_schema.any_schema()),\n            json_schema=json_schema,\n            takes_ctx=takes_ctx,\n            is_async=_utils.is_async_callable(function),\n        )\n\n        return cls(\n            function,\n            takes_ctx=takes_ctx,\n            name=name,\n            description=description,\n            function_schema=function_schema,\n            sequential=sequential,\n        )\n\n    @property\n    def tool_def(self):\n        return ToolDefinition(\n            name=self.name,\n            description=self.description,\n            parameters_json_schema=self.function_schema.json_schema,\n            strict=self.strict,\n            sequential=self.sequential,\n            metadata=self.metadata,\n            kind='unapproved' if self.requires_approval else 'function',\n        )\n\n    async def prepare_tool_def(self, ctx: RunContext[ToolAgentDepsT]) -> ToolDefinition | None:\n        \"\"\"Get the tool definition.\n\n        By default, this method creates a tool definition, then either returns it, or calls `self.prepare`\n        if it's set.\n\n        Returns:\n            return a `ToolDefinition` or `None` if the tools should not be registered for this run.\n        \"\"\"\n        base_tool_def = self.tool_def\n\n        if self.prepare is not None:\n            return await self.prepare(ctx, base_tool_def)\n        else:\n            return base_tool_def\n\n````\n\n#### __init__\n\n```python\n__init__(\n    function: ToolFuncEither[ToolAgentDepsT],\n    *,\n    takes_ctx: bool | None = None,\n    max_retries: int | None = None,\n    name: str | None = None,\n    description: str | None = None,\n    prepare: ToolPrepareFunc[ToolAgentDepsT] | None = None,\n    docstring_format: DocstringFormat = \"auto\",\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[\n        GenerateJsonSchema\n    ] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None,\n    function_schema: FunctionSchema | None = None\n)\n\n```\n\nCreate a new tool instance.\n\nExample usage:\n\n```python\nfrom pydantic_ai import Agent, RunContext, Tool\n\nasync def my_tool(ctx: RunContext[int], x: int, y: int) -> str:\n    return f'{ctx.deps} {x} {y}'\n\nagent = Agent('test', tools=[Tool(my_tool)])\n\n```\n\nor with a custom prepare method:\n\n```python\nfrom pydantic_ai import Agent, RunContext, Tool\nfrom pydantic_ai.tools import ToolDefinition\n\nasync def my_tool(ctx: RunContext[int], x: int, y: int) -> str:\n    return f'{ctx.deps} {x} {y}'\n\nasync def prep_my_tool(\n    ctx: RunContext[int], tool_def: ToolDefinition\n) -> ToolDefinition | None:\n    # only register the tool if `deps == 42`\n    if ctx.deps == 42:\n        return tool_def\n\nagent = Agent('test', tools=[Tool(my_tool, prepare=prep_my_tool)])\n\n```\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `function` | `ToolFuncEither[ToolAgentDepsT]` | The Python function to call as the tool. | *required* | | `takes_ctx` | `bool | None` | Whether the function takes a RunContext first argument, this is inferred if unset. | `None` | | `max_retries` | `int | None` | Maximum number of retries allowed for this tool, set to the agent default if None. | `None` | | `name` | `str | None` | Name of the tool, inferred from the function if None. | `None` | | `description` | `str | None` | Description of the tool, inferred from the function if None. | `None` | | `prepare` | `ToolPrepareFunc[ToolAgentDepsT] | None` | custom method to prepare the tool definition for each step, return None to omit this tool from a given step. This is useful if you want to customise a tool at call time, or omit it completely from a step. See ToolPrepareFunc. | `None` | | `docstring_format` | `DocstringFormat` | The format of the docstring, see DocstringFormat. Defaults to 'auto', such that the format is inferred from the structure of the docstring. | `'auto'` | | `require_parameter_descriptions` | `bool` | If True, raise an error if a parameter description is missing. Defaults to False. | `False` | | `schema_generator` | `type[GenerateJsonSchema]` | The JSON schema generator class to use. Defaults to GenerateToolJsonSchema. | `GenerateToolJsonSchema` | | `strict` | `bool | None` | Whether to enforce JSON schema compliance (only affects OpenAI). See ToolDefinition for more info. | `None` | | `sequential` | `bool` | Whether the function requires a sequential/serial execution environment. Defaults to False. | `False` | | `requires_approval` | `bool` | Whether this tool requires human-in-the-loop approval. Defaults to False. See the tools documentation for more info. | `False` | | `metadata` | `dict[str, Any] | None` | Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization. | `None` | | `function_schema` | `FunctionSchema | None` | The function schema to use for the tool. If not provided, it will be generated. | `None` |\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n````python\ndef __init__(\n    self,\n    function: ToolFuncEither[ToolAgentDepsT],\n    *,\n    takes_ctx: bool | None = None,\n    max_retries: int | None = None,\n    name: str | None = None,\n    description: str | None = None,\n    prepare: ToolPrepareFunc[ToolAgentDepsT] | None = None,\n    docstring_format: DocstringFormat = 'auto',\n    require_parameter_descriptions: bool = False,\n    schema_generator: type[GenerateJsonSchema] = GenerateToolJsonSchema,\n    strict: bool | None = None,\n    sequential: bool = False,\n    requires_approval: bool = False,\n    metadata: dict[str, Any] | None = None,\n    function_schema: _function_schema.FunctionSchema | None = None,\n):\n    \"\"\"Create a new tool instance.\n\n    Example usage:\n\n    ```python {noqa=\"I001\"}\n    from pydantic_ai import Agent, RunContext, Tool\n\n    async def my_tool(ctx: RunContext[int], x: int, y: int) -> str:\n        return f'{ctx.deps} {x} {y}'\n\n    agent = Agent('test', tools=[Tool(my_tool)])\n    ```\n\n    or with a custom prepare method:\n\n    ```python {noqa=\"I001\"}\n\n    from pydantic_ai import Agent, RunContext, Tool\n    from pydantic_ai.tools import ToolDefinition\n\n    async def my_tool(ctx: RunContext[int], x: int, y: int) -> str:\n        return f'{ctx.deps} {x} {y}'\n\n    async def prep_my_tool(\n        ctx: RunContext[int], tool_def: ToolDefinition\n    ) -> ToolDefinition | None:\n        # only register the tool if `deps == 42`\n        if ctx.deps == 42:\n            return tool_def\n\n    agent = Agent('test', tools=[Tool(my_tool, prepare=prep_my_tool)])\n    ```\n\n\n    Args:\n        function: The Python function to call as the tool.\n        takes_ctx: Whether the function takes a [`RunContext`][pydantic_ai.tools.RunContext] first argument,\n            this is inferred if unset.\n        max_retries: Maximum number of retries allowed for this tool, set to the agent default if `None`.\n        name: Name of the tool, inferred from the function if `None`.\n        description: Description of the tool, inferred from the function if `None`.\n        prepare: custom method to prepare the tool definition for each step, return `None` to omit this\n            tool from a given step. This is useful if you want to customise a tool at call time,\n            or omit it completely from a step. See [`ToolPrepareFunc`][pydantic_ai.tools.ToolPrepareFunc].\n        docstring_format: The format of the docstring, see [`DocstringFormat`][pydantic_ai.tools.DocstringFormat].\n            Defaults to `'auto'`, such that the format is inferred from the structure of the docstring.\n        require_parameter_descriptions: If True, raise an error if a parameter description is missing. Defaults to False.\n        schema_generator: The JSON schema generator class to use. Defaults to `GenerateToolJsonSchema`.\n        strict: Whether to enforce JSON schema compliance (only affects OpenAI).\n            See [`ToolDefinition`][pydantic_ai.tools.ToolDefinition] for more info.\n        sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n        requires_approval: Whether this tool requires human-in-the-loop approval. Defaults to False.\n            See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n        metadata: Optional metadata for the tool. This is not sent to the model but can be used for filtering and tool behavior customization.\n        function_schema: The function schema to use for the tool. If not provided, it will be generated.\n    \"\"\"\n    self.function = function\n    self.function_schema = function_schema or _function_schema.function_schema(\n        function,\n        schema_generator,\n        takes_ctx=takes_ctx,\n        docstring_format=docstring_format,\n        require_parameter_descriptions=require_parameter_descriptions,\n    )\n    self.takes_ctx = self.function_schema.takes_ctx\n    self.max_retries = max_retries\n    self.name = name or function.__name__\n    self.description = description or self.function_schema.description\n    self.prepare = prepare\n    self.docstring_format = docstring_format\n    self.require_parameter_descriptions = require_parameter_descriptions\n    self.strict = strict\n    self.sequential = sequential\n    self.requires_approval = requires_approval\n    self.metadata = metadata\n\n````\n\n#### function_schema\n\n```python\nfunction_schema: FunctionSchema = (\n    function_schema\n    or function_schema(\n        function,\n        schema_generator,\n        takes_ctx=takes_ctx,\n        docstring_format=docstring_format,\n        require_parameter_descriptions=require_parameter_descriptions,\n    )\n)\n\n```\n\nThe base JSON schema for the tool's parameters.\n\nThis schema may be modified by the `prepare` function or by the Model class prior to including it in an API request.\n\n#### from_schema\n\n```python\nfrom_schema(\n    function: Callable[..., Any],\n    name: str,\n    description: str | None,\n    json_schema: JsonSchemaValue,\n    takes_ctx: bool = False,\n    sequential: bool = False,\n) -> Self\n\n```\n\nCreates a Pydantic tool from a function and a JSON schema.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `function` | `Callable[..., Any]` | The function to call. This will be called with keywords only, and no validation of the arguments will be performed. | *required* | | `name` | `str` | The unique name of the tool that clearly communicates its purpose | *required* | | `description` | `str | None` | Used to tell the model how/when/why to use the tool. You can provide few-shot examples as a part of the description. | *required* | | `json_schema` | `JsonSchemaValue` | The schema for the function arguments | *required* | | `takes_ctx` | `bool` | An optional boolean parameter indicating whether the function accepts the context object as an argument. | `False` | | `sequential` | `bool` | Whether the function requires a sequential/serial execution environment. Defaults to False. | `False` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Self` | A Pydantic tool that calls the function |\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n```python\n@classmethod\ndef from_schema(\n    cls,\n    function: Callable[..., Any],\n    name: str,\n    description: str | None,\n    json_schema: JsonSchemaValue,\n    takes_ctx: bool = False,\n    sequential: bool = False,\n) -> Self:\n    \"\"\"Creates a Pydantic tool from a function and a JSON schema.\n\n    Args:\n        function: The function to call.\n            This will be called with keywords only, and no validation of\n            the arguments will be performed.\n        name: The unique name of the tool that clearly communicates its purpose\n        description: Used to tell the model how/when/why to use the tool.\n            You can provide few-shot examples as a part of the description.\n        json_schema: The schema for the function arguments\n        takes_ctx: An optional boolean parameter indicating whether the function\n            accepts the context object as an argument.\n        sequential: Whether the function requires a sequential/serial execution environment. Defaults to False.\n\n    Returns:\n        A Pydantic tool that calls the function\n    \"\"\"\n    function_schema = _function_schema.FunctionSchema(\n        function=function,\n        description=description,\n        validator=SchemaValidator(schema=core_schema.any_schema()),\n        json_schema=json_schema,\n        takes_ctx=takes_ctx,\n        is_async=_utils.is_async_callable(function),\n    )\n\n    return cls(\n        function,\n        takes_ctx=takes_ctx,\n        name=name,\n        description=description,\n        function_schema=function_schema,\n        sequential=sequential,\n    )\n\n```\n\n#### prepare_tool_def\n\n```python\nprepare_tool_def(\n    ctx: RunContext[ToolAgentDepsT],\n) -> ToolDefinition | None\n\n```\n\nGet the tool definition.\n\nBy default, this method creates a tool definition, then either returns it, or calls `self.prepare` if it's set.\n\nReturns:\n\n| Type | Description | | --- | --- | | `ToolDefinition | None` | return a ToolDefinition or None if the tools should not be registered for this run. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n```python\nasync def prepare_tool_def(self, ctx: RunContext[ToolAgentDepsT]) -> ToolDefinition | None:\n    \"\"\"Get the tool definition.\n\n    By default, this method creates a tool definition, then either returns it, or calls `self.prepare`\n    if it's set.\n\n    Returns:\n        return a `ToolDefinition` or `None` if the tools should not be registered for this run.\n    \"\"\"\n    base_tool_def = self.tool_def\n\n    if self.prepare is not None:\n        return await self.prepare(ctx, base_tool_def)\n    else:\n        return base_tool_def\n\n```\n\n### ObjectJsonSchema\n\n```python\nObjectJsonSchema: TypeAlias = dict[str, Any]\n\n```\n\nType representing JSON schema of an object, e.g. where `\"type\": \"object\"`.\n\nThis type is used to define tools parameters (aka arguments) in ToolDefinition.\n\nWith PEP-728 this should be a TypedDict with `type: Literal['object']`, and `extra_parts=Any`\n\n### ToolDefinition\n\nDefinition of a tool passed to a model.\n\nThis is used for both function tools and output tools.\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n```python\n@dataclass(repr=False, kw_only=True)\nclass ToolDefinition:\n    \"\"\"Definition of a tool passed to a model.\n\n    This is used for both function tools and output tools.\n    \"\"\"\n\n    name: str\n    \"\"\"The name of the tool.\"\"\"\n\n    parameters_json_schema: ObjectJsonSchema = field(default_factory=lambda: {'type': 'object', 'properties': {}})\n    \"\"\"The JSON schema for the tool's parameters.\"\"\"\n\n    description: str | None = None\n    \"\"\"The description of the tool.\"\"\"\n\n    outer_typed_dict_key: str | None = None\n    \"\"\"The key in the outer [TypedDict] that wraps an output tool.\n\n    This will only be set for output tools which don't have an `object` JSON schema.\n    \"\"\"\n\n    strict: bool | None = None\n    \"\"\"Whether to enforce (vendor-specific) strict JSON schema validation for tool calls.\n\n    Setting this to `True` while using a supported model generally imposes some restrictions on the tool's JSON schema\n    in exchange for guaranteeing the API responses strictly match that schema.\n\n    When `False`, the model may be free to generate other properties or types (depending on the vendor).\n    When `None` (the default), the value will be inferred based on the compatibility of the parameters_json_schema.\n\n    Note: this is currently supported by OpenAI and Anthropic models.\n    \"\"\"\n\n    sequential: bool = False\n    \"\"\"Whether this tool requires a sequential/serial execution environment.\"\"\"\n\n    kind: ToolKind = field(default='function')\n    \"\"\"The kind of tool:\n\n    - `'function'`: a tool that will be executed by Pydantic AI during an agent run and has its result returned to the model\n    - `'output'`: a tool that passes through an output value that ends the run\n    - `'external'`: a tool whose result will be produced outside of the Pydantic AI agent run in which it was called, because it depends on an upstream service (or user) or could take longer to generate than it's reasonable to keep the agent process running.\n        See the [tools documentation](../deferred-tools.md#deferred-tools) for more info.\n    - `'unapproved'`: a tool that requires human-in-the-loop approval.\n        See the [tools documentation](../deferred-tools.md#human-in-the-loop-tool-approval) for more info.\n    \"\"\"\n\n    metadata: dict[str, Any] | None = None\n    \"\"\"Tool metadata that can be set by the toolset this tool came from. It is not sent to the model, but can be used for filtering and tool behavior customization.\n\n    For MCP tools, this contains the `meta`, `annotations`, and `output_schema` fields from the tool definition.\n    \"\"\"\n\n    @property\n    def defer(self) -> bool:\n        \"\"\"Whether calls to this tool will be deferred.\n\n        See the [tools documentation](../deferred-tools.md#deferred-tools) for more info.\n        \"\"\"\n        return self.kind in ('external', 'unapproved')\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### name\n\n```python\nname: str\n\n```\n\nThe name of the tool.\n\n#### parameters_json_schema\n\n```python\nparameters_json_schema: ObjectJsonSchema = field(\n    default_factory=lambda: {\n        \"type\": \"object\",\n        \"properties\": {},\n    }\n)\n\n```\n\nThe JSON schema for the tool's parameters.\n\n#### description\n\n```python\ndescription: str | None = None\n\n```\n\nThe description of the tool.\n\n#### outer_typed_dict_key\n\n```python\nouter_typed_dict_key: str | None = None\n\n```\n\nThe key in the outer [TypedDict] that wraps an output tool.\n\nThis will only be set for output tools which don't have an `object` JSON schema.\n\n#### strict\n\n```python\nstrict: bool | None = None\n\n```\n\nWhether to enforce (vendor-specific) strict JSON schema validation for tool calls.\n\nSetting this to `True` while using a supported model generally imposes some restrictions on the tool's JSON schema in exchange for guaranteeing the API responses strictly match that schema.\n\nWhen `False`, the model may be free to generate other properties or types (depending on the vendor). When `None` (the default), the value will be inferred based on the compatibility of the parameters_json_schema.\n\nNote: this is currently supported by OpenAI and Anthropic models.\n\n#### sequential\n\n```python\nsequential: bool = False\n\n```\n\nWhether this tool requires a sequential/serial execution environment.\n\n#### kind\n\n```python\nkind: ToolKind = field(default='function')\n\n```\n\nThe kind of tool:\n\n- `'function'`: a tool that will be executed by Pydantic AI during an agent run and has its result returned to the model\n- `'output'`: a tool that passes through an output value that ends the run\n- `'external'`: a tool whose result will be produced outside of the Pydantic AI agent run in which it was called, because it depends on an upstream service (or user) or could take longer to generate than it's reasonable to keep the agent process running. See the [tools documentation](../../deferred-tools/#deferred-tools) for more info.\n- `'unapproved'`: a tool that requires human-in-the-loop approval. See the [tools documentation](../../deferred-tools/#human-in-the-loop-tool-approval) for more info.\n\n#### metadata\n\n```python\nmetadata: dict[str, Any] | None = None\n\n```\n\nTool metadata that can be set by the toolset this tool came from. It is not sent to the model, but can be used for filtering and tool behavior customization.\n\nFor MCP tools, this contains the `meta`, `annotations`, and `output_schema` fields from the tool definition.\n\n#### defer\n\n```python\ndefer: bool\n\n```\n\nWhether calls to this tool will be deferred.\n\nSee the [tools documentation](../../deferred-tools/#deferred-tools) for more info.",
  "content_length": 39465
}