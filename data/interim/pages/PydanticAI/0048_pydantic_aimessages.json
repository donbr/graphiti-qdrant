{
  "title": "`pydantic_ai.messages`",
  "source_url": null,
  "content": "The structure of ModelMessage can be shown as a graph:\n\n```\ngraph RL\n    SystemPromptPart(SystemPromptPart) --- ModelRequestPart\n    UserPromptPart(UserPromptPart) --- ModelRequestPart\n    ToolReturnPart(ToolReturnPart) --- ModelRequestPart\n    RetryPromptPart(RetryPromptPart) --- ModelRequestPart\n    TextPart(TextPart) --- ModelResponsePart\n    ToolCallPart(ToolCallPart) --- ModelResponsePart\n    ThinkingPart(ThinkingPart) --- ModelResponsePart\n    ModelRequestPart(\"ModelRequestPart<br>(Union)\") --- ModelRequest\n    ModelRequest(\"ModelRequest(parts=list[...])\") --- ModelMessage\n    ModelResponsePart(\"ModelResponsePart<br>(Union)\") --- ModelResponse\n    ModelResponse(\"ModelResponse(parts=list[...])\") --- ModelMessage(\"ModelMessage<br>(Union)\")\n```\n\n### FinishReason\n\n```python\nFinishReason: TypeAlias = Literal[\n    \"stop\", \"length\", \"content_filter\", \"tool_call\", \"error\"\n]\n\n```\n\nReason the model finished generating the response, normalized to OpenTelemetry values.\n\n### SystemPromptPart\n\nA system prompt, generally written by the application developer.\n\nThis gives the model context and guidance on how to respond.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass SystemPromptPart:\n    \"\"\"A system prompt, generally written by the application developer.\n\n    This gives the model context and guidance on how to respond.\n    \"\"\"\n\n    content: str\n    \"\"\"The content of the prompt.\"\"\"\n\n    _: KW_ONLY\n\n    timestamp: datetime = field(default_factory=_now_utc)\n    \"\"\"The timestamp of the prompt.\"\"\"\n\n    dynamic_ref: str | None = None\n    \"\"\"The ref of the dynamic system prompt function that generated this part.\n\n    Only set if system prompt is dynamic, see [`system_prompt`][pydantic_ai.Agent.system_prompt] for more information.\n    \"\"\"\n\n    part_kind: Literal['system-prompt'] = 'system-prompt'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def otel_event(self, settings: InstrumentationSettings) -> Event:\n        return Event(\n            'gen_ai.system.message',\n            body={'role': 'system', **({'content': self.content} if settings.include_content else {})},\n        )\n\n    def otel_message_parts(self, settings: InstrumentationSettings) -> list[_otel_messages.MessagePart]:\n        return [_otel_messages.TextPart(type='text', **{'content': self.content} if settings.include_content else {})]\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### content\n\n```python\ncontent: str\n\n```\n\nThe content of the prompt.\n\n#### timestamp\n\n```python\ntimestamp: datetime = field(default_factory=now_utc)\n\n```\n\nThe timestamp of the prompt.\n\n#### dynamic_ref\n\n```python\ndynamic_ref: str | None = None\n\n```\n\nThe ref of the dynamic system prompt function that generated this part.\n\nOnly set if system prompt is dynamic, see system_prompt for more information.\n\n#### part_kind\n\n```python\npart_kind: Literal['system-prompt'] = 'system-prompt'\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n### FileUrl\n\nBases: `ABC`\n\nAbstract base class for any URL-based file.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(init=False, repr=False)\nclass FileUrl(ABC):\n    \"\"\"Abstract base class for any URL-based file.\"\"\"\n\n    url: str\n    \"\"\"The URL of the file.\"\"\"\n\n    _: KW_ONLY\n\n    force_download: bool = False\n    \"\"\"For OpenAI and Google APIs it:\n\n    * If True, the file is downloaded and the data is sent to the model as bytes.\n    * If False, the URL is sent directly to the model and no download is performed.\n    \"\"\"\n\n    vendor_metadata: dict[str, Any] | None = None\n    \"\"\"Vendor-specific metadata for the file.\n\n    Supported by:\n    - `GoogleModel`: `VideoUrl.vendor_metadata` is used as `video_metadata`: https://ai.google.dev/gemini-api/docs/video-understanding#customize-video-processing\n    - `OpenAIChatModel`, `OpenAIResponsesModel`: `ImageUrl.vendor_metadata['detail']` is used as `detail` setting for images\n    \"\"\"\n\n    _media_type: Annotated[str | None, pydantic.Field(alias='media_type', default=None, exclude=True)] = field(\n        compare=False, default=None\n    )\n\n    _identifier: Annotated[str | None, pydantic.Field(alias='identifier', default=None, exclude=True)] = field(\n        compare=False, default=None\n    )\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        media_type: str | None = None,\n        identifier: str | None = None,\n        force_download: bool = False,\n        vendor_metadata: dict[str, Any] | None = None,\n    ) -> None:\n        self.url = url\n        self._media_type = media_type\n        self._identifier = identifier\n        self.force_download = force_download\n        self.vendor_metadata = vendor_metadata\n\n    @pydantic.computed_field\n    @property\n    def media_type(self) -> str:\n        \"\"\"Return the media type of the file, based on the URL or the provided `media_type`.\"\"\"\n        return self._media_type or self._infer_media_type()\n\n    @pydantic.computed_field\n    @property\n    def identifier(self) -> str:\n        \"\"\"The identifier of the file, such as a unique ID.\n\n        This identifier can be provided to the model in a message to allow it to refer to this file in a tool call argument,\n        and the tool can look up the file in question by iterating over the message history and finding the matching `FileUrl`.\n\n        This identifier is only automatically passed to the model when the `FileUrl` is returned by a tool.\n        If you're passing the `FileUrl` as a user message, it's up to you to include a separate text part with the identifier,\n        e.g. \"This is file <identifier>:\" preceding the `FileUrl`.\n\n        It's also included in inline-text delimiters for providers that require inlining text documents, so the model can\n        distinguish multiple files.\n        \"\"\"\n        return self._identifier or _multi_modal_content_identifier(self.url)\n\n    @abstractmethod\n    def _infer_media_type(self) -> str:\n        \"\"\"Infer the media type of the file based on the URL.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def format(self) -> str:\n        \"\"\"The file format.\"\"\"\n        raise NotImplementedError\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### url\n\n```python\nurl: str = url\n\n```\n\nThe URL of the file.\n\n#### force_download\n\n```python\nforce_download: bool = force_download\n\n```\n\nFor OpenAI and Google APIs it:\n\n- If True, the file is downloaded and the data is sent to the model as bytes.\n- If False, the URL is sent directly to the model and no download is performed.\n\n#### vendor_metadata\n\n```python\nvendor_metadata: dict[str, Any] | None = vendor_metadata\n\n```\n\nVendor-specific metadata for the file.\n\nSupported by:\n\n- `GoogleModel`: `VideoUrl.vendor_metadata` is used as `video_metadata`: https://ai.google.dev/gemini-api/docs/video-understanding#customize-video-processing\n- `OpenAIChatModel`, `OpenAIResponsesModel`: `ImageUrl.vendor_metadata['detail']` is used as `detail` setting for images\n\n#### media_type\n\n```python\nmedia_type: str\n\n```\n\nReturn the media type of the file, based on the URL or the provided `media_type`.\n\n#### identifier\n\n```python\nidentifier: str\n\n```\n\nThe identifier of the file, such as a unique ID.\n\nThis identifier can be provided to the model in a message to allow it to refer to this file in a tool call argument, and the tool can look up the file in question by iterating over the message history and finding the matching `FileUrl`.\n\nThis identifier is only automatically passed to the model when the `FileUrl` is returned by a tool. If you're passing the `FileUrl` as a user message, it's up to you to include a separate text part with the identifier, e.g. \"This is file :\" preceding the `FileUrl`.\n\nIt's also included in inline-text delimiters for providers that require inlining text documents, so the model can distinguish multiple files.\n\n#### format\n\n```python\nformat: str\n\n```\n\nThe file format.\n\n### VideoUrl\n\nBases: `FileUrl`\n\nA URL to a video.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(init=False, repr=False)\nclass VideoUrl(FileUrl):\n    \"\"\"A URL to a video.\"\"\"\n\n    url: str\n    \"\"\"The URL of the video.\"\"\"\n\n    _: KW_ONLY\n\n    kind: Literal['video-url'] = 'video-url'\n    \"\"\"Type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        media_type: str | None = None,\n        identifier: str | None = None,\n        force_download: bool = False,\n        vendor_metadata: dict[str, Any] | None = None,\n        kind: Literal['video-url'] = 'video-url',\n        # Required for inline-snapshot which expects all dataclass `__init__` methods to take all field names as kwargs.\n        _media_type: str | None = None,\n        _identifier: str | None = None,\n    ) -> None:\n        super().__init__(\n            url=url,\n            force_download=force_download,\n            vendor_metadata=vendor_metadata,\n            media_type=media_type or _media_type,\n            identifier=identifier or _identifier,\n        )\n        self.kind = kind\n\n    def _infer_media_type(self) -> VideoMediaType:\n        \"\"\"Return the media type of the video, based on the url.\"\"\"\n        if self.url.endswith('.mkv'):\n            return 'video/x-matroska'\n        elif self.url.endswith('.mov'):\n            return 'video/quicktime'\n        elif self.url.endswith('.mp4'):\n            return 'video/mp4'\n        elif self.url.endswith('.webm'):\n            return 'video/webm'\n        elif self.url.endswith('.flv'):\n            return 'video/x-flv'\n        elif self.url.endswith(('.mpeg', '.mpg')):\n            return 'video/mpeg'\n        elif self.url.endswith('.wmv'):\n            return 'video/x-ms-wmv'\n        elif self.url.endswith('.three_gp'):\n            return 'video/3gpp'\n        # Assume that YouTube videos are mp4 because there would be no extension\n        # to infer from. This should not be a problem, as Gemini disregards media\n        # type for YouTube URLs.\n        elif self.is_youtube:\n            return 'video/mp4'\n        else:\n            raise ValueError(\n                f'Could not infer media type from video URL: {self.url}. Explicitly provide a `media_type` instead.'\n            )\n\n    @property\n    def is_youtube(self) -> bool:\n        \"\"\"True if the URL has a YouTube domain.\"\"\"\n        return self.url.startswith(('https://youtu.be/', 'https://youtube.com/', 'https://www.youtube.com/'))\n\n    @property\n    def format(self) -> VideoFormat:\n        \"\"\"The file format of the video.\n\n        The choice of supported formats were based on the Bedrock Converse API. Other APIs don't require to use a format.\n        \"\"\"\n        return _video_format_lookup[self.media_type]\n\n```\n\n#### url\n\n```python\nurl: str\n\n```\n\nThe URL of the video.\n\n#### kind\n\n```python\nkind: Literal['video-url'] = kind\n\n```\n\nType identifier, this is available on all parts as a discriminator.\n\n#### is_youtube\n\n```python\nis_youtube: bool\n\n```\n\nTrue if the URL has a YouTube domain.\n\n#### format\n\n```python\nformat: VideoFormat\n\n```\n\nThe file format of the video.\n\nThe choice of supported formats were based on the Bedrock Converse API. Other APIs don't require to use a format.\n\n### AudioUrl\n\nBases: `FileUrl`\n\nA URL to an audio file.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(init=False, repr=False)\nclass AudioUrl(FileUrl):\n    \"\"\"A URL to an audio file.\"\"\"\n\n    url: str\n    \"\"\"The URL of the audio file.\"\"\"\n\n    _: KW_ONLY\n\n    kind: Literal['audio-url'] = 'audio-url'\n    \"\"\"Type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        media_type: str | None = None,\n        identifier: str | None = None,\n        force_download: bool = False,\n        vendor_metadata: dict[str, Any] | None = None,\n        kind: Literal['audio-url'] = 'audio-url',\n        # Required for inline-snapshot which expects all dataclass `__init__` methods to take all field names as kwargs.\n        _media_type: str | None = None,\n        _identifier: str | None = None,\n    ) -> None:\n        super().__init__(\n            url=url,\n            force_download=force_download,\n            vendor_metadata=vendor_metadata,\n            media_type=media_type or _media_type,\n            identifier=identifier or _identifier,\n        )\n        self.kind = kind\n\n    def _infer_media_type(self) -> AudioMediaType:\n        \"\"\"Return the media type of the audio file, based on the url.\n\n        References:\n        - Gemini: https://ai.google.dev/gemini-api/docs/audio#supported-formats\n        \"\"\"\n        if self.url.endswith('.mp3'):\n            return 'audio/mpeg'\n        if self.url.endswith('.wav'):\n            return 'audio/wav'\n        if self.url.endswith('.flac'):\n            return 'audio/flac'\n        if self.url.endswith('.oga'):\n            return 'audio/ogg'\n        if self.url.endswith('.aiff'):\n            return 'audio/aiff'\n        if self.url.endswith('.aac'):\n            return 'audio/aac'\n\n        raise ValueError(\n            f'Could not infer media type from audio URL: {self.url}. Explicitly provide a `media_type` instead.'\n        )\n\n    @property\n    def format(self) -> AudioFormat:\n        \"\"\"The file format of the audio file.\"\"\"\n        return _audio_format_lookup[self.media_type]\n\n```\n\n#### url\n\n```python\nurl: str\n\n```\n\nThe URL of the audio file.\n\n#### kind\n\n```python\nkind: Literal['audio-url'] = kind\n\n```\n\nType identifier, this is available on all parts as a discriminator.\n\n#### format\n\n```python\nformat: AudioFormat\n\n```\n\nThe file format of the audio file.\n\n### ImageUrl\n\nBases: `FileUrl`\n\nA URL to an image.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(init=False, repr=False)\nclass ImageUrl(FileUrl):\n    \"\"\"A URL to an image.\"\"\"\n\n    url: str\n    \"\"\"The URL of the image.\"\"\"\n\n    _: KW_ONLY\n\n    kind: Literal['image-url'] = 'image-url'\n    \"\"\"Type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        media_type: str | None = None,\n        identifier: str | None = None,\n        force_download: bool = False,\n        vendor_metadata: dict[str, Any] | None = None,\n        kind: Literal['image-url'] = 'image-url',\n        # Required for inline-snapshot which expects all dataclass `__init__` methods to take all field names as kwargs.\n        _media_type: str | None = None,\n        _identifier: str | None = None,\n    ) -> None:\n        super().__init__(\n            url=url,\n            force_download=force_download,\n            vendor_metadata=vendor_metadata,\n            media_type=media_type or _media_type,\n            identifier=identifier or _identifier,\n        )\n        self.kind = kind\n\n    def _infer_media_type(self) -> ImageMediaType:\n        \"\"\"Return the media type of the image, based on the url.\"\"\"\n        if self.url.endswith(('.jpg', '.jpeg')):\n            return 'image/jpeg'\n        elif self.url.endswith('.png'):\n            return 'image/png'\n        elif self.url.endswith('.gif'):\n            return 'image/gif'\n        elif self.url.endswith('.webp'):\n            return 'image/webp'\n        else:\n            raise ValueError(\n                f'Could not infer media type from image URL: {self.url}. Explicitly provide a `media_type` instead.'\n            )\n\n    @property\n    def format(self) -> ImageFormat:\n        \"\"\"The file format of the image.\n\n        The choice of supported formats were based on the Bedrock Converse API. Other APIs don't require to use a format.\n        \"\"\"\n        return _image_format_lookup[self.media_type]\n\n```\n\n#### url\n\n```python\nurl: str\n\n```\n\nThe URL of the image.\n\n#### kind\n\n```python\nkind: Literal['image-url'] = kind\n\n```\n\nType identifier, this is available on all parts as a discriminator.\n\n#### format\n\n```python\nformat: ImageFormat\n\n```\n\nThe file format of the image.\n\nThe choice of supported formats were based on the Bedrock Converse API. Other APIs don't require to use a format.\n\n### DocumentUrl\n\nBases: `FileUrl`\n\nThe URL of the document.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(init=False, repr=False)\nclass DocumentUrl(FileUrl):\n    \"\"\"The URL of the document.\"\"\"\n\n    url: str\n    \"\"\"The URL of the document.\"\"\"\n\n    _: KW_ONLY\n\n    kind: Literal['document-url'] = 'document-url'\n    \"\"\"Type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        media_type: str | None = None,\n        identifier: str | None = None,\n        force_download: bool = False,\n        vendor_metadata: dict[str, Any] | None = None,\n        kind: Literal['document-url'] = 'document-url',\n        # Required for inline-snapshot which expects all dataclass `__init__` methods to take all field names as kwargs.\n        _media_type: str | None = None,\n        _identifier: str | None = None,\n    ) -> None:\n        super().__init__(\n            url=url,\n            force_download=force_download,\n            vendor_metadata=vendor_metadata,\n            media_type=media_type or _media_type,\n            identifier=identifier or _identifier,\n        )\n        self.kind = kind\n\n    def _infer_media_type(self) -> str:\n        \"\"\"Return the media type of the document, based on the url.\"\"\"\n        # Common document types are hardcoded here as mime-type support for these\n        # extensions varies across operating systems.\n        if self.url.endswith(('.md', '.mdx', '.markdown')):\n            return 'text/markdown'\n        elif self.url.endswith('.asciidoc'):\n            return 'text/x-asciidoc'\n        elif self.url.endswith('.txt'):\n            return 'text/plain'\n        elif self.url.endswith('.pdf'):\n            return 'application/pdf'\n        elif self.url.endswith('.rtf'):\n            return 'application/rtf'\n        elif self.url.endswith('.doc'):\n            return 'application/msword'\n        elif self.url.endswith('.docx'):\n            return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n        elif self.url.endswith('.xls'):\n            return 'application/vnd.ms-excel'\n        elif self.url.endswith('.xlsx'):\n            return 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n\n        type_, _ = guess_type(self.url)\n        if type_ is None:\n            raise ValueError(\n                f'Could not infer media type from document URL: {self.url}. Explicitly provide a `media_type` instead.'\n            )\n        return type_\n\n    @property\n    def format(self) -> DocumentFormat:\n        \"\"\"The file format of the document.\n\n        The choice of supported formats were based on the Bedrock Converse API. Other APIs don't require to use a format.\n        \"\"\"\n        media_type = self.media_type\n        try:\n            return _document_format_lookup[media_type]\n        except KeyError as e:\n            raise ValueError(f'Unknown document media type: {media_type}') from e\n\n```\n\n#### url\n\n```python\nurl: str\n\n```\n\nThe URL of the document.\n\n#### kind\n\n```python\nkind: Literal['document-url'] = kind\n\n```\n\nType identifier, this is available on all parts as a discriminator.\n\n#### format\n\n```python\nformat: DocumentFormat\n\n```\n\nThe file format of the document.\n\nThe choice of supported formats were based on the Bedrock Converse API. Other APIs don't require to use a format.\n\n### BinaryContent\n\nBinary content, e.g. an audio or image file.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(init=False, repr=False)\nclass BinaryContent:\n    \"\"\"Binary content, e.g. an audio or image file.\"\"\"\n\n    data: bytes\n    \"\"\"The binary data.\"\"\"\n\n    _: KW_ONLY\n\n    media_type: AudioMediaType | ImageMediaType | DocumentMediaType | str\n    \"\"\"The media type of the binary data.\"\"\"\n\n    vendor_metadata: dict[str, Any] | None = None\n    \"\"\"Vendor-specific metadata for the file.\n\n    Supported by:\n    - `GoogleModel`: `BinaryContent.vendor_metadata` is used as `video_metadata`: https://ai.google.dev/gemini-api/docs/video-understanding#customize-video-processing\n    - `OpenAIChatModel`, `OpenAIResponsesModel`: `BinaryContent.vendor_metadata['detail']` is used as `detail` setting for images\n    \"\"\"\n\n    _identifier: Annotated[str | None, pydantic.Field(alias='identifier', default=None, exclude=True)] = field(\n        compare=False, default=None\n    )\n\n    kind: Literal['binary'] = 'binary'\n    \"\"\"Type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def __init__(\n        self,\n        data: bytes,\n        *,\n        media_type: AudioMediaType | ImageMediaType | DocumentMediaType | str,\n        identifier: str | None = None,\n        vendor_metadata: dict[str, Any] | None = None,\n        kind: Literal['binary'] = 'binary',\n        # Required for inline-snapshot which expects all dataclass `__init__` methods to take all field names as kwargs.\n        _identifier: str | None = None,\n    ) -> None:\n        self.data = data\n        self.media_type = media_type\n        self._identifier = identifier or _identifier\n        self.vendor_metadata = vendor_metadata\n        self.kind = kind\n\n    @staticmethod\n    def narrow_type(bc: BinaryContent) -> BinaryContent | BinaryImage:\n        \"\"\"Narrow the type of the `BinaryContent` to `BinaryImage` if it's an image.\"\"\"\n        if bc.is_image:\n            return BinaryImage(\n                data=bc.data,\n                media_type=bc.media_type,\n                identifier=bc.identifier,\n                vendor_metadata=bc.vendor_metadata,\n            )\n        else:\n            return bc\n\n    @classmethod\n    def from_data_uri(cls, data_uri: str) -> BinaryContent:\n        \"\"\"Create a `BinaryContent` from a data URI.\"\"\"\n        prefix = 'data:'\n        if not data_uri.startswith(prefix):\n            raise ValueError('Data URI must start with \"data:\"')\n        media_type, data = data_uri[len(prefix) :].split(';base64,', 1)\n        return cls.narrow_type(cls(data=base64.b64decode(data), media_type=media_type))\n\n    @classmethod\n    def from_path(cls, path: PathLike[str]) -> BinaryContent:\n        \"\"\"Create a `BinaryContent` from a path.\n\n        Defaults to 'application/octet-stream' if the media type cannot be inferred.\n\n        Raises:\n            FileNotFoundError: if the file does not exist.\n            PermissionError: if the file cannot be read.\n        \"\"\"\n        path = Path(path)\n        if not path.exists():\n            raise FileNotFoundError(f'File not found: {path}')\n        media_type, _ = guess_type(path)\n        if media_type is None:\n            media_type = 'application/octet-stream'\n\n        return cls.narrow_type(cls(data=path.read_bytes(), media_type=media_type))\n\n    @pydantic.computed_field\n    @property\n    def identifier(self) -> str:\n        \"\"\"Identifier for the binary content, such as a unique ID.\n\n        This identifier can be provided to the model in a message to allow it to refer to this file in a tool call argument,\n        and the tool can look up the file in question by iterating over the message history and finding the matching `BinaryContent`.\n\n        This identifier is only automatically passed to the model when the `BinaryContent` is returned by a tool.\n        If you're passing the `BinaryContent` as a user message, it's up to you to include a separate text part with the identifier,\n        e.g. \"This is file <identifier>:\" preceding the `BinaryContent`.\n\n        It's also included in inline-text delimiters for providers that require inlining text documents, so the model can\n        distinguish multiple files.\n        \"\"\"\n        return self._identifier or _multi_modal_content_identifier(self.data)\n\n    @property\n    def data_uri(self) -> str:\n        \"\"\"Convert the `BinaryContent` to a data URI.\"\"\"\n        return f'data:{self.media_type};base64,{base64.b64encode(self.data).decode()}'\n\n    @property\n    def is_audio(self) -> bool:\n        \"\"\"Return `True` if the media type is an audio type.\"\"\"\n        return self.media_type.startswith('audio/')\n\n    @property\n    def is_image(self) -> bool:\n        \"\"\"Return `True` if the media type is an image type.\"\"\"\n        return self.media_type.startswith('image/')\n\n    @property\n    def is_video(self) -> bool:\n        \"\"\"Return `True` if the media type is a video type.\"\"\"\n        return self.media_type.startswith('video/')\n\n    @property\n    def is_document(self) -> bool:\n        \"\"\"Return `True` if the media type is a document type.\"\"\"\n        return self.media_type in _document_format_lookup\n\n    @property\n    def format(self) -> str:\n        \"\"\"The file format of the binary content.\"\"\"\n        try:\n            if self.is_audio:\n                return _audio_format_lookup[self.media_type]\n            elif self.is_image:\n                return _image_format_lookup[self.media_type]\n            elif self.is_video:\n                return _video_format_lookup[self.media_type]\n            else:\n                return _document_format_lookup[self.media_type]\n        except KeyError as e:\n            raise ValueError(f'Unknown media type: {self.media_type}') from e\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### data\n\n```python\ndata: bytes = data\n\n```\n\nThe binary data.\n\n#### media_type\n\n```python\nmedia_type: (\n    AudioMediaType\n    | ImageMediaType\n    | DocumentMediaType\n    | str\n) = media_type\n\n```\n\nThe media type of the binary data.\n\n#### vendor_metadata\n\n```python\nvendor_metadata: dict[str, Any] | None = vendor_metadata\n\n```\n\nVendor-specific metadata for the file.\n\nSupported by:\n\n- `GoogleModel`: `BinaryContent.vendor_metadata` is used as `video_metadata`: https://ai.google.dev/gemini-api/docs/video-understanding#customize-video-processing\n- `OpenAIChatModel`, `OpenAIResponsesModel`: `BinaryContent.vendor_metadata['detail']` is used as `detail` setting for images\n\n#### kind\n\n```python\nkind: Literal['binary'] = kind\n\n```\n\nType identifier, this is available on all parts as a discriminator.\n\n#### narrow_type\n\n```python\nnarrow_type(\n    bc: BinaryContent,\n) -> BinaryContent | BinaryImage\n\n```\n\nNarrow the type of the `BinaryContent` to `BinaryImage` if it's an image.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@staticmethod\ndef narrow_type(bc: BinaryContent) -> BinaryContent | BinaryImage:\n    \"\"\"Narrow the type of the `BinaryContent` to `BinaryImage` if it's an image.\"\"\"\n    if bc.is_image:\n        return BinaryImage(\n            data=bc.data,\n            media_type=bc.media_type,\n            identifier=bc.identifier,\n            vendor_metadata=bc.vendor_metadata,\n        )\n    else:\n        return bc\n\n```\n\n#### from_data_uri\n\n```python\nfrom_data_uri(data_uri: str) -> BinaryContent\n\n```\n\nCreate a `BinaryContent` from a data URI.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@classmethod\ndef from_data_uri(cls, data_uri: str) -> BinaryContent:\n    \"\"\"Create a `BinaryContent` from a data URI.\"\"\"\n    prefix = 'data:'\n    if not data_uri.startswith(prefix):\n        raise ValueError('Data URI must start with \"data:\"')\n    media_type, data = data_uri[len(prefix) :].split(';base64,', 1)\n    return cls.narrow_type(cls(data=base64.b64decode(data), media_type=media_type))\n\n```\n\n#### from_path\n\n```python\nfrom_path(path: PathLike[str]) -> BinaryContent\n\n```\n\nCreate a `BinaryContent` from a path.\n\nDefaults to 'application/octet-stream' if the media type cannot be inferred.\n\nRaises:\n\n| Type | Description | | --- | --- | | `FileNotFoundError` | if the file does not exist. | | `PermissionError` | if the file cannot be read. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@classmethod\ndef from_path(cls, path: PathLike[str]) -> BinaryContent:\n    \"\"\"Create a `BinaryContent` from a path.\n\n    Defaults to 'application/octet-stream' if the media type cannot be inferred.\n\n    Raises:\n        FileNotFoundError: if the file does not exist.\n        PermissionError: if the file cannot be read.\n    \"\"\"\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f'File not found: {path}')\n    media_type, _ = guess_type(path)\n    if media_type is None:\n        media_type = 'application/octet-stream'\n\n    return cls.narrow_type(cls(data=path.read_bytes(), media_type=media_type))\n\n```\n\n#### identifier\n\n```python\nidentifier: str\n\n```\n\nIdentifier for the binary content, such as a unique ID.\n\nThis identifier can be provided to the model in a message to allow it to refer to this file in a tool call argument, and the tool can look up the file in question by iterating over the message history and finding the matching `BinaryContent`.\n\nThis identifier is only automatically passed to the model when the `BinaryContent` is returned by a tool. If you're passing the `BinaryContent` as a user message, it's up to you to include a separate text part with the identifier, e.g. \"This is file :\" preceding the `BinaryContent`.\n\nIt's also included in inline-text delimiters for providers that require inlining text documents, so the model can distinguish multiple files.\n\n#### data_uri\n\n```python\ndata_uri: str\n\n```\n\nConvert the `BinaryContent` to a data URI.\n\n#### is_audio\n\n```python\nis_audio: bool\n\n```\n\nReturn `True` if the media type is an audio type.\n\n#### is_image\n\n```python\nis_image: bool\n\n```\n\nReturn `True` if the media type is an image type.\n\n#### is_video\n\n```python\nis_video: bool\n\n```\n\nReturn `True` if the media type is a video type.\n\n#### is_document\n\n```python\nis_document: bool\n\n```\n\nReturn `True` if the media type is a document type.\n\n#### format\n\n```python\nformat: str\n\n```\n\nThe file format of the binary content.\n\n### BinaryImage\n\nBases: `BinaryContent`\n\nBinary content that's guaranteed to be an image.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\nclass BinaryImage(BinaryContent):\n    \"\"\"Binary content that's guaranteed to be an image.\"\"\"\n\n    def __init__(\n        self,\n        data: bytes,\n        *,\n        media_type: str,\n        identifier: str | None = None,\n        vendor_metadata: dict[str, Any] | None = None,\n        # Required for inline-snapshot which expects all dataclass `__init__` methods to take all field names as kwargs.\n        kind: Literal['binary'] = 'binary',\n        _identifier: str | None = None,\n    ):\n        super().__init__(\n            data=data, media_type=media_type, identifier=identifier or _identifier, vendor_metadata=vendor_metadata\n        )\n\n        if not self.is_image:\n            raise ValueError('`BinaryImage` must be have a media type that starts with \"image/\"')  # pragma: no cover\n\n```\n\n### CachePoint\n\nA cache point marker for prompt caching.\n\nCan be inserted into UserPromptPart.content to mark cache boundaries. Models that don't support caching will filter these out.\n\nSupported by:\n\n- Anthropic\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass\nclass CachePoint:\n    \"\"\"A cache point marker for prompt caching.\n\n    Can be inserted into UserPromptPart.content to mark cache boundaries.\n    Models that don't support caching will filter these out.\n\n    Supported by:\n\n    - Anthropic\n    \"\"\"\n\n    kind: Literal['cache-point'] = 'cache-point'\n    \"\"\"Type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    ttl: Literal['5m', '1h'] = '5m'\n    \"\"\"The cache time-to-live, either \"5m\" (5 minutes) or \"1h\" (1 hour).\n\n    Supported by:\n\n    * Anthropic. See https://docs.claude.com/en/docs/build-with-claude/prompt-caching#1-hour-cache-duration for more information.\"\"\"\n\n```\n\n#### kind\n\n```python\nkind: Literal['cache-point'] = 'cache-point'\n\n```\n\nType identifier, this is available on all parts as a discriminator.\n\n#### ttl\n\n```python\nttl: Literal['5m', '1h'] = '5m'\n\n```\n\nThe cache time-to-live, either \"5m\" (5 minutes) or \"1h\" (1 hour).\n\nSupported by:\n\n- Anthropic. See https://docs.claude.com/en/docs/build-with-claude/prompt-caching#1-hour-cache-duration for more information.\n\n### ToolReturn\n\nA structured return value for tools that need to provide both a return value and custom content to the model.\n\nThis class allows tools to return complex responses that include:\n\n- A return value for actual tool return\n- Custom content (including multi-modal content) to be sent to the model as a UserPromptPart\n- Optional metadata for application use\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass ToolReturn:\n    \"\"\"A structured return value for tools that need to provide both a return value and custom content to the model.\n\n    This class allows tools to return complex responses that include:\n    - A return value for actual tool return\n    - Custom content (including multi-modal content) to be sent to the model as a UserPromptPart\n    - Optional metadata for application use\n    \"\"\"\n\n    return_value: Any\n    \"\"\"The return value to be used in the tool response.\"\"\"\n\n    _: KW_ONLY\n\n    content: str | Sequence[UserContent] | None = None\n    \"\"\"The content to be sent to the model as a UserPromptPart.\"\"\"\n\n    metadata: Any = None\n    \"\"\"Additional data that can be accessed programmatically by the application but is not sent to the LLM.\"\"\"\n\n    kind: Literal['tool-return'] = 'tool-return'\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### return_value\n\n```python\nreturn_value: Any\n\n```\n\nThe return value to be used in the tool response.\n\n#### content\n\n```python\ncontent: str | Sequence[UserContent] | None = None\n\n```\n\nThe content to be sent to the model as a UserPromptPart.\n\n#### metadata\n\n```python\nmetadata: Any = None\n\n```\n\nAdditional data that can be accessed programmatically by the application but is not sent to the LLM.\n\n### UserPromptPart\n\nA user prompt, generally written by the end user.\n\nContent comes from the `user_prompt` parameter of Agent.run, Agent.run_sync, and Agent.run_stream.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass UserPromptPart:\n    \"\"\"A user prompt, generally written by the end user.\n\n    Content comes from the `user_prompt` parameter of [`Agent.run`][pydantic_ai.agent.AbstractAgent.run],\n    [`Agent.run_sync`][pydantic_ai.agent.AbstractAgent.run_sync], and [`Agent.run_stream`][pydantic_ai.agent.AbstractAgent.run_stream].\n    \"\"\"\n\n    content: str | Sequence[UserContent]\n    \"\"\"The content of the prompt.\"\"\"\n\n    _: KW_ONLY\n\n    timestamp: datetime = field(default_factory=_now_utc)\n    \"\"\"The timestamp of the prompt.\"\"\"\n\n    part_kind: Literal['user-prompt'] = 'user-prompt'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def otel_event(self, settings: InstrumentationSettings) -> Event:\n        content = [{'kind': part.pop('type'), **part} for part in self.otel_message_parts(settings)]\n        for part in content:\n            if part['kind'] == 'binary' and 'content' in part:\n                part['binary_content'] = part.pop('content')\n        content = [\n            part['content'] if part == {'kind': 'text', 'content': part.get('content')} else part for part in content\n        ]\n        if content in ([{'kind': 'text'}], [self.content]):\n            content = content[0]\n        return Event('gen_ai.user.message', body={'content': content, 'role': 'user'})\n\n    def otel_message_parts(self, settings: InstrumentationSettings) -> list[_otel_messages.MessagePart]:\n        parts: list[_otel_messages.MessagePart] = []\n        content: Sequence[UserContent] = [self.content] if isinstance(self.content, str) else self.content\n        for part in content:\n            if isinstance(part, str):\n                parts.append(\n                    _otel_messages.TextPart(type='text', **({'content': part} if settings.include_content else {}))\n                )\n            elif isinstance(part, ImageUrl | AudioUrl | DocumentUrl | VideoUrl):\n                parts.append(\n                    _otel_messages.MediaUrlPart(\n                        type=part.kind,\n                        **{'url': part.url} if settings.include_content else {},\n                    )\n                )\n            elif isinstance(part, BinaryContent):\n                converted_part = _otel_messages.BinaryDataPart(type='binary', media_type=part.media_type)\n                if settings.include_content and settings.include_binary_content:\n                    converted_part['content'] = base64.b64encode(part.data).decode()\n                parts.append(converted_part)\n            elif isinstance(part, CachePoint):\n                # CachePoint is a marker, not actual content - skip it for otel\n                pass\n            else:\n                parts.append({'type': part.kind})  # pragma: no cover\n        return parts\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### content\n\n```python\ncontent: str | Sequence[UserContent]\n\n```\n\nThe content of the prompt.\n\n#### timestamp\n\n```python\ntimestamp: datetime = field(default_factory=now_utc)\n\n```\n\nThe timestamp of the prompt.\n\n#### part_kind\n\n```python\npart_kind: Literal['user-prompt'] = 'user-prompt'\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n### BaseToolReturnPart\n\nBase class for tool return parts.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass BaseToolReturnPart:\n    \"\"\"Base class for tool return parts.\"\"\"\n\n    tool_name: str\n    \"\"\"The name of the \"tool\" was called.\"\"\"\n\n    content: Any\n    \"\"\"The return value.\"\"\"\n\n    tool_call_id: str = field(default_factory=_generate_tool_call_id)\n    \"\"\"The tool call identifier, this is used by some models including OpenAI.\n\n    In case the tool call id is not provided by the model, Pydantic AI will generate a random one.\n    \"\"\"\n\n    _: KW_ONLY\n\n    metadata: Any = None\n    \"\"\"Additional data that can be accessed programmatically by the application but is not sent to the LLM.\"\"\"\n\n    timestamp: datetime = field(default_factory=_now_utc)\n    \"\"\"The timestamp, when the tool returned.\"\"\"\n\n    def model_response_str(self) -> str:\n        \"\"\"Return a string representation of the content for the model.\"\"\"\n        if isinstance(self.content, str):\n            return self.content\n        else:\n            return tool_return_ta.dump_json(self.content).decode()\n\n    def model_response_object(self) -> dict[str, Any]:\n        \"\"\"Return a dictionary representation of the content, wrapping non-dict types appropriately.\"\"\"\n        # gemini supports JSON dict return values, but no other JSON types, hence we wrap anything else in a dict\n        json_content = tool_return_ta.dump_python(self.content, mode='json')\n        if isinstance(json_content, dict):\n            return json_content  # type: ignore[reportUnknownReturn]\n        else:\n            return {'return_value': json_content}\n\n    def otel_event(self, settings: InstrumentationSettings) -> Event:\n        return Event(\n            'gen_ai.tool.message',\n            body={\n                **({'content': self.content} if settings.include_content else {}),\n                'role': 'tool',\n                'id': self.tool_call_id,\n                'name': self.tool_name,\n            },\n        )\n\n    def otel_message_parts(self, settings: InstrumentationSettings) -> list[_otel_messages.MessagePart]:\n        from .models.instrumented import InstrumentedModel\n\n        part = _otel_messages.ToolCallResponsePart(\n            type='tool_call_response',\n            id=self.tool_call_id,\n            name=self.tool_name,\n        )\n\n        if settings.include_content and self.content is not None:\n            part['result'] = InstrumentedModel.serialize_any(self.content)\n\n        return [part]\n\n    def has_content(self) -> bool:\n        \"\"\"Return `True` if the tool return has content.\"\"\"\n        return self.content is not None  # pragma: no cover\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### tool_name\n\n```python\ntool_name: str\n\n```\n\nThe name of the \"tool\" was called.\n\n#### content\n\n```python\ncontent: Any\n\n```\n\nThe return value.\n\n#### tool_call_id\n\n```python\ntool_call_id: str = field(\n    default_factory=generate_tool_call_id\n)\n\n```\n\nThe tool call identifier, this is used by some models including OpenAI.\n\nIn case the tool call id is not provided by the model, Pydantic AI will generate a random one.\n\n#### metadata\n\n```python\nmetadata: Any = None\n\n```\n\nAdditional data that can be accessed programmatically by the application but is not sent to the LLM.\n\n#### timestamp\n\n```python\ntimestamp: datetime = field(default_factory=now_utc)\n\n```\n\nThe timestamp, when the tool returned.\n\n#### model_response_str\n\n```python\nmodel_response_str() -> str\n\n```\n\nReturn a string representation of the content for the model.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef model_response_str(self) -> str:\n    \"\"\"Return a string representation of the content for the model.\"\"\"\n    if isinstance(self.content, str):\n        return self.content\n    else:\n        return tool_return_ta.dump_json(self.content).decode()\n\n```\n\n#### model_response_object\n\n```python\nmodel_response_object() -> dict[str, Any]\n\n```\n\nReturn a dictionary representation of the content, wrapping non-dict types appropriately.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef model_response_object(self) -> dict[str, Any]:\n    \"\"\"Return a dictionary representation of the content, wrapping non-dict types appropriately.\"\"\"\n    # gemini supports JSON dict return values, but no other JSON types, hence we wrap anything else in a dict\n    json_content = tool_return_ta.dump_python(self.content, mode='json')\n    if isinstance(json_content, dict):\n        return json_content  # type: ignore[reportUnknownReturn]\n    else:\n        return {'return_value': json_content}\n\n```\n\n#### has_content\n\n```python\nhas_content() -> bool\n\n```\n\nReturn `True` if the tool return has content.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef has_content(self) -> bool:\n    \"\"\"Return `True` if the tool return has content.\"\"\"\n    return self.content is not None  # pragma: no cover\n\n```\n\n### ToolReturnPart\n\nBases: `BaseToolReturnPart`\n\nA tool return message, this encodes the result of running a tool.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass ToolReturnPart(BaseToolReturnPart):\n    \"\"\"A tool return message, this encodes the result of running a tool.\"\"\"\n\n    _: KW_ONLY\n\n    part_kind: Literal['tool-return'] = 'tool-return'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n```\n\n#### part_kind\n\n```python\npart_kind: Literal['tool-return'] = 'tool-return'\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n### BuiltinToolReturnPart\n\nBases: `BaseToolReturnPart`\n\nA tool return message from a built-in tool.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass BuiltinToolReturnPart(BaseToolReturnPart):\n    \"\"\"A tool return message from a built-in tool.\"\"\"\n\n    _: KW_ONLY\n\n    provider_name: str | None = None\n    \"\"\"The name of the provider that generated the response.\"\"\"\n\n    provider_details: dict[str, Any] | None = None\n    \"\"\"Additional data returned by the provider that can't be mapped to standard fields.\n\n    This is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\"\"\"\n\n    part_kind: Literal['builtin-tool-return'] = 'builtin-tool-return'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n```\n\n#### provider_name\n\n```python\nprovider_name: str | None = None\n\n```\n\nThe name of the provider that generated the response.\n\n#### provider_details\n\n```python\nprovider_details: dict[str, Any] | None = None\n\n```\n\nAdditional data returned by the provider that can't be mapped to standard fields.\n\nThis is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\n\n#### part_kind\n\n```python\npart_kind: Literal[\"builtin-tool-return\"] = (\n    \"builtin-tool-return\"\n)\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n### RetryPromptPart\n\nA message back to a model asking it to try again.\n\nThis can be sent for a number of reasons:\n\n- Pydantic validation of tool arguments failed, here content is derived from a Pydantic ValidationError\n- a tool raised a ModelRetry exception\n- no tool was found for the tool name\n- the model returned plain text when a structured response was expected\n- Pydantic validation of a structured response failed, here content is derived from a Pydantic ValidationError\n- an output validator raised a ModelRetry exception\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n````python\n@dataclass(repr=False)\nclass RetryPromptPart:\n    \"\"\"A message back to a model asking it to try again.\n\n    This can be sent for a number of reasons:\n\n    * Pydantic validation of tool arguments failed, here content is derived from a Pydantic\n      [`ValidationError`][pydantic_core.ValidationError]\n    * a tool raised a [`ModelRetry`][pydantic_ai.exceptions.ModelRetry] exception\n    * no tool was found for the tool name\n    * the model returned plain text when a structured response was expected\n    * Pydantic validation of a structured response failed, here content is derived from a Pydantic\n      [`ValidationError`][pydantic_core.ValidationError]\n    * an output validator raised a [`ModelRetry`][pydantic_ai.exceptions.ModelRetry] exception\n    \"\"\"\n\n    content: list[pydantic_core.ErrorDetails] | str\n    \"\"\"Details of why and how the model should retry.\n\n    If the retry was triggered by a [`ValidationError`][pydantic_core.ValidationError], this will be a list of\n    error details.\n    \"\"\"\n\n    _: KW_ONLY\n\n    tool_name: str | None = None\n    \"\"\"The name of the tool that was called, if any.\"\"\"\n\n    tool_call_id: str = field(default_factory=_generate_tool_call_id)\n    \"\"\"The tool call identifier, this is used by some models including OpenAI.\n\n    In case the tool call id is not provided by the model, Pydantic AI will generate a random one.\n    \"\"\"\n\n    timestamp: datetime = field(default_factory=_now_utc)\n    \"\"\"The timestamp, when the retry was triggered.\"\"\"\n\n    part_kind: Literal['retry-prompt'] = 'retry-prompt'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def model_response(self) -> str:\n        \"\"\"Return a string message describing why the retry is requested.\"\"\"\n        if isinstance(self.content, str):\n            if self.tool_name is None:\n                description = f'Validation feedback:\\n{self.content}'\n            else:\n                description = self.content\n        else:\n            json_errors = error_details_ta.dump_json(self.content, exclude={'__all__': {'ctx'}}, indent=2)\n            plural = isinstance(self.content, list) and len(self.content) != 1\n            description = (\n                f'{len(self.content)} validation error{\"s\" if plural else \"\"}:\\n```json\\n{json_errors.decode()}\\n```'\n            )\n        return f'{description}\\n\\nFix the errors and try again.'\n\n    def otel_event(self, settings: InstrumentationSettings) -> Event:\n        if self.tool_name is None:\n            return Event('gen_ai.user.message', body={'content': self.model_response(), 'role': 'user'})\n        else:\n            return Event(\n                'gen_ai.tool.message',\n                body={\n                    **({'content': self.model_response()} if settings.include_content else {}),\n                    'role': 'tool',\n                    'id': self.tool_call_id,\n                    'name': self.tool_name,\n                },\n            )\n\n    def otel_message_parts(self, settings: InstrumentationSettings) -> list[_otel_messages.MessagePart]:\n        if self.tool_name is None:\n            return [_otel_messages.TextPart(type='text', content=self.model_response())]\n        else:\n            part = _otel_messages.ToolCallResponsePart(\n                type='tool_call_response',\n                id=self.tool_call_id,\n                name=self.tool_name,\n            )\n\n            if settings.include_content:\n                part['result'] = self.model_response()\n\n            return [part]\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n````\n\n#### content\n\n```python\ncontent: list[ErrorDetails] | str\n\n```\n\nDetails of why and how the model should retry.\n\nIf the retry was triggered by a ValidationError, this will be a list of error details.\n\n#### tool_name\n\n```python\ntool_name: str | None = None\n\n```\n\nThe name of the tool that was called, if any.\n\n#### tool_call_id\n\n```python\ntool_call_id: str = field(\n    default_factory=generate_tool_call_id\n)\n\n```\n\nThe tool call identifier, this is used by some models including OpenAI.\n\nIn case the tool call id is not provided by the model, Pydantic AI will generate a random one.\n\n#### timestamp\n\n```python\ntimestamp: datetime = field(default_factory=now_utc)\n\n```\n\nThe timestamp, when the retry was triggered.\n\n#### part_kind\n\n```python\npart_kind: Literal['retry-prompt'] = 'retry-prompt'\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n#### model_response\n\n```python\nmodel_response() -> str\n\n```\n\nReturn a string message describing why the retry is requested.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n````python\ndef model_response(self) -> str:\n    \"\"\"Return a string message describing why the retry is requested.\"\"\"\n    if isinstance(self.content, str):\n        if self.tool_name is None:\n            description = f'Validation feedback:\\n{self.content}'\n        else:\n            description = self.content\n    else:\n        json_errors = error_details_ta.dump_json(self.content, exclude={'__all__': {'ctx'}}, indent=2)\n        plural = isinstance(self.content, list) and len(self.content) != 1\n        description = (\n            f'{len(self.content)} validation error{\"s\" if plural else \"\"}:\\n```json\\n{json_errors.decode()}\\n```'\n        )\n    return f'{description}\\n\\nFix the errors and try again.'\n\n````\n\n### ModelRequestPart\n\n```python\nModelRequestPart = Annotated[\n    SystemPromptPart\n    | UserPromptPart\n    | ToolReturnPart\n    | RetryPromptPart,\n    Discriminator(\"part_kind\"),\n]\n\n```\n\nA message part sent by Pydantic AI to a model.\n\n### ModelRequest\n\nA request generated by Pydantic AI and sent to a model, e.g. a message from the Pydantic AI app to the model.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass ModelRequest:\n    \"\"\"A request generated by Pydantic AI and sent to a model, e.g. a message from the Pydantic AI app to the model.\"\"\"\n\n    parts: Sequence[ModelRequestPart]\n    \"\"\"The parts of the user message.\"\"\"\n\n    _: KW_ONLY\n\n    instructions: str | None = None\n    \"\"\"The instructions for the model.\"\"\"\n\n    kind: Literal['request'] = 'request'\n    \"\"\"Message type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    run_id: str | None = None\n    \"\"\"The unique identifier of the agent run in which this message originated.\"\"\"\n\n    metadata: dict[str, Any] | None = None\n    \"\"\"Additional data that can be accessed programmatically by the application but is not sent to the LLM.\"\"\"\n\n    @classmethod\n    def user_text_prompt(cls, user_prompt: str, *, instructions: str | None = None) -> ModelRequest:\n        \"\"\"Create a `ModelRequest` with a single user prompt as text.\"\"\"\n        return cls(parts=[UserPromptPart(user_prompt)], instructions=instructions)\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### parts\n\n```python\nparts: Sequence[ModelRequestPart]\n\n```\n\nThe parts of the user message.\n\n#### instructions\n\n```python\ninstructions: str | None = None\n\n```\n\nThe instructions for the model.\n\n#### kind\n\n```python\nkind: Literal['request'] = 'request'\n\n```\n\nMessage type identifier, this is available on all parts as a discriminator.\n\n#### run_id\n\n```python\nrun_id: str | None = None\n\n```\n\nThe unique identifier of the agent run in which this message originated.\n\n#### metadata\n\n```python\nmetadata: dict[str, Any] | None = None\n\n```\n\nAdditional data that can be accessed programmatically by the application but is not sent to the LLM.\n\n#### user_text_prompt\n\n```python\nuser_text_prompt(\n    user_prompt: str, *, instructions: str | None = None\n) -> ModelRequest\n\n```\n\nCreate a `ModelRequest` with a single user prompt as text.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@classmethod\ndef user_text_prompt(cls, user_prompt: str, *, instructions: str | None = None) -> ModelRequest:\n    \"\"\"Create a `ModelRequest` with a single user prompt as text.\"\"\"\n    return cls(parts=[UserPromptPart(user_prompt)], instructions=instructions)\n\n```\n\n### TextPart\n\nA plain text response from a model.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass TextPart:\n    \"\"\"A plain text response from a model.\"\"\"\n\n    content: str\n    \"\"\"The text content of the response.\"\"\"\n\n    _: KW_ONLY\n\n    id: str | None = None\n    \"\"\"An optional identifier of the text part.\"\"\"\n\n    provider_details: dict[str, Any] | None = None\n    \"\"\"Additional data returned by the provider that can't be mapped to standard fields.\n\n    This is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\"\"\"\n\n    part_kind: Literal['text'] = 'text'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def has_content(self) -> bool:\n        \"\"\"Return `True` if the text content is non-empty.\"\"\"\n        return bool(self.content)\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### content\n\n```python\ncontent: str\n\n```\n\nThe text content of the response.\n\n#### id\n\n```python\nid: str | None = None\n\n```\n\nAn optional identifier of the text part.\n\n#### provider_details\n\n```python\nprovider_details: dict[str, Any] | None = None\n\n```\n\nAdditional data returned by the provider that can't be mapped to standard fields.\n\nThis is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\n\n#### part_kind\n\n```python\npart_kind: Literal['text'] = 'text'\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n#### has_content\n\n```python\nhas_content() -> bool\n\n```\n\nReturn `True` if the text content is non-empty.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef has_content(self) -> bool:\n    \"\"\"Return `True` if the text content is non-empty.\"\"\"\n    return bool(self.content)\n\n```\n\n### ThinkingPart\n\nA thinking response from a model.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass ThinkingPart:\n    \"\"\"A thinking response from a model.\"\"\"\n\n    content: str\n    \"\"\"The thinking content of the response.\"\"\"\n\n    _: KW_ONLY\n\n    id: str | None = None\n    \"\"\"The identifier of the thinking part.\"\"\"\n\n    signature: str | None = None\n    \"\"\"The signature of the thinking.\n\n    Supported by:\n\n    * Anthropic (corresponds to the `signature` field)\n    * Bedrock (corresponds to the `signature` field)\n    * Google (corresponds to the `thought_signature` field)\n    * OpenAI (corresponds to the `encrypted_content` field)\n    \"\"\"\n\n    provider_name: str | None = None\n    \"\"\"The name of the provider that generated the response.\n\n    Signatures are only sent back to the same provider.\n    \"\"\"\n\n    provider_details: dict[str, Any] | None = None\n    \"\"\"Additional data returned by the provider that can't be mapped to standard fields.\n\n    This is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\"\"\"\n\n    part_kind: Literal['thinking'] = 'thinking'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def has_content(self) -> bool:\n        \"\"\"Return `True` if the thinking content is non-empty.\"\"\"\n        return bool(self.content)\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### content\n\n```python\ncontent: str\n\n```\n\nThe thinking content of the response.\n\n#### id\n\n```python\nid: str | None = None\n\n```\n\nThe identifier of the thinking part.\n\n#### signature\n\n```python\nsignature: str | None = None\n\n```\n\nThe signature of the thinking.\n\nSupported by:\n\n- Anthropic (corresponds to the `signature` field)\n- Bedrock (corresponds to the `signature` field)\n- Google (corresponds to the `thought_signature` field)\n- OpenAI (corresponds to the `encrypted_content` field)\n\n#### provider_name\n\n```python\nprovider_name: str | None = None\n\n```\n\nThe name of the provider that generated the response.\n\nSignatures are only sent back to the same provider.\n\n#### provider_details\n\n```python\nprovider_details: dict[str, Any] | None = None\n\n```\n\nAdditional data returned by the provider that can't be mapped to standard fields.\n\nThis is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\n\n#### part_kind\n\n```python\npart_kind: Literal['thinking'] = 'thinking'\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n#### has_content\n\n```python\nhas_content() -> bool\n\n```\n\nReturn `True` if the thinking content is non-empty.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef has_content(self) -> bool:\n    \"\"\"Return `True` if the thinking content is non-empty.\"\"\"\n    return bool(self.content)\n\n```\n\n### FilePart\n\nA file response from a model.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass FilePart:\n    \"\"\"A file response from a model.\"\"\"\n\n    content: Annotated[BinaryContent, pydantic.AfterValidator(BinaryImage.narrow_type)]\n    \"\"\"The file content of the response.\"\"\"\n\n    _: KW_ONLY\n\n    id: str | None = None\n    \"\"\"The identifier of the file part.\"\"\"\n\n    provider_name: str | None = None\n    \"\"\"The name of the provider that generated the response.\n    \"\"\"\n\n    provider_details: dict[str, Any] | None = None\n    \"\"\"Additional data returned by the provider that can't be mapped to standard fields.\n\n    This is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\"\"\"\n\n    part_kind: Literal['file'] = 'file'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    def has_content(self) -> bool:\n        \"\"\"Return `True` if the file content is non-empty.\"\"\"\n        return bool(self.content.data)\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### content\n\n```python\ncontent: Annotated[\n    BinaryContent, AfterValidator(narrow_type)\n]\n\n```\n\nThe file content of the response.\n\n#### id\n\n```python\nid: str | None = None\n\n```\n\nThe identifier of the file part.\n\n#### provider_name\n\n```python\nprovider_name: str | None = None\n\n```\n\nThe name of the provider that generated the response.\n\n#### provider_details\n\n```python\nprovider_details: dict[str, Any] | None = None\n\n```\n\nAdditional data returned by the provider that can't be mapped to standard fields.\n\nThis is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\n\n#### part_kind\n\n```python\npart_kind: Literal['file'] = 'file'\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n#### has_content\n\n```python\nhas_content() -> bool\n\n```\n\nReturn `True` if the file content is non-empty.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef has_content(self) -> bool:\n    \"\"\"Return `True` if the file content is non-empty.\"\"\"\n    return bool(self.content.data)\n\n```\n\n### BaseToolCallPart\n\nA tool call from a model.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass BaseToolCallPart:\n    \"\"\"A tool call from a model.\"\"\"\n\n    tool_name: str\n    \"\"\"The name of the tool to call.\"\"\"\n\n    args: str | dict[str, Any] | None = None\n    \"\"\"The arguments to pass to the tool.\n\n    This is stored either as a JSON string or a Python dictionary depending on how data was received.\n    \"\"\"\n\n    tool_call_id: str = field(default_factory=_generate_tool_call_id)\n    \"\"\"The tool call identifier, this is used by some models including OpenAI.\n\n    In case the tool call id is not provided by the model, Pydantic AI will generate a random one.\n    \"\"\"\n\n    _: KW_ONLY\n\n    id: str | None = None\n    \"\"\"An optional identifier of the tool call part, separate from the tool call ID.\n\n    This is used by some APIs like OpenAI Responses.\"\"\"\n\n    provider_details: dict[str, Any] | None = None\n    \"\"\"Additional data returned by the provider that can't be mapped to standard fields.\n\n    This is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\"\"\"\n\n    def args_as_dict(self) -> dict[str, Any]:\n        \"\"\"Return the arguments as a Python dictionary.\n\n        This is just for convenience with models that require dicts as input.\n        \"\"\"\n        if not self.args:\n            return {}\n        if isinstance(self.args, dict):\n            return self.args\n        args = pydantic_core.from_json(self.args)\n        assert isinstance(args, dict), 'args should be a dict'\n        return cast(dict[str, Any], args)\n\n    def args_as_json_str(self) -> str:\n        \"\"\"Return the arguments as a JSON string.\n\n        This is just for convenience with models that require JSON strings as input.\n        \"\"\"\n        if not self.args:\n            return '{}'\n        if isinstance(self.args, str):\n            return self.args\n        return pydantic_core.to_json(self.args).decode()\n\n    def has_content(self) -> bool:\n        \"\"\"Return `True` if the arguments contain any data.\"\"\"\n        if isinstance(self.args, dict):\n            # TODO: This should probably return True if you have the value False, or 0, etc.\n            #   It makes sense to me to ignore empty strings, but not sure about empty lists or dicts\n            return any(self.args.values())\n        else:\n            return bool(self.args)\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### tool_name\n\n```python\ntool_name: str\n\n```\n\nThe name of the tool to call.\n\n#### args\n\n```python\nargs: str | dict[str, Any] | None = None\n\n```\n\nThe arguments to pass to the tool.\n\nThis is stored either as a JSON string or a Python dictionary depending on how data was received.\n\n#### tool_call_id\n\n```python\ntool_call_id: str = field(\n    default_factory=generate_tool_call_id\n)\n\n```\n\nThe tool call identifier, this is used by some models including OpenAI.\n\nIn case the tool call id is not provided by the model, Pydantic AI will generate a random one.\n\n#### id\n\n```python\nid: str | None = None\n\n```\n\nAn optional identifier of the tool call part, separate from the tool call ID.\n\nThis is used by some APIs like OpenAI Responses.\n\n#### provider_details\n\n```python\nprovider_details: dict[str, Any] | None = None\n\n```\n\nAdditional data returned by the provider that can't be mapped to standard fields.\n\nThis is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\n\n#### args_as_dict\n\n```python\nargs_as_dict() -> dict[str, Any]\n\n```\n\nReturn the arguments as a Python dictionary.\n\nThis is just for convenience with models that require dicts as input.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef args_as_dict(self) -> dict[str, Any]:\n    \"\"\"Return the arguments as a Python dictionary.\n\n    This is just for convenience with models that require dicts as input.\n    \"\"\"\n    if not self.args:\n        return {}\n    if isinstance(self.args, dict):\n        return self.args\n    args = pydantic_core.from_json(self.args)\n    assert isinstance(args, dict), 'args should be a dict'\n    return cast(dict[str, Any], args)\n\n```\n\n#### args_as_json_str\n\n```python\nargs_as_json_str() -> str\n\n```\n\nReturn the arguments as a JSON string.\n\nThis is just for convenience with models that require JSON strings as input.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef args_as_json_str(self) -> str:\n    \"\"\"Return the arguments as a JSON string.\n\n    This is just for convenience with models that require JSON strings as input.\n    \"\"\"\n    if not self.args:\n        return '{}'\n    if isinstance(self.args, str):\n        return self.args\n    return pydantic_core.to_json(self.args).decode()\n\n```\n\n#### has_content\n\n```python\nhas_content() -> bool\n\n```\n\nReturn `True` if the arguments contain any data.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef has_content(self) -> bool:\n    \"\"\"Return `True` if the arguments contain any data.\"\"\"\n    if isinstance(self.args, dict):\n        # TODO: This should probably return True if you have the value False, or 0, etc.\n        #   It makes sense to me to ignore empty strings, but not sure about empty lists or dicts\n        return any(self.args.values())\n    else:\n        return bool(self.args)\n\n```\n\n### ToolCallPart\n\nBases: `BaseToolCallPart`\n\nA tool call from a model.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass ToolCallPart(BaseToolCallPart):\n    \"\"\"A tool call from a model.\"\"\"\n\n    _: KW_ONLY\n\n    part_kind: Literal['tool-call'] = 'tool-call'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n```\n\n#### part_kind\n\n```python\npart_kind: Literal['tool-call'] = 'tool-call'\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n### BuiltinToolCallPart\n\nBases: `BaseToolCallPart`\n\nA tool call to a built-in tool.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass BuiltinToolCallPart(BaseToolCallPart):\n    \"\"\"A tool call to a built-in tool.\"\"\"\n\n    _: KW_ONLY\n\n    provider_name: str | None = None\n    \"\"\"The name of the provider that generated the response.\n\n    Built-in tool calls are only sent back to the same provider.\n    \"\"\"\n\n    part_kind: Literal['builtin-tool-call'] = 'builtin-tool-call'\n    \"\"\"Part type identifier, this is available on all parts as a discriminator.\"\"\"\n\n```\n\n#### provider_name\n\n```python\nprovider_name: str | None = None\n\n```\n\nThe name of the provider that generated the response.\n\nBuilt-in tool calls are only sent back to the same provider.\n\n#### part_kind\n\n```python\npart_kind: Literal[\"builtin-tool-call\"] = (\n    \"builtin-tool-call\"\n)\n\n```\n\nPart type identifier, this is available on all parts as a discriminator.\n\n### ModelResponsePart\n\n```python\nModelResponsePart = Annotated[\n    TextPart\n    | ToolCallPart\n    | BuiltinToolCallPart\n    | BuiltinToolReturnPart\n    | ThinkingPart\n    | FilePart,\n    Discriminator(\"part_kind\"),\n]\n\n```\n\nA message part returned by a model.\n\n### ModelResponse\n\nA response from a model, e.g. a message from the model to the Pydantic AI app.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass ModelResponse:\n    \"\"\"A response from a model, e.g. a message from the model to the Pydantic AI app.\"\"\"\n\n    parts: Sequence[ModelResponsePart]\n    \"\"\"The parts of the model message.\"\"\"\n\n    _: KW_ONLY\n\n    usage: RequestUsage = field(default_factory=RequestUsage)\n    \"\"\"Usage information for the request.\n\n    This has a default to make tests easier, and to support loading old messages where usage will be missing.\n    \"\"\"\n\n    model_name: str | None = None\n    \"\"\"The name of the model that generated the response.\"\"\"\n\n    timestamp: datetime = field(default_factory=_now_utc)\n    \"\"\"The timestamp of the response.\n\n    If the model provides a timestamp in the response (as OpenAI does) that will be used.\n    \"\"\"\n\n    kind: Literal['response'] = 'response'\n    \"\"\"Message type identifier, this is available on all parts as a discriminator.\"\"\"\n\n    provider_name: str | None = None\n    \"\"\"The name of the LLM provider that generated the response.\"\"\"\n\n    provider_details: Annotated[\n        dict[str, Any] | None,\n        # `vendor_details` is deprecated, but we still want to support deserializing model responses stored in a DB before the name was changed\n        pydantic.Field(validation_alias=pydantic.AliasChoices('provider_details', 'vendor_details')),\n    ] = None\n    \"\"\"Additional data returned by the provider that can't be mapped to standard fields.\"\"\"\n\n    provider_response_id: Annotated[\n        str | None,\n        # `vendor_id` is deprecated, but we still want to support deserializing model responses stored in a DB before the name was changed\n        pydantic.Field(validation_alias=pydantic.AliasChoices('provider_response_id', 'vendor_id')),\n    ] = None\n    \"\"\"request ID as specified by the model provider. This can be used to track the specific request to the model.\"\"\"\n\n    finish_reason: FinishReason | None = None\n    \"\"\"Reason the model finished generating the response, normalized to OpenTelemetry values.\"\"\"\n\n    run_id: str | None = None\n    \"\"\"The unique identifier of the agent run in which this message originated.\"\"\"\n\n    metadata: dict[str, Any] | None = None\n    \"\"\"Additional data that can be accessed programmatically by the application but is not sent to the LLM.\"\"\"\n\n    @property\n    def text(self) -> str | None:\n        \"\"\"Get the text in the response.\"\"\"\n        texts: list[str] = []\n        last_part: ModelResponsePart | None = None\n        for part in self.parts:\n            if isinstance(part, TextPart):\n                # Adjacent text parts should be joined together, but if there are parts in between\n                # (like built-in tool calls) they should have newlines between them\n                if isinstance(last_part, TextPart):\n                    texts[-1] += part.content\n                else:\n                    texts.append(part.content)\n            last_part = part\n        if not texts:\n            return None\n\n        return '\\n\\n'.join(texts)\n\n    @property\n    def thinking(self) -> str | None:\n        \"\"\"Get the thinking in the response.\"\"\"\n        thinking_parts = [part.content for part in self.parts if isinstance(part, ThinkingPart)]\n        if not thinking_parts:\n            return None\n        return '\\n\\n'.join(thinking_parts)\n\n    @property\n    def files(self) -> list[BinaryContent]:\n        \"\"\"Get the files in the response.\"\"\"\n        return [part.content for part in self.parts if isinstance(part, FilePart)]\n\n    @property\n    def images(self) -> list[BinaryImage]:\n        \"\"\"Get the images in the response.\"\"\"\n        return [file for file in self.files if isinstance(file, BinaryImage)]\n\n    @property\n    def tool_calls(self) -> list[ToolCallPart]:\n        \"\"\"Get the tool calls in the response.\"\"\"\n        return [part for part in self.parts if isinstance(part, ToolCallPart)]\n\n    @property\n    def builtin_tool_calls(self) -> list[tuple[BuiltinToolCallPart, BuiltinToolReturnPart]]:\n        \"\"\"Get the builtin tool calls and results in the response.\"\"\"\n        calls = [part for part in self.parts if isinstance(part, BuiltinToolCallPart)]\n        if not calls:\n            return []\n        returns_by_id = {part.tool_call_id: part for part in self.parts if isinstance(part, BuiltinToolReturnPart)}\n        return [\n            (call_part, returns_by_id[call_part.tool_call_id])\n            for call_part in calls\n            if call_part.tool_call_id in returns_by_id\n        ]\n\n    @deprecated('`price` is deprecated, use `cost` instead')\n    def price(self) -> genai_types.PriceCalculation:  # pragma: no cover\n        return self.cost()\n\n    def cost(self) -> genai_types.PriceCalculation:\n        \"\"\"Calculate the cost of the usage.\n\n        Uses [`genai-prices`](https://github.com/pydantic/genai-prices).\n        \"\"\"\n        assert self.model_name, 'Model name is required to calculate price'\n        return calc_price(\n            self.usage,\n            self.model_name,\n            provider_id=self.provider_name,\n            genai_request_timestamp=self.timestamp,\n        )\n\n    def otel_events(self, settings: InstrumentationSettings) -> list[Event]:\n        \"\"\"Return OpenTelemetry events for the response.\"\"\"\n        result: list[Event] = []\n\n        def new_event_body():\n            new_body: dict[str, Any] = {'role': 'assistant'}\n            ev = Event('gen_ai.assistant.message', body=new_body)\n            result.append(ev)\n            return new_body\n\n        body = new_event_body()\n        for part in self.parts:\n            if isinstance(part, ToolCallPart):\n                body.setdefault('tool_calls', []).append(\n                    {\n                        'id': part.tool_call_id,\n                        'type': 'function',\n                        'function': {\n                            'name': part.tool_name,\n                            **({'arguments': part.args} if settings.include_content else {}),\n                        },\n                    }\n                )\n            elif isinstance(part, TextPart | ThinkingPart):\n                kind = part.part_kind\n                body.setdefault('content', []).append(\n                    {'kind': kind, **({'text': part.content} if settings.include_content else {})}\n                )\n            elif isinstance(part, FilePart):\n                body.setdefault('content', []).append(\n                    {\n                        'kind': 'binary',\n                        'media_type': part.content.media_type,\n                        **(\n                            {'binary_content': base64.b64encode(part.content.data).decode()}\n                            if settings.include_content and settings.include_binary_content\n                            else {}\n                        ),\n                    }\n                )\n\n        if content := body.get('content'):\n            text_content = content[0].get('text')\n            if content == [{'kind': 'text', 'text': text_content}]:\n                body['content'] = text_content\n\n        return result\n\n    def otel_message_parts(self, settings: InstrumentationSettings) -> list[_otel_messages.MessagePart]:\n        parts: list[_otel_messages.MessagePart] = []\n        for part in self.parts:\n            if isinstance(part, TextPart):\n                parts.append(\n                    _otel_messages.TextPart(\n                        type='text',\n                        **({'content': part.content} if settings.include_content else {}),\n                    )\n                )\n            elif isinstance(part, ThinkingPart):\n                parts.append(\n                    _otel_messages.ThinkingPart(\n                        type='thinking',\n                        **({'content': part.content} if settings.include_content else {}),\n                    )\n                )\n            elif isinstance(part, FilePart):\n                converted_part = _otel_messages.BinaryDataPart(type='binary', media_type=part.content.media_type)\n                if settings.include_content and settings.include_binary_content:\n                    converted_part['content'] = base64.b64encode(part.content.data).decode()\n                parts.append(converted_part)\n            elif isinstance(part, BaseToolCallPart):\n                call_part = _otel_messages.ToolCallPart(type='tool_call', id=part.tool_call_id, name=part.tool_name)\n                if isinstance(part, BuiltinToolCallPart):\n                    call_part['builtin'] = True\n                if settings.include_content and part.args is not None:\n                    from .models.instrumented import InstrumentedModel\n\n                    if isinstance(part.args, str):\n                        call_part['arguments'] = part.args\n                    else:\n                        call_part['arguments'] = {k: InstrumentedModel.serialize_any(v) for k, v in part.args.items()}\n\n                parts.append(call_part)\n            elif isinstance(part, BuiltinToolReturnPart):\n                return_part = _otel_messages.ToolCallResponsePart(\n                    type='tool_call_response',\n                    id=part.tool_call_id,\n                    name=part.tool_name,\n                    builtin=True,\n                )\n                if settings.include_content and part.content is not None:  # pragma: no branch\n                    from .models.instrumented import InstrumentedModel\n\n                    return_part['result'] = InstrumentedModel.serialize_any(part.content)\n\n                parts.append(return_part)\n        return parts\n\n    @property\n    @deprecated('`vendor_details` is deprecated, use `provider_details` instead')\n    def vendor_details(self) -> dict[str, Any] | None:\n        return self.provider_details\n\n    @property\n    @deprecated('`vendor_id` is deprecated, use `provider_response_id` instead')\n    def vendor_id(self) -> str | None:\n        return self.provider_response_id\n\n    @property\n    @deprecated('`provider_request_id` is deprecated, use `provider_response_id` instead')\n    def provider_request_id(self) -> str | None:\n        return self.provider_response_id\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### parts\n\n```python\nparts: Sequence[ModelResponsePart]\n\n```\n\nThe parts of the model message.\n\n#### usage\n\n```python\nusage: RequestUsage = field(default_factory=RequestUsage)\n\n```\n\nUsage information for the request.\n\nThis has a default to make tests easier, and to support loading old messages where usage will be missing.\n\n#### model_name\n\n```python\nmodel_name: str | None = None\n\n```\n\nThe name of the model that generated the response.\n\n#### timestamp\n\n```python\ntimestamp: datetime = field(default_factory=now_utc)\n\n```\n\nThe timestamp of the response.\n\nIf the model provides a timestamp in the response (as OpenAI does) that will be used.\n\n#### kind\n\n```python\nkind: Literal['response'] = 'response'\n\n```\n\nMessage type identifier, this is available on all parts as a discriminator.\n\n#### provider_name\n\n```python\nprovider_name: str | None = None\n\n```\n\nThe name of the LLM provider that generated the response.\n\n#### provider_details\n\n```python\nprovider_details: Annotated[\n    dict[str, Any] | None,\n    Field(\n        validation_alias=AliasChoices(\n            provider_details, vendor_details\n        )\n    ),\n] = None\n\n```\n\nAdditional data returned by the provider that can't be mapped to standard fields.\n\n#### provider_response_id\n\n```python\nprovider_response_id: Annotated[\n    str | None,\n    Field(\n        validation_alias=AliasChoices(\n            provider_response_id, vendor_id\n        )\n    ),\n] = None\n\n```\n\nrequest ID as specified by the model provider. This can be used to track the specific request to the model.\n\n#### finish_reason\n\n```python\nfinish_reason: FinishReason | None = None\n\n```\n\nReason the model finished generating the response, normalized to OpenTelemetry values.\n\n#### run_id\n\n```python\nrun_id: str | None = None\n\n```\n\nThe unique identifier of the agent run in which this message originated.\n\n#### metadata\n\n```python\nmetadata: dict[str, Any] | None = None\n\n```\n\nAdditional data that can be accessed programmatically by the application but is not sent to the LLM.\n\n#### text\n\n```python\ntext: str | None\n\n```\n\nGet the text in the response.\n\n#### thinking\n\n```python\nthinking: str | None\n\n```\n\nGet the thinking in the response.\n\n#### files\n\n```python\nfiles: list[BinaryContent]\n\n```\n\nGet the files in the response.\n\n#### images\n\n```python\nimages: list[BinaryImage]\n\n```\n\nGet the images in the response.\n\n#### tool_calls\n\n```python\ntool_calls: list[ToolCallPart]\n\n```\n\nGet the tool calls in the response.\n\n#### builtin_tool_calls\n\n```python\nbuiltin_tool_calls: list[\n    tuple[BuiltinToolCallPart, BuiltinToolReturnPart]\n]\n\n```\n\nGet the builtin tool calls and results in the response.\n\n#### price\n\n```python\nprice() -> PriceCalculation\n\n```\n\nDeprecated\n\n`price` is deprecated, use `cost` instead\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@deprecated('`price` is deprecated, use `cost` instead')\ndef price(self) -> genai_types.PriceCalculation:  # pragma: no cover\n    return self.cost()\n\n```\n\n#### cost\n\n```python\ncost() -> PriceCalculation\n\n```\n\nCalculate the cost of the usage.\n\nUses [`genai-prices`](https://github.com/pydantic/genai-prices).\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef cost(self) -> genai_types.PriceCalculation:\n    \"\"\"Calculate the cost of the usage.\n\n    Uses [`genai-prices`](https://github.com/pydantic/genai-prices).\n    \"\"\"\n    assert self.model_name, 'Model name is required to calculate price'\n    return calc_price(\n        self.usage,\n        self.model_name,\n        provider_id=self.provider_name,\n        genai_request_timestamp=self.timestamp,\n    )\n\n```\n\n#### otel_events\n\n```python\notel_events(\n    settings: InstrumentationSettings,\n) -> list[Event]\n\n```\n\nReturn OpenTelemetry events for the response.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef otel_events(self, settings: InstrumentationSettings) -> list[Event]:\n    \"\"\"Return OpenTelemetry events for the response.\"\"\"\n    result: list[Event] = []\n\n    def new_event_body():\n        new_body: dict[str, Any] = {'role': 'assistant'}\n        ev = Event('gen_ai.assistant.message', body=new_body)\n        result.append(ev)\n        return new_body\n\n    body = new_event_body()\n    for part in self.parts:\n        if isinstance(part, ToolCallPart):\n            body.setdefault('tool_calls', []).append(\n                {\n                    'id': part.tool_call_id,\n                    'type': 'function',\n                    'function': {\n                        'name': part.tool_name,\n                        **({'arguments': part.args} if settings.include_content else {}),\n                    },\n                }\n            )\n        elif isinstance(part, TextPart | ThinkingPart):\n            kind = part.part_kind\n            body.setdefault('content', []).append(\n                {'kind': kind, **({'text': part.content} if settings.include_content else {})}\n            )\n        elif isinstance(part, FilePart):\n            body.setdefault('content', []).append(\n                {\n                    'kind': 'binary',\n                    'media_type': part.content.media_type,\n                    **(\n                        {'binary_content': base64.b64encode(part.content.data).decode()}\n                        if settings.include_content and settings.include_binary_content\n                        else {}\n                    ),\n                }\n            )\n\n    if content := body.get('content'):\n        text_content = content[0].get('text')\n        if content == [{'kind': 'text', 'text': text_content}]:\n            body['content'] = text_content\n\n    return result\n\n```\n\n### ModelMessage\n\n```python\nModelMessage = Annotated[\n    ModelRequest | ModelResponse, Discriminator(\"kind\")\n]\n\n```\n\nAny message sent to or returned by a model.\n\n### ModelMessagesTypeAdapter\n\n```python\nModelMessagesTypeAdapter = TypeAdapter(\n    list[ModelMessage],\n    config=ConfigDict(\n        defer_build=True,\n        ser_json_bytes=\"base64\",\n        val_json_bytes=\"base64\",\n    ),\n)\n\n```\n\nPydantic TypeAdapter for (de)serializing messages.\n\n### TextPartDelta\n\nA partial update (delta) for a `TextPart` to append new text content.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass TextPartDelta:\n    \"\"\"A partial update (delta) for a `TextPart` to append new text content.\"\"\"\n\n    content_delta: str\n    \"\"\"The incremental text content to add to the existing `TextPart` content.\"\"\"\n\n    _: KW_ONLY\n\n    provider_details: dict[str, Any] | None = None\n    \"\"\"Additional data returned by the provider that can't be mapped to standard fields.\n\n    This is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\"\"\"\n\n    part_delta_kind: Literal['text'] = 'text'\n    \"\"\"Part delta type identifier, used as a discriminator.\"\"\"\n\n    def apply(self, part: ModelResponsePart) -> TextPart:\n        \"\"\"Apply this text delta to an existing `TextPart`.\n\n        Args:\n            part: The existing model response part, which must be a `TextPart`.\n\n        Returns:\n            A new `TextPart` with updated text content.\n\n        Raises:\n            ValueError: If `part` is not a `TextPart`.\n        \"\"\"\n        if not isinstance(part, TextPart):\n            raise ValueError('Cannot apply TextPartDeltas to non-TextParts')  # pragma: no cover\n        return replace(\n            part,\n            content=part.content + self.content_delta,\n            provider_details={**(part.provider_details or {}), **(self.provider_details or {})} or None,\n        )\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### content_delta\n\n```python\ncontent_delta: str\n\n```\n\nThe incremental text content to add to the existing `TextPart` content.\n\n#### provider_details\n\n```python\nprovider_details: dict[str, Any] | None = None\n\n```\n\nAdditional data returned by the provider that can't be mapped to standard fields.\n\nThis is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\n\n#### part_delta_kind\n\n```python\npart_delta_kind: Literal['text'] = 'text'\n\n```\n\nPart delta type identifier, used as a discriminator.\n\n#### apply\n\n```python\napply(part: ModelResponsePart) -> TextPart\n\n```\n\nApply this text delta to an existing `TextPart`.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `part` | `ModelResponsePart` | The existing model response part, which must be a TextPart. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `TextPart` | A new TextPart with updated text content. |\n\nRaises:\n\n| Type | Description | | --- | --- | | `ValueError` | If part is not a TextPart. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef apply(self, part: ModelResponsePart) -> TextPart:\n    \"\"\"Apply this text delta to an existing `TextPart`.\n\n    Args:\n        part: The existing model response part, which must be a `TextPart`.\n\n    Returns:\n        A new `TextPart` with updated text content.\n\n    Raises:\n        ValueError: If `part` is not a `TextPart`.\n    \"\"\"\n    if not isinstance(part, TextPart):\n        raise ValueError('Cannot apply TextPartDeltas to non-TextParts')  # pragma: no cover\n    return replace(\n        part,\n        content=part.content + self.content_delta,\n        provider_details={**(part.provider_details or {}), **(self.provider_details or {})} or None,\n    )\n\n```\n\n### ThinkingPartDelta\n\nA partial update (delta) for a `ThinkingPart` to append new thinking content.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False, kw_only=True)\nclass ThinkingPartDelta:\n    \"\"\"A partial update (delta) for a `ThinkingPart` to append new thinking content.\"\"\"\n\n    content_delta: str | None = None\n    \"\"\"The incremental thinking content to add to the existing `ThinkingPart` content.\"\"\"\n\n    signature_delta: str | None = None\n    \"\"\"Optional signature delta.\n\n    Note this is never treated as a delta  it can replace None.\n    \"\"\"\n\n    provider_name: str | None = None\n    \"\"\"Optional provider name for the thinking part.\n\n    Signatures are only sent back to the same provider.\n    \"\"\"\n\n    provider_details: dict[str, Any] | None = None\n    \"\"\"Additional data returned by the provider that can't be mapped to standard fields.\n\n    This is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\"\"\"\n\n    part_delta_kind: Literal['thinking'] = 'thinking'\n    \"\"\"Part delta type identifier, used as a discriminator.\"\"\"\n\n    @overload\n    def apply(self, part: ModelResponsePart) -> ThinkingPart: ...\n\n    @overload\n    def apply(self, part: ModelResponsePart | ThinkingPartDelta) -> ThinkingPart | ThinkingPartDelta: ...\n\n    def apply(self, part: ModelResponsePart | ThinkingPartDelta) -> ThinkingPart | ThinkingPartDelta:\n        \"\"\"Apply this thinking delta to an existing `ThinkingPart`.\n\n        Args:\n            part: The existing model response part, which must be a `ThinkingPart`.\n\n        Returns:\n            A new `ThinkingPart` with updated thinking content.\n\n        Raises:\n            ValueError: If `part` is not a `ThinkingPart`.\n        \"\"\"\n        if isinstance(part, ThinkingPart):\n            new_content = part.content + self.content_delta if self.content_delta else part.content\n            new_signature = self.signature_delta if self.signature_delta is not None else part.signature\n            new_provider_name = self.provider_name if self.provider_name is not None else part.provider_name\n            new_provider_details = {**(part.provider_details or {}), **(self.provider_details or {})} or None\n            return replace(\n                part,\n                content=new_content,\n                signature=new_signature,\n                provider_name=new_provider_name,\n                provider_details=new_provider_details,\n            )\n        elif isinstance(part, ThinkingPartDelta):\n            if self.content_delta is None and self.signature_delta is None:\n                raise ValueError('Cannot apply ThinkingPartDelta with no content or signature')\n            if self.content_delta is not None:\n                part = replace(part, content_delta=(part.content_delta or '') + self.content_delta)\n            if self.signature_delta is not None:\n                part = replace(part, signature_delta=self.signature_delta)\n            if self.provider_name is not None:\n                part = replace(part, provider_name=self.provider_name)\n            if self.provider_details is not None:\n                part = replace(part, provider_details={**(part.provider_details or {}), **self.provider_details})\n            return part\n        raise ValueError(  # pragma: no cover\n            f'Cannot apply ThinkingPartDeltas to non-ThinkingParts or non-ThinkingPartDeltas ({part=}, {self=})'\n        )\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### content_delta\n\n```python\ncontent_delta: str | None = None\n\n```\n\nThe incremental thinking content to add to the existing `ThinkingPart` content.\n\n#### signature_delta\n\n```python\nsignature_delta: str | None = None\n\n```\n\nOptional signature delta.\n\nNote this is never treated as a delta  it can replace None.\n\n#### provider_name\n\n```python\nprovider_name: str | None = None\n\n```\n\nOptional provider name for the thinking part.\n\nSignatures are only sent back to the same provider.\n\n#### provider_details\n\n```python\nprovider_details: dict[str, Any] | None = None\n\n```\n\nAdditional data returned by the provider that can't be mapped to standard fields.\n\nThis is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\n\n#### part_delta_kind\n\n```python\npart_delta_kind: Literal['thinking'] = 'thinking'\n\n```\n\nPart delta type identifier, used as a discriminator.\n\n#### apply\n\n```python\napply(part: ModelResponsePart) -> ThinkingPart\n\n```\n\n```python\napply(\n    part: ModelResponsePart | ThinkingPartDelta,\n) -> ThinkingPart | ThinkingPartDelta\n\n```\n\n```python\napply(\n    part: ModelResponsePart | ThinkingPartDelta,\n) -> ThinkingPart | ThinkingPartDelta\n\n```\n\nApply this thinking delta to an existing `ThinkingPart`.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `part` | `ModelResponsePart | ThinkingPartDelta` | The existing model response part, which must be a ThinkingPart. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `ThinkingPart | ThinkingPartDelta` | A new ThinkingPart with updated thinking content. |\n\nRaises:\n\n| Type | Description | | --- | --- | | `ValueError` | If part is not a ThinkingPart. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef apply(self, part: ModelResponsePart | ThinkingPartDelta) -> ThinkingPart | ThinkingPartDelta:\n    \"\"\"Apply this thinking delta to an existing `ThinkingPart`.\n\n    Args:\n        part: The existing model response part, which must be a `ThinkingPart`.\n\n    Returns:\n        A new `ThinkingPart` with updated thinking content.\n\n    Raises:\n        ValueError: If `part` is not a `ThinkingPart`.\n    \"\"\"\n    if isinstance(part, ThinkingPart):\n        new_content = part.content + self.content_delta if self.content_delta else part.content\n        new_signature = self.signature_delta if self.signature_delta is not None else part.signature\n        new_provider_name = self.provider_name if self.provider_name is not None else part.provider_name\n        new_provider_details = {**(part.provider_details or {}), **(self.provider_details or {})} or None\n        return replace(\n            part,\n            content=new_content,\n            signature=new_signature,\n            provider_name=new_provider_name,\n            provider_details=new_provider_details,\n        )\n    elif isinstance(part, ThinkingPartDelta):\n        if self.content_delta is None and self.signature_delta is None:\n            raise ValueError('Cannot apply ThinkingPartDelta with no content or signature')\n        if self.content_delta is not None:\n            part = replace(part, content_delta=(part.content_delta or '') + self.content_delta)\n        if self.signature_delta is not None:\n            part = replace(part, signature_delta=self.signature_delta)\n        if self.provider_name is not None:\n            part = replace(part, provider_name=self.provider_name)\n        if self.provider_details is not None:\n            part = replace(part, provider_details={**(part.provider_details or {}), **self.provider_details})\n        return part\n    raise ValueError(  # pragma: no cover\n        f'Cannot apply ThinkingPartDeltas to non-ThinkingParts or non-ThinkingPartDeltas ({part=}, {self=})'\n    )\n\n```\n\n### ToolCallPartDelta\n\nA partial update (delta) for a `ToolCallPart` to modify tool name, arguments, or tool call ID.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False, kw_only=True)\nclass ToolCallPartDelta:\n    \"\"\"A partial update (delta) for a `ToolCallPart` to modify tool name, arguments, or tool call ID.\"\"\"\n\n    tool_name_delta: str | None = None\n    \"\"\"Incremental text to add to the existing tool name, if any.\"\"\"\n\n    args_delta: str | dict[str, Any] | None = None\n    \"\"\"Incremental data to add to the tool arguments.\n\n    If this is a string, it will be appended to existing JSON arguments.\n    If this is a dict, it will be merged with existing dict arguments.\n    \"\"\"\n\n    tool_call_id: str | None = None\n    \"\"\"Optional tool call identifier, this is used by some models including OpenAI.\n\n    Note this is never treated as a delta  it can replace None, but otherwise if a\n    non-matching value is provided an error will be raised.\"\"\"\n\n    provider_details: dict[str, Any] | None = None\n    \"\"\"Additional data returned by the provider that can't be mapped to standard fields.\n\n    This is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\"\"\"\n\n    part_delta_kind: Literal['tool_call'] = 'tool_call'\n    \"\"\"Part delta type identifier, used as a discriminator.\"\"\"\n\n    def as_part(self) -> ToolCallPart | None:\n        \"\"\"Convert this delta to a fully formed `ToolCallPart` if possible, otherwise return `None`.\n\n        Returns:\n            A `ToolCallPart` if `tool_name_delta` is set, otherwise `None`.\n        \"\"\"\n        if self.tool_name_delta is None:\n            return None\n\n        return ToolCallPart(self.tool_name_delta, self.args_delta, self.tool_call_id or _generate_tool_call_id())\n\n    @overload\n    def apply(self, part: ModelResponsePart) -> ToolCallPart | BuiltinToolCallPart: ...\n\n    @overload\n    def apply(\n        self, part: ModelResponsePart | ToolCallPartDelta\n    ) -> ToolCallPart | BuiltinToolCallPart | ToolCallPartDelta: ...\n\n    def apply(\n        self, part: ModelResponsePart | ToolCallPartDelta\n    ) -> ToolCallPart | BuiltinToolCallPart | ToolCallPartDelta:\n        \"\"\"Apply this delta to a part or delta, returning a new part or delta with the changes applied.\n\n        Args:\n            part: The existing model response part or delta to update.\n\n        Returns:\n            Either a new `ToolCallPart` or `BuiltinToolCallPart`, or an updated `ToolCallPartDelta`.\n\n        Raises:\n            ValueError: If `part` is neither a `ToolCallPart`, `BuiltinToolCallPart`, nor a `ToolCallPartDelta`.\n            UnexpectedModelBehavior: If applying JSON deltas to dict arguments or vice versa.\n        \"\"\"\n        if isinstance(part, ToolCallPart | BuiltinToolCallPart):\n            return self._apply_to_part(part)\n\n        if isinstance(part, ToolCallPartDelta):\n            return self._apply_to_delta(part)\n\n        raise ValueError(  # pragma: no cover\n            f'Can only apply ToolCallPartDeltas to ToolCallParts, BuiltinToolCallParts, or ToolCallPartDeltas, not {part}'\n        )\n\n    def _apply_to_delta(self, delta: ToolCallPartDelta) -> ToolCallPart | BuiltinToolCallPart | ToolCallPartDelta:\n        \"\"\"Internal helper to apply this delta to another delta.\"\"\"\n        if self.tool_name_delta:\n            # Append incremental text to the existing tool_name_delta\n            updated_tool_name_delta = (delta.tool_name_delta or '') + self.tool_name_delta\n            delta = replace(delta, tool_name_delta=updated_tool_name_delta)\n\n        if isinstance(self.args_delta, str):\n            if isinstance(delta.args_delta, dict):\n                raise UnexpectedModelBehavior(\n                    f'Cannot apply JSON deltas to non-JSON tool arguments ({delta=}, {self=})'\n                )\n            updated_args_delta = (delta.args_delta or '') + self.args_delta\n            delta = replace(delta, args_delta=updated_args_delta)\n        elif isinstance(self.args_delta, dict):\n            if isinstance(delta.args_delta, str):\n                raise UnexpectedModelBehavior(\n                    f'Cannot apply dict deltas to non-dict tool arguments ({delta=}, {self=})'\n                )\n            updated_args_delta = {**(delta.args_delta or {}), **self.args_delta}\n            delta = replace(delta, args_delta=updated_args_delta)\n\n        if self.tool_call_id:\n            delta = replace(delta, tool_call_id=self.tool_call_id)\n\n        # If we now have enough data to create a full ToolCallPart, do so\n        if delta.tool_name_delta is not None:\n            return ToolCallPart(delta.tool_name_delta, delta.args_delta, delta.tool_call_id or _generate_tool_call_id())\n\n        return delta\n\n    def _apply_to_part(self, part: ToolCallPart | BuiltinToolCallPart) -> ToolCallPart | BuiltinToolCallPart:\n        \"\"\"Internal helper to apply this delta directly to a `ToolCallPart` or `BuiltinToolCallPart`.\"\"\"\n        if self.tool_name_delta:\n            # Append incremental text to the existing tool_name\n            tool_name = part.tool_name + self.tool_name_delta\n            part = replace(part, tool_name=tool_name)\n\n        if isinstance(self.args_delta, str):\n            if isinstance(part.args, dict):\n                raise UnexpectedModelBehavior(f'Cannot apply JSON deltas to non-JSON tool arguments ({part=}, {self=})')\n            updated_json = (part.args or '') + self.args_delta\n            part = replace(part, args=updated_json)\n        elif isinstance(self.args_delta, dict):\n            if isinstance(part.args, str):\n                raise UnexpectedModelBehavior(f'Cannot apply dict deltas to non-dict tool arguments ({part=}, {self=})')\n            updated_dict = {**(part.args or {}), **self.args_delta}\n            part = replace(part, args=updated_dict)\n\n        if self.tool_call_id:\n            part = replace(part, tool_call_id=self.tool_call_id)\n        return part\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### tool_name_delta\n\n```python\ntool_name_delta: str | None = None\n\n```\n\nIncremental text to add to the existing tool name, if any.\n\n#### args_delta\n\n```python\nargs_delta: str | dict[str, Any] | None = None\n\n```\n\nIncremental data to add to the tool arguments.\n\nIf this is a string, it will be appended to existing JSON arguments. If this is a dict, it will be merged with existing dict arguments.\n\n#### tool_call_id\n\n```python\ntool_call_id: str | None = None\n\n```\n\nOptional tool call identifier, this is used by some models including OpenAI.\n\nNote this is never treated as a delta  it can replace None, but otherwise if a non-matching value is provided an error will be raised.\n\n#### provider_details\n\n```python\nprovider_details: dict[str, Any] | None = None\n\n```\n\nAdditional data returned by the provider that can't be mapped to standard fields.\n\nThis is used for data that is required to be sent back to APIs, as well as data users may want to access programmatically.\n\n#### part_delta_kind\n\n```python\npart_delta_kind: Literal['tool_call'] = 'tool_call'\n\n```\n\nPart delta type identifier, used as a discriminator.\n\n#### as_part\n\n```python\nas_part() -> ToolCallPart | None\n\n```\n\nConvert this delta to a fully formed `ToolCallPart` if possible, otherwise return `None`.\n\nReturns:\n\n| Type | Description | | --- | --- | | `ToolCallPart | None` | A ToolCallPart if tool_name_delta is set, otherwise None. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef as_part(self) -> ToolCallPart | None:\n    \"\"\"Convert this delta to a fully formed `ToolCallPart` if possible, otherwise return `None`.\n\n    Returns:\n        A `ToolCallPart` if `tool_name_delta` is set, otherwise `None`.\n    \"\"\"\n    if self.tool_name_delta is None:\n        return None\n\n    return ToolCallPart(self.tool_name_delta, self.args_delta, self.tool_call_id or _generate_tool_call_id())\n\n```\n\n#### apply\n\n```python\napply(\n    part: ModelResponsePart,\n) -> ToolCallPart | BuiltinToolCallPart\n\n```\n\n```python\napply(\n    part: ModelResponsePart | ToolCallPartDelta,\n) -> ToolCallPart | BuiltinToolCallPart | ToolCallPartDelta\n\n```\n\n```python\napply(\n    part: ModelResponsePart | ToolCallPartDelta,\n) -> ToolCallPart | BuiltinToolCallPart | ToolCallPartDelta\n\n```\n\nApply this delta to a part or delta, returning a new part or delta with the changes applied.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `part` | `ModelResponsePart | ToolCallPartDelta` | The existing model response part or delta to update. | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `ToolCallPart | BuiltinToolCallPart | ToolCallPartDelta` | Either a new ToolCallPart or BuiltinToolCallPart, or an updated ToolCallPartDelta. |\n\nRaises:\n\n| Type | Description | | --- | --- | | `ValueError` | If part is neither a ToolCallPart, BuiltinToolCallPart, nor a ToolCallPartDelta. | | `UnexpectedModelBehavior` | If applying JSON deltas to dict arguments or vice versa. |\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\ndef apply(\n    self, part: ModelResponsePart | ToolCallPartDelta\n) -> ToolCallPart | BuiltinToolCallPart | ToolCallPartDelta:\n    \"\"\"Apply this delta to a part or delta, returning a new part or delta with the changes applied.\n\n    Args:\n        part: The existing model response part or delta to update.\n\n    Returns:\n        Either a new `ToolCallPart` or `BuiltinToolCallPart`, or an updated `ToolCallPartDelta`.\n\n    Raises:\n        ValueError: If `part` is neither a `ToolCallPart`, `BuiltinToolCallPart`, nor a `ToolCallPartDelta`.\n        UnexpectedModelBehavior: If applying JSON deltas to dict arguments or vice versa.\n    \"\"\"\n    if isinstance(part, ToolCallPart | BuiltinToolCallPart):\n        return self._apply_to_part(part)\n\n    if isinstance(part, ToolCallPartDelta):\n        return self._apply_to_delta(part)\n\n    raise ValueError(  # pragma: no cover\n        f'Can only apply ToolCallPartDeltas to ToolCallParts, BuiltinToolCallParts, or ToolCallPartDeltas, not {part}'\n    )\n\n```\n\n### ModelResponsePartDelta\n\n```python\nModelResponsePartDelta = Annotated[\n    TextPartDelta | ThinkingPartDelta | ToolCallPartDelta,\n    Discriminator(\"part_delta_kind\"),\n]\n\n```\n\nA partial update (delta) for any model response part.\n\n### PartStartEvent\n\nAn event indicating that a new part has started.\n\nIf multiple `PartStartEvent`s are received with the same index, the new one should fully replace the old one.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False, kw_only=True)\nclass PartStartEvent:\n    \"\"\"An event indicating that a new part has started.\n\n    If multiple `PartStartEvent`s are received with the same index,\n    the new one should fully replace the old one.\n    \"\"\"\n\n    index: int\n    \"\"\"The index of the part within the overall response parts list.\"\"\"\n\n    part: ModelResponsePart\n    \"\"\"The newly started `ModelResponsePart`.\"\"\"\n\n    previous_part_kind: (\n        Literal['text', 'thinking', 'tool-call', 'builtin-tool-call', 'builtin-tool-return', 'file'] | None\n    ) = None\n    \"\"\"The kind of the previous part, if any.\n\n    This is useful for UI event streams to know whether to group parts of the same kind together when emitting events.\n    \"\"\"\n\n    event_kind: Literal['part_start'] = 'part_start'\n    \"\"\"Event type identifier, used as a discriminator.\"\"\"\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### index\n\n```python\nindex: int\n\n```\n\nThe index of the part within the overall response parts list.\n\n#### part\n\n```python\npart: ModelResponsePart\n\n```\n\nThe newly started `ModelResponsePart`.\n\n#### previous_part_kind\n\n```python\nprevious_part_kind: (\n    Literal[\n        \"text\",\n        \"thinking\",\n        \"tool-call\",\n        \"builtin-tool-call\",\n        \"builtin-tool-return\",\n        \"file\",\n    ]\n    | None\n) = None\n\n```\n\nThe kind of the previous part, if any.\n\nThis is useful for UI event streams to know whether to group parts of the same kind together when emitting events.\n\n#### event_kind\n\n```python\nevent_kind: Literal['part_start'] = 'part_start'\n\n```\n\nEvent type identifier, used as a discriminator.\n\n### PartDeltaEvent\n\nAn event indicating a delta update for an existing part.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False, kw_only=True)\nclass PartDeltaEvent:\n    \"\"\"An event indicating a delta update for an existing part.\"\"\"\n\n    index: int\n    \"\"\"The index of the part within the overall response parts list.\"\"\"\n\n    delta: ModelResponsePartDelta\n    \"\"\"The delta to apply to the specified part.\"\"\"\n\n    event_kind: Literal['part_delta'] = 'part_delta'\n    \"\"\"Event type identifier, used as a discriminator.\"\"\"\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### index\n\n```python\nindex: int\n\n```\n\nThe index of the part within the overall response parts list.\n\n#### delta\n\n```python\ndelta: ModelResponsePartDelta\n\n```\n\nThe delta to apply to the specified part.\n\n#### event_kind\n\n```python\nevent_kind: Literal['part_delta'] = 'part_delta'\n\n```\n\nEvent type identifier, used as a discriminator.\n\n### PartEndEvent\n\nAn event indicating that a part is complete.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False, kw_only=True)\nclass PartEndEvent:\n    \"\"\"An event indicating that a part is complete.\"\"\"\n\n    index: int\n    \"\"\"The index of the part within the overall response parts list.\"\"\"\n\n    part: ModelResponsePart\n    \"\"\"The complete `ModelResponsePart`.\"\"\"\n\n    next_part_kind: (\n        Literal['text', 'thinking', 'tool-call', 'builtin-tool-call', 'builtin-tool-return', 'file'] | None\n    ) = None\n    \"\"\"The kind of the next part, if any.\n\n    This is useful for UI event streams to know whether to group parts of the same kind together when emitting events.\n    \"\"\"\n\n    event_kind: Literal['part_end'] = 'part_end'\n    \"\"\"Event type identifier, used as a discriminator.\"\"\"\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### index\n\n```python\nindex: int\n\n```\n\nThe index of the part within the overall response parts list.\n\n#### part\n\n```python\npart: ModelResponsePart\n\n```\n\nThe complete `ModelResponsePart`.\n\n#### next_part_kind\n\n```python\nnext_part_kind: (\n    Literal[\n        \"text\",\n        \"thinking\",\n        \"tool-call\",\n        \"builtin-tool-call\",\n        \"builtin-tool-return\",\n        \"file\",\n    ]\n    | None\n) = None\n\n```\n\nThe kind of the next part, if any.\n\nThis is useful for UI event streams to know whether to group parts of the same kind together when emitting events.\n\n#### event_kind\n\n```python\nevent_kind: Literal['part_end'] = 'part_end'\n\n```\n\nEvent type identifier, used as a discriminator.\n\n### FinalResultEvent\n\nAn event indicating the response to the current model request matches the output schema and will produce a result.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False, kw_only=True)\nclass FinalResultEvent:\n    \"\"\"An event indicating the response to the current model request matches the output schema and will produce a result.\"\"\"\n\n    tool_name: str | None\n    \"\"\"The name of the output tool that was called. `None` if the result is from text content and not from a tool.\"\"\"\n    tool_call_id: str | None\n    \"\"\"The tool call ID, if any, that this result is associated with.\"\"\"\n    event_kind: Literal['final_result'] = 'final_result'\n    \"\"\"Event type identifier, used as a discriminator.\"\"\"\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### tool_name\n\n```python\ntool_name: str | None\n\n```\n\nThe name of the output tool that was called. `None` if the result is from text content and not from a tool.\n\n#### tool_call_id\n\n```python\ntool_call_id: str | None\n\n```\n\nThe tool call ID, if any, that this result is associated with.\n\n#### event_kind\n\n```python\nevent_kind: Literal['final_result'] = 'final_result'\n\n```\n\nEvent type identifier, used as a discriminator.\n\n### ModelResponseStreamEvent\n\n```python\nModelResponseStreamEvent = Annotated[\n    PartStartEvent\n    | PartDeltaEvent\n    | PartEndEvent\n    | FinalResultEvent,\n    Discriminator(\"event_kind\"),\n]\n\n```\n\nAn event in the model response stream, starting a new part, applying a delta to an existing one, indicating a part is complete, or indicating the final result.\n\n### FunctionToolCallEvent\n\nAn event indicating the start to a call to a function tool.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass FunctionToolCallEvent:\n    \"\"\"An event indicating the start to a call to a function tool.\"\"\"\n\n    part: ToolCallPart\n    \"\"\"The (function) tool call to make.\"\"\"\n\n    _: KW_ONLY\n\n    event_kind: Literal['function_tool_call'] = 'function_tool_call'\n    \"\"\"Event type identifier, used as a discriminator.\"\"\"\n\n    @property\n    def tool_call_id(self) -> str:\n        \"\"\"An ID used for matching details about the call to its result.\"\"\"\n        return self.part.tool_call_id\n\n    @property\n    @deprecated('`call_id` is deprecated, use `tool_call_id` instead.')\n    def call_id(self) -> str:\n        \"\"\"An ID used for matching details about the call to its result.\"\"\"\n        return self.part.tool_call_id  # pragma: no cover\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### part\n\n```python\npart: ToolCallPart\n\n```\n\nThe (function) tool call to make.\n\n#### event_kind\n\n```python\nevent_kind: Literal[\"function_tool_call\"] = (\n    \"function_tool_call\"\n)\n\n```\n\nEvent type identifier, used as a discriminator.\n\n#### tool_call_id\n\n```python\ntool_call_id: str\n\n```\n\nAn ID used for matching details about the call to its result.\n\n#### call_id\n\n```python\ncall_id: str\n\n```\n\nAn ID used for matching details about the call to its result.\n\n### FunctionToolResultEvent\n\nAn event indicating the result of a function tool call.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@dataclass(repr=False)\nclass FunctionToolResultEvent:\n    \"\"\"An event indicating the result of a function tool call.\"\"\"\n\n    result: ToolReturnPart | RetryPromptPart\n    \"\"\"The result of the call to the function tool.\"\"\"\n\n    _: KW_ONLY\n\n    content: str | Sequence[UserContent] | None = None\n    \"\"\"The content that will be sent to the model as a UserPromptPart following the result.\"\"\"\n\n    event_kind: Literal['function_tool_result'] = 'function_tool_result'\n    \"\"\"Event type identifier, used as a discriminator.\"\"\"\n\n    @property\n    def tool_call_id(self) -> str:\n        \"\"\"An ID used to match the result to its original call.\"\"\"\n        return self.result.tool_call_id\n\n    __repr__ = _utils.dataclasses_no_defaults_repr\n\n```\n\n#### result\n\n```python\nresult: ToolReturnPart | RetryPromptPart\n\n```\n\nThe result of the call to the function tool.\n\n#### content\n\n```python\ncontent: str | Sequence[UserContent] | None = None\n\n```\n\nThe content that will be sent to the model as a UserPromptPart following the result.\n\n#### event_kind\n\n```python\nevent_kind: Literal[\"function_tool_result\"] = (\n    \"function_tool_result\"\n)\n\n```\n\nEvent type identifier, used as a discriminator.\n\n#### tool_call_id\n\n```python\ntool_call_id: str\n\n```\n\nAn ID used to match the result to its original call.\n\n### BuiltinToolCallEvent\n\nDeprecated\n\n`BuiltinToolCallEvent` is deprecated, look for `PartStartEvent` and `PartDeltaEvent` with `BuiltinToolCallPart` instead.\n\nAn event indicating the start to a call to a built-in tool.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@deprecated(\n    '`BuiltinToolCallEvent` is deprecated, look for `PartStartEvent` and `PartDeltaEvent` with `BuiltinToolCallPart` instead.'\n)\n@dataclass(repr=False)\nclass BuiltinToolCallEvent:\n    \"\"\"An event indicating the start to a call to a built-in tool.\"\"\"\n\n    part: BuiltinToolCallPart\n    \"\"\"The built-in tool call to make.\"\"\"\n\n    _: KW_ONLY\n\n    event_kind: Literal['builtin_tool_call'] = 'builtin_tool_call'\n    \"\"\"Event type identifier, used as a discriminator.\"\"\"\n\n```\n\n#### part\n\n```python\npart: BuiltinToolCallPart\n\n```\n\nThe built-in tool call to make.\n\n#### event_kind\n\n```python\nevent_kind: Literal[\"builtin_tool_call\"] = (\n    \"builtin_tool_call\"\n)\n\n```\n\nEvent type identifier, used as a discriminator.\n\n### BuiltinToolResultEvent\n\nDeprecated\n\n`BuiltinToolResultEvent` is deprecated, look for `PartStartEvent` and `PartDeltaEvent` with `BuiltinToolReturnPart` instead.\n\nAn event indicating the result of a built-in tool call.\n\nSource code in `pydantic_ai_slim/pydantic_ai/messages.py`\n\n```python\n@deprecated(\n    '`BuiltinToolResultEvent` is deprecated, look for `PartStartEvent` and `PartDeltaEvent` with `BuiltinToolReturnPart` instead.'\n)\n@dataclass(repr=False)\nclass BuiltinToolResultEvent:\n    \"\"\"An event indicating the result of a built-in tool call.\"\"\"\n\n    result: BuiltinToolReturnPart\n    \"\"\"The result of the call to the built-in tool.\"\"\"\n\n    _: KW_ONLY\n\n    event_kind: Literal['builtin_tool_result'] = 'builtin_tool_result'\n    \"\"\"Event type identifier, used as a discriminator.\"\"\"\n\n```\n\n#### result\n\n```python\nresult: BuiltinToolReturnPart\n\n```\n\nThe result of the call to the built-in tool.\n\n#### event_kind\n\n```python\nevent_kind: Literal[\"builtin_tool_result\"] = (\n    \"builtin_tool_result\"\n)\n\n```\n\nEvent type identifier, used as a discriminator.\n\n### HandleResponseEvent\n\n```python\nHandleResponseEvent = Annotated[\n    FunctionToolCallEvent\n    | FunctionToolResultEvent\n    | BuiltinToolCallEvent\n    | BuiltinToolResultEvent,\n    Discriminator(\"event_kind\"),\n]\n\n```\n\nAn event yielded when handling a model response, indicating tool calls and results.\n\n### AgentStreamEvent\n\n```python\nAgentStreamEvent = Annotated[\n    ModelResponseStreamEvent | HandleResponseEvent,\n    Discriminator(\"event_kind\"),\n]\n\n```\n\nAn event in the agent stream: model response stream events and response-handling events.",
  "content_length": 115624
}