{
  "title": "Function Tools",
  "source_url": null,
  "content": "Function tools provide a mechanism for models to perform actions and retrieve extra information to help them generate a response.\n\nThey're useful when you want to enable the model to take some action and use the result, when it is impractical or impossible to put all the context an agent might need into the instructions, or when you want to make agents' behavior more deterministic or reliable by deferring some of the logic required to generate a response to another (not necessarily AI-powered) tool.\n\nIf you want a model to be able to call a function as its final action, without the result being sent back to the model, you can use an [output function](../output/#output-functions) instead.\n\nThere are a number of ways to register tools with an agent:\n\n- via the @agent.tool decorator — for tools that need access to the agent context\n- via the @agent.tool_plain decorator — for tools that do not need access to the agent context\n- via the tools keyword argument to `Agent` which can take either plain functions, or instances of Tool\n\nFor more advanced use cases, the [toolsets](../toolsets/) feature lets you manage collections of tools (built by you or provided by an [MCP server](../mcp/client/) or other [third party](../third-party-tools/#third-party-tools)) and register them with an agent in one go via the toolsets keyword argument to `Agent`. Internally, all `tools` and `toolsets` are gathered into a single [combined toolset](../toolsets/#combining-toolsets) that's made available to the model.\n\nFunction tools vs. RAG\n\nFunction tools are basically the \"R\" of RAG (Retrieval-Augmented Generation) — they augment what the model can do by letting it request extra information.\n\nThe main semantic difference between Pydantic AI Tools and RAG is RAG is synonymous with vector search, while Pydantic AI tools are more general-purpose. (Note: we may add support for vector search functionality in the future, particularly an API for generating embeddings. See [#58](https://github.com/pydantic/pydantic-ai/issues/58))\n\nFunction Tools vs. Structured Outputs\n\nAs the name suggests, function tools use the model's \"tools\" or \"functions\" API to let the model know what is available to call. Tools or functions are also used to define the schema(s) for [structured output](../output/) when using the default [tool output mode](../output/#tool-output), thus a model might have access to many tools, some of which call function tools while others end the run and produce a final output.\n\n## Registering via Decorator\n\n`@agent.tool` is considered the default decorator since in the majority of cases tools will need access to the agent context.\n\nHere's an example using both:\n\ndice_game.py\n\n```python\nimport random\n\nfrom pydantic_ai import Agent, RunContext\n\nagent = Agent(\n    'google-gla:gemini-2.5-flash',  # (1)!\n    deps_type=str,  # (2)!\n    system_prompt=(\n        \"You're a dice game, you should roll the die and see if the number \"\n        \"you get back matches the user's guess. If so, tell them they're a winner. \"\n        \"Use the player's name in the response.\"\n    ),\n)\n\n\n@agent.tool_plain  # (3)!\ndef roll_dice() -> str:\n    \"\"\"Roll a six-sided die and return the result.\"\"\"\n    return str(random.randint(1, 6))\n\n\n@agent.tool  # (4)!\ndef get_player_name(ctx: RunContext[str]) -> str:\n    \"\"\"Get the player's name.\"\"\"\n    return ctx.deps\n\n\ndice_result = agent.run_sync('My guess is 4', deps='Anne')  # (5)!\nprint(dice_result.output)\n#> Congratulations Anne, you guessed correctly! You're a winner!\n\n```\n\n1. This is a pretty simple task, so we can use the fast and cheap Gemini flash model.\n1. We pass the user's name as the dependency, to keep things simple we use just the name as a string as the dependency.\n1. This tool doesn't need any context, it just returns a random number. You could probably use dynamic instructions in this case.\n1. This tool needs the player's name, so it uses `RunContext` to access dependencies which are just the player's name in this case.\n1. Run the agent, passing the player's name as the dependency.\n\n*(This example is complete, it can be run \"as is\")*\n\nLet's print the messages from that game to see what happened:\n\ndice_game_messages.py\n\n```python\nfrom dice_game import dice_result\n\nprint(dice_result.all_messages())\n\"\"\"\n[\n    ModelRequest(\n        parts=[\n            SystemPromptPart(\n                content=\"You're a dice game, you should roll the die and see if the number you get back matches the user's guess. If so, tell them they're a winner. Use the player's name in the response.\",\n                timestamp=datetime.datetime(...),\n            ),\n            UserPromptPart(\n                content='My guess is 4',\n                timestamp=datetime.datetime(...),\n            ),\n        ],\n        run_id='...',\n    ),\n    ModelResponse(\n        parts=[\n            ToolCallPart(\n                tool_name='roll_dice', args={}, tool_call_id='pyd_ai_tool_call_id'\n            )\n        ],\n        usage=RequestUsage(input_tokens=90, output_tokens=2),\n        model_name='gemini-2.5-flash',\n        timestamp=datetime.datetime(...),\n        run_id='...',\n    ),\n    ModelRequest(\n        parts=[\n            ToolReturnPart(\n                tool_name='roll_dice',\n                content='4',\n                tool_call_id='pyd_ai_tool_call_id',\n                timestamp=datetime.datetime(...),\n            )\n        ],\n        run_id='...',\n    ),\n    ModelResponse(\n        parts=[\n            ToolCallPart(\n                tool_name='get_player_name', args={}, tool_call_id='pyd_ai_tool_call_id'\n            )\n        ],\n        usage=RequestUsage(input_tokens=91, output_tokens=4),\n        model_name='gemini-2.5-flash',\n        timestamp=datetime.datetime(...),\n        run_id='...',\n    ),\n    ModelRequest(\n        parts=[\n            ToolReturnPart(\n                tool_name='get_player_name',\n                content='Anne',\n                tool_call_id='pyd_ai_tool_call_id',\n                timestamp=datetime.datetime(...),\n            )\n        ],\n        run_id='...',\n    ),\n    ModelResponse(\n        parts=[\n            TextPart(\n                content=\"Congratulations Anne, you guessed correctly! You're a winner!\"\n            )\n        ],\n        usage=RequestUsage(input_tokens=92, output_tokens=12),\n        model_name='gemini-2.5-flash',\n        timestamp=datetime.datetime(...),\n        run_id='...',\n    ),\n]\n\"\"\"\n\n```\n\nWe can represent this with a diagram:\n\n```\nsequenceDiagram\n    participant Agent\n    participant LLM\n\n    Note over Agent: Send prompts\n    Agent ->> LLM: System: \"You're a dice game...\"<br>User: \"My guess is 4\"\n    activate LLM\n    Note over LLM: LLM decides to use<br>a tool\n\n    LLM ->> Agent: Call tool<br>roll_dice()\n    deactivate LLM\n    activate Agent\n    Note over Agent: Rolls a six-sided die\n\n    Agent -->> LLM: ToolReturn<br>\"4\"\n    deactivate Agent\n    activate LLM\n    Note over LLM: LLM decides to use<br>another tool\n\n    LLM ->> Agent: Call tool<br>get_player_name()\n    deactivate LLM\n    activate Agent\n    Note over Agent: Retrieves player name\n    Agent -->> LLM: ToolReturn<br>\"Anne\"\n    deactivate Agent\n    activate LLM\n    Note over LLM: LLM constructs final response\n\n    LLM ->> Agent: ModelResponse<br>\"Congratulations Anne, ...\"\n    deactivate LLM\n    Note over Agent: Game session complete\n```\n\n## Registering via Agent Argument\n\nAs well as using the decorators, we can register tools via the `tools` argument to the Agent constructor. This is useful when you want to reuse tools, and can also give more fine-grained control over the tools.\n\ndice_game_tool_kwarg.py\n\n```python\nimport random\n\nfrom pydantic_ai import Agent, RunContext, Tool\n\nsystem_prompt = \"\"\"\\\nYou're a dice game, you should roll the die and see if the number\nyou get back matches the user's guess. If so, tell them they're a winner.\nUse the player's name in the response.\n\"\"\"\n\n\ndef roll_dice() -> str:\n    \"\"\"Roll a six-sided die and return the result.\"\"\"\n    return str(random.randint(1, 6))\n\n\ndef get_player_name(ctx: RunContext[str]) -> str:\n    \"\"\"Get the player's name.\"\"\"\n    return ctx.deps\n\n\nagent_a = Agent(\n    'google-gla:gemini-2.5-flash',\n    deps_type=str,\n    tools=[roll_dice, get_player_name],  # (1)!\n    system_prompt=system_prompt,\n)\nagent_b = Agent(\n    'google-gla:gemini-2.5-flash',\n    deps_type=str,\n    tools=[  # (2)!\n        Tool(roll_dice, takes_ctx=False),\n        Tool(get_player_name, takes_ctx=True),\n    ],\n    system_prompt=system_prompt,\n)\n\ndice_result = {}\ndice_result['a'] = agent_a.run_sync('My guess is 6', deps='Yashar')\ndice_result['b'] = agent_b.run_sync('My guess is 4', deps='Anne')\nprint(dice_result['a'].output)\n#> Tough luck, Yashar, you rolled a 4. Better luck next time.\nprint(dice_result['b'].output)\n#> Congratulations Anne, you guessed correctly! You're a winner!\n\n```\n\n1. The simplest way to register tools via the `Agent` constructor is to pass a list of functions, the function signature is inspected to determine if the tool takes RunContext.\n1. `agent_a` and `agent_b` are identical — but we can use Tool to reuse tool definitions and give more fine-grained control over how tools are defined, e.g. setting their name or description, or using a custom [`prepare`](../tools-advanced/#tool-prepare) method.\n\n*(This example is complete, it can be run \"as is\")*\n\n## Tool Output\n\nTools can return anything that Pydantic can serialize to JSON. For advanced output options including multi-modal content and metadata, see [Advanced Tool Features](../tools-advanced/#function-tool-output).\n\n## Tool Schema\n\nFunction parameters are extracted from the function signature, and all parameters except `RunContext` are used to build the schema for that tool call.\n\nEven better, Pydantic AI extracts the docstring from functions and (thanks to [griffe](https://mkdocstrings.github.io/griffe/)) extracts parameter descriptions from the docstring and adds them to the schema.\n\n[Griffe supports](https://mkdocstrings.github.io/griffe/reference/docstrings/#docstrings) extracting parameter descriptions from `google`, `numpy`, and `sphinx` style docstrings. Pydantic AI will infer the format to use based on the docstring, but you can explicitly set it using docstring_format. You can also enforce parameter requirements by setting `require_parameter_descriptions=True`. This will raise a UserError if a parameter description is missing.\n\nTo demonstrate a tool's schema, here we use FunctionModel to print the schema a model would receive:\n\ntool_schema.py\n\n```python\nfrom pydantic_ai import Agent, ModelMessage, ModelResponse, TextPart\nfrom pydantic_ai.models.function import AgentInfo, FunctionModel\n\nagent = Agent()\n\n\n@agent.tool_plain(docstring_format='google', require_parameter_descriptions=True)\ndef foobar(a: int, b: str, c: dict[str, list[float]]) -> str:\n    \"\"\"Get me foobar.\n\n    Args:\n        a: apple pie\n        b: banana cake\n        c: carrot smoothie\n    \"\"\"\n    return f'{a} {b} {c}'\n\n\ndef print_schema(messages: list[ModelMessage], info: AgentInfo) -> ModelResponse:\n    tool = info.function_tools[0]\n    print(tool.description)\n    #> Get me foobar.\n    print(tool.parameters_json_schema)\n    \"\"\"\n    {\n        'additionalProperties': False,\n        'properties': {\n            'a': {'description': 'apple pie', 'type': 'integer'},\n            'b': {'description': 'banana cake', 'type': 'string'},\n            'c': {\n                'additionalProperties': {'items': {'type': 'number'}, 'type': 'array'},\n                'description': 'carrot smoothie',\n                'type': 'object',\n            },\n        },\n        'required': ['a', 'b', 'c'],\n        'type': 'object',\n    }\n    \"\"\"\n    return ModelResponse(parts=[TextPart('foobar')])\n\n\nagent.run_sync('hello', model=FunctionModel(print_schema))\n\n```\n\n*(This example is complete, it can be run \"as is\")*\n\nIf a tool has a single parameter that can be represented as an object in JSON schema (e.g. dataclass, TypedDict, pydantic model), the schema for the tool is simplified to be just that object.\n\nHere's an example where we use TestModel.last_model_request_parameters to inspect the tool schema that would be passed to the model.\n\nsingle_parameter_tool.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent\nfrom pydantic_ai.models.test import TestModel\n\nagent = Agent()\n\n\nclass Foobar(BaseModel):\n    \"\"\"This is a Foobar\"\"\"\n\n    x: int\n    y: str\n    z: float = 3.14\n\n\n@agent.tool_plain\ndef foobar(f: Foobar) -> str:\n    return str(f)\n\n\ntest_model = TestModel()\nresult = agent.run_sync('hello', model=test_model)\nprint(result.output)\n#> {\"foobar\":\"x=0 y='a' z=3.14\"}\nprint(test_model.last_model_request_parameters.function_tools)\n\"\"\"\n[\n    ToolDefinition(\n        name='foobar',\n        parameters_json_schema={\n            'properties': {\n                'x': {'type': 'integer'},\n                'y': {'type': 'string'},\n                'z': {'default': 3.14, 'type': 'number'},\n            },\n            'required': ['x', 'y'],\n            'title': 'Foobar',\n            'type': 'object',\n        },\n        description='This is a Foobar',\n    )\n]\n\"\"\"\n\n```\n\n*(This example is complete, it can be run \"as is\")*\n\n## See Also\n\nFor more tool features and integrations, see:\n\n- [Advanced Tool Features](../tools-advanced/) - Custom schemas, dynamic tools, tool execution and retries\n- [Toolsets](../toolsets/) - Managing collections of tools\n- [Builtin Tools](../builtin-tools/) - Native tools provided by LLM providers\n- [Common Tools](../common-tools/) - Ready-to-use tool implementations\n- [Third-Party Tools](../third-party-tools/) - Integrations with MCP, LangChain, ACI.dev and other tool libraries\n- [Deferred Tools](../deferred-tools/) - Tools requiring approval or external execution",
  "content_length": 13743
}