{
  "title": "`pydantic_ai.output`",
  "source_url": null,
  "content": "### OutputDataT\n\n```python\nOutputDataT = TypeVar(\n    \"OutputDataT\", default=str, covariant=True\n)\n\n```\n\nCovariant type variable for the output data type of a run.\n\n### ToolOutput\n\nBases: `Generic[OutputDataT]`\n\nMarker class to use a tool for output and optionally customize the tool.\n\nExample: tool_output.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, ToolOutput\n\n\nclass Fruit(BaseModel):\n    name: str\n    color: str\n\n\nclass Vehicle(BaseModel):\n    name: str\n    wheels: int\n\n\nagent = Agent(\n    'openai:gpt-4o',\n    output_type=[\n        ToolOutput(Fruit, name='return_fruit'),\n        ToolOutput(Vehicle, name='return_vehicle'),\n    ],\n)\nresult = agent.run_sync('What is a banana?')\nprint(repr(result.output))\n#> Fruit(name='banana', color='yellow')\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/output.py`\n\n````python\n@dataclass(init=False)\nclass ToolOutput(Generic[OutputDataT]):\n    \"\"\"Marker class to use a tool for output and optionally customize the tool.\n\n    Example:\n    ```python {title=\"tool_output.py\"}\n    from pydantic import BaseModel\n\n    from pydantic_ai import Agent, ToolOutput\n\n\n    class Fruit(BaseModel):\n        name: str\n        color: str\n\n\n    class Vehicle(BaseModel):\n        name: str\n        wheels: int\n\n\n    agent = Agent(\n        'openai:gpt-4o',\n        output_type=[\n            ToolOutput(Fruit, name='return_fruit'),\n            ToolOutput(Vehicle, name='return_vehicle'),\n        ],\n    )\n    result = agent.run_sync('What is a banana?')\n    print(repr(result.output))\n    #> Fruit(name='banana', color='yellow')\n    ```\n    \"\"\"\n\n    output: OutputTypeOrFunction[OutputDataT]\n    \"\"\"An output type or function.\"\"\"\n    name: str | None\n    \"\"\"The name of the tool that will be passed to the model. If not specified and only one output is provided, `final_result` will be used. If multiple outputs are provided, the name of the output type or function will be added to the tool name.\"\"\"\n    description: str | None\n    \"\"\"The description of the tool that will be passed to the model. If not specified, the docstring of the output type or function will be used.\"\"\"\n    max_retries: int | None\n    \"\"\"The maximum number of retries for the tool.\"\"\"\n    strict: bool | None\n    \"\"\"Whether to use strict mode for the tool.\"\"\"\n\n    def __init__(\n        self,\n        type_: OutputTypeOrFunction[OutputDataT],\n        *,\n        name: str | None = None,\n        description: str | None = None,\n        max_retries: int | None = None,\n        strict: bool | None = None,\n    ):\n        self.output = type_\n        self.name = name\n        self.description = description\n        self.max_retries = max_retries\n        self.strict = strict\n\n````\n\n#### output\n\n```python\noutput: OutputTypeOrFunction[OutputDataT] = type_\n\n```\n\nAn output type or function.\n\n#### name\n\n```python\nname: str | None = name\n\n```\n\nThe name of the tool that will be passed to the model. If not specified and only one output is provided, `final_result` will be used. If multiple outputs are provided, the name of the output type or function will be added to the tool name.\n\n#### description\n\n```python\ndescription: str | None = description\n\n```\n\nThe description of the tool that will be passed to the model. If not specified, the docstring of the output type or function will be used.\n\n#### max_retries\n\n```python\nmax_retries: int | None = max_retries\n\n```\n\nThe maximum number of retries for the tool.\n\n#### strict\n\n```python\nstrict: bool | None = strict\n\n```\n\nWhether to use strict mode for the tool.\n\n### NativeOutput\n\nBases: `Generic[OutputDataT]`\n\nMarker class to use the model's native structured outputs functionality for outputs and optionally customize the name and description.\n\nExample: native_output.py\n\n```python\nfrom pydantic_ai import Agent, NativeOutput\n\nfrom tool_output import Fruit, Vehicle\n\nagent = Agent(\n    'openai:gpt-4o',\n    output_type=NativeOutput(\n        [Fruit, Vehicle],\n        name='Fruit or vehicle',\n        description='Return a fruit or vehicle.'\n    ),\n)\nresult = agent.run_sync('What is a Ford Explorer?')\nprint(repr(result.output))\n#> Vehicle(name='Ford Explorer', wheels=4)\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/output.py`\n\n````python\n@dataclass(init=False)\nclass NativeOutput(Generic[OutputDataT]):\n    \"\"\"Marker class to use the model's native structured outputs functionality for outputs and optionally customize the name and description.\n\n    Example:\n    ```python {title=\"native_output.py\" requires=\"tool_output.py\"}\n    from pydantic_ai import Agent, NativeOutput\n\n    from tool_output import Fruit, Vehicle\n\n    agent = Agent(\n        'openai:gpt-4o',\n        output_type=NativeOutput(\n            [Fruit, Vehicle],\n            name='Fruit or vehicle',\n            description='Return a fruit or vehicle.'\n        ),\n    )\n    result = agent.run_sync('What is a Ford Explorer?')\n    print(repr(result.output))\n    #> Vehicle(name='Ford Explorer', wheels=4)\n    ```\n    \"\"\"\n\n    outputs: OutputTypeOrFunction[OutputDataT] | Sequence[OutputTypeOrFunction[OutputDataT]]\n    \"\"\"The output types or functions.\"\"\"\n    name: str | None\n    \"\"\"The name of the structured output that will be passed to the model. If not specified and only one output is provided, the name of the output type or function will be used.\"\"\"\n    description: str | None\n    \"\"\"The description of the structured output that will be passed to the model. If not specified and only one output is provided, the docstring of the output type or function will be used.\"\"\"\n    strict: bool | None\n    \"\"\"Whether to use strict mode for the output, if the model supports it.\"\"\"\n\n    def __init__(\n        self,\n        outputs: OutputTypeOrFunction[OutputDataT] | Sequence[OutputTypeOrFunction[OutputDataT]],\n        *,\n        name: str | None = None,\n        description: str | None = None,\n        strict: bool | None = None,\n    ):\n        self.outputs = outputs\n        self.name = name\n        self.description = description\n        self.strict = strict\n\n````\n\n#### outputs\n\n```python\noutputs: (\n    OutputTypeOrFunction[OutputDataT]\n    | Sequence[OutputTypeOrFunction[OutputDataT]]\n) = outputs\n\n```\n\nThe output types or functions.\n\n#### name\n\n```python\nname: str | None = name\n\n```\n\nThe name of the structured output that will be passed to the model. If not specified and only one output is provided, the name of the output type or function will be used.\n\n#### description\n\n```python\ndescription: str | None = description\n\n```\n\nThe description of the structured output that will be passed to the model. If not specified and only one output is provided, the docstring of the output type or function will be used.\n\n#### strict\n\n```python\nstrict: bool | None = strict\n\n```\n\nWhether to use strict mode for the output, if the model supports it.\n\n### PromptedOutput\n\nBases: `Generic[OutputDataT]`\n\nMarker class to use a prompt to tell the model what to output and optionally customize the prompt.\n\nExample: prompted_output.py\n\n```python\nfrom pydantic import BaseModel\n\nfrom pydantic_ai import Agent, PromptedOutput\n\nfrom tool_output import Vehicle\n\n\nclass Device(BaseModel):\n    name: str\n    kind: str\n\n\nagent = Agent(\n    'openai:gpt-4o',\n    output_type=PromptedOutput(\n        [Vehicle, Device],\n        name='Vehicle or device',\n        description='Return a vehicle or device.'\n    ),\n)\nresult = agent.run_sync('What is a MacBook?')\nprint(repr(result.output))\n#> Device(name='MacBook', kind='laptop')\n\nagent = Agent(\n    'openai:gpt-4o',\n    output_type=PromptedOutput(\n        [Vehicle, Device],\n        template='Gimme some JSON: {schema}'\n    ),\n)\nresult = agent.run_sync('What is a Ford Explorer?')\nprint(repr(result.output))\n#> Vehicle(name='Ford Explorer', wheels=4)\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/output.py`\n\n````python\n@dataclass(init=False)\nclass PromptedOutput(Generic[OutputDataT]):\n    \"\"\"Marker class to use a prompt to tell the model what to output and optionally customize the prompt.\n\n    Example:\n    ```python {title=\"prompted_output.py\" requires=\"tool_output.py\"}\n    from pydantic import BaseModel\n\n    from pydantic_ai import Agent, PromptedOutput\n\n    from tool_output import Vehicle\n\n\n    class Device(BaseModel):\n        name: str\n        kind: str\n\n\n    agent = Agent(\n        'openai:gpt-4o',\n        output_type=PromptedOutput(\n            [Vehicle, Device],\n            name='Vehicle or device',\n            description='Return a vehicle or device.'\n        ),\n    )\n    result = agent.run_sync('What is a MacBook?')\n    print(repr(result.output))\n    #> Device(name='MacBook', kind='laptop')\n\n    agent = Agent(\n        'openai:gpt-4o',\n        output_type=PromptedOutput(\n            [Vehicle, Device],\n            template='Gimme some JSON: {schema}'\n        ),\n    )\n    result = agent.run_sync('What is a Ford Explorer?')\n    print(repr(result.output))\n    #> Vehicle(name='Ford Explorer', wheels=4)\n    ```\n    \"\"\"\n\n    outputs: OutputTypeOrFunction[OutputDataT] | Sequence[OutputTypeOrFunction[OutputDataT]]\n    \"\"\"The output types or functions.\"\"\"\n    name: str | None\n    \"\"\"The name of the structured output that will be passed to the model. If not specified and only one output is provided, the name of the output type or function will be used.\"\"\"\n    description: str | None\n    \"\"\"The description that will be passed to the model. If not specified and only one output is provided, the docstring of the output type or function will be used.\"\"\"\n    template: str | None\n    \"\"\"Template for the prompt passed to the model.\n    The '{schema}' placeholder will be replaced with the output JSON schema.\n    If not specified, the default template specified on the model's profile will be used.\n    \"\"\"\n\n    def __init__(\n        self,\n        outputs: OutputTypeOrFunction[OutputDataT] | Sequence[OutputTypeOrFunction[OutputDataT]],\n        *,\n        name: str | None = None,\n        description: str | None = None,\n        template: str | None = None,\n    ):\n        self.outputs = outputs\n        self.name = name\n        self.description = description\n        self.template = template\n\n````\n\n#### outputs\n\n```python\noutputs: (\n    OutputTypeOrFunction[OutputDataT]\n    | Sequence[OutputTypeOrFunction[OutputDataT]]\n) = outputs\n\n```\n\nThe output types or functions.\n\n#### name\n\n```python\nname: str | None = name\n\n```\n\nThe name of the structured output that will be passed to the model. If not specified and only one output is provided, the name of the output type or function will be used.\n\n#### description\n\n```python\ndescription: str | None = description\n\n```\n\nThe description that will be passed to the model. If not specified and only one output is provided, the docstring of the output type or function will be used.\n\n#### template\n\n```python\ntemplate: str | None = template\n\n```\n\nTemplate for the prompt passed to the model. The '{schema}' placeholder will be replaced with the output JSON schema. If not specified, the default template specified on the model's profile will be used.\n\n### TextOutput\n\nBases: `Generic[OutputDataT]`\n\nMarker class to use text output for an output function taking a string argument.\n\nExample:\n\n```python\nfrom pydantic_ai import Agent, TextOutput\n\n\ndef split_into_words(text: str) -> list[str]:\n    return text.split()\n\n\nagent = Agent(\n    'openai:gpt-4o',\n    output_type=TextOutput(split_into_words),\n)\nresult = agent.run_sync('Who was Albert Einstein?')\nprint(result.output)\n#> ['Albert', 'Einstein', 'was', 'a', 'German-born', 'theoretical', 'physicist.']\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/output.py`\n\n````python\n@dataclass\nclass TextOutput(Generic[OutputDataT]):\n    \"\"\"Marker class to use text output for an output function taking a string argument.\n\n    Example:\n    ```python\n    from pydantic_ai import Agent, TextOutput\n\n\n    def split_into_words(text: str) -> list[str]:\n        return text.split()\n\n\n    agent = Agent(\n        'openai:gpt-4o',\n        output_type=TextOutput(split_into_words),\n    )\n    result = agent.run_sync('Who was Albert Einstein?')\n    print(result.output)\n    #> ['Albert', 'Einstein', 'was', 'a', 'German-born', 'theoretical', 'physicist.']\n    ```\n    \"\"\"\n\n    output_function: TextOutputFunc[OutputDataT]\n    \"\"\"The function that will be called to process the model's plain text output. The function must take a single string argument.\"\"\"\n\n````\n\n#### output_function\n\n```python\noutput_function: TextOutputFunc[OutputDataT]\n\n```\n\nThe function that will be called to process the model's plain text output. The function must take a single string argument.\n\n### StructuredDict\n\n```python\nStructuredDict(\n    json_schema: JsonSchemaValue,\n    name: str | None = None,\n    description: str | None = None,\n) -> type[JsonSchemaValue]\n\n```\n\nReturns a `dict[str, Any]` subclass with a JSON schema attached that will be used for structured output.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `json_schema` | `JsonSchemaValue` | A JSON schema of type object defining the structure of the dictionary content. | *required* | | `name` | `str | None` | Optional name of the structured output. If not provided, the title field of the JSON schema will be used if it's present. | `None` | | `description` | `str | None` | Optional description of the structured output. If not provided, the description field of the JSON schema will be used if it's present. | `None` |\n\nExample: structured_dict.py\n\n```python\nfrom pydantic_ai import Agent, StructuredDict\n\nschema = {\n    'type': 'object',\n    'properties': {\n        'name': {'type': 'string'},\n        'age': {'type': 'integer'}\n    },\n    'required': ['name', 'age']\n}\n\nagent = Agent('openai:gpt-4o', output_type=StructuredDict(schema))\nresult = agent.run_sync('Create a person')\nprint(result.output)\n#> {'name': 'John Doe', 'age': 30}\n\n```\n\nSource code in `pydantic_ai_slim/pydantic_ai/output.py`\n\n````python\ndef StructuredDict(\n    json_schema: JsonSchemaValue, name: str | None = None, description: str | None = None\n) -> type[JsonSchemaValue]:\n    \"\"\"Returns a `dict[str, Any]` subclass with a JSON schema attached that will be used for structured output.\n\n    Args:\n        json_schema: A JSON schema of type `object` defining the structure of the dictionary content.\n        name: Optional name of the structured output. If not provided, the `title` field of the JSON schema will be used if it's present.\n        description: Optional description of the structured output. If not provided, the `description` field of the JSON schema will be used if it's present.\n\n    Example:\n    ```python {title=\"structured_dict.py\"}\n    from pydantic_ai import Agent, StructuredDict\n\n    schema = {\n        'type': 'object',\n        'properties': {\n            'name': {'type': 'string'},\n            'age': {'type': 'integer'}\n        },\n        'required': ['name', 'age']\n    }\n\n    agent = Agent('openai:gpt-4o', output_type=StructuredDict(schema))\n    result = agent.run_sync('Create a person')\n    print(result.output)\n    #> {'name': 'John Doe', 'age': 30}\n    ```\n    \"\"\"\n    json_schema = _utils.check_object_json_schema(json_schema)\n\n    # Pydantic `TypeAdapter` fails when `object.__get_pydantic_json_schema__` has `$defs`, so we inline them\n    # See https://github.com/pydantic/pydantic/issues/12145\n    if '$defs' in json_schema:\n        json_schema = InlineDefsJsonSchemaTransformer(json_schema).walk()\n        if '$defs' in json_schema:\n            raise exceptions.UserError(\n                '`StructuredDict` does not currently support recursive `$ref`s and `$defs`. See https://github.com/pydantic/pydantic/issues/12145 for more information.'\n            )\n\n    if name:\n        json_schema['title'] = name\n\n    if description:\n        json_schema['description'] = description\n\n    class _StructuredDict(JsonSchemaValue):\n        __is_model_like__ = True\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls, source_type: Any, handler: GetCoreSchemaHandler\n        ) -> core_schema.CoreSchema:\n            return core_schema.dict_schema(\n                keys_schema=core_schema.str_schema(),\n                values_schema=core_schema.any_schema(),\n            )\n\n        @classmethod\n        def __get_pydantic_json_schema__(\n            cls, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n        ) -> JsonSchemaValue:\n            return json_schema\n\n    return _StructuredDict\n\n````\n\n### DeferredToolRequests\n\nTool calls that require approval or external execution.\n\nThis can be used as an agent's `output_type` and will be used as the output of the agent run if the model called any deferred tools.\n\nResults can be passed to the next agent run using a DeferredToolResults object with the same tool call IDs.\n\nSee [deferred tools docs](../../deferred-tools/#deferred-tools) for more information.\n\nSource code in `pydantic_ai_slim/pydantic_ai/tools.py`\n\n```python\n@dataclass(kw_only=True)\nclass DeferredToolRequests:\n    \"\"\"Tool calls that require approval or external execution.\n\n    This can be used as an agent's `output_type` and will be used as the output of the agent run if the model called any deferred tools.\n\n    Results can be passed to the next agent run using a [`DeferredToolResults`][pydantic_ai.tools.DeferredToolResults] object with the same tool call IDs.\n\n    See [deferred tools docs](../deferred-tools.md#deferred-tools) for more information.\n    \"\"\"\n\n    calls: list[ToolCallPart] = field(default_factory=list)\n    \"\"\"Tool calls that require external execution.\"\"\"\n    approvals: list[ToolCallPart] = field(default_factory=list)\n    \"\"\"Tool calls that require human-in-the-loop approval.\"\"\"\n    metadata: dict[str, dict[str, Any]] = field(default_factory=dict)\n    \"\"\"Metadata for deferred tool calls, keyed by `tool_call_id`.\"\"\"\n\n```\n\n#### calls\n\n```python\ncalls: list[ToolCallPart] = field(default_factory=list)\n\n```\n\nTool calls that require external execution.\n\n#### approvals\n\n```python\napprovals: list[ToolCallPart] = field(default_factory=list)\n\n```\n\nTool calls that require human-in-the-loop approval.\n\n#### metadata\n\n```python\nmetadata: dict[str, dict[str, Any]] = field(\n    default_factory=dict\n)\n\n```\n\nMetadata for deferred tool calls, keyed by `tool_call_id`.",
  "content_length": 18239
}