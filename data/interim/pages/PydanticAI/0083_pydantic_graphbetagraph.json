{
  "title": "`pydantic_graph.beta.graph`",
  "source_url": null,
  "content": "Core graph execution engine for the next version of the pydantic-graph library.\n\nThis module provides the main `Graph` class and `GraphRun` execution engine that handles the orchestration of nodes, edges, and parallel execution paths in the graph-based workflow system.\n\n### StateT\n\n```python\nStateT = TypeVar('StateT', infer_variance=True)\n\n```\n\nType variable for graph state.\n\n### DepsT\n\n```python\nDepsT = TypeVar('DepsT', infer_variance=True)\n\n```\n\nType variable for graph dependencies.\n\n### InputT\n\n```python\nInputT = TypeVar('InputT', infer_variance=True)\n\n```\n\nType variable for graph inputs.\n\n### OutputT\n\n```python\nOutputT = TypeVar('OutputT', infer_variance=True)\n\n```\n\nType variable for graph outputs.\n\n### EndMarker\n\nBases: `Generic[OutputT]`\n\nA marker indicating the end of graph execution with a final value.\n\nEndMarker is used internally to signal that the graph has completed execution and carries the final output value.\n\nType Parameters\n\nOutputT: The type of the final output value\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\n@dataclass(init=False)\nclass EndMarker(Generic[OutputT]):\n    \"\"\"A marker indicating the end of graph execution with a final value.\n\n    EndMarker is used internally to signal that the graph has completed\n    execution and carries the final output value.\n\n    Type Parameters:\n        OutputT: The type of the final output value\n    \"\"\"\n\n    _value: OutputT\n    \"\"\"The final output value from the graph execution.\"\"\"\n\n    def __init__(self, value: OutputT):\n        # This manually-defined initializer is necessary due to https://github.com/python/mypy/issues/17623.\n        self._value = value\n\n    @property\n    def value(self) -> OutputT:\n        return self._value\n\n```\n\n### JoinItem\n\nAn item representing data flowing into a join operation.\n\nJoinItem carries input data from a parallel execution path to a join node, along with metadata about which execution 'fork' it originated from.\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\n@dataclass\nclass JoinItem:\n    \"\"\"An item representing data flowing into a join operation.\n\n    JoinItem carries input data from a parallel execution path to a join\n    node, along with metadata about which execution 'fork' it originated from.\n    \"\"\"\n\n    join_id: JoinID\n    \"\"\"The ID of the join node this item is targeting.\"\"\"\n\n    inputs: Any\n    \"\"\"The input data for the join operation.\"\"\"\n\n    fork_stack: ForkStack\n    \"\"\"The stack of ForkStackItems that led to producing this join item.\"\"\"\n\n```\n\n#### join_id\n\n```python\njoin_id: JoinID\n\n```\n\nThe ID of the join node this item is targeting.\n\n#### inputs\n\n```python\ninputs: Any\n\n```\n\nThe input data for the join operation.\n\n#### fork_stack\n\n```python\nfork_stack: ForkStack\n\n```\n\nThe stack of ForkStackItems that led to producing this join item.\n\n### Graph\n\nBases: `Generic[StateT, DepsT, InputT, OutputT]`\n\nA complete graph definition ready for execution.\n\nThe Graph class represents a complete workflow graph with typed inputs, outputs, state, and dependencies. It contains all nodes, edges, and metadata needed for execution.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies InputT: The type of the input data OutputT: The type of the output data\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\n@dataclass(repr=False)\nclass Graph(Generic[StateT, DepsT, InputT, OutputT]):\n    \"\"\"A complete graph definition ready for execution.\n\n    The Graph class represents a complete workflow graph with typed inputs,\n    outputs, state, and dependencies. It contains all nodes, edges, and\n    metadata needed for execution.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        InputT: The type of the input data\n        OutputT: The type of the output data\n    \"\"\"\n\n    name: str | None\n    \"\"\"Optional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\"\"\"\n\n    state_type: type[StateT]\n    \"\"\"The type of the graph state.\"\"\"\n\n    deps_type: type[DepsT]\n    \"\"\"The type of the dependencies.\"\"\"\n\n    input_type: type[InputT]\n    \"\"\"The type of the input data.\"\"\"\n\n    output_type: type[OutputT]\n    \"\"\"The type of the output data.\"\"\"\n\n    auto_instrument: bool\n    \"\"\"Whether to automatically create instrumentation spans.\"\"\"\n\n    nodes: dict[NodeID, AnyNode]\n    \"\"\"All nodes in the graph indexed by their ID.\"\"\"\n\n    edges_by_source: dict[NodeID, list[Path]]\n    \"\"\"Outgoing paths from each source node.\"\"\"\n\n    parent_forks: dict[JoinID, ParentFork[NodeID]]\n    \"\"\"Parent fork information for each join node.\"\"\"\n\n    intermediate_join_nodes: dict[JoinID, set[JoinID]]\n    \"\"\"For each join, the set of other joins that appear between it and its parent fork.\n\n    Used to determine which joins are \"final\" (have no other joins as intermediates) and\n    which joins should preserve fork stacks when proceeding downstream.\"\"\"\n\n    def get_parent_fork(self, join_id: JoinID) -> ParentFork[NodeID]:\n        \"\"\"Get the parent fork information for a join node.\n\n        Args:\n            join_id: The ID of the join node\n\n        Returns:\n            The parent fork information for the join\n\n        Raises:\n            RuntimeError: If the join ID is not found or has no parent fork\n        \"\"\"\n        result = self.parent_forks.get(join_id)\n        if result is None:\n            raise RuntimeError(f'Node {join_id} is not a join node or did not have a dominating fork (this is a bug)')\n        return result\n\n    def is_final_join(self, join_id: JoinID) -> bool:\n        \"\"\"Check if a join is 'final' (has no downstream joins with the same parent fork).\n\n        A join is non-final if it appears as an intermediate node for another join\n        with the same parent fork.\n\n        Args:\n            join_id: The ID of the join node\n\n        Returns:\n            True if the join is final, False if it's non-final\n        \"\"\"\n        # Check if this join appears in any other join's intermediate_join_nodes\n        for intermediate_joins in self.intermediate_join_nodes.values():\n            if join_id in intermediate_joins:\n                return False\n        return True\n\n    async def run(\n        self,\n        *,\n        state: StateT = None,\n        deps: DepsT = None,\n        inputs: InputT = None,\n        span: AbstractContextManager[AbstractSpan] | None = None,\n        infer_name: bool = True,\n    ) -> OutputT:\n        \"\"\"Execute the graph and return the final output.\n\n        This is the main entry point for graph execution. It runs the graph\n        to completion and returns the final output value.\n\n        Args:\n            state: The graph state instance\n            deps: The dependencies instance\n            inputs: The input data for the graph\n            span: Optional span for tracing/instrumentation\n            infer_name: Whether to infer the graph name from the calling frame.\n\n        Returns:\n            The final output from the graph execution\n        \"\"\"\n        if infer_name and self.name is None:\n            inferred_name = infer_obj_name(self, depth=2)\n            if inferred_name is not None:  # pragma: no branch\n                self.name = inferred_name\n\n        async with self.iter(state=state, deps=deps, inputs=inputs, span=span, infer_name=False) as graph_run:\n            # Note: This would probably be better using `async for _ in graph_run`, but this tests the `next` method,\n            # which I'm less confident will be implemented correctly if not used on the critical path. We can change it\n            # once we have tests, etc.\n            event: Any = None\n            while True:\n                try:\n                    event = await graph_run.next(event)\n                except StopAsyncIteration:\n                    assert isinstance(event, EndMarker), 'Graph run should end with an EndMarker.'\n                    return cast(EndMarker[OutputT], event).value\n\n    @asynccontextmanager\n    async def iter(\n        self,\n        *,\n        state: StateT = None,\n        deps: DepsT = None,\n        inputs: InputT = None,\n        span: AbstractContextManager[AbstractSpan] | None = None,\n        infer_name: bool = True,\n    ) -> AsyncIterator[GraphRun[StateT, DepsT, OutputT]]:\n        \"\"\"Create an iterator for step-by-step graph execution.\n\n        This method allows for more fine-grained control over graph execution,\n        enabling inspection of intermediate states and results.\n\n        Args:\n            state: The graph state instance\n            deps: The dependencies instance\n            inputs: The input data for the graph\n            span: Optional span for tracing/instrumentation\n            infer_name: Whether to infer the graph name from the calling frame.\n\n        Yields:\n            A GraphRun instance that can be iterated for step-by-step execution\n        \"\"\"\n        if infer_name and self.name is None:\n            inferred_name = infer_obj_name(self, depth=3)  # depth=3 because asynccontextmanager adds one\n            if inferred_name is not None:  # pragma: no branch\n                self.name = inferred_name\n\n        with ExitStack() as stack:\n            entered_span: AbstractSpan | None = None\n            if span is None:\n                if self.auto_instrument:\n                    entered_span = stack.enter_context(logfire_span('run graph {graph.name}', graph=self))\n            else:\n                entered_span = stack.enter_context(span)\n            traceparent = None if entered_span is None else get_traceparent(entered_span)\n            async with GraphRun[StateT, DepsT, OutputT](\n                graph=self,\n                state=state,\n                deps=deps,\n                inputs=inputs,\n                traceparent=traceparent,\n            ) as graph_run:\n                yield graph_run\n\n    def render(self, *, title: str | None = None, direction: StateDiagramDirection | None = None) -> str:\n        \"\"\"Render the graph as a Mermaid diagram string.\n\n        Args:\n            title: Optional title for the diagram\n            direction: Optional direction for the diagram layout\n\n        Returns:\n            A string containing the Mermaid diagram representation\n        \"\"\"\n        from pydantic_graph.beta.mermaid import build_mermaid_graph\n\n        return build_mermaid_graph(self.nodes, self.edges_by_source).render(title=title, direction=direction)\n\n    def __repr__(self) -> str:\n        super_repr = super().__repr__()  # include class and memory address\n        # Insert the result of calling `__str__` before the final '>' in the repr\n        return f'{super_repr[:-1]}\\n{self}\\n{super_repr[-1]}'\n\n    def __str__(self) -> str:\n        \"\"\"Return a Mermaid diagram representation of the graph.\n\n        Returns:\n            A string containing the Mermaid diagram of the graph\n        \"\"\"\n        return self.render()\n\n```\n\n#### name\n\n```python\nname: str | None\n\n```\n\nOptional name for the graph, if not provided the name will be inferred from the calling frame on the first call to a graph method.\n\n#### state_type\n\n```python\nstate_type: type[StateT]\n\n```\n\nThe type of the graph state.\n\n#### deps_type\n\n```python\ndeps_type: type[DepsT]\n\n```\n\nThe type of the dependencies.\n\n#### input_type\n\n```python\ninput_type: type[InputT]\n\n```\n\nThe type of the input data.\n\n#### output_type\n\n```python\noutput_type: type[OutputT]\n\n```\n\nThe type of the output data.\n\n#### auto_instrument\n\n```python\nauto_instrument: bool\n\n```\n\nWhether to automatically create instrumentation spans.\n\n#### nodes\n\n```python\nnodes: dict[NodeID, AnyNode]\n\n```\n\nAll nodes in the graph indexed by their ID.\n\n#### edges_by_source\n\n```python\nedges_by_source: dict[NodeID, list[Path]]\n\n```\n\nOutgoing paths from each source node.\n\n#### parent_forks\n\n```python\nparent_forks: dict[JoinID, ParentFork[NodeID]]\n\n```\n\nParent fork information for each join node.\n\n#### intermediate_join_nodes\n\n```python\nintermediate_join_nodes: dict[JoinID, set[JoinID]]\n\n```\n\nFor each join, the set of other joins that appear between it and its parent fork.\n\nUsed to determine which joins are \"final\" (have no other joins as intermediates) and which joins should preserve fork stacks when proceeding downstream.\n\n#### get_parent_fork\n\n```python\nget_parent_fork(join_id: JoinID) -> ParentFork[NodeID]\n\n```\n\nGet the parent fork information for a join node.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `join_id` | `JoinID` | The ID of the join node | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `ParentFork[NodeID]` | The parent fork information for the join |\n\nRaises:\n\n| Type | Description | | --- | --- | | `RuntimeError` | If the join ID is not found or has no parent fork |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef get_parent_fork(self, join_id: JoinID) -> ParentFork[NodeID]:\n    \"\"\"Get the parent fork information for a join node.\n\n    Args:\n        join_id: The ID of the join node\n\n    Returns:\n        The parent fork information for the join\n\n    Raises:\n        RuntimeError: If the join ID is not found or has no parent fork\n    \"\"\"\n    result = self.parent_forks.get(join_id)\n    if result is None:\n        raise RuntimeError(f'Node {join_id} is not a join node or did not have a dominating fork (this is a bug)')\n    return result\n\n```\n\n#### is_final_join\n\n```python\nis_final_join(join_id: JoinID) -> bool\n\n```\n\nCheck if a join is 'final' (has no downstream joins with the same parent fork).\n\nA join is non-final if it appears as an intermediate node for another join with the same parent fork.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `join_id` | `JoinID` | The ID of the join node | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `bool` | True if the join is final, False if it's non-final |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef is_final_join(self, join_id: JoinID) -> bool:\n    \"\"\"Check if a join is 'final' (has no downstream joins with the same parent fork).\n\n    A join is non-final if it appears as an intermediate node for another join\n    with the same parent fork.\n\n    Args:\n        join_id: The ID of the join node\n\n    Returns:\n        True if the join is final, False if it's non-final\n    \"\"\"\n    # Check if this join appears in any other join's intermediate_join_nodes\n    for intermediate_joins in self.intermediate_join_nodes.values():\n        if join_id in intermediate_joins:\n            return False\n    return True\n\n```\n\n#### run\n\n```python\nrun(\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    inputs: InputT = None,\n    span: (\n        AbstractContextManager[AbstractSpan] | None\n    ) = None,\n    infer_name: bool = True\n) -> OutputT\n\n```\n\nExecute the graph and return the final output.\n\nThis is the main entry point for graph execution. It runs the graph to completion and returns the final output value.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `state` | `StateT` | The graph state instance | `None` | | `deps` | `DepsT` | The dependencies instance | `None` | | `inputs` | `InputT` | The input data for the graph | `None` | | `span` | `AbstractContextManager[AbstractSpan] | None` | Optional span for tracing/instrumentation | `None` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `OutputT` | The final output from the graph execution |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\nasync def run(\n    self,\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    inputs: InputT = None,\n    span: AbstractContextManager[AbstractSpan] | None = None,\n    infer_name: bool = True,\n) -> OutputT:\n    \"\"\"Execute the graph and return the final output.\n\n    This is the main entry point for graph execution. It runs the graph\n    to completion and returns the final output value.\n\n    Args:\n        state: The graph state instance\n        deps: The dependencies instance\n        inputs: The input data for the graph\n        span: Optional span for tracing/instrumentation\n        infer_name: Whether to infer the graph name from the calling frame.\n\n    Returns:\n        The final output from the graph execution\n    \"\"\"\n    if infer_name and self.name is None:\n        inferred_name = infer_obj_name(self, depth=2)\n        if inferred_name is not None:  # pragma: no branch\n            self.name = inferred_name\n\n    async with self.iter(state=state, deps=deps, inputs=inputs, span=span, infer_name=False) as graph_run:\n        # Note: This would probably be better using `async for _ in graph_run`, but this tests the `next` method,\n        # which I'm less confident will be implemented correctly if not used on the critical path. We can change it\n        # once we have tests, etc.\n        event: Any = None\n        while True:\n            try:\n                event = await graph_run.next(event)\n            except StopAsyncIteration:\n                assert isinstance(event, EndMarker), 'Graph run should end with an EndMarker.'\n                return cast(EndMarker[OutputT], event).value\n\n```\n\n#### iter\n\n```python\niter(\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    inputs: InputT = None,\n    span: (\n        AbstractContextManager[AbstractSpan] | None\n    ) = None,\n    infer_name: bool = True\n) -> AsyncIterator[GraphRun[StateT, DepsT, OutputT]]\n\n```\n\nCreate an iterator for step-by-step graph execution.\n\nThis method allows for more fine-grained control over graph execution, enabling inspection of intermediate states and results.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `state` | `StateT` | The graph state instance | `None` | | `deps` | `DepsT` | The dependencies instance | `None` | | `inputs` | `InputT` | The input data for the graph | `None` | | `span` | `AbstractContextManager[AbstractSpan] | None` | Optional span for tracing/instrumentation | `None` | | `infer_name` | `bool` | Whether to infer the graph name from the calling frame. | `True` |\n\nYields:\n\n| Type | Description | | --- | --- | | `AsyncIterator[GraphRun[StateT, DepsT, OutputT]]` | A GraphRun instance that can be iterated for step-by-step execution |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\n@asynccontextmanager\nasync def iter(\n    self,\n    *,\n    state: StateT = None,\n    deps: DepsT = None,\n    inputs: InputT = None,\n    span: AbstractContextManager[AbstractSpan] | None = None,\n    infer_name: bool = True,\n) -> AsyncIterator[GraphRun[StateT, DepsT, OutputT]]:\n    \"\"\"Create an iterator for step-by-step graph execution.\n\n    This method allows for more fine-grained control over graph execution,\n    enabling inspection of intermediate states and results.\n\n    Args:\n        state: The graph state instance\n        deps: The dependencies instance\n        inputs: The input data for the graph\n        span: Optional span for tracing/instrumentation\n        infer_name: Whether to infer the graph name from the calling frame.\n\n    Yields:\n        A GraphRun instance that can be iterated for step-by-step execution\n    \"\"\"\n    if infer_name and self.name is None:\n        inferred_name = infer_obj_name(self, depth=3)  # depth=3 because asynccontextmanager adds one\n        if inferred_name is not None:  # pragma: no branch\n            self.name = inferred_name\n\n    with ExitStack() as stack:\n        entered_span: AbstractSpan | None = None\n        if span is None:\n            if self.auto_instrument:\n                entered_span = stack.enter_context(logfire_span('run graph {graph.name}', graph=self))\n        else:\n            entered_span = stack.enter_context(span)\n        traceparent = None if entered_span is None else get_traceparent(entered_span)\n        async with GraphRun[StateT, DepsT, OutputT](\n            graph=self,\n            state=state,\n            deps=deps,\n            inputs=inputs,\n            traceparent=traceparent,\n        ) as graph_run:\n            yield graph_run\n\n```\n\n#### render\n\n```python\nrender(\n    *,\n    title: str | None = None,\n    direction: StateDiagramDirection | None = None\n) -> str\n\n```\n\nRender the graph as a Mermaid diagram string.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `title` | `str | None` | Optional title for the diagram | `None` | | `direction` | `StateDiagramDirection | None` | Optional direction for the diagram layout | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `str` | A string containing the Mermaid diagram representation |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef render(self, *, title: str | None = None, direction: StateDiagramDirection | None = None) -> str:\n    \"\"\"Render the graph as a Mermaid diagram string.\n\n    Args:\n        title: Optional title for the diagram\n        direction: Optional direction for the diagram layout\n\n    Returns:\n        A string containing the Mermaid diagram representation\n    \"\"\"\n    from pydantic_graph.beta.mermaid import build_mermaid_graph\n\n    return build_mermaid_graph(self.nodes, self.edges_by_source).render(title=title, direction=direction)\n\n```\n\n#### __str__\n\n```python\n__str__() -> str\n\n```\n\nReturn a Mermaid diagram representation of the graph.\n\nReturns:\n\n| Type | Description | | --- | --- | | `str` | A string containing the Mermaid diagram of the graph |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef __str__(self) -> str:\n    \"\"\"Return a Mermaid diagram representation of the graph.\n\n    Returns:\n        A string containing the Mermaid diagram of the graph\n    \"\"\"\n    return self.render()\n\n```\n\n### GraphTaskRequest\n\nA request to run a task representing the execution of a node in the graph.\n\nGraphTaskRequest encapsulates all the information needed to execute a specific node, including its inputs and the fork context it's executing within.\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\n@dataclass\nclass GraphTaskRequest:\n    \"\"\"A request to run a task representing the execution of a node in the graph.\n\n    GraphTaskRequest encapsulates all the information needed to execute a specific\n    node, including its inputs and the fork context it's executing within.\n    \"\"\"\n\n    node_id: NodeID\n    \"\"\"The ID of the node to execute.\"\"\"\n\n    inputs: Any\n    \"\"\"The input data for the node.\"\"\"\n\n    fork_stack: ForkStack = field(repr=False)\n    \"\"\"Stack of forks that have been entered.\n\n    Used by the GraphRun to decide when to proceed through joins.\n    \"\"\"\n\n```\n\n#### node_id\n\n```python\nnode_id: NodeID\n\n```\n\nThe ID of the node to execute.\n\n#### inputs\n\n```python\ninputs: Any\n\n```\n\nThe input data for the node.\n\n#### fork_stack\n\n```python\nfork_stack: ForkStack = field(repr=False)\n\n```\n\nStack of forks that have been entered.\n\nUsed by the GraphRun to decide when to proceed through joins.\n\n### GraphTask\n\nBases: `GraphTaskRequest`\n\nA task representing the execution of a node in the graph.\n\nGraphTask encapsulates all the information needed to execute a specific node, including its inputs and the fork context it's executing within, and has a unique ID to identify the task within the graph run.\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\n@dataclass\nclass GraphTask(GraphTaskRequest):\n    \"\"\"A task representing the execution of a node in the graph.\n\n    GraphTask encapsulates all the information needed to execute a specific\n    node, including its inputs and the fork context it's executing within,\n    and has a unique ID to identify the task within the graph run.\n    \"\"\"\n\n    task_id: TaskID = field(repr=False)\n    \"\"\"Unique identifier for this task.\"\"\"\n\n    @staticmethod\n    def from_request(request: GraphTaskRequest, get_task_id: Callable[[], TaskID]) -> GraphTask:\n        # Don't call the get_task_id callable, this is already a task\n        if isinstance(request, GraphTask):\n            return request\n        return GraphTask(request.node_id, request.inputs, request.fork_stack, get_task_id())\n\n```\n\n#### task_id\n\n```python\ntask_id: TaskID = field(repr=False)\n\n```\n\nUnique identifier for this task.\n\n### GraphRun\n\nBases: `Generic[StateT, DepsT, OutputT]`\n\nA single execution instance of a graph.\n\nGraphRun manages the execution state for a single run of a graph, including task scheduling, fork/join coordination, and result tracking.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies OutputT: The type of the output data\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\nclass GraphRun(Generic[StateT, DepsT, OutputT]):\n    \"\"\"A single execution instance of a graph.\n\n    GraphRun manages the execution state for a single run of a graph,\n    including task scheduling, fork/join coordination, and result tracking.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        OutputT: The type of the output data\n    \"\"\"\n\n    def __init__(\n        self,\n        graph: Graph[StateT, DepsT, InputT, OutputT],\n        *,\n        state: StateT,\n        deps: DepsT,\n        inputs: InputT,\n        traceparent: str | None,\n    ):\n        \"\"\"Initialize a graph run.\n\n        Args:\n            graph: The graph to execute\n            state: The graph state instance\n            deps: The dependencies instance\n            inputs: The input data for the graph\n            traceparent: Optional trace parent for instrumentation\n        \"\"\"\n        self.graph = graph\n        \"\"\"The graph being executed.\"\"\"\n\n        self.state = state\n        \"\"\"The graph state instance.\"\"\"\n\n        self.deps = deps\n        \"\"\"The dependencies instance.\"\"\"\n\n        self.inputs = inputs\n        \"\"\"The initial input data.\"\"\"\n\n        self._active_reducers: dict[tuple[JoinID, NodeRunID], JoinState] = {}\n        \"\"\"Active reducers for join operations.\"\"\"\n\n        self._next: EndMarker[OutputT] | Sequence[GraphTask] | None = None\n        \"\"\"The next item to be processed.\"\"\"\n\n        self._next_task_id = 0\n        self._next_node_run_id = 0\n        initial_fork_stack: ForkStack = (ForkStackItem(StartNode.id, self._get_next_node_run_id(), 0),)\n        self._first_task = GraphTask(\n            node_id=StartNode.id, inputs=inputs, fork_stack=initial_fork_stack, task_id=self._get_next_task_id()\n        )\n        self._iterator_task_group = create_task_group()\n        self._iterator_instance = _GraphIterator[StateT, DepsT, OutputT](\n            self.graph,\n            self.state,\n            self.deps,\n            self._iterator_task_group,\n            self._get_next_node_run_id,\n            self._get_next_task_id,\n        )\n        self._iterator = self._iterator_instance.iter_graph(self._first_task)\n\n        self.__traceparent = traceparent\n        self._async_exit_stack = AsyncExitStack()\n\n    async def __aenter__(self):\n        self._async_exit_stack.enter_context(_unwrap_exception_groups())\n        await self._async_exit_stack.enter_async_context(self._iterator_task_group)\n        await self._async_exit_stack.enter_async_context(self._iterator_context())\n        return self\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any):\n        await self._async_exit_stack.__aexit__(exc_type, exc_val, exc_tb)\n\n    @asynccontextmanager\n    async def _iterator_context(self):\n        try:\n            yield\n        finally:\n            self._iterator_instance.iter_stream_sender.close()\n            self._iterator_instance.iter_stream_receiver.close()\n            await self._iterator.aclose()\n\n    @overload\n    def _traceparent(self, *, required: Literal[False]) -> str | None: ...\n    @overload\n    def _traceparent(self) -> str: ...\n    def _traceparent(self, *, required: bool = True) -> str | None:\n        \"\"\"Get the trace parent for instrumentation.\n\n        Args:\n            required: Whether to raise an error if no traceparent exists\n\n        Returns:\n            The traceparent string, or None if not required and not set\n\n        Raises:\n            GraphRuntimeError: If required is True and no traceparent exists\n        \"\"\"\n        if self.__traceparent is None and required:  # pragma: no cover\n            raise exceptions.GraphRuntimeError('No span was created for this graph run')\n        return self.__traceparent\n\n    def __aiter__(self) -> AsyncIterator[EndMarker[OutputT] | Sequence[GraphTask]]:\n        \"\"\"Return self as an async iterator.\n\n        Returns:\n            Self for async iteration\n        \"\"\"\n        return self\n\n    async def __anext__(self) -> EndMarker[OutputT] | Sequence[GraphTask]:\n        \"\"\"Get the next item in the async iteration.\n\n        Returns:\n            The next execution result from the graph\n        \"\"\"\n        if self._next is None:\n            self._next = await anext(self._iterator)\n        else:\n            self._next = await self._iterator.asend(self._next)\n        return self._next\n\n    async def next(\n        self, value: EndMarker[OutputT] | Sequence[GraphTaskRequest] | None = None\n    ) -> EndMarker[OutputT] | Sequence[GraphTask]:\n        \"\"\"Advance the graph execution by one step.\n\n        This method allows for sending a value to the iterator, which is useful\n        for resuming iteration or overriding intermediate results.\n\n        Args:\n            value: Optional value to send to the iterator\n\n        Returns:\n            The next execution result: either an EndMarker, or sequence of GraphTasks\n        \"\"\"\n        if self._next is None:\n            # Prevent `TypeError: can't send non-None value to a just-started async generator`\n            # if `next` is called before the `first_node` has run.\n            await anext(self)\n        if value is not None:\n            if isinstance(value, EndMarker):\n                self._next = value\n            else:\n                self._next = [GraphTask.from_request(gtr, self._get_next_task_id) for gtr in value]\n        return await anext(self)\n\n    @property\n    def next_task(self) -> EndMarker[OutputT] | Sequence[GraphTask]:\n        \"\"\"Get the next task(s) to be executed.\n\n        Returns:\n            The next execution item, or the initial task if none is set\n        \"\"\"\n        return self._next or [self._first_task]\n\n    @property\n    def output(self) -> OutputT | None:\n        \"\"\"Get the final output if the graph has completed.\n\n        Returns:\n            The output value if execution is complete, None otherwise\n        \"\"\"\n        if isinstance(self._next, EndMarker):\n            return self._next.value\n        return None\n\n    def _get_next_task_id(self) -> TaskID:\n        next_id = TaskID(f'task:{self._next_task_id}')\n        self._next_task_id += 1\n        return next_id\n\n    def _get_next_node_run_id(self) -> NodeRunID:\n        next_id = NodeRunID(f'task:{self._next_node_run_id}')\n        self._next_node_run_id += 1\n        return next_id\n\n```\n\n#### __init__\n\n```python\n__init__(\n    graph: Graph[StateT, DepsT, InputT, OutputT],\n    *,\n    state: StateT,\n    deps: DepsT,\n    inputs: InputT,\n    traceparent: str | None\n)\n\n```\n\nInitialize a graph run.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `graph` | `Graph[StateT, DepsT, InputT, OutputT]` | The graph to execute | *required* | | `state` | `StateT` | The graph state instance | *required* | | `deps` | `DepsT` | The dependencies instance | *required* | | `inputs` | `InputT` | The input data for the graph | *required* | | `traceparent` | `str | None` | Optional trace parent for instrumentation | *required* |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef __init__(\n    self,\n    graph: Graph[StateT, DepsT, InputT, OutputT],\n    *,\n    state: StateT,\n    deps: DepsT,\n    inputs: InputT,\n    traceparent: str | None,\n):\n    \"\"\"Initialize a graph run.\n\n    Args:\n        graph: The graph to execute\n        state: The graph state instance\n        deps: The dependencies instance\n        inputs: The input data for the graph\n        traceparent: Optional trace parent for instrumentation\n    \"\"\"\n    self.graph = graph\n    \"\"\"The graph being executed.\"\"\"\n\n    self.state = state\n    \"\"\"The graph state instance.\"\"\"\n\n    self.deps = deps\n    \"\"\"The dependencies instance.\"\"\"\n\n    self.inputs = inputs\n    \"\"\"The initial input data.\"\"\"\n\n    self._active_reducers: dict[tuple[JoinID, NodeRunID], JoinState] = {}\n    \"\"\"Active reducers for join operations.\"\"\"\n\n    self._next: EndMarker[OutputT] | Sequence[GraphTask] | None = None\n    \"\"\"The next item to be processed.\"\"\"\n\n    self._next_task_id = 0\n    self._next_node_run_id = 0\n    initial_fork_stack: ForkStack = (ForkStackItem(StartNode.id, self._get_next_node_run_id(), 0),)\n    self._first_task = GraphTask(\n        node_id=StartNode.id, inputs=inputs, fork_stack=initial_fork_stack, task_id=self._get_next_task_id()\n    )\n    self._iterator_task_group = create_task_group()\n    self._iterator_instance = _GraphIterator[StateT, DepsT, OutputT](\n        self.graph,\n        self.state,\n        self.deps,\n        self._iterator_task_group,\n        self._get_next_node_run_id,\n        self._get_next_task_id,\n    )\n    self._iterator = self._iterator_instance.iter_graph(self._first_task)\n\n    self.__traceparent = traceparent\n    self._async_exit_stack = AsyncExitStack()\n\n```\n\n#### graph\n\n```python\ngraph = graph\n\n```\n\nThe graph being executed.\n\n#### state\n\n```python\nstate = state\n\n```\n\nThe graph state instance.\n\n#### deps\n\n```python\ndeps = deps\n\n```\n\nThe dependencies instance.\n\n#### inputs\n\n```python\ninputs = inputs\n\n```\n\nThe initial input data.\n\n#### __aiter__\n\n```python\n__aiter__() -> (\n    AsyncIterator[EndMarker[OutputT] | Sequence[GraphTask]]\n)\n\n```\n\nReturn self as an async iterator.\n\nReturns:\n\n| Type | Description | | --- | --- | | `AsyncIterator[EndMarker[OutputT] | Sequence[GraphTask]]` | Self for async iteration |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\ndef __aiter__(self) -> AsyncIterator[EndMarker[OutputT] | Sequence[GraphTask]]:\n    \"\"\"Return self as an async iterator.\n\n    Returns:\n        Self for async iteration\n    \"\"\"\n    return self\n\n```\n\n#### __anext__\n\n```python\n__anext__() -> EndMarker[OutputT] | Sequence[GraphTask]\n\n```\n\nGet the next item in the async iteration.\n\nReturns:\n\n| Type | Description | | --- | --- | | `EndMarker[OutputT] | Sequence[GraphTask]` | The next execution result from the graph |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\nasync def __anext__(self) -> EndMarker[OutputT] | Sequence[GraphTask]:\n    \"\"\"Get the next item in the async iteration.\n\n    Returns:\n        The next execution result from the graph\n    \"\"\"\n    if self._next is None:\n        self._next = await anext(self._iterator)\n    else:\n        self._next = await self._iterator.asend(self._next)\n    return self._next\n\n```\n\n#### next\n\n```python\nnext(\n    value: (\n        EndMarker[OutputT]\n        | Sequence[GraphTaskRequest]\n        | None\n    ) = None,\n) -> EndMarker[OutputT] | Sequence[GraphTask]\n\n```\n\nAdvance the graph execution by one step.\n\nThis method allows for sending a value to the iterator, which is useful for resuming iteration or overriding intermediate results.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `value` | `EndMarker[OutputT] | Sequence[GraphTaskRequest] | None` | Optional value to send to the iterator | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `EndMarker[OutputT] | Sequence[GraphTask]` | The next execution result: either an EndMarker, or sequence of GraphTasks |\n\nSource code in `pydantic_graph/pydantic_graph/beta/graph.py`\n\n```python\nasync def next(\n    self, value: EndMarker[OutputT] | Sequence[GraphTaskRequest] | None = None\n) -> EndMarker[OutputT] | Sequence[GraphTask]:\n    \"\"\"Advance the graph execution by one step.\n\n    This method allows for sending a value to the iterator, which is useful\n    for resuming iteration or overriding intermediate results.\n\n    Args:\n        value: Optional value to send to the iterator\n\n    Returns:\n        The next execution result: either an EndMarker, or sequence of GraphTasks\n    \"\"\"\n    if self._next is None:\n        # Prevent `TypeError: can't send non-None value to a just-started async generator`\n        # if `next` is called before the `first_node` has run.\n        await anext(self)\n    if value is not None:\n        if isinstance(value, EndMarker):\n            self._next = value\n        else:\n            self._next = [GraphTask.from_request(gtr, self._get_next_task_id) for gtr in value]\n    return await anext(self)\n\n```\n\n#### next_task\n\n```python\nnext_task: EndMarker[OutputT] | Sequence[GraphTask]\n\n```\n\nGet the next task(s) to be executed.\n\nReturns:\n\n| Type | Description | | --- | --- | | `EndMarker[OutputT] | Sequence[GraphTask]` | The next execution item, or the initial task if none is set |\n\n#### output\n\n```python\noutput: OutputT | None\n\n```\n\nGet the final output if the graph has completed.\n\nReturns:\n\n| Type | Description | | --- | --- | | `OutputT | None` | The output value if execution is complete, None otherwise |",
  "content_length": 37232
}