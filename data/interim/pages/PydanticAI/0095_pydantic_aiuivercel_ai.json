{
  "title": "`pydantic_ai.ui.vercel_ai`",
  "source_url": null,
  "content": "Vercel AI protocol adapter for Pydantic AI agents.\n\nThis module provides classes for integrating Pydantic AI agents with the Vercel AI protocol, enabling streaming event-based communication for interactive AI applications.\n\nConverted to Python from: https://github.com/vercel/ai/blob/ai%405.0.34/packages/ai/src/ui/ui-messages.ts\n\n### VercelAIAdapter\n\nBases: `UIAdapter[RequestData, UIMessage, BaseChunk, AgentDepsT, OutputDataT]`\n\nUI adapter for the Vercel AI protocol.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/_adapter.py`\n\n```python\n@dataclass\nclass VercelAIAdapter(UIAdapter[RequestData, UIMessage, BaseChunk, AgentDepsT, OutputDataT]):\n    \"\"\"UI adapter for the Vercel AI protocol.\"\"\"\n\n    @classmethod\n    def build_run_input(cls, body: bytes) -> RequestData:\n        \"\"\"Build a Vercel AI run input object from the request body.\"\"\"\n        return request_data_ta.validate_json(body)\n\n    def build_event_stream(self) -> UIEventStream[RequestData, BaseChunk, AgentDepsT, OutputDataT]:\n        \"\"\"Build a Vercel AI event stream transformer.\"\"\"\n        return VercelAIEventStream(self.run_input, accept=self.accept)\n\n    @cached_property\n    def messages(self) -> list[ModelMessage]:\n        \"\"\"Pydantic AI messages from the Vercel AI run input.\"\"\"\n        return self.load_messages(self.run_input.messages)\n\n    @classmethod\n    def load_messages(cls, messages: Sequence[UIMessage]) -> list[ModelMessage]:  # noqa: C901\n        \"\"\"Transform Vercel AI messages into Pydantic AI messages.\"\"\"\n        builder = MessagesBuilder()\n\n        for msg in messages:\n            if msg.role == 'system':\n                for part in msg.parts:\n                    if isinstance(part, TextUIPart):\n                        builder.add(SystemPromptPart(content=part.text))\n                    else:  # pragma: no cover\n                        raise ValueError(f'Unsupported system message part type: {type(part)}')\n            elif msg.role == 'user':\n                user_prompt_content: str | list[UserContent] = []\n                for part in msg.parts:\n                    if isinstance(part, TextUIPart):\n                        user_prompt_content.append(part.text)\n                    elif isinstance(part, FileUIPart):\n                        try:\n                            file = BinaryContent.from_data_uri(part.url)\n                        except ValueError:\n                            media_type_prefix = part.media_type.split('/', 1)[0]\n                            match media_type_prefix:\n                                case 'image':\n                                    file = ImageUrl(url=part.url, media_type=part.media_type)\n                                case 'video':\n                                    file = VideoUrl(url=part.url, media_type=part.media_type)\n                                case 'audio':\n                                    file = AudioUrl(url=part.url, media_type=part.media_type)\n                                case _:\n                                    file = DocumentUrl(url=part.url, media_type=part.media_type)\n                        user_prompt_content.append(file)\n                    else:  # pragma: no cover\n                        raise ValueError(f'Unsupported user message part type: {type(part)}')\n\n                if user_prompt_content:  # pragma: no branch\n                    if len(user_prompt_content) == 1 and isinstance(user_prompt_content[0], str):\n                        user_prompt_content = user_prompt_content[0]\n                    builder.add(UserPromptPart(content=user_prompt_content))\n\n            elif msg.role == 'assistant':\n                for part in msg.parts:\n                    if isinstance(part, TextUIPart):\n                        builder.add(TextPart(content=part.text))\n                    elif isinstance(part, ReasoningUIPart):\n                        builder.add(ThinkingPart(content=part.text))\n                    elif isinstance(part, FileUIPart):\n                        try:\n                            file = BinaryContent.from_data_uri(part.url)\n                        except ValueError as e:  # pragma: no cover\n                            # We don't yet handle non-data-URI file URLs returned by assistants, as no Pydantic AI models do this.\n                            raise ValueError(\n                                'Vercel AI integration can currently only handle assistant file parts with data URIs.'\n                            ) from e\n                        builder.add(FilePart(content=file))\n                    elif isinstance(part, ToolUIPart | DynamicToolUIPart):\n                        if isinstance(part, DynamicToolUIPart):\n                            tool_name = part.tool_name\n                            builtin_tool = False\n                        else:\n                            tool_name = part.type.removeprefix('tool-')\n                            builtin_tool = part.provider_executed\n\n                        tool_call_id = part.tool_call_id\n                        args = part.input\n\n                        if builtin_tool:\n                            call_part = BuiltinToolCallPart(tool_name=tool_name, tool_call_id=tool_call_id, args=args)\n                            builder.add(call_part)\n\n                            if isinstance(part, ToolOutputAvailablePart | ToolOutputErrorPart):\n                                if part.state == 'output-available':\n                                    output = part.output\n                                else:\n                                    output = {'error_text': part.error_text, 'is_error': True}\n\n                                provider_name = (\n                                    (part.call_provider_metadata or {}).get('pydantic_ai', {}).get('provider_name')\n                                )\n                                call_part.provider_name = provider_name\n\n                                builder.add(\n                                    BuiltinToolReturnPart(\n                                        tool_name=tool_name,\n                                        tool_call_id=tool_call_id,\n                                        content=output,\n                                        provider_name=provider_name,\n                                    )\n                                )\n                        else:\n                            builder.add(ToolCallPart(tool_name=tool_name, tool_call_id=tool_call_id, args=args))\n\n                            if part.state == 'output-available':\n                                builder.add(\n                                    ToolReturnPart(tool_name=tool_name, tool_call_id=tool_call_id, content=part.output)\n                                )\n                            elif part.state == 'output-error':\n                                builder.add(\n                                    RetryPromptPart(\n                                        tool_name=tool_name, tool_call_id=tool_call_id, content=part.error_text\n                                    )\n                                )\n                    elif isinstance(part, DataUIPart):  # pragma: no cover\n                        # Contains custom data that shouldn't be sent to the model\n                        pass\n                    elif isinstance(part, SourceUrlUIPart):  # pragma: no cover\n                        # TODO: Once we support citations: https://github.com/pydantic/pydantic-ai/issues/3126\n                        pass\n                    elif isinstance(part, SourceDocumentUIPart):  # pragma: no cover\n                        # TODO: Once we support citations: https://github.com/pydantic/pydantic-ai/issues/3126\n                        pass\n                    elif isinstance(part, StepStartUIPart):  # pragma: no cover\n                        # Nothing to do here\n                        pass\n                    else:\n                        assert_never(part)\n            else:\n                assert_never(msg.role)\n\n        return builder.messages\n\n```\n\n#### build_run_input\n\n```python\nbuild_run_input(body: bytes) -> RequestData\n\n```\n\nBuild a Vercel AI run input object from the request body.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/_adapter.py`\n\n```python\n@classmethod\ndef build_run_input(cls, body: bytes) -> RequestData:\n    \"\"\"Build a Vercel AI run input object from the request body.\"\"\"\n    return request_data_ta.validate_json(body)\n\n```\n\n#### build_event_stream\n\n```python\nbuild_event_stream() -> (\n    UIEventStream[\n        RequestData, BaseChunk, AgentDepsT, OutputDataT\n    ]\n)\n\n```\n\nBuild a Vercel AI event stream transformer.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/_adapter.py`\n\n```python\ndef build_event_stream(self) -> UIEventStream[RequestData, BaseChunk, AgentDepsT, OutputDataT]:\n    \"\"\"Build a Vercel AI event stream transformer.\"\"\"\n    return VercelAIEventStream(self.run_input, accept=self.accept)\n\n```\n\n#### messages\n\n```python\nmessages: list[ModelMessage]\n\n```\n\nPydantic AI messages from the Vercel AI run input.\n\n#### load_messages\n\n```python\nload_messages(\n    messages: Sequence[UIMessage],\n) -> list[ModelMessage]\n\n```\n\nTransform Vercel AI messages into Pydantic AI messages.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/_adapter.py`\n\n```python\n@classmethod\ndef load_messages(cls, messages: Sequence[UIMessage]) -> list[ModelMessage]:  # noqa: C901\n    \"\"\"Transform Vercel AI messages into Pydantic AI messages.\"\"\"\n    builder = MessagesBuilder()\n\n    for msg in messages:\n        if msg.role == 'system':\n            for part in msg.parts:\n                if isinstance(part, TextUIPart):\n                    builder.add(SystemPromptPart(content=part.text))\n                else:  # pragma: no cover\n                    raise ValueError(f'Unsupported system message part type: {type(part)}')\n        elif msg.role == 'user':\n            user_prompt_content: str | list[UserContent] = []\n            for part in msg.parts:\n                if isinstance(part, TextUIPart):\n                    user_prompt_content.append(part.text)\n                elif isinstance(part, FileUIPart):\n                    try:\n                        file = BinaryContent.from_data_uri(part.url)\n                    except ValueError:\n                        media_type_prefix = part.media_type.split('/', 1)[0]\n                        match media_type_prefix:\n                            case 'image':\n                                file = ImageUrl(url=part.url, media_type=part.media_type)\n                            case 'video':\n                                file = VideoUrl(url=part.url, media_type=part.media_type)\n                            case 'audio':\n                                file = AudioUrl(url=part.url, media_type=part.media_type)\n                            case _:\n                                file = DocumentUrl(url=part.url, media_type=part.media_type)\n                    user_prompt_content.append(file)\n                else:  # pragma: no cover\n                    raise ValueError(f'Unsupported user message part type: {type(part)}')\n\n            if user_prompt_content:  # pragma: no branch\n                if len(user_prompt_content) == 1 and isinstance(user_prompt_content[0], str):\n                    user_prompt_content = user_prompt_content[0]\n                builder.add(UserPromptPart(content=user_prompt_content))\n\n        elif msg.role == 'assistant':\n            for part in msg.parts:\n                if isinstance(part, TextUIPart):\n                    builder.add(TextPart(content=part.text))\n                elif isinstance(part, ReasoningUIPart):\n                    builder.add(ThinkingPart(content=part.text))\n                elif isinstance(part, FileUIPart):\n                    try:\n                        file = BinaryContent.from_data_uri(part.url)\n                    except ValueError as e:  # pragma: no cover\n                        # We don't yet handle non-data-URI file URLs returned by assistants, as no Pydantic AI models do this.\n                        raise ValueError(\n                            'Vercel AI integration can currently only handle assistant file parts with data URIs.'\n                        ) from e\n                    builder.add(FilePart(content=file))\n                elif isinstance(part, ToolUIPart | DynamicToolUIPart):\n                    if isinstance(part, DynamicToolUIPart):\n                        tool_name = part.tool_name\n                        builtin_tool = False\n                    else:\n                        tool_name = part.type.removeprefix('tool-')\n                        builtin_tool = part.provider_executed\n\n                    tool_call_id = part.tool_call_id\n                    args = part.input\n\n                    if builtin_tool:\n                        call_part = BuiltinToolCallPart(tool_name=tool_name, tool_call_id=tool_call_id, args=args)\n                        builder.add(call_part)\n\n                        if isinstance(part, ToolOutputAvailablePart | ToolOutputErrorPart):\n                            if part.state == 'output-available':\n                                output = part.output\n                            else:\n                                output = {'error_text': part.error_text, 'is_error': True}\n\n                            provider_name = (\n                                (part.call_provider_metadata or {}).get('pydantic_ai', {}).get('provider_name')\n                            )\n                            call_part.provider_name = provider_name\n\n                            builder.add(\n                                BuiltinToolReturnPart(\n                                    tool_name=tool_name,\n                                    tool_call_id=tool_call_id,\n                                    content=output,\n                                    provider_name=provider_name,\n                                )\n                            )\n                    else:\n                        builder.add(ToolCallPart(tool_name=tool_name, tool_call_id=tool_call_id, args=args))\n\n                        if part.state == 'output-available':\n                            builder.add(\n                                ToolReturnPart(tool_name=tool_name, tool_call_id=tool_call_id, content=part.output)\n                            )\n                        elif part.state == 'output-error':\n                            builder.add(\n                                RetryPromptPart(\n                                    tool_name=tool_name, tool_call_id=tool_call_id, content=part.error_text\n                                )\n                            )\n                elif isinstance(part, DataUIPart):  # pragma: no cover\n                    # Contains custom data that shouldn't be sent to the model\n                    pass\n                elif isinstance(part, SourceUrlUIPart):  # pragma: no cover\n                    # TODO: Once we support citations: https://github.com/pydantic/pydantic-ai/issues/3126\n                    pass\n                elif isinstance(part, SourceDocumentUIPart):  # pragma: no cover\n                    # TODO: Once we support citations: https://github.com/pydantic/pydantic-ai/issues/3126\n                    pass\n                elif isinstance(part, StepStartUIPart):  # pragma: no cover\n                    # Nothing to do here\n                    pass\n                else:\n                    assert_never(part)\n        else:\n            assert_never(msg.role)\n\n    return builder.messages\n\n```\n\n### VercelAIEventStream\n\nBases: `UIEventStream[RequestData, BaseChunk, AgentDepsT, OutputDataT]`\n\nUI event stream transformer for the Vercel AI protocol.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/_event_stream.py`\n\n```python\n@dataclass\nclass VercelAIEventStream(UIEventStream[RequestData, BaseChunk, AgentDepsT, OutputDataT]):\n    \"\"\"UI event stream transformer for the Vercel AI protocol.\"\"\"\n\n    _step_started: bool = False\n\n    @property\n    def response_headers(self) -> Mapping[str, str] | None:\n        return VERCEL_AI_DSP_HEADERS\n\n    def encode_event(self, event: BaseChunk) -> str:\n        return f'data: {event.encode()}\\n\\n'\n\n    async def before_stream(self) -> AsyncIterator[BaseChunk]:\n        yield StartChunk()\n\n    async def before_response(self) -> AsyncIterator[BaseChunk]:\n        if self._step_started:\n            yield FinishStepChunk()\n\n        self._step_started = True\n        yield StartStepChunk()\n\n    async def after_stream(self) -> AsyncIterator[BaseChunk]:\n        yield FinishStepChunk()\n\n        yield FinishChunk()\n        yield DoneChunk()\n\n    async def on_error(self, error: Exception) -> AsyncIterator[BaseChunk]:\n        yield ErrorChunk(error_text=str(error))\n\n    async def handle_text_start(self, part: TextPart, follows_text: bool = False) -> AsyncIterator[BaseChunk]:\n        if follows_text:\n            message_id = self.message_id\n        else:\n            message_id = self.new_message_id()\n            yield TextStartChunk(id=message_id)\n\n        if part.content:\n            yield TextDeltaChunk(id=message_id, delta=part.content)\n\n    async def handle_text_delta(self, delta: TextPartDelta) -> AsyncIterator[BaseChunk]:\n        if delta.content_delta:  # pragma: no branch\n            yield TextDeltaChunk(id=self.message_id, delta=delta.content_delta)\n\n    async def handle_text_end(self, part: TextPart, followed_by_text: bool = False) -> AsyncIterator[BaseChunk]:\n        if not followed_by_text:\n            yield TextEndChunk(id=self.message_id)\n\n    async def handle_thinking_start(\n        self, part: ThinkingPart, follows_thinking: bool = False\n    ) -> AsyncIterator[BaseChunk]:\n        message_id = self.new_message_id()\n        yield ReasoningStartChunk(id=message_id)\n        if part.content:\n            yield ReasoningDeltaChunk(id=message_id, delta=part.content)\n\n    async def handle_thinking_delta(self, delta: ThinkingPartDelta) -> AsyncIterator[BaseChunk]:\n        if delta.content_delta:  # pragma: no branch\n            yield ReasoningDeltaChunk(id=self.message_id, delta=delta.content_delta)\n\n    async def handle_thinking_end(\n        self, part: ThinkingPart, followed_by_thinking: bool = False\n    ) -> AsyncIterator[BaseChunk]:\n        yield ReasoningEndChunk(id=self.message_id)\n\n    def handle_tool_call_start(self, part: ToolCallPart | BuiltinToolCallPart) -> AsyncIterator[BaseChunk]:\n        return self._handle_tool_call_start(part)\n\n    def handle_builtin_tool_call_start(self, part: BuiltinToolCallPart) -> AsyncIterator[BaseChunk]:\n        return self._handle_tool_call_start(part, provider_executed=True)\n\n    async def _handle_tool_call_start(\n        self,\n        part: ToolCallPart | BuiltinToolCallPart,\n        tool_call_id: str | None = None,\n        provider_executed: bool | None = None,\n    ) -> AsyncIterator[BaseChunk]:\n        tool_call_id = tool_call_id or part.tool_call_id\n        yield ToolInputStartChunk(\n            tool_call_id=tool_call_id,\n            tool_name=part.tool_name,\n            provider_executed=provider_executed,\n        )\n        if part.args:\n            yield ToolInputDeltaChunk(tool_call_id=tool_call_id, input_text_delta=part.args_as_json_str())\n\n    async def handle_tool_call_delta(self, delta: ToolCallPartDelta) -> AsyncIterator[BaseChunk]:\n        tool_call_id = delta.tool_call_id or ''\n        assert tool_call_id, '`ToolCallPartDelta.tool_call_id` must be set'\n        yield ToolInputDeltaChunk(\n            tool_call_id=tool_call_id,\n            input_text_delta=delta.args_delta if isinstance(delta.args_delta, str) else _json_dumps(delta.args_delta),\n        )\n\n    async def handle_tool_call_end(self, part: ToolCallPart) -> AsyncIterator[BaseChunk]:\n        yield ToolInputAvailableChunk(\n            tool_call_id=part.tool_call_id, tool_name=part.tool_name, input=part.args_as_dict()\n        )\n\n    async def handle_builtin_tool_call_end(self, part: BuiltinToolCallPart) -> AsyncIterator[BaseChunk]:\n        yield ToolInputAvailableChunk(\n            tool_call_id=part.tool_call_id,\n            tool_name=part.tool_name,\n            input=part.args_as_dict(),\n            provider_executed=True,\n            provider_metadata={'pydantic_ai': {'provider_name': part.provider_name}},\n        )\n\n    async def handle_builtin_tool_return(self, part: BuiltinToolReturnPart) -> AsyncIterator[BaseChunk]:\n        yield ToolOutputAvailableChunk(\n            tool_call_id=part.tool_call_id,\n            output=self._tool_return_output(part),\n            provider_executed=True,\n        )\n\n    async def handle_file(self, part: FilePart) -> AsyncIterator[BaseChunk]:\n        file = part.content\n        yield FileChunk(url=file.data_uri, media_type=file.media_type)\n\n    async def handle_function_tool_result(self, event: FunctionToolResultEvent) -> AsyncIterator[BaseChunk]:\n        part = event.result\n        if isinstance(part, RetryPromptPart):\n            yield ToolOutputErrorChunk(tool_call_id=part.tool_call_id, error_text=part.model_response())\n        else:\n            yield ToolOutputAvailableChunk(tool_call_id=part.tool_call_id, output=self._tool_return_output(part))\n\n        # ToolCallResultEvent.content may hold user parts (e.g. text, images) that Vercel AI does not currently have events for\n\n    def _tool_return_output(self, part: BaseToolReturnPart) -> Any:\n        output = part.model_response_object()\n        # Unwrap the return value from the output dictionary if it exists\n        return output.get('return_value', output)\n\n```\n\nVercel AI request types (UI messages).\n\nConverted to Python from: https://github.com/vercel/ai/blob/ai%405.0.59/packages/ai/src/ui/ui-messages.ts\n\n### ProviderMetadata\n\n```python\nProviderMetadata = dict[str, dict[str, JSONValue]]\n\n```\n\nProvider metadata.\n\n### BaseUIPart\n\nBases: `CamelBaseModel`, `ABC`\n\nAbstract base class for all UI parts.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass BaseUIPart(CamelBaseModel, ABC):\n    \"\"\"Abstract base class for all UI parts.\"\"\"\n\n```\n\n### TextUIPart\n\nBases: `BaseUIPart`\n\nA text part of a message.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass TextUIPart(BaseUIPart):\n    \"\"\"A text part of a message.\"\"\"\n\n    type: Literal['text'] = 'text'\n\n    text: str\n    \"\"\"The text content.\"\"\"\n\n    state: Literal['streaming', 'done'] | None = None\n    \"\"\"The state of the text part.\"\"\"\n\n    provider_metadata: ProviderMetadata | None = None\n    \"\"\"The provider metadata.\"\"\"\n\n```\n\n#### text\n\n```python\ntext: str\n\n```\n\nThe text content.\n\n#### state\n\n```python\nstate: Literal['streaming', 'done'] | None = None\n\n```\n\nThe state of the text part.\n\n#### provider_metadata\n\n```python\nprovider_metadata: ProviderMetadata | None = None\n\n```\n\nThe provider metadata.\n\n### ReasoningUIPart\n\nBases: `BaseUIPart`\n\nA reasoning part of a message.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass ReasoningUIPart(BaseUIPart):\n    \"\"\"A reasoning part of a message.\"\"\"\n\n    type: Literal['reasoning'] = 'reasoning'\n\n    text: str\n    \"\"\"The reasoning text.\"\"\"\n\n    state: Literal['streaming', 'done'] | None = None\n    \"\"\"The state of the reasoning part.\"\"\"\n\n    provider_metadata: ProviderMetadata | None = None\n    \"\"\"The provider metadata.\"\"\"\n\n```\n\n#### text\n\n```python\ntext: str\n\n```\n\nThe reasoning text.\n\n#### state\n\n```python\nstate: Literal['streaming', 'done'] | None = None\n\n```\n\nThe state of the reasoning part.\n\n#### provider_metadata\n\n```python\nprovider_metadata: ProviderMetadata | None = None\n\n```\n\nThe provider metadata.\n\n### SourceUrlUIPart\n\nBases: `BaseUIPart`\n\nA source part of a message.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass SourceUrlUIPart(BaseUIPart):\n    \"\"\"A source part of a message.\"\"\"\n\n    type: Literal['source-url'] = 'source-url'\n    source_id: str\n    url: str\n    title: str | None = None\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### SourceDocumentUIPart\n\nBases: `BaseUIPart`\n\nA document source part of a message.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass SourceDocumentUIPart(BaseUIPart):\n    \"\"\"A document source part of a message.\"\"\"\n\n    type: Literal['source-document'] = 'source-document'\n    source_id: str\n    media_type: str\n    title: str\n    filename: str | None = None\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### FileUIPart\n\nBases: `BaseUIPart`\n\nA file part of a message.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass FileUIPart(BaseUIPart):\n    \"\"\"A file part of a message.\"\"\"\n\n    type: Literal['file'] = 'file'\n\n    media_type: str\n    \"\"\"\n    IANA media type of the file.\n    @see https://www.iana.org/assignments/media-types/media-types.xhtml\n    \"\"\"\n\n    filename: str | None = None\n    \"\"\"Optional filename of the file.\"\"\"\n\n    url: str\n    \"\"\"\n    The URL of the file.\n    It can either be a URL to a hosted file or a [Data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs).\n    \"\"\"\n\n    provider_metadata: ProviderMetadata | None = None\n    \"\"\"The provider metadata.\"\"\"\n\n```\n\n#### media_type\n\n```python\nmedia_type: str\n\n```\n\nIANA media type of the file. @see https://www.iana.org/assignments/media-types/media-types.xhtml\n\n#### filename\n\n```python\nfilename: str | None = None\n\n```\n\nOptional filename of the file.\n\n#### url\n\n```python\nurl: str\n\n```\n\nThe URL of the file. It can either be a URL to a hosted file or a [Data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs).\n\n#### provider_metadata\n\n```python\nprovider_metadata: ProviderMetadata | None = None\n\n```\n\nThe provider metadata.\n\n### StepStartUIPart\n\nBases: `BaseUIPart`\n\nA step boundary part of a message.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass StepStartUIPart(BaseUIPart):\n    \"\"\"A step boundary part of a message.\"\"\"\n\n    type: Literal['step-start'] = 'step-start'\n\n```\n\n### DataUIPart\n\nBases: `BaseUIPart`\n\nData part with dynamic type based on data name.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass DataUIPart(BaseUIPart):\n    \"\"\"Data part with dynamic type based on data name.\"\"\"\n\n    type: Annotated[str, Field(pattern=r'^data-')]\n    id: str | None = None\n    data: Any\n\n```\n\n### ToolInputStreamingPart\n\nBases: `BaseUIPart`\n\nTool part in input-streaming state.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass ToolInputStreamingPart(BaseUIPart):\n    \"\"\"Tool part in input-streaming state.\"\"\"\n\n    type: Annotated[str, Field(pattern=r'^tool-')]\n    tool_call_id: str\n    state: Literal['input-streaming'] = 'input-streaming'\n    input: Any | None = None\n    provider_executed: bool | None = None\n\n```\n\n### ToolInputAvailablePart\n\nBases: `BaseUIPart`\n\nTool part in input-available state.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass ToolInputAvailablePart(BaseUIPart):\n    \"\"\"Tool part in input-available state.\"\"\"\n\n    type: Annotated[str, Field(pattern=r'^tool-')]\n    tool_call_id: str\n    state: Literal['input-available'] = 'input-available'\n    input: Any | None = None\n    provider_executed: bool | None = None\n    call_provider_metadata: ProviderMetadata | None = None\n\n```\n\n### ToolOutputAvailablePart\n\nBases: `BaseUIPart`\n\nTool part in output-available state.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass ToolOutputAvailablePart(BaseUIPart):\n    \"\"\"Tool part in output-available state.\"\"\"\n\n    type: Annotated[str, Field(pattern=r'^tool-')]\n    tool_call_id: str\n    state: Literal['output-available'] = 'output-available'\n    input: Any | None = None\n    output: Any | None = None\n    provider_executed: bool | None = None\n    call_provider_metadata: ProviderMetadata | None = None\n    preliminary: bool | None = None\n\n```\n\n### ToolOutputErrorPart\n\nBases: `BaseUIPart`\n\nTool part in output-error state.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass ToolOutputErrorPart(BaseUIPart):\n    \"\"\"Tool part in output-error state.\"\"\"\n\n    type: Annotated[str, Field(pattern=r'^tool-')]\n    tool_call_id: str\n    state: Literal['output-error'] = 'output-error'\n    input: Any | None = None\n    raw_input: Any | None = None\n    error_text: str\n    provider_executed: bool | None = None\n    call_provider_metadata: ProviderMetadata | None = None\n\n```\n\n### ToolUIPart\n\n```python\nToolUIPart = (\n    ToolInputStreamingPart\n    | ToolInputAvailablePart\n    | ToolOutputAvailablePart\n    | ToolOutputErrorPart\n)\n\n```\n\nUnion of all tool part types.\n\n### DynamicToolInputStreamingPart\n\nBases: `BaseUIPart`\n\nDynamic tool part in input-streaming state.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass DynamicToolInputStreamingPart(BaseUIPart):\n    \"\"\"Dynamic tool part in input-streaming state.\"\"\"\n\n    type: Literal['dynamic-tool'] = 'dynamic-tool'\n    tool_name: str\n    tool_call_id: str\n    state: Literal['input-streaming'] = 'input-streaming'\n    input: Any | None = None\n\n```\n\n### DynamicToolInputAvailablePart\n\nBases: `BaseUIPart`\n\nDynamic tool part in input-available state.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass DynamicToolInputAvailablePart(BaseUIPart):\n    \"\"\"Dynamic tool part in input-available state.\"\"\"\n\n    type: Literal['dynamic-tool'] = 'dynamic-tool'\n    tool_name: str\n    tool_call_id: str\n    state: Literal['input-available'] = 'input-available'\n    input: Any\n    call_provider_metadata: ProviderMetadata | None = None\n\n```\n\n### DynamicToolOutputAvailablePart\n\nBases: `BaseUIPart`\n\nDynamic tool part in output-available state.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass DynamicToolOutputAvailablePart(BaseUIPart):\n    \"\"\"Dynamic tool part in output-available state.\"\"\"\n\n    type: Literal['dynamic-tool'] = 'dynamic-tool'\n    tool_name: str\n    tool_call_id: str\n    state: Literal['output-available'] = 'output-available'\n    input: Any\n    output: Any\n    call_provider_metadata: ProviderMetadata | None = None\n    preliminary: bool | None = None\n\n```\n\n### DynamicToolOutputErrorPart\n\nBases: `BaseUIPart`\n\nDynamic tool part in output-error state.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass DynamicToolOutputErrorPart(BaseUIPart):\n    \"\"\"Dynamic tool part in output-error state.\"\"\"\n\n    type: Literal['dynamic-tool'] = 'dynamic-tool'\n    tool_name: str\n    tool_call_id: str\n    state: Literal['output-error'] = 'output-error'\n    input: Any\n    error_text: str\n    call_provider_metadata: ProviderMetadata | None = None\n\n```\n\n### DynamicToolUIPart\n\n```python\nDynamicToolUIPart = (\n    DynamicToolInputStreamingPart\n    | DynamicToolInputAvailablePart\n    | DynamicToolOutputAvailablePart\n    | DynamicToolOutputErrorPart\n)\n\n```\n\nUnion of all dynamic tool part types.\n\n### UIMessagePart\n\n```python\nUIMessagePart = (\n    TextUIPart\n    | ReasoningUIPart\n    | ToolUIPart\n    | DynamicToolUIPart\n    | SourceUrlUIPart\n    | SourceDocumentUIPart\n    | FileUIPart\n    | DataUIPart\n    | StepStartUIPart\n)\n\n```\n\nUnion of all message part types.\n\n### UIMessage\n\nBases: `CamelBaseModel`\n\nA message as displayed in the UI by Vercel AI Elements.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass UIMessage(CamelBaseModel):\n    \"\"\"A message as displayed in the UI by Vercel AI Elements.\"\"\"\n\n    id: str\n    \"\"\"A unique identifier for the message.\"\"\"\n\n    role: Literal['system', 'user', 'assistant']\n    \"\"\"The role of the message.\"\"\"\n\n    metadata: Any | None = None\n    \"\"\"The metadata of the message.\"\"\"\n\n    parts: list[UIMessagePart]\n    \"\"\"\n    The parts of the message. Use this for rendering the message in the UI.\n    System messages should be avoided (set the system prompt on the server instead).\n    They can have text parts.\n    User messages can have text parts and file parts.\n    Assistant messages can have text, reasoning, tool invocation, and file parts.\n    \"\"\"\n\n```\n\n#### id\n\n```python\nid: str\n\n```\n\nA unique identifier for the message.\n\n#### role\n\n```python\nrole: Literal['system', 'user', 'assistant']\n\n```\n\nThe role of the message.\n\n#### metadata\n\n```python\nmetadata: Any | None = None\n\n```\n\nThe metadata of the message.\n\n#### parts\n\n```python\nparts: list[UIMessagePart]\n\n```\n\nThe parts of the message. Use this for rendering the message in the UI. System messages should be avoided (set the system prompt on the server instead). They can have text parts. User messages can have text parts and file parts. Assistant messages can have text, reasoning, tool invocation, and file parts.\n\n### SubmitMessage\n\nBases: `CamelBaseModel`\n\nSubmit message request.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass SubmitMessage(CamelBaseModel, extra='allow'):\n    \"\"\"Submit message request.\"\"\"\n\n    trigger: Literal['submit-message'] = 'submit-message'\n    id: str\n    messages: list[UIMessage]\n\n```\n\n### RegenerateMessage\n\nBases: `CamelBaseModel`\n\nAsk the agent to regenerate a message.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/request_types.py`\n\n```python\nclass RegenerateMessage(CamelBaseModel, extra='allow'):\n    \"\"\"Ask the agent to regenerate a message.\"\"\"\n\n    trigger: Literal['regenerate-message']\n    id: str\n    messages: list[UIMessage]\n    message_id: str\n\n```\n\n### RequestData\n\n```python\nRequestData = Annotated[\n    SubmitMessage | RegenerateMessage,\n    Discriminator(\"trigger\"),\n]\n\n```\n\nUnion of all request data types.\n\nVercel AI response types (SSE chunks).\n\nConverted to Python from: https://github.com/vercel/ai/blob/ai%405.0.59/packages/ai/src/ui-message-stream/ui-message-chunks.ts\n\n### ProviderMetadata\n\n```python\nProviderMetadata = dict[str, dict[str, JSONValue]]\n\n```\n\nProvider metadata.\n\n### BaseChunk\n\nBases: `CamelBaseModel`, `ABC`\n\nAbstract base class for response SSE events.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass BaseChunk(CamelBaseModel, ABC):\n    \"\"\"Abstract base class for response SSE events.\"\"\"\n\n    def encode(self) -> str:\n        return self.model_dump_json(by_alias=True, exclude_none=True)\n\n```\n\n### TextStartChunk\n\nBases: `BaseChunk`\n\nText start chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass TextStartChunk(BaseChunk):\n    \"\"\"Text start chunk.\"\"\"\n\n    type: Literal['text-start'] = 'text-start'\n    id: str\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### TextDeltaChunk\n\nBases: `BaseChunk`\n\nText delta chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass TextDeltaChunk(BaseChunk):\n    \"\"\"Text delta chunk.\"\"\"\n\n    type: Literal['text-delta'] = 'text-delta'\n    delta: str\n    id: str\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### TextEndChunk\n\nBases: `BaseChunk`\n\nText end chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass TextEndChunk(BaseChunk):\n    \"\"\"Text end chunk.\"\"\"\n\n    type: Literal['text-end'] = 'text-end'\n    id: str\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### ReasoningStartChunk\n\nBases: `BaseChunk`\n\nReasoning start chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ReasoningStartChunk(BaseChunk):\n    \"\"\"Reasoning start chunk.\"\"\"\n\n    type: Literal['reasoning-start'] = 'reasoning-start'\n    id: str\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### ReasoningDeltaChunk\n\nBases: `BaseChunk`\n\nReasoning delta chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ReasoningDeltaChunk(BaseChunk):\n    \"\"\"Reasoning delta chunk.\"\"\"\n\n    type: Literal['reasoning-delta'] = 'reasoning-delta'\n    id: str\n    delta: str\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### ReasoningEndChunk\n\nBases: `BaseChunk`\n\nReasoning end chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ReasoningEndChunk(BaseChunk):\n    \"\"\"Reasoning end chunk.\"\"\"\n\n    type: Literal['reasoning-end'] = 'reasoning-end'\n    id: str\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### ErrorChunk\n\nBases: `BaseChunk`\n\nError chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ErrorChunk(BaseChunk):\n    \"\"\"Error chunk.\"\"\"\n\n    type: Literal['error'] = 'error'\n    error_text: str\n\n```\n\n### ToolInputStartChunk\n\nBases: `BaseChunk`\n\nTool input start chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ToolInputStartChunk(BaseChunk):\n    \"\"\"Tool input start chunk.\"\"\"\n\n    type: Literal['tool-input-start'] = 'tool-input-start'\n    tool_call_id: str\n    tool_name: str\n    provider_executed: bool | None = None\n    dynamic: bool | None = None\n\n```\n\n### ToolInputDeltaChunk\n\nBases: `BaseChunk`\n\nTool input delta chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ToolInputDeltaChunk(BaseChunk):\n    \"\"\"Tool input delta chunk.\"\"\"\n\n    type: Literal['tool-input-delta'] = 'tool-input-delta'\n    tool_call_id: str\n    input_text_delta: str\n\n```\n\n### ToolOutputAvailableChunk\n\nBases: `BaseChunk`\n\nTool output available chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ToolOutputAvailableChunk(BaseChunk):\n    \"\"\"Tool output available chunk.\"\"\"\n\n    type: Literal['tool-output-available'] = 'tool-output-available'\n    tool_call_id: str\n    output: Any\n    provider_executed: bool | None = None\n    dynamic: bool | None = None\n    preliminary: bool | None = None\n\n```\n\n### ToolInputAvailableChunk\n\nBases: `BaseChunk`\n\nTool input available chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ToolInputAvailableChunk(BaseChunk):\n    \"\"\"Tool input available chunk.\"\"\"\n\n    type: Literal['tool-input-available'] = 'tool-input-available'\n    tool_call_id: str\n    tool_name: str\n    input: Any\n    provider_executed: bool | None = None\n    provider_metadata: ProviderMetadata | None = None\n    dynamic: bool | None = None\n\n```\n\n### ToolInputErrorChunk\n\nBases: `BaseChunk`\n\nTool input error chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ToolInputErrorChunk(BaseChunk):\n    \"\"\"Tool input error chunk.\"\"\"\n\n    type: Literal['tool-input-error'] = 'tool-input-error'\n    tool_call_id: str\n    tool_name: str\n    input: Any\n    provider_executed: bool | None = None\n    provider_metadata: ProviderMetadata | None = None\n    dynamic: bool | None = None\n    error_text: str\n\n```\n\n### ToolOutputErrorChunk\n\nBases: `BaseChunk`\n\nTool output error chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass ToolOutputErrorChunk(BaseChunk):\n    \"\"\"Tool output error chunk.\"\"\"\n\n    type: Literal['tool-output-error'] = 'tool-output-error'\n    tool_call_id: str\n    error_text: str\n    provider_executed: bool | None = None\n    dynamic: bool | None = None\n\n```\n\n### SourceUrlChunk\n\nBases: `BaseChunk`\n\nSource URL chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass SourceUrlChunk(BaseChunk):\n    \"\"\"Source URL chunk.\"\"\"\n\n    type: Literal['source-url'] = 'source-url'\n    source_id: str\n    url: str\n    title: str | None = None\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### SourceDocumentChunk\n\nBases: `BaseChunk`\n\nSource document chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass SourceDocumentChunk(BaseChunk):\n    \"\"\"Source document chunk.\"\"\"\n\n    type: Literal['source-document'] = 'source-document'\n    source_id: str\n    media_type: str\n    title: str\n    filename: str | None = None\n    provider_metadata: ProviderMetadata | None = None\n\n```\n\n### FileChunk\n\nBases: `BaseChunk`\n\nFile chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass FileChunk(BaseChunk):\n    \"\"\"File chunk.\"\"\"\n\n    type: Literal['file'] = 'file'\n    url: str\n    media_type: str\n\n```\n\n### DataChunk\n\nBases: `BaseChunk`\n\nData chunk with dynamic type.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass DataChunk(BaseChunk):\n    \"\"\"Data chunk with dynamic type.\"\"\"\n\n    type: Annotated[str, Field(pattern=r'^data-')]\n    data: Any\n\n```\n\n### StartStepChunk\n\nBases: `BaseChunk`\n\nStart step chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass StartStepChunk(BaseChunk):\n    \"\"\"Start step chunk.\"\"\"\n\n    type: Literal['start-step'] = 'start-step'\n\n```\n\n### FinishStepChunk\n\nBases: `BaseChunk`\n\nFinish step chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass FinishStepChunk(BaseChunk):\n    \"\"\"Finish step chunk.\"\"\"\n\n    type: Literal['finish-step'] = 'finish-step'\n\n```\n\n### StartChunk\n\nBases: `BaseChunk`\n\nStart chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass StartChunk(BaseChunk):\n    \"\"\"Start chunk.\"\"\"\n\n    type: Literal['start'] = 'start'\n    message_id: str | None = None\n    message_metadata: Any | None = None\n\n```\n\n### FinishChunk\n\nBases: `BaseChunk`\n\nFinish chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass FinishChunk(BaseChunk):\n    \"\"\"Finish chunk.\"\"\"\n\n    type: Literal['finish'] = 'finish'\n    message_metadata: Any | None = None\n\n```\n\n### AbortChunk\n\nBases: `BaseChunk`\n\nAbort chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass AbortChunk(BaseChunk):\n    \"\"\"Abort chunk.\"\"\"\n\n    type: Literal['abort'] = 'abort'\n\n```\n\n### MessageMetadataChunk\n\nBases: `BaseChunk`\n\nMessage metadata chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass MessageMetadataChunk(BaseChunk):\n    \"\"\"Message metadata chunk.\"\"\"\n\n    type: Literal['message-metadata'] = 'message-metadata'\n    message_metadata: Any\n\n```\n\n### DoneChunk\n\nBases: `BaseChunk`\n\nDone chunk.\n\nSource code in `pydantic_ai_slim/pydantic_ai/ui/vercel_ai/response_types.py`\n\n```python\nclass DoneChunk(BaseChunk):\n    \"\"\"Done chunk.\"\"\"\n\n    type: Literal['done'] = 'done'\n\n    def encode(self) -> str:\n        return '[DONE]'\n\n```",
  "content_length": 42755
}