{
  "title": "`pydantic_graph.beta.step`",
  "source_url": null,
  "content": "Step-based graph execution components.\n\nThis module provides the core abstractions for step-based graph execution, including step contexts, step functions, and step nodes that bridge between the v1 and v2 graph execution systems.\n\n### StepContext\n\nBases: `Generic[StateT, DepsT, InputT]`\n\nContext information passed to step functions during graph execution.\n\nThe step context provides access to the current graph state, dependencies, and input data for a step.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies InputT: The type of the input data\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\n@dataclass(init=False)\nclass StepContext(Generic[StateT, DepsT, InputT]):\n    \"\"\"Context information passed to step functions during graph execution.\n\n    The step context provides access to the current graph state, dependencies, and input data for a step.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        InputT: The type of the input data\n    \"\"\"\n\n    _state: StateT\n    \"\"\"The current graph state.\"\"\"\n    _deps: DepsT\n    \"\"\"The graph run dependencies.\"\"\"\n    _inputs: InputT\n    \"\"\"The input data for this step.\"\"\"\n\n    def __init__(self, *, state: StateT, deps: DepsT, inputs: InputT):\n        self._state = state\n        self._deps = deps\n        self._inputs = inputs\n\n    @property\n    def state(self) -> StateT:\n        return self._state\n\n    @property\n    def deps(self) -> DepsT:\n        return self._deps\n\n    @property\n    def inputs(self) -> InputT:\n        \"\"\"The input data for this step.\n\n        This must be a property to ensure correct variance behavior\n        \"\"\"\n        return self._inputs\n\n```\n\n#### inputs\n\n```python\ninputs: InputT\n\n```\n\nThe input data for this step.\n\nThis must be a property to ensure correct variance behavior\n\n### StepFunction\n\nBases: `Protocol[StateT, DepsT, InputT, OutputT]`\n\nProtocol for step functions that can be executed in the graph.\n\nStep functions are async callables that receive a step context and return a result.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies InputT: The type of the input data OutputT: The type of the output data\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\nclass StepFunction(Protocol[StateT, DepsT, InputT, OutputT]):\n    \"\"\"Protocol for step functions that can be executed in the graph.\n\n    Step functions are async callables that receive a step context and return a result.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        InputT: The type of the input data\n        OutputT: The type of the output data\n    \"\"\"\n\n    def __call__(self, ctx: StepContext[StateT, DepsT, InputT]) -> Awaitable[OutputT]:\n        \"\"\"Execute the step function with the given context.\n\n        Args:\n            ctx: The step context containing state, dependencies, and inputs\n\n        Returns:\n            An awaitable that resolves to the step's output\n        \"\"\"\n        raise NotImplementedError\n\n```\n\n#### __call__\n\n```python\n__call__(\n    ctx: StepContext[StateT, DepsT, InputT],\n) -> Awaitable[OutputT]\n\n```\n\nExecute the step function with the given context.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `ctx` | `StepContext[StateT, DepsT, InputT]` | The step context containing state, dependencies, and inputs | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `Awaitable[OutputT]` | An awaitable that resolves to the step's output |\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\ndef __call__(self, ctx: StepContext[StateT, DepsT, InputT]) -> Awaitable[OutputT]:\n    \"\"\"Execute the step function with the given context.\n\n    Args:\n        ctx: The step context containing state, dependencies, and inputs\n\n    Returns:\n        An awaitable that resolves to the step's output\n    \"\"\"\n    raise NotImplementedError\n\n```\n\n### StreamFunction\n\nBases: `Protocol[StateT, DepsT, InputT, OutputT]`\n\nProtocol for stream functions that can be executed in the graph.\n\nStream functions are async callables that receive a step context and return an async iterator.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies InputT: The type of the input data OutputT: The type of the output data\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\nclass StreamFunction(Protocol[StateT, DepsT, InputT, OutputT]):\n    \"\"\"Protocol for stream functions that can be executed in the graph.\n\n    Stream functions are async callables that receive a step context and return an async iterator.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        InputT: The type of the input data\n        OutputT: The type of the output data\n    \"\"\"\n\n    def __call__(self, ctx: StepContext[StateT, DepsT, InputT]) -> AsyncIterator[OutputT]:\n        \"\"\"Execute the stream function with the given context.\n\n        Args:\n            ctx: The step context containing state, dependencies, and inputs\n\n        Returns:\n            An async iterator yielding the streamed output\n        \"\"\"\n        raise NotImplementedError\n        yield\n\n```\n\n#### __call__\n\n```python\n__call__(\n    ctx: StepContext[StateT, DepsT, InputT],\n) -> AsyncIterator[OutputT]\n\n```\n\nExecute the stream function with the given context.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `ctx` | `StepContext[StateT, DepsT, InputT]` | The step context containing state, dependencies, and inputs | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `AsyncIterator[OutputT]` | An async iterator yielding the streamed output |\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\ndef __call__(self, ctx: StepContext[StateT, DepsT, InputT]) -> AsyncIterator[OutputT]:\n    \"\"\"Execute the stream function with the given context.\n\n    Args:\n        ctx: The step context containing state, dependencies, and inputs\n\n    Returns:\n        An async iterator yielding the streamed output\n    \"\"\"\n    raise NotImplementedError\n    yield\n\n```\n\n### AnyStepFunction\n\n```python\nAnyStepFunction = StepFunction[Any, Any, Any, Any]\n\n```\n\nType alias for a step function with any type parameters.\n\n### Step\n\nBases: `Generic[StateT, DepsT, InputT, OutputT]`\n\nA step in the graph execution that wraps a step function.\n\nSteps represent individual units of execution in the graph, encapsulating a step function along with metadata like ID and label.\n\nType Parameters\n\nStateT: The type of the graph state DepsT: The type of the dependencies InputT: The type of the input data OutputT: The type of the output data\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\n@dataclass(init=False)\nclass Step(Generic[StateT, DepsT, InputT, OutputT]):\n    \"\"\"A step in the graph execution that wraps a step function.\n\n    Steps represent individual units of execution in the graph, encapsulating\n    a step function along with metadata like ID and label.\n\n    Type Parameters:\n        StateT: The type of the graph state\n        DepsT: The type of the dependencies\n        InputT: The type of the input data\n        OutputT: The type of the output data\n    \"\"\"\n\n    id: NodeID\n    \"\"\"Unique identifier for this step.\"\"\"\n    _call: StepFunction[StateT, DepsT, InputT, OutputT]\n    \"\"\"The step function to execute.\"\"\"\n    label: str | None\n    \"\"\"Optional human-readable label for this step.\"\"\"\n\n    def __init__(self, *, id: NodeID, call: StepFunction[StateT, DepsT, InputT, OutputT], label: str | None = None):\n        self.id = id\n        self._call = call\n        self.label = label\n\n    @property\n    def call(self) -> StepFunction[StateT, DepsT, InputT, OutputT]:\n        \"\"\"The step function to execute. This needs to be a property for proper variance inference.\"\"\"\n        return self._call\n\n    @overload\n    def as_node(self, inputs: None = None) -> StepNode[StateT, DepsT]: ...\n\n    @overload\n    def as_node(self, inputs: InputT) -> StepNode[StateT, DepsT]: ...\n\n    def as_node(self, inputs: InputT | None = None) -> StepNode[StateT, DepsT]:\n        \"\"\"Create a step node with bound inputs.\n\n        Args:\n            inputs: The input data to bind to this step, or None\n\n        Returns:\n            A [`StepNode`][pydantic_graph.beta.step.StepNode] with this step and the bound inputs\n        \"\"\"\n        return StepNode(self, inputs)\n\n```\n\n#### id\n\n```python\nid: NodeID = id\n\n```\n\nUnique identifier for this step.\n\n#### label\n\n```python\nlabel: str | None = label\n\n```\n\nOptional human-readable label for this step.\n\n#### call\n\n```python\ncall: StepFunction[StateT, DepsT, InputT, OutputT]\n\n```\n\nThe step function to execute. This needs to be a property for proper variance inference.\n\n#### as_node\n\n```python\nas_node(inputs: None = None) -> StepNode[StateT, DepsT]\n\n```\n\n```python\nas_node(inputs: InputT) -> StepNode[StateT, DepsT]\n\n```\n\n```python\nas_node(\n    inputs: InputT | None = None,\n) -> StepNode[StateT, DepsT]\n\n```\n\nCreate a step node with bound inputs.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `inputs` | `InputT | None` | The input data to bind to this step, or None | `None` |\n\nReturns:\n\n| Type | Description | | --- | --- | | `StepNode[StateT, DepsT]` | A StepNode with this step and the bound inputs |\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\ndef as_node(self, inputs: InputT | None = None) -> StepNode[StateT, DepsT]:\n    \"\"\"Create a step node with bound inputs.\n\n    Args:\n        inputs: The input data to bind to this step, or None\n\n    Returns:\n        A [`StepNode`][pydantic_graph.beta.step.StepNode] with this step and the bound inputs\n    \"\"\"\n    return StepNode(self, inputs)\n\n```\n\n### StepNode\n\nBases: `BaseNode[StateT, DepsT, Any]`\n\nA base node that represents a step with bound inputs.\n\nStepNode bridges between the v1 and v2 graph execution systems by wrapping a Step with bound inputs in a BaseNode interface. It is not meant to be run directly but rather used to indicate transitions to v2-style steps.\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\n@dataclass\nclass StepNode(BaseNode[StateT, DepsT, Any]):\n    \"\"\"A base node that represents a step with bound inputs.\n\n    StepNode bridges between the v1 and v2 graph execution systems by wrapping\n    a [`Step`][pydantic_graph.beta.step.Step] with bound inputs in a BaseNode interface.\n    It is not meant to be run directly but rather used to indicate transitions\n    to v2-style steps.\n    \"\"\"\n\n    step: Step[StateT, DepsT, Any, Any]\n    \"\"\"The step to execute.\"\"\"\n\n    inputs: Any\n    \"\"\"The inputs bound to this step.\"\"\"\n\n    async def run(self, ctx: GraphRunContext[StateT, DepsT]) -> BaseNode[StateT, DepsT, Any] | End[Any]:\n        \"\"\"Attempt to run the step node.\n\n        Args:\n            ctx: The graph execution context\n\n        Returns:\n            The result of step execution\n\n        Raises:\n            NotImplementedError: Always raised as StepNode is not meant to be run directly\n        \"\"\"\n        raise NotImplementedError(\n            '`StepNode` is not meant to be run directly, it is meant to be used in `BaseNode` subclasses to indicate a transition to v2-style steps.'\n        )\n\n```\n\n#### step\n\n```python\nstep: Step[StateT, DepsT, Any, Any]\n\n```\n\nThe step to execute.\n\n#### inputs\n\n```python\ninputs: Any\n\n```\n\nThe inputs bound to this step.\n\n#### run\n\n```python\nrun(\n    ctx: GraphRunContext[StateT, DepsT],\n) -> BaseNode[StateT, DepsT, Any] | End[Any]\n\n```\n\nAttempt to run the step node.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `ctx` | `GraphRunContext[StateT, DepsT]` | The graph execution context | *required* |\n\nReturns:\n\n| Type | Description | | --- | --- | | `BaseNode[StateT, DepsT, Any] | End[Any]` | The result of step execution |\n\nRaises:\n\n| Type | Description | | --- | --- | | `NotImplementedError` | Always raised as StepNode is not meant to be run directly |\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\nasync def run(self, ctx: GraphRunContext[StateT, DepsT]) -> BaseNode[StateT, DepsT, Any] | End[Any]:\n    \"\"\"Attempt to run the step node.\n\n    Args:\n        ctx: The graph execution context\n\n    Returns:\n        The result of step execution\n\n    Raises:\n        NotImplementedError: Always raised as StepNode is not meant to be run directly\n    \"\"\"\n    raise NotImplementedError(\n        '`StepNode` is not meant to be run directly, it is meant to be used in `BaseNode` subclasses to indicate a transition to v2-style steps.'\n    )\n\n```\n\n### NodeStep\n\nBases: `Step[StateT, DepsT, Any, BaseNode[StateT, DepsT, Any] | End[Any]]`\n\nA step that wraps a BaseNode type for execution.\n\nNodeStep allows v1-style BaseNode classes to be used as steps in the v2 graph execution system. It validates that the input is of the expected node type and runs it with the appropriate graph context.\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\nclass NodeStep(Step[StateT, DepsT, Any, BaseNode[StateT, DepsT, Any] | End[Any]]):\n    \"\"\"A step that wraps a BaseNode type for execution.\n\n    NodeStep allows v1-style BaseNode classes to be used as steps in the\n    v2 graph execution system. It validates that the input is of the expected\n    node type and runs it with the appropriate graph context.\n    \"\"\"\n\n    node_type: type[BaseNode[StateT, DepsT, Any]]\n    \"\"\"The BaseNode type this step executes.\"\"\"\n\n    def __init__(\n        self,\n        node_type: type[BaseNode[StateT, DepsT, Any]],\n        *,\n        id: NodeID | None = None,\n        label: str | None = None,\n    ):\n        \"\"\"Initialize a node step.\n\n        Args:\n            node_type: The BaseNode class this step will execute\n            id: Optional unique identifier, defaults to the node's get_node_id()\n            label: Optional human-readable label for this step\n        \"\"\"\n        super().__init__(\n            id=id or NodeID(node_type.get_node_id()),\n            call=self._call_node,\n            label=label,\n        )\n        # `type[BaseNode[StateT, DepsT, Any]]` could actually be a `typing._GenericAlias` like `pydantic_ai._agent_graph.UserPromptNode[~DepsT, ~OutputT]`,\n        # so we get the origin to get to the actual class\n        self.node_type = get_origin(node_type) or node_type\n\n    async def _call_node(self, ctx: StepContext[StateT, DepsT, Any]) -> BaseNode[StateT, DepsT, Any] | End[Any]:\n        \"\"\"Execute the wrapped node with the step context.\n\n        Args:\n            ctx: The step context containing the node instance to run\n\n        Returns:\n            The result of running the node, either another BaseNode or End\n\n        Raises:\n            ValueError: If the input node is not of the expected type\n        \"\"\"\n        node = ctx.inputs\n        if not isinstance(node, self.node_type):\n            raise ValueError(f'Node {node} is not of type {self.node_type}')  # pragma: no cover\n        node = cast(BaseNode[StateT, DepsT, Any], node)\n        return await node.run(GraphRunContext(state=ctx.state, deps=ctx.deps))\n\n```\n\n#### __init__\n\n```python\n__init__(\n    node_type: type[BaseNode[StateT, DepsT, Any]],\n    *,\n    id: NodeID | None = None,\n    label: str | None = None\n)\n\n```\n\nInitialize a node step.\n\nParameters:\n\n| Name | Type | Description | Default | | --- | --- | --- | --- | | `node_type` | `type[BaseNode[StateT, DepsT, Any]]` | The BaseNode class this step will execute | *required* | | `id` | `NodeID | None` | Optional unique identifier, defaults to the node's get_node_id() | `None` | | `label` | `str | None` | Optional human-readable label for this step | `None` |\n\nSource code in `pydantic_graph/pydantic_graph/beta/step.py`\n\n```python\ndef __init__(\n    self,\n    node_type: type[BaseNode[StateT, DepsT, Any]],\n    *,\n    id: NodeID | None = None,\n    label: str | None = None,\n):\n    \"\"\"Initialize a node step.\n\n    Args:\n        node_type: The BaseNode class this step will execute\n        id: Optional unique identifier, defaults to the node's get_node_id()\n        label: Optional human-readable label for this step\n    \"\"\"\n    super().__init__(\n        id=id or NodeID(node_type.get_node_id()),\n        call=self._call_node,\n        label=label,\n    )\n    # `type[BaseNode[StateT, DepsT, Any]]` could actually be a `typing._GenericAlias` like `pydantic_ai._agent_graph.UserPromptNode[~DepsT, ~OutputT]`,\n    # so we get the origin to get to the actual class\n    self.node_type = get_origin(node_type) or node_type\n\n```\n\n#### node_type\n\n```python\nnode_type: type[BaseNode[StateT, DepsT, Any]] = (\n    get_origin(node_type) or node_type\n)\n\n```\n\nThe BaseNode type this step executes.",
  "content_length": 16832
}