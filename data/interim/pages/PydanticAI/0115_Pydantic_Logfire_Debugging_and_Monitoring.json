{
  "title": "Pydantic Logfire Debugging and Monitoring",
  "source_url": null,
  "content": "Applications that use LLMs have some challenges that are well known and understood: LLMs are **slow**, **unreliable** and **expensive**.\n\nThese applications also have some challenges that most developers have encountered much less often: LLMs are **fickle** and **non-deterministic**. Subtle changes in a prompt can completely change a model's performance, and there's no `EXPLAIN` query you can run to understand why.\n\nWarning\n\nFrom a software engineers point of view, you can think of LLMs as the worst database you've ever heard of, but worse.\n\nIf LLMs weren't so bloody useful, we'd never touch them.\n\nTo build successful applications with LLMs, we need new tools to understand both model performance, and the behavior of applications that rely on them.\n\nLLM Observability tools that just let you understand how your model is performing are useless: making API calls to an LLM is easy, it's building that into an application that's hard.\n\n## Pydantic Logfire\n\n[Pydantic Logfire](https://pydantic.dev/logfire) is an observability platform developed by the team who created and maintain Pydantic Validation and Pydantic AI. Logfire aims to let you understand your entire application: Gen AI, classic predictive AI, HTTP traffic, database queries and everything else a modern application needs, all using OpenTelemetry.\n\nPydantic Logfire is a commercial product\n\nLogfire is a commercially supported, hosted platform with an extremely generous and perpetual [free tier](https://pydantic.dev/pricing/). You can sign up and start using Logfire in a couple of minutes. Logfire can also be self-hosted on the enterprise tier.\n\nPydantic AI has built-in (but optional) support for Logfire. That means if the `logfire` package is installed and configured and agent instrumentation is enabled then detailed information about agent runs is sent to Logfire. Otherwise there's virtually no overhead and nothing is sent.\n\nHere's an example showing details of running the [Weather Agent](../examples/weather-agent/) in Logfire:\n\nA trace is generated for the agent run, and spans are emitted for each model request and tool call.\n\n## Using Logfire\n\nTo use Logfire, you'll need a Logfire [account](https://logfire.pydantic.dev). The Logfire Python SDK is included with `pydantic-ai`:\n\n```bash\npip install pydantic-ai\n\n```\n\n```bash\nuv add pydantic-ai\n\n```\n\nOr if you're using the slim package, you can install it with the `logfire` optional group:\n\n```bash\npip install \"pydantic-ai-slim[logfire]\"\n\n```\n\n```bash\nuv add \"pydantic-ai-slim[logfire]\"\n\n```\n\nThen authenticate your local environment with Logfire:\n\n```bash\n logfire auth\n\n```\n\n```bash\nuv run logfire auth\n\n```\n\nAnd configure a project to send data to:\n\n```bash\n logfire projects new\n\n```\n\n```bash\nuv run logfire projects new\n\n```\n\n(Or use an existing project with `logfire projects use`)\n\nThis will write to a `.logfire` directory in the current working directory, which the Logfire SDK will use for configuration at run time.\n\nWith that, you can start using Logfire to instrument Pydantic AI code:\n\n[Learn about Gateway](../gateway) instrument_pydantic_ai.py\n\n```python\nimport logfire\n\nfrom pydantic_ai import Agent\n\nlogfire.configure()  # (1)!\nlogfire.instrument_pydantic_ai()  # (2)!\n\nagent = Agent('gateway/openai:gpt-5', instructions='Be concise, reply with one sentence.')\nresult = agent.run_sync('Where does \"hello world\" come from?')  # (3)!\nprint(result.output)\n\"\"\"\nThe first known use of \"hello, world\" was in a 1974 textbook about the C programming language.\n\"\"\"\n\n```\n\n1. logfire.configure() configures the SDK, by default it will find the write token from the `.logfire` directory, but you can also pass a token directly.\n1. logfire.instrument_pydantic_ai() enables instrumentation of Pydantic AI.\n1. Since we've enabled instrumentation, a trace will be generated for each run, with spans emitted for models calls and tool function execution\n\ninstrument_pydantic_ai.py\n\n```python\nimport logfire\n\nfrom pydantic_ai import Agent\n\nlogfire.configure()  # (1)!\nlogfire.instrument_pydantic_ai()  # (2)!\n\nagent = Agent('openai:gpt-5', instructions='Be concise, reply with one sentence.')\nresult = agent.run_sync('Where does \"hello world\" come from?')  # (3)!\nprint(result.output)\n\"\"\"\nThe first known use of \"hello, world\" was in a 1974 textbook about the C programming language.\n\"\"\"\n\n```\n\n1. logfire.configure() configures the SDK, by default it will find the write token from the `.logfire` directory, but you can also pass a token directly.\n1. logfire.instrument_pydantic_ai() enables instrumentation of Pydantic AI.\n1. Since we've enabled instrumentation, a trace will be generated for each run, with spans emitted for models calls and tool function execution\n\n*(This example is complete, it can be run \"as is\")*\n\nWhich will display in Logfire thus:\n\nThe [Logfire documentation](https://logfire.pydantic.dev/docs/) has more details on how to use Logfire, including how to instrument other libraries like [HTTPX](https://logfire.pydantic.dev/docs/integrations/http-clients/httpx/) and [FastAPI](https://logfire.pydantic.dev/docs/integrations/web-frameworks/fastapi/).\n\nSince Logfire is built on [OpenTelemetry](https://opentelemetry.io/), you can use the Logfire Python SDK to send data to any OpenTelemetry collector, see [below](#using-opentelemetry).\n\n### Debugging\n\nTo demonstrate how Logfire can let you visualise the flow of a Pydantic AI run, here's the view you get from Logfire while running the [chat app examples](../examples/chat-app/):\n\n### Monitoring Performance\n\nWe can also query data with SQL in Logfire to monitor the performance of an application. Here's a real world example of using Logfire to monitor Pydantic AI runs inside Logfire itself:\n\n### Monitoring HTTP Requests\n\nAs per Hamel Husain's influential 2024 blog post [\"Fuck You, Show Me The Prompt.\"](https://hamel.dev/blog/posts/prompt/) (bear with the capitalization, the point is valid), it's often useful to be able to view the raw HTTP requests and responses made to model providers.\n\nTo observe raw HTTP requests made to model providers, you can use Logfire's [HTTPX instrumentation](https://logfire.pydantic.dev/docs/integrations/http-clients/httpx/) since all provider SDKs (except for [Bedrock](../models/bedrock/)) use the [HTTPX](https://www.python-httpx.org/) library internally:\n\n[Learn about Gateway](../gateway) with_logfire_instrument_httpx.py\n\n```python\nimport logfire\n\nfrom pydantic_ai import Agent\n\nlogfire.configure()\nlogfire.instrument_pydantic_ai()\nlogfire.instrument_httpx(capture_all=True)  # (1)!\n\nagent = Agent('gateway/openai:gpt-5')\nresult = agent.run_sync('What is the capital of France?')\nprint(result.output)\n#> The capital of France is Paris.\n\n```\n\n1. See the logfire.instrument_httpx docs more details, `capture_all=True` means both headers and body are captured for both the request and response.\n\nwith_logfire_instrument_httpx.py\n\n```python\nimport logfire\n\nfrom pydantic_ai import Agent\n\nlogfire.configure()\nlogfire.instrument_pydantic_ai()\nlogfire.instrument_httpx(capture_all=True)  # (1)!\n\nagent = Agent('openai:gpt-5')\nresult = agent.run_sync('What is the capital of France?')\nprint(result.output)\n#> The capital of France is Paris.\n\n```\n\n1. See the logfire.instrument_httpx docs more details, `capture_all=True` means both headers and body are captured for both the request and response.\n\n## Using OpenTelemetry\n\nPydantic AI's instrumentation uses [OpenTelemetry](https://opentelemetry.io/) (OTel), which Logfire is based on.\n\nThis means you can debug and monitor Pydantic AI with any OpenTelemetry backend.\n\nPydantic AI follows the [OpenTelemetry Semantic Conventions for Generative AI systems](https://opentelemetry.io/docs/specs/semconv/gen-ai/), so while we think you'll have the best experience using the Logfire platform , you should be able to use any OTel service with GenAI support.\n\n### Logfire with an alternative OTel backend\n\nYou can use the Logfire SDK completely freely and send the data to any OpenTelemetry backend.\n\nHere's an example of configuring the Logfire library to send data to the excellent [otel-tui](https://github.com/ymtdzzz/otel-tui) â€” an open source terminal based OTel backend and viewer (no association with Pydantic Validation).\n\nRun `otel-tui` with docker (see [the otel-tui readme](https://github.com/ymtdzzz/otel-tui) for more instructions):\n\nTerminal\n\n```text\ndocker run --rm -it -p 4318:4318 --name otel-tui ymtdzzz/otel-tui:latest\n\n```\n\nthen run,\n\n[Learn about Gateway](../gateway) otel_tui.py\n\n```python\nimport os\n\nimport logfire\n\nfrom pydantic_ai import Agent\n\nos.environ['OTEL_EXPORTER_OTLP_ENDPOINT'] = 'http://localhost:4318'  # (1)!\nlogfire.configure(send_to_logfire=False)  # (2)!\nlogfire.instrument_pydantic_ai()\nlogfire.instrument_httpx(capture_all=True)\n\nagent = Agent('gateway/openai:gpt-5')\nresult = agent.run_sync('What is the capital of France?')\nprint(result.output)\n#> Paris\n\n```\n\n1. Set the `OTEL_EXPORTER_OTLP_ENDPOINT` environment variable to the URL of your OpenTelemetry backend. If you're using a backend that requires authentication, you may need to set [other environment variables](https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/). Of course, these can also be set outside the process, e.g. with `export OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318`.\n1. We configure Logfire to disable sending data to the Logfire OTel backend itself. If you removed `send_to_logfire=False`, data would be sent to both Logfire and your OpenTelemetry backend.\n\notel_tui.py\n\n```python\nimport os\n\nimport logfire\n\nfrom pydantic_ai import Agent\n\nos.environ['OTEL_EXPORTER_OTLP_ENDPOINT'] = 'http://localhost:4318'  # (1)!\nlogfire.configure(send_to_logfire=False)  # (2)!\nlogfire.instrument_pydantic_ai()\nlogfire.instrument_httpx(capture_all=True)\n\nagent = Agent('openai:gpt-5')\nresult = agent.run_sync('What is the capital of France?')\nprint(result.output)\n#> Paris\n\n```\n\n1. Set the `OTEL_EXPORTER_OTLP_ENDPOINT` environment variable to the URL of your OpenTelemetry backend. If you're using a backend that requires authentication, you may need to set [other environment variables](https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/). Of course, these can also be set outside the process, e.g. with `export OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318`.\n1. We configure Logfire to disable sending data to the Logfire OTel backend itself. If you removed `send_to_logfire=False`, data would be sent to both Logfire and your OpenTelemetry backend.\n\nRunning the above code will send tracing data to `otel-tui`, which will display like this:\n\nRunning the [weather agent](../examples/weather-agent/) example connected to `otel-tui` shows how it can be used to visualise a more complex trace:\n\nFor more information on using the Logfire SDK to send data to alternative backends, see [the Logfire documentation](https://logfire.pydantic.dev/docs/how-to-guides/alternative-backends/).\n\n### OTel without Logfire\n\nYou can also emit OpenTelemetry data from Pydantic AI without using Logfire at all.\n\nTo do this, you'll need to install and configure the OpenTelemetry packages you need. To run the following examples, use\n\nTerminal\n\n```text\nuv run \\\n  --with 'pydantic-ai-slim[openai]' \\\n  --with opentelemetry-sdk \\\n  --with opentelemetry-exporter-otlp \\\n  raw_otel.py\n\n```\n\n[Learn about Gateway](../gateway) raw_otel.py\n\n```python\nimport os\n\nfrom opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\nfrom opentelemetry.trace import set_tracer_provider\n\nfrom pydantic_ai import Agent\n\nos.environ['OTEL_EXPORTER_OTLP_ENDPOINT'] = 'http://localhost:4318'\nexporter = OTLPSpanExporter()\nspan_processor = BatchSpanProcessor(exporter)\ntracer_provider = TracerProvider()\ntracer_provider.add_span_processor(span_processor)\n\nset_tracer_provider(tracer_provider)\n\nAgent.instrument_all()\nagent = Agent('gateway/openai:gpt-5')\nresult = agent.run_sync('What is the capital of France?')\nprint(result.output)\n#> Paris\n\n```\n\nraw_otel.py\n\n```python\nimport os\n\nfrom opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\nfrom opentelemetry.trace import set_tracer_provider\n\nfrom pydantic_ai import Agent\n\nos.environ['OTEL_EXPORTER_OTLP_ENDPOINT'] = 'http://localhost:4318'\nexporter = OTLPSpanExporter()\nspan_processor = BatchSpanProcessor(exporter)\ntracer_provider = TracerProvider()\ntracer_provider.add_span_processor(span_processor)\n\nset_tracer_provider(tracer_provider)\n\nAgent.instrument_all()\nagent = Agent('openai:gpt-5')\nresult = agent.run_sync('What is the capital of France?')\nprint(result.output)\n#> Paris\n\n```\n\n### Alternative Observability backends\n\nBecause Pydantic AI uses OpenTelemetry for observability, you can easily configure it to send data to any OpenTelemetry-compatible backend, not just our observability platform [Pydantic Logfire](#pydantic-logfire).\n\nThe following providers have dedicated documentation on Pydantic AI:\n\n- [Langfuse](https://langfuse.com/docs/integrations/pydantic-ai)\n- [W&B Weave](https://weave-docs.wandb.ai/guides/integrations/pydantic_ai/)\n- [Arize](https://arize.com/docs/ax/observe/tracing-integrations-auto/pydantic-ai)\n- [Openlayer](https://www.openlayer.com/docs/integrations/pydantic-ai)\n- [OpenLIT](https://docs.openlit.io/latest/integrations/pydantic)\n- [LangWatch](https://docs.langwatch.ai/integration/python/integrations/pydantic-ai)\n- [Patronus AI](https://docs.patronus.ai/docs/percival/pydantic)\n- [Opik](https://www.comet.com/docs/opik/tracing/integrations/pydantic-ai)\n- [mlflow](https://mlflow.org/docs/latest/genai/tracing/integrations/listing/pydantic_ai)\n- [Agenta](https://docs.agenta.ai/observability/integrations/pydanticai)\n- [Confident AI](https://documentation.confident-ai.com/docs/llm-tracing/integrations/pydanticai)\n- [LangWatch](https://docs.langwatch.ai/integration/python/integrations/pydantic-ai)\n- [Braintrust](https://www.braintrust.dev/docs/integrations/sdk-integrations/pydantic-ai)\n\n## Advanced usage\n\n### Configuring data format\n\nPydantic AI follows the [OpenTelemetry Semantic Conventions for Generative AI systems](https://opentelemetry.io/docs/specs/semconv/gen-ai/). Specifically, it follows version 1.37.0 of the conventions by default, with a few exceptions. Certain span and attribute names are not spec compliant by default for compatibility reasons, but can be made compliant by passing InstrumentationSettings(version=3) (the default is currently `version=2`). This will change the following:\n\n- The span name `agent run` becomes `invoke_agent {gen_ai.agent.name}` (with the agent name filled in)\n- The span name `running tool` becomes `execute_tool {gen_ai.tool.name}` (with the tool name filled in)\n- The attribute name `tool_arguments` becomes `gen_ai.tool.call.arguments`\n- The attribute name `tool_response` becomes `gen_ai.tool.call.result`\n\nTo use [OpenTelemetry semantic conventions version 1.36.0](https://github.com/open-telemetry/semantic-conventions/blob/v1.36.0/docs/gen-ai/README.md) or older, pass InstrumentationSettings(version=1). Moreover, those semantic conventions specify that messages should be captured as individual events (logs) that are children of the request span, whereas by default, Pydantic AI instead collects these events into a JSON array which is set as a single large attribute called `events` on the request span. To change this, use `event_mode='logs'`:\n\n[Learn about Gateway](../gateway) instrumentation_settings_event_mode.py\n\n```python\nimport logfire\n\nfrom pydantic_ai import Agent\n\nlogfire.configure()\nlogfire.instrument_pydantic_ai(version=1, event_mode='logs')\nagent = Agent('gateway/openai:gpt-5')\nresult = agent.run_sync('What is the capital of France?')\nprint(result.output)\n#> The capital of France is Paris.\n\n```\n\ninstrumentation_settings_event_mode.py\n\n```python\nimport logfire\n\nfrom pydantic_ai import Agent\n\nlogfire.configure()\nlogfire.instrument_pydantic_ai(version=1, event_mode='logs')\nagent = Agent('openai:gpt-5')\nresult = agent.run_sync('What is the capital of France?')\nprint(result.output)\n#> The capital of France is Paris.\n\n```\n\nThis won't look as good in the Logfire UI, and will also be removed from Pydantic AI in a future release, but may be useful for backwards compatibility.\n\nNote that the OpenTelemetry Semantic Conventions are still experimental and are likely to change.\n\n### Setting OpenTelemetry SDK providers\n\nBy default, the global `TracerProvider` and `EventLoggerProvider` are used. These are set automatically by `logfire.configure()`. They can also be set by the `set_tracer_provider` and `set_event_logger_provider` functions in the OpenTelemetry Python SDK. You can set custom providers with InstrumentationSettings.\n\n[Learn about Gateway](../gateway) instrumentation_settings_providers.py\n\n```python\nfrom opentelemetry.sdk._events import EventLoggerProvider\nfrom opentelemetry.sdk.trace import TracerProvider\n\nfrom pydantic_ai import Agent, InstrumentationSettings\n\ninstrumentation_settings = InstrumentationSettings(\n    tracer_provider=TracerProvider(),\n    event_logger_provider=EventLoggerProvider(),\n)\n\nagent = Agent('gateway/openai:gpt-5', instrument=instrumentation_settings)\n### or to instrument all agents:\nAgent.instrument_all(instrumentation_settings)\n\n```\n\ninstrumentation_settings_providers.py\n\n```python\nfrom opentelemetry.sdk._events import EventLoggerProvider\nfrom opentelemetry.sdk.trace import TracerProvider\n\nfrom pydantic_ai import Agent, InstrumentationSettings\n\ninstrumentation_settings = InstrumentationSettings(\n    tracer_provider=TracerProvider(),\n    event_logger_provider=EventLoggerProvider(),\n)\n\nagent = Agent('openai:gpt-5', instrument=instrumentation_settings)\n### or to instrument all agents:\nAgent.instrument_all(instrumentation_settings)\n\n```\n\n### Instrumenting a specific `Model`\n\ninstrumented_model_example.py\n\n```python\nfrom pydantic_ai import Agent\nfrom pydantic_ai.models.instrumented import InstrumentationSettings, InstrumentedModel\n\nsettings = InstrumentationSettings()\nmodel = InstrumentedModel('openai:gpt-5', settings)\nagent = Agent(model)\n\n```\n\n### Excluding binary content\n\n[Learn about Gateway](../gateway) excluding_binary_content.py\n\n```python\nfrom pydantic_ai import Agent, InstrumentationSettings\n\ninstrumentation_settings = InstrumentationSettings(include_binary_content=False)\n\nagent = Agent('gateway/openai:gpt-5', instrument=instrumentation_settings)\n### or to instrument all agents:\nAgent.instrument_all(instrumentation_settings)\n\n```\n\nexcluding_binary_content.py\n\n```python\nfrom pydantic_ai import Agent, InstrumentationSettings\n\ninstrumentation_settings = InstrumentationSettings(include_binary_content=False)\n\nagent = Agent('openai:gpt-5', instrument=instrumentation_settings)\n### or to instrument all agents:\nAgent.instrument_all(instrumentation_settings)\n\n```\n\n### Excluding prompts and completions\n\nFor privacy and security reasons, you may want to monitor your agent's behavior and performance without exposing sensitive user data or proprietary prompts in your observability platform. Pydantic AI allows you to exclude the actual content from instrumentation events while preserving the structural information needed for debugging and monitoring.\n\nWhen `include_content=False` is set, Pydantic AI will exclude sensitive content from OpenTelemetry events, including user prompts and model completions, tool call arguments and responses, and any other message content.\n\n[Learn about Gateway](../gateway) excluding_sensitive_content.py\n\n```python\nfrom pydantic_ai import Agent\nfrom pydantic_ai.models.instrumented import InstrumentationSettings\n\ninstrumentation_settings = InstrumentationSettings(include_content=False)\n\nagent = Agent('gateway/openai:gpt-5', instrument=instrumentation_settings)\n### or to instrument all agents:\nAgent.instrument_all(instrumentation_settings)\n\n```\n\nexcluding_sensitive_content.py\n\n```python\nfrom pydantic_ai import Agent\nfrom pydantic_ai.models.instrumented import InstrumentationSettings\n\ninstrumentation_settings = InstrumentationSettings(include_content=False)\n\nagent = Agent('openai:gpt-5', instrument=instrumentation_settings)\n### or to instrument all agents:\nAgent.instrument_all(instrumentation_settings)\n\n```\n\nThis setting is particularly useful in production environments where compliance requirements or data sensitivity concerns make it necessary to limit what content is sent to your observability platform.",
  "content_length": 20606
}