{
  "title": "Overview",
  "source_url": null,
  "content": "> Temporal Knowledge Graphs for Agentic Applications\n\n<Card title=\"What is a Knowledge Graph?\" icon=\"duotone chart-network\">\n  Graphiti helps you create and query Knowledge Graphs that evolve over time. A\n  knowledge graph is a network of interconnected facts, such as *“Kendra loves\n  Adidas shoes.”* Each fact is a *“triplet”* represented by two entities, or\n  nodes (*”Kendra”, “Adidas shoes”*), and their relationship, or edge\n  (*”loves”*).\n\n  <br />\n\n  Knowledge Graphs have been explored extensively for information retrieval.\n  What makes Graphiti unique is its ability to autonomously build a knowledge\n  graph while handling changing relationships and maintaining historical\n  context.\n</Card>\n\n![graphiti intro slides](file:cb9d38f7-c214-45fb-9a18-0f77a3a3ccb0)\n\nGraphiti builds dynamic, temporally-aware knowledge graphs that represent complex, evolving relationships between entities over time. It ingests both unstructured and structured data, and the resulting graph may be queried using a fusion of time, full-text, semantic, and graph algorithm approaches.\n\nWith Graphiti, you can build LLM applications such as:\n\n* Assistants that learn from user interactions, fusing personal knowledge with dynamic data from business systems like CRMs and billing platforms.\n* Agents that autonomously execute complex tasks, reasoning with state changes from multiple dynamic sources.\n\nGraphiti supports a wide range of applications in sales, customer service, health, finance, and more, enabling long-term recall and state-based reasoning for both assistants and agents.\n\n## Graphiti and Zep Memory\n\nGraphiti powers the core of [Zep's memory layer](https://www.getzep.com) for LLM-powered Assistants and Agents.\n\nWe're excited to open-source Graphiti, believing its potential reaches far beyond memory applications.\n\n## Why Graphiti?\n\nWe were intrigued by Microsoft’s GraphRAG, which expanded on RAG text chunking by using a graph to better model a document corpus and making this representation available via semantic and graph search techniques. However, GraphRAG did not address our core problem: It's primarily designed for static documents and doesn't inherently handle temporal aspects of data.\n\nGraphiti is designed from the ground up to handle constantly changing information, hybrid semantic and graph search, and scale:\n\n* **Temporal Awareness:** Tracks changes in facts and relationships over time, enabling point-in-time queries. Graph edges include temporal metadata to record relationship lifecycles.\n* **Episodic Processing:** Ingests data as discrete episodes, maintaining data provenance and allowing incremental entity and relationship extraction.\n* **Custom Entity Types:** Supports defining domain-specific entity types, enabling more precise knowledge representation for specialized applications.\n* **Hybrid Search:** Combines semantic and BM25 full-text search, with the ability to rerank results by distance from a central node e.g. \"Kendra\".\n* **Scalable:** Designed for processing large datasets, with parallelization of LLM calls for bulk processing while preserving the chronology of events.\n* **Supports Varied Sources:** Can ingest both unstructured text and structured JSON data.\n\n| Aspect                     | GraphRAG                              | Graphiti                                         |\n| -------------------------- | ------------------------------------- | ------------------------------------------------ |\n| **Primary Use**            | Static document summarization         | Dynamic data management                          |\n| **Data Handling**          | Batch-oriented processing             | Continuous, incremental updates                  |\n| **Knowledge Structure**    | Entity clusters & community summaries | Episodic data, semantic entities, communities    |\n| **Retrieval Method**       | Sequential LLM summarization          | Hybrid semantic, keyword, and graph-based search |\n| **Adaptability**           | Low                                   | High                                             |\n| **Temporal Handling**      | Basic timestamp tracking              | Explicit bi-temporal tracking                    |\n| **Contradiction Handling** | LLM-driven summarization judgments    | Temporal edge invalidation                       |\n| **Query Latency**          | Seconds to tens of seconds            | Typically sub-second latency                     |\n| **Custom Entity Types**    | No                                    | Yes, customizable                                |\n| **Scalability**            | Moderate                              | High, optimized for large datasets               |\n\nGraphiti is specifically designed to address the challenges of dynamic and frequently updated datasets, making it particularly suitable for applications requiring real-time interaction and precise historical queries.\n\n![graphiti demo slides](file:b1ca5c14-32b1-4342-96ca-d9d11a0c128d)",
  "content_length": 4964
}