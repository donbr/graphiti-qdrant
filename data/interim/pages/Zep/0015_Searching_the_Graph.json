{
  "title": "Searching the Graph",
  "source_url": null,
  "content": "<Note title=\"Custom Context Blocks\" icon=\"link\">\n  Graph search results should be used in conjunction with [Advanced Context Block Construction](/cookbook/advanced-context-block-construction) to create rich, contextual prompts for AI models. Custom context blocks allow you to format and structure the retrieved graph information, combining search results with conversation history and other relevant data to provide comprehensive context for your AI applications.\n\n  Learn how to integrate graph search results into your context generation workflow for more effective AI interactions.\n</Note>\n\n## Introduction\n\nZep's graph search provides powerful hybrid search capabilities that combine semantic similarity with BM25 full-text search to find relevant information across your knowledge graph. This approach leverages the best of both worlds: semantic understanding for conceptual matches and full-text search for exact term matching. Additionally, you can optionally enable breadth-first search to bias results toward information connected to specific starting points in your graph.\n\n### How It Works\n\n* **Semantic similarity**: Converts queries into embeddings to find conceptually similar content\n* **BM25 full-text search**: Performs traditional keyword-based search for exact matches\n* **Breadth-first search** (optional): Biases results toward information connected to specified starting nodes, useful for contextual relevance\n* **Hybrid results**: Combines and reranks results using sophisticated algorithms\n\n### Graph Concepts\n\n* **Nodes**: Connection points representing entities (people, places, concepts) discussed in conversations or added via the Graph API\n* **Edges**: Relationships between nodes containing specific facts and interactions\n\nThe example below demonstrates a simple search:\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=query,\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: query,\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID: zep.String(userID),\n      Query:  query,\n  })\n  ```\n</CodeBlocks>\n\n<Tip title=\"Best Practices\" icon=\"magnifying-glass\">\n  Keep queries short: they are truncated at 400 characters. Long queries may increase latency without improving search quality.\n  Break down complex searches into smaller, targeted queries. Use precise, contextual queries rather than generic ones\n</Tip>\n\n## Configurable Parameters\n\nZep provides extensive configuration options to fine-tune search behavior and optimize results for your specific use case:\n\n| Parameter                          | Type    | Description                                                                                                                                                                                                                       | Default   | Required |\n| ---------------------------------- | ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- | -------- |\n| `graph_id`                         | string  | Search within a graph                                                                                                                                                                                                             | -         | Yes\\*    |\n| `user_id`                          | string  | Search within a user graph                                                                                                                                                                                                        | -         | Yes\\*    |\n| `query`                            | string  | Search text (max 400 characters)                                                                                                                                                                                                  | -         | Yes      |\n| `scope`                            | string  | Search target: `\"edges\"`, `\"nodes\"`, or `\"episodes\"`                                                                                                                                                                              | `\"edges\"` | No       |\n| `reranker`                         | string  | Reranking method: `\"rrf\"`, `\"mmr\"`, `\"node_distance\"`, `\"episode_mentions\"`, or `\"cross_encoder\"`                                                                                                                                 | `\"rrf\"`   | No       |\n| `limit`                            | integer | Maximum number of results to return                                                                                                                                                                                               | `10`      | No       |\n| `mmr_lambda`                       | float   | MMR diversity vs relevance balance (0.0-1.0)                                                                                                                                                                                      | -         | No†      |\n| `center_node_uuid`                 | string  | Center node for distance-based reranking                                                                                                                                                                                          | -         | No‡      |\n| `search_filters`                   | object  | Filter by entity types (`node_labels`), edge types (`edge_types`), exclude entity types (`exclude_node_labels`), exclude edge types (`exclude_edge_types`), or timestamps (`created_at`, `expired_at`, `invalid_at`, `valid_at`§) | -         | No       |\n| `bfs_origin_node_uuids`            | array   | Node UUIDs to seed breadth-first searches from                                                                                                                                                                                    | -         | No       |\n| ~~`min_fact_rating`~~ (deprecated) | double  | ~~The minimum rating by which to filter relevant facts (range: 0.0-1.0). Can only be used when using `scope=\"edges\"`~~                                                                                                            | -         | No       |\n\n\\*Either `user_id` OR `graph_id` is required\n†Required when using `mmr` reranker\\\n‡Required when using `node_distance` reranker\\\n§Timestamp filtering only applies to edge scope searches\n\n## Search Scopes\n\nZep supports three different search scopes, each optimized for different types of information retrieval:\n\n### Edges (Default)\n\nEdges represent individual relationships and facts between entities in your graph. They contain specific interactions, conversations, and detailed information. Edge search is ideal for:\n\n* Finding specific details or conversations\n* Retrieving precise facts about relationships\n* Getting granular information about interactions\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  # Edge search (default scope)\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"What did John say about the project?\",\n      scope=\"edges\",  # Optional - this is the default\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  // Edge search (default scope)\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"What did John say about the project?\",\n    scope: \"edges\", // Optional - this is the default\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  // Edge search (default scope)\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID: zep.String(userID),\n      Query:  \"What did John say about the project?\",\n      Scope:  zep.GraphSearchScopeEdges.Ptr(), // Optional - this is the default\n  })\n  ```\n</CodeBlocks>\n\n### Nodes\n\nNodes are connection points in the graph that represent entities. Each node maintains a summary of facts from its connections (edges), providing a comprehensive overview. Node search is useful for:\n\n* Understanding broader context around entities\n* Getting entity summaries and overviews\n* Finding all information related to a specific person, place, or concept\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  search_results = client.graph.search(\n      graph_id=graph_id,\n      query=\"John Smith\",\n      scope=\"nodes\",\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const searchResults = await client.graph.search({\n    graphId: graphId,\n    query: \"John Smith\",\n    scope: \"nodes\",\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      GraphID: zep.String(graphID),\n      Query:   \"John Smith\",\n      Scope:   zep.GraphSearchScopeNodes.Ptr(),\n  })\n  ```\n</CodeBlocks>\n\n### Episodes\n\nEpisodes represent individual messages or chunks of data sent to Zep. Episode search allows you to find relevant episodes based on their content, making it ideal for:\n\n* Finding specific messages or data chunks related to your query\n* Discovering when certain topics were mentioned\n* Retrieving relevant individual interactions\n* Understanding the context of specific messages\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"project discussion\",\n      scope=\"episodes\",\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"project discussion\",\n    scope: \"episodes\",\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID: zep.String(userID),\n      Query:  \"project discussion\",\n      Scope:  zep.GraphSearchScopeEpisodes.Ptr(),\n  })\n  ```\n</CodeBlocks>\n\n## Rerankers\n\nZep provides multiple reranking algorithms to optimize search results for different use cases. Each reranker applies a different strategy to prioritize and order results:\n\n### RRF (Reciprocal Rank Fusion)\n\n<a name=\"reciprocal-rank-fusion\" />\n\nReciprocal Rank Fusion is the default reranker that intelligently combines results from both semantic similarity and BM25 full-text search. It merges the two result sets by considering the rank position of each result in both searches, creating a unified ranking that leverages the strengths of both approaches.\n\n**When to use**: RRF is ideal for most general-purpose search scenarios where you want balanced results combining conceptual understanding with exact keyword matching.\n\n**Score interpretation**: RRF scores combine semantic similarity and keyword matching by summing reciprocal ranks (1/rank) from both search methods, resulting in higher scores for results that perform well in both approaches. Scores don't follow a fixed 0-1 scale but rather reflect the combined strength across both search types, with higher values indicating better overall relevance.\n\n### MMR (Maximal Marginal Relevance)\n\n<a name=\"maximal-marginal-re-ranking\" />\n\nMaximal Marginal Relevance addresses a common issue in similarity searches: highly similar top results that don't add diverse information to your context. MMR reranks results to balance relevance with diversity, promoting varied but still relevant results over redundant similar ones.\n\n**When to use**: Use MMR when you need diverse information for comprehensive context, such as generating summaries, answering complex questions, or avoiding repetitive results.\n\n**Required parameter**: `mmr_lambda` (0.0-1.0) - Controls the balance between relevance (1.0) and diversity (0.0). A value of 0.5 provides balanced results.\n\n**Score interpretation**: MMR scores balance relevance with diversity based on your mmr\\_lambda setting, meaning a moderately relevant but diverse result may score higher than a highly relevant but similar result. Interpret scores relative to your lambda value: with lambda=0.5, moderate scores may indicate valuable diversity rather than poor relevance.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"project status\",\n      reranker=\"mmr\",\n      mmr_lambda=0.5, # Balance diversity vs relevance\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"project status\",\n    reranker: \"mmr\",\n    mmrLambda: 0.5, // Balance diversity vs relevance\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID:    zep.String(userID),\n      Query:     \"project status\",\n      Reranker:  zep.GraphSearchQueryRerankerMmr.Ptr(),\n      MmrLambda: zep.Float64(0.5), // Balance diversity vs relevance\n  })\n  ```\n</CodeBlocks>\n\n### Cross Encoder\n\n`cross_encoder` uses a specialized neural model that jointly analyzes the query and each search result together, rather than analyzing them separately. This provides more accurate relevance scoring by understanding the relationship between the query and potential results in a single model pass.\n\n**When to use**: Use cross encoder when you need the highest accuracy in relevance scoring and are willing to trade some performance for better results. Ideal for critical searches where precision is paramount.\n\n**Trade-offs**: Higher accuracy but slower performance compared to other rerankers.\n\n**Score interpretation**: Cross encoder scores follow a sigmoid curve (`0-1` range) where highly relevant results cluster near the top with scores that decay rapidly as relevance decreases. You'll typically see a sharp drop-off between truly relevant results (higher scores) and less relevant ones, making it easy to set meaningful relevance thresholds.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"critical project decision\",\n      reranker=\"cross_encoder\",\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"critical project decision\",\n    reranker: \"cross_encoder\",\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID:   zep.String(userID),\n      Query:    \"critical project decision\",\n      Reranker: zep.GraphSearchQueryRerankerCrossEncoder.Ptr(),\n  })\n  ```\n</CodeBlocks>\n\n### Episode Mentions\n\n`episode_mentions` reranks search results based on how frequently nodes or edges have been mentioned across all episodes, including both conversational episodes (chat history) and episodes created via `graph.add`. Results that appear more often across these episodes are prioritized, reflecting their importance and relevance.\n\n**When to use**: Use episode mentions when you want to surface information that has been frequently referenced across conversations or data uploads. Useful for understanding recurring themes, important topics, or frequently mentioned entities across all your graph data.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"team feedback\",\n      reranker=\"episode_mentions\",\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"team feedback\",\n    reranker: \"episode_mentions\",\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID:   zep.String(userID),\n      Query:    \"team feedback\",\n      Reranker: zep.GraphSearchQueryRerankerEpisodeMentions.Ptr(),\n  })\n  ```\n</CodeBlocks>\n\n### Node Distance\n\n`node_distance` reranks search results based on graph proximity, prioritizing results that are closer (fewer hops) to a specified center node. This spatial approach to relevance is useful for finding information contextually related to a specific entity or concept.\n\n**When to use**: Use node distance when you want to find information specifically related to a particular entity, person, or concept in your graph. Ideal for exploring the immediate context around a known entity.\n\n**Required parameter**: `center_node_uuid` - The UUID of the node to use as the center point for distance calculations.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"recent activities\",\n      reranker=\"node_distance\",\n      center_node_uuid=center_node_uuid,\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"recent activities\",\n    reranker: \"node_distance\",\n    centerNodeUuid: centerNodeUuid,\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID:         zep.String(userID),\n      Query:          \"recent activities\",\n      Reranker:       zep.GraphSearchQueryRerankerNodeDistance.Ptr(),\n      CenterNodeUuid: zep.String(centerNodeUuid),\n  })\n  ```\n</CodeBlocks>\n\n### Reranker Score\n\nGraph search results include a reranker score that provides a measure of relevance for each returned result. This score is available when using any reranker and is returned on any node, edge, or episode from `graph.search`. The reranker score can be used to manually filter results to only include those above a certain relevance threshold, allowing for more precise control over search result quality.\n\nThe interpretation of the score depends on which reranker is used. For example, when using the `cross_encoder` reranker, the score follows a sigmoid curve with the score decaying rapidly as relevance decreases. For more information about the score field in the response, see the [SDK reference](https://help.getzep.com/sdk-reference/graph/search#response.body.edges.score).\n\n#### Relevance Score\n\nWhen using the `cross_encoder` reranker, search results include an additional `relevance` field alongside the `score` field. The `relevance` field is a rank-aligned score in the range \\[0, 1] derived from the existing sigmoid-distributed `score` to improve interpretability and thresholding.\n\n**Key characteristics:**\n\n* Range: \\[0, 1]\n* Only populated when using the `cross_encoder` reranker\n* Preserves the ranking order produced by Zep's reranker\n* Not a probability; it is a monotonic transform of `score` to reduce saturation near 1\n* Use `relevance` for sorting, filtering, and analytics\n\nThe `relevance` field provides a more intuitive metric for evaluating search result quality compared to the raw `score`, making it easier to set meaningful thresholds and analyze results.\n\n## Search Filters\n\nZep allows you to filter search results by specific entity types or edge types, enabling more targeted searches within your graph.\n\n### Entity Type Filtering\n\nFilter search results to only include nodes of specific entity types. This is useful when you want to focus on particular kinds of entities (e.g., only people, only companies, only locations).\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"software engineers\",\n      scope=\"nodes\",\n      search_filters={\n          \"node_labels\": [\"Person\", \"Company\"]\n      }\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"software engineers\",\n    scope: \"nodes\",\n    searchFilters: {\n      nodeLabels: [\"Person\", \"Company\"]\n    }\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  searchFilters := zep.SearchFilters{NodeLabels: []string{\"Person\", \"Company\"}}\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID:        zep.String(userID),\n      Query:         \"software engineers\",\n      Scope:         zep.GraphSearchScopeNodes.Ptr(),\n      SearchFilters: &searchFilters,\n  })\n  ```\n</CodeBlocks>\n\n### Edge Type Filtering\n\nFilter search results to only include edges of specific relationship types. This helps you find particular kinds of relationships or interactions between entities.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"project collaboration\",\n      scope=\"edges\",\n      search_filters={\n          \"edge_types\": [\"WORKS_WITH\", \"COLLABORATES_ON\"]\n      }\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"project collaboration\",\n    scope: \"edges\",\n    searchFilters: {\n      edgeTypes: [\"WORKS_WITH\", \"COLLABORATES_ON\"]\n    }\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  searchFilters := zep.SearchFilters{EdgeTypes: []string{\"WORKS_WITH\", \"COLLABORATES_ON\"}}\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID:        zep.String(userID),\n      Query:         \"project collaboration\",\n      Scope:         zep.GraphSearchScopeEdges.Ptr(),\n      SearchFilters: &searchFilters,\n  })\n  ```\n</CodeBlocks>\n\n### Exclusion Filters\n\nExclusion filters allow you to exclude specific entity types or edge types from your search results. This is useful when you want to filter out certain types of information while keeping all others.\n\n#### Excluding Node Labels\n\nExclude specific entity types from node or edge search results. When searching edges, nodes connected to the edges are also checked against exclusion filters.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  # Exclude certain entity types from results\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"project information\",\n      scope=\"nodes\",\n      search_filters={\n          \"exclude_node_labels\": [\"Assistant\", \"Document\"]\n      }\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  // Exclude certain entity types from results\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"project information\",\n    scope: \"nodes\",\n    searchFilters: {\n      excludeNodeLabels: [\"Assistant\", \"Document\"]\n    }\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  // Exclude certain entity types from results\n  searchFilters := zep.SearchFilters{ExcludeNodeLabels: []string{\"Assistant\", \"Document\"}}\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID:        zep.String(userID),\n      Query:         \"project information\",\n      Scope:         zep.GraphSearchScopeNodes.Ptr(),\n      SearchFilters: &searchFilters,\n  })\n  ```\n</CodeBlocks>\n\n#### Excluding Edge Types\n\nExclude specific edge types from search results. This helps you filter out certain kinds of relationships while keeping all others.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  # Exclude certain edge types from results\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"user activities\",\n      scope=\"edges\",\n      search_filters={\n          \"exclude_edge_types\": [\"LOCATED_AT\", \"OCCURRED_AT\"]\n      }\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  // Exclude certain edge types from results\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"user activities\",\n    scope: \"edges\",\n    searchFilters: {\n      excludeEdgeTypes: [\"LOCATED_AT\", \"OCCURRED_AT\"]\n    }\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  // Exclude certain edge types from results\n  searchFilters := zep.SearchFilters{ExcludeEdgeTypes: []string{\"LOCATED_AT\", \"OCCURRED_AT\"}}\n  searchResults, err := client.Graph.Search(context.TODO(), &zep.GraphSearchQuery{\n      UserID:        zep.String(userID),\n      Query:         \"user activities\",\n      Scope:         zep.GraphSearchScopeEdges.Ptr(),\n      SearchFilters: &searchFilters,\n  })\n  ```\n</CodeBlocks>\n\n<Note>\n  Exclusion filters can be combined with inclusion filters (`node_labels` and `edge_types`). When both are specified, results must match the inclusion criteria AND not match any exclusion criteria.\n</Note>\n\n### Datetime Filtering\n\nFilter search results based on timestamps, enabling temporal-based queries to find information from specific time periods. This feature allows you to search for content based on four different timestamp types, each serving a distinct purpose in tracking the lifecycle of facts in your knowledge graph.\n\n<Note title=\"Edge Scope Only\" icon=\"warning\">\n  Datetime filtering only applies to edge scope searches. When using `scope=\"nodes\"` or `scope=\"episodes\"`, datetime filter values are ignored and have no effect on search results.\n</Note>\n\n**Available Timestamp Types:**\n\n| Timestamp    | Description                                          | Example Use Case                                       |\n| ------------ | ---------------------------------------------------- | ------------------------------------------------------ |\n| `created_at` | The time when Zep learned the fact was true          | Finding when information was first added to the system |\n| `valid_at`   | The real world time that the fact started being true | Identifying when a relationship or state began         |\n| `invalid_at` | The real world time that the fact stopped being true | Finding when a relationship or state ended             |\n| `expired_at` | The time that Zep learned that the fact was false    | Tracking when information was marked as outdated       |\n\nFor example, for the fact \"Alice is married to Bob\":\n\n* `valid_at`: The time they got married\n* `invalid_at`: The time they got divorced\n* `created_at`: The time Zep learned they were married\n* `expired_at`: The time Zep learned they were divorced\n\n**Logic Behavior:**\n\n* **Outer array/list**: Uses OR logic - any condition graph can match\n* **Inner array/list**: Uses AND logic - all conditions within a graph must match\n\nIn the example below, results are returned if they match:\n\n* (created >= 2025-07-01 AND created \\< 2025-08-01) OR (created \\< 2025-05-01)\n\n**Date Format**: All dates must be in ISO 8601 format with timezone (e.g., \"2025-07-01T20:57:56Z\")\n\n**Comparison Operators**: Supports `>=`, `<=`, `<`, and `>` for flexible date range queries\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n  from zep_cloud.types import SearchFilters, DateFilter\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  # Search for edges created in July 2025 OR before May 2025\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"project discussions\",\n      scope=\"edges\",\n      search_filters=SearchFilters(\n          created_at=[\n              # First condition graph (AND logic within)\n              [DateFilter(comparison_operator=\">=\", date=\"2025-07-01T20:57:56Z\"), \n               DateFilter(comparison_operator=\"<\", date=\"2025-08-01T20:57:56Z\")],\n              # Second condition graph (OR logic with first graph)\n              [DateFilter(comparison_operator=\"<\", date=\"2025-05-01T20:57:56Z\")],\n          ]\n      )\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  // Search for edges created in July 2025 OR before May 2025\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"project discussions\",\n    scope: \"edges\",\n    searchFilters: {\n      createdAt: [\n        // First condition graph (AND logic within)\n        [\n          {comparisonOperator: \">=\", date: \"2025-07-01T20:57:56Z\"},\n          {comparisonOperator: \"<\", date: \"2025-08-01T20:57:56Z\"}\n        ],\n        // Second condition graph (OR logic with first graph)\n        [\n          {comparisonOperator: \"<\", date: \"2025-05-01T20:57:56Z\"}\n        ]\n      ]\n    }\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  // Search for edges created in July 2025 OR before May 2025\n  searchResults, err := client.Graph.Search(ctx, &zep.GraphSearchQuery{\n      UserID: zep.String(userID),\n      Query:  \"project discussions\",\n      Scope:  zep.GraphSearchScopeEdges.Ptr(),\n      SearchFilters: &zep.SearchFilters{\n          CreatedAt: [][]*zep.DateFilter{\n              // First condition graph (AND logic within)\n              {\n                  {\n                      ComparisonOperator: zep.ComparisonOperatorGreaterThanEqual,\n                      Date:              \"2025-07-01T20:57:56Z\",\n                  },\n                  {\n                      ComparisonOperator: zep.ComparisonOperatorLessThan,\n                      Date:              \"2025-08-01T20:57:56Z\",\n                  },\n              },\n              // Second condition graph (OR logic with first graph)\n              {\n                  {\n                      ComparisonOperator: zep.ComparisonOperatorLessThan,\n                      Date:              \"2025-05-01T20:57:56Z\",\n                  },\n              },\n          },\n      },\n  })\n  ```\n</CodeBlocks>\n\n**Common Use Cases:**\n\n* **Date Range Filtering**: Find facts from specific time periods using any timestamp type\n* **Recent Activity**: Search for edges created or expired after a certain date using `>=` operator\n* **Historical Data**: Find older information using `<` or `<=` operators on any timestamp\n* **Validity Period Analysis**: Use `valid_at` and `invalid_at` together to find facts that were true during specific periods\n* **Audit Trail**: Use `created_at` and `expired_at` to track when your system learned about changes\n* **Complex Temporal Queries**: Combine multiple date conditions across different timestamp types\n\n## ~~Filtering by Fact Rating~~ (deprecated)\n\n~~The `min_fact_rating` parameter allows you to filter search results based on the relevancy rating of facts stored in your graph edges. When specified, all facts returned will have at least the minimum rating value you set.~~\n\n~~This parameter accepts values between 0.0 and 1.0, where higher values indicate more relevant facts. By setting a minimum threshold, you can ensure that only highly relevant facts are included in your search results.~~\n\n~~**Important**: The `min_fact_rating` parameter can only be used when searching with `scope=\"edges\"` as fact ratings are associated with edge relationships.~~\n\n~~Read more about [fact ratings and how they work](/facts#rating-facts-for-relevancy).~~\n\n## Breadth-First Search (BFS)\n\nThe `bfs_origin_node_uuids` parameter enables breadth-first searches starting from specified nodes, which helps make search results more relevant to recent context. This is particularly useful when combined with recent episode IDs to bias search results toward information connected to recent conversations. You can pass episode IDs as BFS node IDs because episodes are represented as nodes under the hood.\n\n**When to use**: Use BFS when you want to find information that's contextually connected to specific starting points in your graph, such as recent episodes or important entities.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  # Get recent episodes to use as BFS origin points\n  episodes = client.graph.episode.get_by_user_id(\n      user_id=user_id,\n      lastn=10\n  ).episodes\n\n  episode_uuids = [episode.uuid_ for episode in episodes if episode.role == 'user']\n\n  # Search with BFS starting from recent episodes\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"project updates\",\n      scope=\"edges\",\n      bfs_origin_node_uuids=episode_uuids,\n      limit=10\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  // Get recent episodes to use as BFS origin points\n  const episodeResponse = await client.graph.episode.getByUserId(userId, { lastn: 10 });\n  const episodeUuids = (episodeResponse.episodes || [])\n      .filter((episode) => episode.role === \"user\")\n      .map((episode) => episode.uuid);\n\n  // Search with BFS starting from recent episodes\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"project updates\",\n    scope: \"edges\",\n    bfsOriginNodeUuids: episodeUuids,\n    limit: 10,\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  // Get recent episodes to use as BFS origin points\n  response, err := client.Graph.Episode.GetByUserID(\n      ctx,\n      userID,\n      &zep.EpisodeGetByUserIDRequest{\n          Lastn: zep.Int(10),\n      },\n  )\n\n  var episodeUUIDs []string\n  for _, episode := range response.Episodes {\n      if episode.Role != nil && *episode.Role == zep.RoleTypeUserRole {\n          episodeUUIDs = append(episodeUUIDs, episode.UUID)\n      }\n  }\n\n  // Search with BFS starting from recent episodes\n  searchResults, err := client.Graph.Search(ctx, &zep.GraphSearchQuery{\n      UserID:             zep.String(userID),\n      Query:              \"project updates\",\n      Scope:              zep.GraphSearchScopeEdges.Ptr(),\n      BfsOriginNodeUUIDs: episodeUUIDs,\n      Limit:              zep.Int(10),\n  })\n  ```\n</CodeBlocks>",
  "content_length": 38278
}