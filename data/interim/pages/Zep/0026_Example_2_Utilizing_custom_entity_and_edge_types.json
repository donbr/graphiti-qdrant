{
  "title": "Example 2: Utilizing custom entity and edge types",
  "source_url": null,
  "content": "## Search\n\nFor a custom context block that uses custom entity and edge types, we perform multiple searches (with our custom query string) filtering to the custom entity or edge type we want to include in the context block:\n\n<Tip>\n  These searches can be performed in parallel to reduce latency, using our [async Python client](/quickstart#initialize-the-client), TypeScript promises, or goroutines.\n</Tip>\n\n<CodeBlocks>\n  ```python\n  query = \"Find some food around here\"\n\n  search_results_restaurant_visits = client.graph.search(\n      query=query,\n      user_id=user_id,\n      scope='edges',\n      search_filters={\n          \"edge_types\": [\"RESTAURANT_VISIT\"]\n      },\n      reranker='cross_encoder',\n      limit=10\n  )\n  search_results_dietary_preferences = client.graph.search(\n      query=query,\n      user_id=user_id,\n      scope='edges',\n      search_filters={\n          \"edge_types\": [\"DIETARY_PREFERENCE\"]\n      },\n      reranker='cross_encoder',\n      limit=10\n  )\n  search_results_restaurants = client.graph.search(\n      query=query,\n      user_id=user_id,\n      scope='nodes',\n      search_filters={\n          \"node_labels\": [\"Restaurant\"]\n      },\n      reranker='cross_encoder',\n      limit=10\n  )\n  ```\n\n  ```typescript\n  query = \"Find some food around here\";\n\n  const searchResultsRestaurantVisits = await client.graph.search({\n      query,\n      userId: userId,\n      scope: \"edges\",\n      searchFilters: {\n          edgeTypes: [\"RESTAURANT_VISIT\"]\n      },\n      reranker: \"cross_encoder\",\n      limit: 10,\n  });\n\n  const searchResultsDietaryPreferences = await client.graph.search({\n      query,\n      userId: userId,\n      scope: \"edges\",\n      searchFilters: {\n          edgeTypes: [\"DIETARY_PREFERENCE\"]\n      },\n      reranker: \"cross_encoder\",\n      limit: 10,\n  });\n\n  const searchResultsRestaurants = await client.graph.search({\n      query,\n      userId: userId,\n      scope: \"nodes\",\n      searchFilters: {\n          nodeLabels: [\"Restaurant\"]\n      },\n      reranker: \"cross_encoder\",\n      limit: 10,\n  });\n  ```\n\n  ```go\n  query := \"Find some food around here\"\n\n  searchFiltersRestaurantVisits := zep.SearchFilters{EdgeTypes: []string{\"RESTAURANT_VISIT\"}}\n  searchResultsRestaurantVisits, err := client.Graph.Search(\n  \tctx,\n  \t&zep.GraphSearchQuery{\n  \t\tUserID:        zep.String(userID),\n  \t\tQuery:         query,\n  \t\tScope:         zep.GraphSearchScopeEdges.Ptr(),\n  \t\tSearchFilters: &searchFiltersRestaurantVisits,\n  \t\tReranker:      zep.RerankerCrossEncoder.Ptr(),\n  \t\tLimit:         zep.Int(10),\n  \t},\n  )\n  if err != nil {\n  \tfmt.Printf(\"Error searching graph (RESTAURANT_VISIT edges): %v\\n\", err)\n  \treturn\n  }\n\n  searchFiltersDietaryPreferences := zep.SearchFilters{EdgeTypes: []string{\"DIETARY_PREFERENCE\"}}\n  searchResultsDietaryPreferences, err := client.Graph.Search(\n  \tctx,\n  \t&zep.GraphSearchQuery{\n  \t\tUserID:        zep.String(userID),\n  \t\tQuery:         query,\n  \t\tScope:         zep.GraphSearchScopeEdges.Ptr(),\n  \t\tSearchFilters: &searchFiltersDietaryPreferences,\n  \t\tReranker:      zep.RerankerCrossEncoder.Ptr(),\n  \t\tLimit:         zep.Int(10),\n  \t},\n  )\n  if err != nil {\n  \tfmt.Printf(\"Error searching graph (DIETARY_PREFERENCE edges): %v\\n\", err)\n  \treturn\n  }\n\n  searchFiltersRestaurants := zep.SearchFilters{NodeLabels: []string{\"Restaurant\"}}\n  searchResultsRestaurants, err := client.Graph.Search(\n  \tctx,\n  \t&zep.GraphSearchQuery{\n  \t\tUserID:        zep.String(userID),\n  \t\tQuery:         query,\n  \t\tScope:         zep.GraphSearchScopeNodes.Ptr(),\n  \t\tSearchFilters: &searchFiltersRestaurants,\n  \t\tReranker:      zep.RerankerCrossEncoder.Ptr(),\n  \t\tLimit:         zep.Int(10),\n  \t},\n  )\n  if err != nil {\n  \tfmt.Printf(\"Error searching graph (Restaurant nodes): %v\\n\", err)\n  \treturn\n  }\n  ```\n</CodeBlocks>\n\n## Build the context block\n\nUsing the search results and a few helper functions, we can compose the context block. Note that in this example, we focus on unpacking the custom attributes of the nodes and edges, but this is a design choice that you can experiment with for your use case.\n\nNote also that we designed the context block template around the custom entity and edge types that we are unpacking into the context block:\n\n<CodeBlocks>\n  ```python\n  from zep_cloud import EntityEdge, EntityNode\n\n  CONTEXT_STRING_TEMPLATE = \"\"\"\n  PREVIOUS_RESTAURANT_VISITS, DIETARY_PREFERENCES, and RESTAURANTS represent relevant context to the current conversation.\n  # These are the most relevant restaurants the user has previously visited\n  # format: restaurant_name: RESTAURANT_NAME\n  <PREVIOUS_RESTAURANT_VISITS>\n  {restaurant_visits}\n  </PREVIOUS_RESTAURANT_VISITS>\n\n  # These are the most relevant dietary preferences of the user, whether they represent an allergy, and their valid date ranges\n  # format: allergy: True/False; preference_type: PREFERENCE_TYPE (Date range: from - to)\n  <DIETARY_PREFERENCES>\n  {dietary_preferences}\n  </DIETARY_PREFERENCES>\n\n  # These are the most relevant restaurants the user has discussed previously\n  # format: name: RESTAURANT_NAME; cuisine_type: CUISINE_TYPE; dietary_accommodation: DIETARY_ACCOMMODATION\n  <RESTAURANTS>\n  {restaurants}\n  </RESTAURANTS>\n  \"\"\"\n\n  def format_edge_with_attributes(edge: EntityEdge, include_timestamps: bool = True) -> str:\n      attrs_str = '; '.join(f\"{k}: {v}\" for k, v in sorted(edge.attributes.items()))\n      if include_timestamps:\n          valid_at = edge.valid_at if edge.valid_at is not None else \"date unknown\"\n          invalid_at = edge.invalid_at if edge.invalid_at is not None else \"present\"\n          return f\"  - {attrs_str} (Date range: {valid_at} - {invalid_at})\"\n      return f\"  - {attrs_str}\"\n\n  def format_node_with_attributes(node: EntityNode) -> str:\n      attributes = {k: v for k, v in node.attributes.items() if k != \"labels\"}\n      attrs_str = '; '.join(f\"{k}: {v}\" for k, v in sorted(attributes.items()))\n      base = f\"  - name: {node.name}; {attrs_str}\"\n      return base\n\n  def compose_context_block(restaurant_visit_edges: list[EntityEdge], dietary_preference_edges: list[EntityEdge], restaurant_nodes: list[EntityNode]) -> str:\n      restaurant_visits = [format_edge_with_attributes(edge, include_timestamps=False) for edge in restaurant_visit_edges]\n      dietary_preferences = [format_edge_with_attributes(edge, include_timestamps=True) for edge in dietary_preference_edges]\n      restaurant_nodes = [format_node_with_attributes(node) for node in restaurant_nodes]\n      return CONTEXT_STRING_TEMPLATE.format(restaurant_visits='\\n'.join(restaurant_visits), dietary_preferences='\\n'.join(dietary_preferences), restaurants='\\n'.join(restaurant_nodes))\n\n\n  restaurant_visit_edges = search_results_restaurant_visits.edges\n  dietary_preference_edges = search_results_dietary_preferences.edges\n  restaurant_nodes = search_results_restaurants.nodes\n\n  context_block = compose_context_block(restaurant_visit_edges, dietary_preference_edges, restaurant_nodes)\n  print(context_block)\n  ```\n\n  ```typescript\n  import type { EntityEdge, EntityNode } from \"@getzep/zep-cloud/api\";\n\n  const CONTEXT_STRING_TEMPLATE_2 = `PREVIOUS_RESTAURANT_VISITS, DIETARY_PREFERENCES, and RESTAURANTS represent relevant context to the current conversation.\n  # These are the most relevant restaurants the user has previously visited\n  # format: restaurant_name: RESTAURANT_NAME\n  <PREVIOUS_RESTAURANT_VISITS>\n  {restaurant_visits}\n  </PREVIOUS_RESTAURANT_VISITS>\n\n  # These are the most relevant dietary preferences of the user, whether they represent an allergy, and their valid date ranges\n  # format: allergy: True/False; preference_type: PREFERENCE_TYPE (Date range: from - to)\n  <DIETARY_PREFERENCES>\n  {dietary_preferences}\n  </DIETARY_PREFERENCES>\n\n  # These are the most relevant restaurants the user has discussed previously\n  # format: name: RESTAURANT_NAME; cuisine_type: CUISINE_TYPE; dietary_accommodation: DIETARY_ACCOMMODATION\n  <RESTAURANTS>\n  {restaurants}\n  </RESTAURANTS>`;\n\n  function formatEdgeWithAttributes(edge: EntityEdge, includeTimestamps = true): string {\n      const attrs = Object.entries(edge.attributes ?? {})\n          .sort(([a], [b]) => a.localeCompare(b))\n          .map(([k, v]) => `${k}: ${v}`)\n          .join('; ');\n      if (includeTimestamps) {\n          const validAt = edge.validAt ?? \"date unknown\";\n          const invalidAt = edge.invalidAt ?? \"present\";\n          return `  - ${attrs} (Date range: ${validAt} - ${invalidAt})`;\n      }\n      return `  - ${attrs}`;\n  }\n\n  function formatNodeWithAttributes(node: EntityNode): string {\n      const attributes = Object.entries(node.attributes ?? {})\n          .filter(([k]) => k !== \"labels\")\n          .sort(([a], [b]) => a.localeCompare(b))\n          .map(([k, v]) => `${k}: ${v}`)\n          .join('; ');\n      return `  - name: ${node.name}; ${attributes}`;\n  }\n\n  function composeContextBlock2(\n      restaurantVisitEdges: EntityEdge[],\n      dietaryPreferenceEdges: EntityEdge[],\n      restaurantNodes: EntityNode[]\n  ): string {\n      const restaurantVisits = restaurantVisitEdges.map(e => formatEdgeWithAttributes(e, false)).join('\\n');\n      const dietaryPreferences = dietaryPreferenceEdges.map(e => formatEdgeWithAttributes(e, true)).join('\\n');\n      const restaurants = restaurantNodes.map(n => formatNodeWithAttributes(n)).join('\\n');\n      return CONTEXT_STRING_TEMPLATE_2\n          .replace('{restaurant_visits}', restaurantVisits)\n          .replace('{dietary_preferences}', dietaryPreferences)\n          .replace('{restaurants}', restaurants);\n  }\n\n  const restaurantVisitEdges: EntityEdge[] = searchResultsRestaurantVisits.edges ?? [];\n  const dietaryPreferenceEdges: EntityEdge[] = searchResultsDietaryPreferences.edges ?? [];\n  const restaurantNodes: EntityNode[] = searchResultsRestaurants.nodes ?? [];\n\n  const contextBlock2 = composeContextBlock2(restaurantVisitEdges, dietaryPreferenceEdges, restaurantNodes);\n  console.log(contextBlock2);\n  ```\n\n  ```go\n  import (\n  \t\"strings\"\n  )\n  \t\n  const CONTEXT_STRING_TEMPLATE_2 = `PREVIOUS_RESTAURANT_VISITS, DIETARY_PREFERENCES, and RESTAURANTS represent relevant context to the current conversation.\n  # These are the most relevant restaurants the user has previously visited\n  # format: restaurant_name: RESTAURANT_NAME\n  <PREVIOUS_RESTAURANT_VISITS>\n  {restaurant_visits}\n  </PREVIOUS_RESTAURANT_VISITS>\n\n  # These are the most relevant dietary preferences of the user, whether they represent an allergy, and their valid date ranges\n  # format: allergy: True/False; preference_type: PREFERENCE_TYPE (Date range: from - to)\n  <DIETARY_PREFERENCES>\n  {dietary_preferences}\n  </DIETARY_PREFERENCES>\n\n  # These are the most relevant restaurants the user has discussed previously\n  # format: name: RESTAURANT_NAME; cuisine_type: CUISINE_TYPE; dietary_accommodation: DIETARY_ACCOMMODATION\n  <RESTAURANTS>\n  {restaurants}\n  </RESTAURANTS>`\n\n  formatEdgeWithAttributes := func(edge *zep.EntityEdge, includeTimestamps bool) string {\n  \tattrs := make([]string, 0)\n  \tfor _, k := range []string{\"allergy\", \"preference_type\", \"restaurant_name\"} {\n  \t\tif v, ok := edge.Attributes[k]; ok {\n  \t\t\tattrs = append(attrs, fmt.Sprintf(\"%s: %v\", k, v))\n  \t\t}\n  \t}\n  \tattrsStr := strings.Join(attrs, \"; \")\n  \tif includeTimestamps {\n  \t\tvalidAt := \"date unknown\"\n  \t\tif edge.ValidAt != nil && *edge.ValidAt != \"\" {\n  \t\t\tvalidAt = *edge.ValidAt\n  \t\t}\n  \t\tinvalidAt := \"present\"\n  \t\tif edge.InvalidAt != nil && *edge.InvalidAt != \"\" {\n  \t\t\tinvalidAt = *edge.InvalidAt\n  \t\t}\n  \t\treturn fmt.Sprintf(\"  - %s (Date range: %s - %s)\", attrsStr, validAt, invalidAt)\n  \t}\n  \treturn fmt.Sprintf(\"  - %s\", attrsStr)\n  }\n\n  formatNodeWithAttributes := func(node *zep.EntityNode) string {\n  \tattrs := make([]string, 0)\n  \tfor k, v := range node.Attributes {\n  \t\tif k == \"labels\" {\n  \t\t\tcontinue\n  \t\t}\n  \t\tattrs = append(attrs, fmt.Sprintf(\"%s: %v\", k, v))\n  \t}\n  \tattrsStr := strings.Join(attrs, \"; \")\n  \treturn fmt.Sprintf(\"  - name: %s; %s\", node.Name, attrsStr)\n  }\n\n  composeContextBlock2 := func(restaurantVisitEdges []*zep.EntityEdge, dietaryPreferenceEdges []*zep.EntityEdge, restaurantNodes []*zep.EntityNode) string {\n  \trestaurantVisits := make([]string, 0)\n  \tfor _, edge := range restaurantVisitEdges {\n  \t\trestaurantVisits = append(restaurantVisits, formatEdgeWithAttributes(edge, false))\n  \t}\n  \tdietaryPreferences := make([]string, 0)\n  \tfor _, edge := range dietaryPreferenceEdges {\n  \t\tdietaryPreferences = append(dietaryPreferences, formatEdgeWithAttributes(edge, true))\n  \t}\n  \trestaurants := make([]string, 0)\n  \tfor _, node := range restaurantNodes {\n  \t\trestaurants = append(restaurants, formatNodeWithAttributes(node))\n  \t}\n  \tresult := strings.ReplaceAll(CONTEXT_STRING_TEMPLATE_2, \"{restaurant_visits}\", strings.Join(restaurantVisits, \"\\n\"))\n  \tresult = strings.ReplaceAll(result, \"{dietary_preferences}\", strings.Join(dietaryPreferences, \"\\n\"))\n  \tresult = strings.ReplaceAll(result, \"{restaurants}\", strings.Join(restaurants, \"\\n\"))\n  \treturn result\n  }\n\n  restaurantVisitEdges := searchResultsRestaurantVisits.Edges\n  dietaryPreferenceEdges := searchResultsDietaryPreferences.Edges\n  restaurantNodes := searchResultsRestaurants.Nodes\n\n  contextBlock2 := composeContextBlock2(restaurantVisitEdges, dietaryPreferenceEdges, restaurantNodes)\n  fmt.Println(contextBlock2)\n  ```\n</CodeBlocks>\n\n```text\nPREVIOUS_RESTAURANT_VISITS, DIETARY_PREFERENCES, and RESTAURANTS represent relevant context to the current conversation.\n### These are the most relevant restaurants the user has previously visited\n### format: restaurant_name: RESTAURANT_NAME\n<PREVIOUS_RESTAURANT_VISITS>\n  - restaurant_name: Insomnia Cookies\n  - restaurant_name: Green Leaf Cafe\n</PREVIOUS_RESTAURANT_VISITS>\n \n### These are the most relevant dietary preferences of the user, whether they represent an allergy, and their valid date ranges\n### format: allergy: True/False; preference_type: PREFERENCE_TYPE (Date range: from - to)\n<DIETARY_PREFERENCES>\n  - allergy: False; preference_type: vegetarian (Date range: 2025-06-16T02:17:25Z - present)\n  - allergy: False; preference_type: lactose intolerance (Date range: 2025-06-16T02:17:25Z - present)\n</DIETARY_PREFERENCES>\n \n### These are the most relevant restaurants the user has discussed previously\n### format: name: RESTAURANT_NAME; cuisine_type: CUISINE_TYPE; dietary_accommodation: DIETARY_ACCOMMODATION\n<RESTAURANTS>\n  - name: Green Leaf Cafe; dietary_accommodation: vegetarian\n  - name: Insomnia Cookies; \n</RESTAURANTS>\n```",
  "content_length": 14442
}