{
  "title": "Threads",
  "source_url": null,
  "content": "## Overview\n\nThreads represent a conversation. Each [User](/users) can have multiple threads, and each thread is a sequence of chat messages.\n\nChat messages are added to threads using [`thread.add_messages`](/adding-memory#adding-messages), which both adds those messages to the thread history and ingests those messages into the user-level knowledge graph. The user knowledge graph contains data from all of that user's threads to create an integrated understanding of the user.\n\n<Note>\n  The knowledge graph does not separate the data from different threads, but integrates the data together to create a unified picture of the user. So the [get thread user context](/sdk-reference/thread/get-user-context) endpoint and the associated [`thread.get_user_context`](/retrieving-memory#zeps-context-block) method don't return memory derived only from that thread, but instead return whatever user-level memory is most relevant to that thread, based on the thread's most recent messages.\n</Note>\n\n## Adding a Thread\n\n`threadIds` are arbitrary identifiers that you can map to relevant business objects in your app, such as users or a\nconversation a user might have with your app. Before you create a thread, make sure you have [created a user](/users#adding-a-user) first. Then create a thread with:\n\n<CodeBlocks>\n  ```python Python\n  client = Zep(\n      api_key=API_KEY,\n  )\n  thread_id = uuid.uuid4().hex # A new thread identifier\n\n  client.thread.create(\n      thread_id=thread_id,\n      user_id=user_id,\n  )\n  ```\n\n  ```typescript TypeScript\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const threadId: string = uuid.v4(); // Generate a new thread identifier\n\n  await client.thread.create({\n    threadId: threadId,\n    userId: userId,\n  });\n  ```\n\n  ```go Go\n  import (\n  \t\"context\"\n  \t\"log\"\n\n  \t\"github.com/getzep/zep-go/v3\"\n  \tzepclient \"github.com/getzep/zep-go/v3/client\"\n  \t\"github.com/getzep/zep-go/v3/option\"\n  \t\"github.com/google/uuid\"\n  )\n\n  client := zepclient.NewClient(option.WithAPIKey(apiKey))\n\n  threadID := uuid.New().String() // Generate a new thread identifier\n\n  _, err := client.Thread.Create(context.TODO(), &zep.CreateThreadRequest{\n  \tThreadID: threadID,\n  \tUserID:   userID,\n  })\n  if err != nil {\n  \tlog.Fatalf(\"Failed to create thread: %v\", err)\n  }\n  ```\n</CodeBlocks>\n\n## Getting Messages of a Thread\n\n<CodeBlocks>\n  ```python Python\n  messages = client.thread.get(thread_id)\n  ```\n\n  ```typescript TypeScript\n  const messages = await client.thread.get(threadId);\n  ```\n\n  ```go Go\n  messages, err := client.Thread.Get(context.TODO(), threadID, &zep.ThreadGetRequest{})\n  if err != nil {\n  \tlog.Fatalf(\"Failed to get thread messages: %v\", err)\n  }\n  ```\n</CodeBlocks>\n\n## Deleting a Thread\n\nDeleting a thread deletes it and its associated messages. It does not however delete the associated data in the user's knowledge graph. To remove data from the graph, see [deleting data from the graph](/deleting-data-from-the-graph).\n\n<CodeBlocks>\n  ```python Python\n  client.thread.delete(thread_id)\n  ```\n\n  ```typescript TypeScript\n  await client.thread.delete(threadId);\n  ```\n\n  ```go Go\n  _, err := client.Thread.Delete(context.TODO(), threadID)\n  if err != nil {\n  \tlog.Fatalf(\"Failed to delete thread: %v\", err)\n  }\n  ```\n</CodeBlocks>\n\n## Listing Threads\n\nYou can list all Threads in the Zep Memory Store with page\\_size and page\\_number parameters for pagination.\n\n<CodeBlocks>\n  ```python Python\n  # List the first 10 Threads\n  result = client.thread.list_all(page_size=10, page_number=1)\n  for thread in result.threads:\n      print(thread)\n  ```\n\n  ```typescript TypeScript\n  // List the first 10 Threads\n  const { threads } = await client.thread.listAll({\n    pageSize: 10,\n    pageNumber: 1,\n  });\n  console.log(\"First 10 Threads:\");\n  threads.forEach((thread) => console.log(thread));\n  ```\n\n  ```go Go\n  // List the first 10 Threads\n  result, err := client.Thread.ListAll(context.TODO(), &zep.ThreadListAllRequest{\n  \tPageSize:   zep.Int(10),\n  \tPageNumber: zep.Int(1),\n  })\n  if err != nil {\n  \tlog.Fatalf(\"Failed to list threads: %v\", err)\n  }\n  for _, thread := range result.Threads {\n  \tlog.Printf(\"%+v\\n\", thread)\n  }\n  ```\n</CodeBlocks>\n\n## Automatic Cache Warming\n\nWhen you create a new thread, Zep automatically warms the cache for that user's graph data in the background. This optimization improves query latency for graph operations on newly created threads by pre-loading the user's data into the hot cache tier.\n\nThe warming operation runs asynchronously and does not block the thread creation response. No additional action is required on your partâ€”this happens automatically whenever you create a thread for a user with an existing graph.\n\nFor more information about Zep's multi-tier caching architecture and manual cache warming, see [Warming the User Cache](/performance#warming-the-user-cache).",
  "content_length": 4864
}