{
  "title": "Graph Namespacing",
  "source_url": null,
  "content": "> Using group_ids to create isolated graph namespaces\n\n## Overview\n\nGraphiti supports the concept of graph namespacing through the use of `group_id` parameters. This feature allows you to create isolated graph environments within the same Graphiti instance, enabling multiple distinct knowledge graphs to coexist without interference.\n\nGraph namespacing is particularly useful for:\n\n* **Multi-tenant applications**: Isolate data between different customers or organizations\n* **Testing environments**: Maintain separate development, testing, and production graphs\n* **Domain-specific knowledge**: Create specialized graphs for different domains or use cases\n* **Team collaboration**: Allow different teams to work with their own graph spaces\n\n## How Namespacing Works\n\nIn Graphiti, every node and edge can be associated with a `group_id`. When you specify a `group_id`, you're effectively creating a namespace for that data. Nodes and edges with the same `group_id` form a cohesive, isolated graph that can be queried and manipulated independently from other namespaces.\n\n### Key Benefits\n\n* **Data isolation**: Prevent data leakage between different namespaces\n* **Simplified management**: Organize and manage related data together\n* **Performance optimization**: Improve query performance by limiting the search space\n* **Flexible architecture**: Support multiple use cases within a single Graphiti instance\n\n## Using group\\_ids in Graphiti\n\n### Adding Episodes with group\\_id\n\nWhen adding episodes to your graph, you can specify a `group_id` to namespace the episode and all its extracted entities:\n\n```python\nawait graphiti.add_episode(\n    name=\"customer_interaction\",\n    episode_body=\"Customer Jane mentioned she loves our new SuperLight Wool Runners in Dark Grey.\",\n    source=EpisodeType.text,\n    source_description=\"Customer feedback\",\n    reference_time=datetime.now(),\n    group_id=\"customer_team\"  # This namespaces the episode and its entities\n)\n```\n\n### Adding Fact Triples with group\\_id\n\nWhen manually adding fact triples, ensure both nodes and the edge share the same `group_id`:\n\n```python\nfrom graphiti_core.nodes import EntityNode\nfrom graphiti_core.edges import EntityEdge\nimport uuid\nfrom datetime import datetime\n\n### Define a namespace for this data\nnamespace = \"product_catalog\"\n\n### Create source and target nodes with the namespace\nsource_node = EntityNode(\n    uuid=str(uuid.uuid4()),\n    name=\"SuperLight Wool Runners\",\n    group_id=namespace  # Apply namespace to source node\n)\n\ntarget_node = EntityNode(\n    uuid=str(uuid.uuid4()),\n    name=\"Sustainable Footwear\",\n    group_id=namespace  # Apply namespace to target node\n)\n\n### Create an edge with the same namespace\nedge = EntityEdge(\n    group_id=namespace,  # Apply namespace to edge\n    source_node_uuid=source_node.uuid,\n    target_node_uuid=target_node.uuid,\n    created_at=datetime.now(),\n    name=\"is_category_of\",\n    fact=\"SuperLight Wool Runners is a product in the Sustainable Footwear category\"\n)\n\n### Add the triplet to the graph\nawait graphiti.add_triplet(source_node, edge, target_node)\n```\n\n### Querying Within a Namespace\n\nWhen querying the graph, specify the `group_id` to limit results to a particular namespace:\n\n```python\n### Search within a specific namespace\nsearch_results = await graphiti.search(\n    query=\"Wool Runners\",\n    group_id=\"product_catalog\"  # Only search within this namespace\n)\n\n### For more advanced node-specific searches, use the _search method with a recipe\nfrom graphiti_core.search.search_config_recipes import NODE_HYBRID_SEARCH_RRF\n\n### Create a search config for nodes only\nnode_search_config = NODE_HYBRID_SEARCH_RRF.model_copy(deep=True)\nnode_search_config.limit = 5  # Limit to 5 results\n\n### Execute the node search within a specific namespace\nnode_search_results = await graphiti._search(\n    query=\"SuperLight Wool Runners\",\n    group_id=\"product_catalog\",  # Only search within this namespace\n    config=node_search_config\n)\n```\n\n## Best Practices for Graph Namespacing\n\n1. **Consistent naming**: Use a consistent naming convention for your `group_id` values\n2. **Documentation**: Maintain documentation of your namespace structure and purpose\n3. **Granularity**: Choose an appropriate level of granularity for your namespaces\n   * Too many namespaces can lead to fragmented data\n   * Too few namespaces may not provide sufficient isolation\n4. **Cross-namespace queries**: When necessary, perform multiple queries across namespaces and combine results in your application logic\n\n## Example: Multi-tenant Application\n\nHere's an example of using namespacing in a multi-tenant application:\n\n```python\nasync def add_customer_data(tenant_id, customer_data):\n    \"\"\"Add customer data to a tenant-specific namespace\"\"\"\n    \n    # Use the tenant_id as the namespace\n    namespace = f\"tenant_{tenant_id}\"\n    \n    # Create an episode for this customer data\n    await graphiti.add_episode(\n        name=f\"customer_data_{customer_data['id']}\",\n        episode_body=customer_data,\n        source=EpisodeType.json,\n        source_description=\"Customer profile update\",\n        reference_time=datetime.now(),\n        group_id=namespace  # Namespace by tenant\n    )\n\nasync def search_tenant_data(tenant_id, query):\n    \"\"\"Search within a tenant's namespace\"\"\"\n    \n    namespace = f\"tenant_{tenant_id}\"\n    \n    # Only search within this tenant's namespace\n    return await graphiti.search(\n        query=query,\n        group_id=namespace\n    )\n```",
  "content_length": 5474
}