{
  "title": "Autogen memory integration",
  "source_url": null,
  "content": "> Add persistent memory to Microsoft Autogen agents using the zep-autogen package.\n\nThe `zep-autogen` package provides seamless integration between Zep and Microsoft Autogen agents. Choose between [user-specific conversation memory](/users) or structured [knowledge graph memory](/graph-overview) for intelligent context retrieval.\n\n## Install dependencies\n\n<CodeBlocks>\n  ```bash pip\n  pip install zep-autogen zep-cloud autogen-core autogen-agentchat\n  ```\n\n  ```bash uv  \n  uv add zep-autogen zep-cloud autogen-core autogen-agentchat\n  ```\n\n  ```bash poetry\n  poetry add zep-autogen zep-cloud autogen-core autogen-agentchat\n  ```\n</CodeBlocks>\n\n## Environment setup\n\nSet your API keys as environment variables:\n\n```bash\nexport ZEP_API_KEY=\"your_zep_api_key\"\nexport OPENAI_API_KEY=\"your_openai_api_key\"\n```\n\n## Memory types\n\n**User Memory**: Stores conversation history in [user threads](/users) with automatic context injection\\\n**Knowledge Graph Memory**: Maintains structured knowledge with [custom entity models](/customizing-graph-structure)\n\n## User memory\n\n<Steps>\n  ### Step 1: Setup required imports\n\n  ```python\n  import os\n  import uuid\n  import asyncio\n  from autogen_agentchat.agents import AssistantAgent\n  from autogen_ext.models.openai import OpenAIChatCompletionClient\n  from autogen_core.memory import MemoryContent, MemoryMimeType\n  from zep_cloud.client import AsyncZep\n  from zep_autogen import ZepUserMemory\n  ```\n\n  ### Step 2: Initialize client and create user\n\n  ```python\n  # Initialize Zep client\n  zep_client = AsyncZep(api_key=os.environ.get(\"ZEP_API_KEY\"))\n  user_id = f\"user_{uuid.uuid4().hex[:16]}\"\n  thread_id = f\"thread_{uuid.uuid4().hex[:16]}\"\n\n  # Create user (required before using memory)\n  try:\n      await zep_client.user.add(\n          user_id=user_id,\n          email=\"alice@example.com\",\n          first_name=\"Alice\"\n      )\n  except Exception as e:\n      print(f\"User might already exist: {e}\")\n\n  # Create thread (required for conversation memory)\n  try:\n      await zep_client.thread.create(thread_id=thread_id, user_id=user_id)\n  except Exception as e:\n      print(f\"Thread creation failed: {e}\")\n  ```\n\n  ### Step 3: Create memory with configuration\n\n  ```python\n  # Create user memory with configuration\n  memory = ZepUserMemory(\n      client=zep_client,\n      user_id=user_id,\n      thread_id=thread_id\n  )\n  ```\n\n  ### Step 4: Create agent with memory\n\n  ```python\n  # Create agent with Zep memory\n  agent = AssistantAgent(\n      name=\"MemoryAwareAssistant\",\n      model_client=OpenAIChatCompletionClient(\n          model=\"gpt-4.1-mini\",\n          api_key=os.environ.get(\"OPENAI_API_KEY\")\n      ),\n      memory=[memory],\n      system_message=\"You are a helpful assistant with persistent memory.\"\n  )\n  ```\n\n  ### Step 5: Store messages and run conversations\n\n  ```python\n  # Helper function to store messages with proper metadata\n  async def add_message(message: str, role: str, name: str = None):\n      \"\"\"Store a message in Zep memory following AutoGen standards.\"\"\"\n      metadata = {\"type\": \"message\", \"role\": role}\n      if name:\n          metadata[\"name\"] = name\n      \n      await memory.add(MemoryContent(\n          content=message,\n          mime_type=MemoryMimeType.TEXT,\n          metadata=metadata\n      ))\n\n  # Example conversation with memory persistence\n  user_message = \"My name is Alice and I love hiking in the mountains.\"\n  print(f\"User: {user_message}\")\n\n  # Store user message\n  await add_message(user_message, \"user\", \"Alice\")\n\n  # Run agent - it will automatically retrieve context via update_context()\n  response = await agent.run(task=user_message)\n  agent_response = response.messages[-1].content\n  print(f\"Agent: {agent_response}\")\n\n  # Store agent response\n  await add_message(agent_response, \"assistant\")\n  ```\n</Steps>\n\n<Callout intent=\"info\">\n  **Automatic Context Injection**: ZepUserMemory automatically injects relevant conversation history and context via the `update_context()` method. The agent receives up to 10 recent messages plus context from Zep's Context Block.\n</Callout>\n\n## Knowledge graph memory\n\n<Steps>\n  ### Step 1: Define custom entity models\n\n  ```python\n  from zep_autogen.graph_memory import ZepGraphMemory\n  from zep_cloud.external_clients.ontology import EntityModel, EntityText\n  from pydantic import Field\n\n  # Define entity models using Pydantic\n  class ProgrammingLanguage(EntityModel):\n      \"\"\"A programming language entity.\"\"\"\n      paradigm: EntityText = Field(\n          description=\"programming paradigm (e.g., object-oriented, functional)\",\n          default=None\n      )\n      use_case: EntityText = Field(\n          description=\"primary use cases for this language\",\n          default=None\n      )\n\n  class Framework(EntityModel):\n      \"\"\"A software framework or library.\"\"\"\n      language: EntityText = Field(\n          description=\"the programming language this framework is built for\",\n          default=None\n      )\n      purpose: EntityText = Field(\n          description=\"primary purpose of this framework\",\n          default=None\n      )\n  ```\n\n  ### Step 2: Setup graph with ontology\n\n  ```python\n  from zep_cloud import SearchFilters\n\n  # Set ontology first\n  await zep_client.graph.set_ontology(\n      entities={\n          \"ProgrammingLanguage\": ProgrammingLanguage,\n          \"Framework\": Framework,\n      }\n  )\n\n  # Create graph\n  graph_id = f\"graph_{uuid.uuid4().hex[:16]}\"\n  try:\n      await zep_client.graph.create(\n          graph_id=graph_id,\n          name=\"Programming Knowledge Graph\"\n      )\n      print(f\"Created graph: {graph_id}\")\n  except Exception as e:\n      print(f\"Graph creation failed: {e}\")\n  ```\n\n  ### Step 3: Initialize graph memory with filters\n\n  ```python\n  # Create graph memory with search configuration\n  graph_memory = ZepGraphMemory(\n      client=zep_client,\n      graph_id=graph_id,\n      search_filters=SearchFilters(\n          node_labels=[\"ProgrammingLanguage\", \"Framework\"]\n      ),\n      facts_limit=20,  # Max facts in context injection (default: 20)\n      entity_limit=5   # Max entities in context injection (default: 5)\n  )\n  ```\n\n  ### Step 4: Add data and wait for indexing\n\n  ```python\n  # Add structured knowledge\n  await graph_memory.add(MemoryContent(\n      content=\"Python is excellent for data science and AI development\",\n      mime_type=MemoryMimeType.TEXT,\n      metadata={\"type\": \"data\"}  # \"data\" stores in graph, \"message\" stores as episode\n  ))\n\n  # Wait for graph processing (required)\n  print(\"Waiting for graph indexing...\")\n  await asyncio.sleep(30)  # Allow time for knowledge extraction\n\n  <Callout intent=\"info\">\n  **Graph Memory Context Injection**: ZepGraphMemory automatically retrieves the last 2 episodes from the graph and uses their content to query for relevant facts (up to `facts_limit`) and entities (up to `entity_limit`). This context is injected as a system message during agent interactions.\n  </Callout>\n  ```\n\n  ### Step 5: Create agent with graph memory\n\n  ```python\n  # Create agent with graph memory\n  agent = AssistantAgent(\n      name=\"GraphMemoryAssistant\",\n      model_client=OpenAIChatCompletionClient(model=\"gpt-4.1-mini\"),\n      memory=[graph_memory],\n      system_message=\"You are a technical assistant with programming knowledge.\"\n  )\n  ```\n</Steps>\n\n## Tools integration\n\nZep tools allow agents to search and add data directly to memory storage with manual control and structured responses.\n\n<Callout intent=\"warning\">\n  **Important**: Tools must be bound to either `graph_id` OR `user_id`, not both. This determines whether they operate on knowledge graphs or user graphs.\n</Callout>\n\n### Tool function parameters\n\n**Search Tool Parameters**:\n\n* `query`: str (required) - Search query text\n* `limit`: int (optional, default 10) - Maximum results to return\n* `scope`: str (optional, default \"edges\") - Search scope: \"edges\", \"nodes\", \"episodes\"\n\n**Add Tool Parameters**:\n\n* `data`: str (required) - Content to store\n* `data_type`: str (optional, default \"text\") - Data type: \"text\", \"json\", \"message\"\n\n### User graph tools\n\n```python\nfrom zep_autogen import create_search_graph_tool, create_add_graph_data_tool\n\n### Create tools bound to user graph\nsearch_tool = create_search_graph_tool(zep_client, user_id=user_id)\nadd_tool = create_add_graph_data_tool(zep_client, user_id=user_id)\n\n### Agent with user graph tools\nagent = AssistantAgent(\n    name=\"UserKnowledgeAssistant\",\n    model_client=OpenAIChatCompletionClient(model=\"gpt-4.1-mini\"),\n    tools=[search_tool, add_tool],\n    system_message=\"You can search and add data to the user's knowledge graph.\",\n    reflect_on_tool_use=True  # Enables tool usage reflection\n)\n```\n\n### Knowledge graph tools\n\n```python\n### Create tools bound to knowledge graph\nsearch_tool = create_search_graph_tool(zep_client, graph_id=graph_id)\nadd_tool = create_add_graph_data_tool(zep_client, graph_id=graph_id)\n\n### Agent with knowledge graph tools\nagent = AssistantAgent(\n    name=\"KnowledgeGraphAssistant\",\n    model_client=OpenAIChatCompletionClient(model=\"gpt-4.1-mini\"),\n    tools=[search_tool, add_tool],\n    system_message=\"You can search and add data to the knowledge graph.\",\n    reflect_on_tool_use=True\n)\n```\n\n## Query memory\n\nBoth memory types support direct querying with different scope parameters.\n\n### User memory queries\n\n```python\n### Query user conversation history  \nresults = await memory.query(\"What does Alice like?\", limit=5)\n\n### Process different result types\nfor result in results.results:\n    content = result.content\n    metadata = result.metadata\n    \n    if 'edge_name' in metadata:\n        # Fact/relationship result\n        print(f\"Fact: {content}\")\n        print(f\"Relationship: {metadata['edge_name']}\")\n        print(f\"Valid: {metadata.get('valid_at', 'N/A')} - {metadata.get('invalid_at', 'present')}\")\n    elif 'node_name' in metadata:\n        # Entity result\n        print(f\"Entity: {metadata['node_name']}\")\n        print(f\"Summary: {content}\")\n    else:\n        # Episode/message result\n        print(f\"Message: {content}\")\n        print(f\"Role: {metadata.get('episode_role', 'unknown')}\")\n    \n    print(f\"Source: {metadata.get('source')}\\n\")\n```\n\n### Graph memory queries\n\n```python\n### Query knowledge graph with scope control\nfacts_results = await graph_memory.query(\n    \"Python frameworks\", \n    limit=10, \n    scope=\"edges\"  # \"edges\" (facts), \"nodes\" (entities), \"episodes\" (messages)\n)\n\nprint(f\"Found {len(facts_results.results)} facts about Python frameworks:\")\nfor result in facts_results.results:\n    print(f\"- {result.content}\")\n    \nentities_results = await graph_memory.query(\n    \"programming languages\",\n    limit=5,\n    scope=\"nodes\"\n)\n\nprint(f\"\\nFound {len(entities_results.results)} programming language entities:\")\nfor result in entities_results.results:\n    entity_name = result.metadata.get('node_name', 'Unknown')\n    print(f\"- {entity_name}: {result.content}\")\n```\n\n### Search result structure\n\n<AccordionGroup>\n  <Accordion title=\"Edge results (facts)\">\n    ```json\n    {\n        \"content\": \"fact text\",\n        \"metadata\": {\n            \"source\": \"graph\" | \"user_graph\",\n            \"edge_name\": \"relationship_name\",\n            \"edge_attributes\": {...},\n            \"created_at\": \"timestamp\",\n            \"valid_at\": \"timestamp\",\n            \"invalid_at\": \"timestamp\",\n            \"expired_at\": \"timestamp\"\n        }\n    }\n    ```\n  </Accordion>\n\n  <Accordion title=\"Node results (entities)\">\n    ```json\n    {\n        \"content\": \"entity_name:\\n entity_summary\",\n        \"metadata\": {\n            \"source\": \"graph\" | \"user_graph\",\n            \"node_name\": \"entity_name\",\n            \"node_attributes\": {...},\n            \"created_at\": \"timestamp\"\n        }\n    }\n    ```\n  </Accordion>\n\n  <Accordion title=\"Episode results (messages)\">\n    ```json\n    {\n        \"content\": \"episode_content\",\n        \"metadata\": {\n            \"source\": \"graph\" | \"user_graph\",\n            \"episode_type\": \"source_type\",\n            \"episode_role\": \"role_type\",\n            \"episode_name\": \"role_name\",\n            \"created_at\": \"timestamp\"\n        }\n    }\n    ```\n  </Accordion>\n</AccordionGroup>\n\n## Memory vs tools comparison\n\n<Callout intent=\"note\">\n  **Memory Objects** (ZepUserMemory/ZepGraphMemory):\n\n  * Automatic context injection via `update_context()`\n  * Attached to agent's memory list\n  * Transparent operation - happens automatically\n  * Better for consistent memory across interactions\n\n  **Function Tools** (search/add tools):\n\n  * Manual control - agent decides when to use\n  * More explicit and observable operations\n  * Better for specific search/add operations\n  * Works with AutoGen's tool reflection features\n  * Provides structured return values\n\n  **Note**: Both approaches can be combined - using memory for automatic context and tools for explicit operations.\n</Callout>",
  "content_length": 12810
}