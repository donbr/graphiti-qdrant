{
  "title": "Check Data Ingestion Status",
  "source_url": null,
  "content": "Data added to Zep is processed asynchronously and can take a few seconds to a few minutes to finish processing. This recipe shows how to check whether data upload operations are finished processing.\n\nZep provides two methods for checking data ingestion status:\n\n* **Task polling** (recommended for async operations): Use `client.task.get()` to check the status of batch operations, clone operations, and fact triple additions\n* **Episode polling**: Use `graph.episode.get()` to check individual episode processing status\n\n## Checking Operation Status with Task Polling\n\nWhen using operations that return a `task_id`, you can poll for completion status using `client.task.get()`. The following operations return a `task_id`:\n\n* `graph.add_batch()` - Batch episode additions\n* `thread.add_messages_batch()` - Batch message additions to threads\n* `graph.clone()` - Graph cloning operations\n* `graph.add_fact_triple()` - Custom fact/node triplet additions\n\nThis is the recommended approach for these operations as it provides a single status check for the entire operation.\n\nFirst, let's create a user:\n\n<CodeBlocks>\n  ```python\n  import os\n  import uuid\n  import time\n  from dotenv import find_dotenv, load_dotenv\n  from zep_cloud.client import Zep\n  from zep_cloud import EpisodeData\n\n  load_dotenv(dotenv_path=find_dotenv())\n\n  client = Zep(api_key=os.environ.get(\"ZEP_API_KEY\"))\n  uuid_value = uuid.uuid4().hex[:4]\n  user_id = \"-\" + uuid_value\n  client.user.add(\n      user_id=user_id,\n      first_name=\"John\",\n      last_name=\"Doe\",\n      email=\"john.doe@example.com\"\n  )\n  ```\n\n  ```typescript\n  import { ZepClient, EpisodeData } from \"@getzep/zep-cloud\";\n  import * as dotenv from \"dotenv\";\n  import { v4 as uuidv4 } from 'uuid';\n\n  // Load environment variables\n  dotenv.config();\n\n  const client = new ZepClient({ apiKey: process.env.ZEP_API_KEY || \"\" });\n  const uuidValue = uuidv4().substring(0, 4);\n  const userId = \"-\" + uuidValue;\n\n  async function main() {\n    // Add user\n    await client.user.add({\n      userId: userId,\n      firstName: \"John\",\n      lastName: \"Doe\",\n      email: \"john.doe@example.com\"\n    });\n  ```\n\n  ```go\n  package main\n\n  import (\n  \t\"context\"\n  \t\"fmt\"\n  \t\"os\"\n  \t\"strings\"\n  \t\"time\"\n\n  \t\"github.com/getzep/zep-go/v3\"\n  \tzepclient \"github.com/getzep/zep-go/v3/client\"\n  \t\"github.com/getzep/zep-go/v3/option\"\n  \t\"github.com/google/uuid\"\n  \t\"github.com/joho/godotenv\"\n  )\n\n  func main() {\n  \t// Load .env file\n  \terr := godotenv.Load()\n  \tif err != nil {\n  \t\tfmt.Println(\"Warning: Error loading .env file:\", err)\n  \t}\n\n  \t// Get API key from environment variable\n  \tapiKey := os.Getenv(\"ZEP_API_KEY\")\n  \tif apiKey == \"\" {\n  \t\tfmt.Println(\"ZEP_API_KEY environment variable is not set\")\n  \t\treturn\n  \t}\n\n  \t// Initialize Zep client\n  \tclient := zepclient.NewClient(\n  \t\toption.WithAPIKey(apiKey),\n  \t)\n\n  \t// Create a UUID\n  \tuuidValue := strings.ToLower(uuid.New().String()[:4])\n  \tuserID := \"-\" + uuidValue\n  \tctx := context.Background()\n\n  \t// Add a user\n  \tuserRequest := &zep.CreateUserRequest{\n  \t\tUserID:    zep.String(userID),\n  \t\tFirstName: zep.String(\"John\"),\n  \t\tLastName:  zep.String(\"Doe\"),\n  \t\tEmail:     zep.String(\"john.doe@example.com\"),\n  \t}\n  \t_, err = client.User.Add(ctx, userRequest)\n  \tif err != nil {\n  \t\tfmt.Printf(\"Error creating user: %v\\n\", err)\n  \t\treturn\n  \t}\n  ```\n</CodeBlocks>\n\nNow, let's add a batch of episodes to the graph. The response includes a `task_id` in each episode that we can use to check the processing status:\n\n<CodeBlocks>\n  ```python\n  # Add batch data to the graph\n  episodes = [\n      EpisodeData(\n          data=\"The user is an avid fan of Eric Clapton\",\n          type=\"text\"\n      ),\n      EpisodeData(\n          data=\"The user attended a concert last night\",\n          type=\"text\"\n      ),\n      EpisodeData(\n          data=\"The user plays guitar as a hobby\",\n          type=\"text\"\n      )\n  ]\n\n  batch_result = client.graph.add_batch(\n      graph_id=user_id,\n      episodes=episodes\n  )\n\n  # Get the task_id from the first episode (all episodes in a batch share the same task_id)\n  task_id = batch_result[0].task_id\n  print(f\"Batch processing task ID: {task_id}\")\n  ```\n\n  ```typescript\n    // Add batch data to the graph\n    const episodes: EpisodeData[] = [\n      {\n        data: \"The user is an avid fan of Eric Clapton\",\n        type: \"text\"\n      },\n      {\n        data: \"The user attended a concert last night\",\n        type: \"text\"\n      },\n      {\n        data: \"The user plays guitar as a hobby\",\n        type: \"text\"\n      }\n    ];\n\n    const batchResult = await client.graph.addBatch({\n      graphId: userId,\n      episodes: episodes\n    });\n\n    // Get the task_id from the first episode (all episodes in a batch share the same task_id)\n    const taskId = batchResult[0].taskId;\n    console.log(`Batch processing task ID: ${taskId}`);\n  ```\n\n  ```go\n  \t// Add batch data to the graph\n  \tepisodes := []*zep.EpisodeData{\n  \t\t{\n  \t\t\tData: \"The user is an avid fan of Eric Clapton\",\n  \t\t\tType: zep.GraphDataTypeText,\n  \t\t},\n  \t\t{\n  \t\t\tData: \"The user attended a concert last night\",\n  \t\t\tType: zep.GraphDataTypeText,\n  \t\t},\n  \t\t{\n  \t\t\tData: \"The user plays guitar as a hobby\",\n  \t\t\tType: zep.GraphDataTypeText,\n  \t\t},\n  \t}\n\n  \tbatchResult, err := client.Graph.AddBatch(ctx, &zep.AddDataBatchRequest{\n  \t\tGraphID:  zep.String(userID),\n  \t\tEpisodes: episodes,\n  \t})\n  \tif err != nil {\n  \t\tfmt.Printf(\"Error adding batch data: %v\\n\", err)\n  \t\treturn\n  \t}\n\n  \t// Get the task_id from the first episode (all episodes in a batch share the same task_id)\n  \ttaskID := batchResult[0].TaskID\n  \tfmt.Printf(\"Batch processing task ID: %s\\n\", *taskID)\n  ```\n</CodeBlocks>\n\nNow we can poll the task status using `client.task.get()` to check when the entire batch has finished processing:\n\n<CodeBlocks>\n  ```python\n  # Poll the task status until completion\n  while True:\n      task = client.task.get(task_id=task_id)\n\n      if task.status == \"completed\":\n          print(\"Batch processing completed successfully\")\n          break\n      elif task.status == \"failed\":\n          print(f\"Batch processing failed: {task.error}\")\n          break\n\n      print(f\"Batch processing status: {task.status}\")\n      time.sleep(1)\n  ```\n\n  ```typescript\n    // Poll the task status until completion\n    const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n    while (true) {\n      const task = await client.task.get(taskId);\n\n      if (task.status === \"completed\") {\n        console.log(\"Batch processing completed successfully\");\n        break;\n      } else if (task.status === \"failed\") {\n        console.log(`Batch processing failed: ${task.error}`);\n        break;\n      }\n\n      console.log(`Batch processing status: ${task.status}`);\n      await sleep(1000);\n    }\n  ```\n\n  ```go\n  \t// Poll the task status until completion\n  \tfor {\n  \t\ttask, err := client.Task.Get(ctx, *taskID)\n  \t\tif err != nil {\n  \t\t\tfmt.Printf(\"Error getting task: %v\\n\", err)\n  \t\t\treturn\n  \t\t}\n\n  \t\tif task.Status == \"completed\" {\n  \t\t\tfmt.Println(\"Batch processing completed successfully\")\n  \t\t\tbreak\n  \t\t} else if task.Status == \"failed\" {\n  \t\t\tfmt.Printf(\"Batch processing failed: %v\\n\", task.Error)\n  \t\t\tbreak\n  \t\t}\n\n  \t\tfmt.Printf(\"Batch processing status: %s\\n\", task.Status)\n  \t\ttime.Sleep(1 * time.Second)\n  \t}\n  ```\n</CodeBlocks>\n\nOnce the batch is complete, you can search for the data that was added:\n\n<CodeBlocks>\n  ```python\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"Eric Clapton\",\n      scope=\"nodes\",\n      limit=1,\n      reranker=\"cross_encoder\",\n  )\n\n  print(search_results.nodes)\n  ```\n\n  ```typescript\n    const searchResults = await client.graph.search({\n      userId: userId,\n      query: \"Eric Clapton\",\n      scope: \"nodes\",\n      limit: 1,\n      reranker: \"cross_encoder\"\n    });\n\n    console.log(searchResults.nodes);\n  }\n\n  main().catch(error => console.error(\"Error:\", error));\n  ```\n\n  ```go\n  \tsearchResults, err := client.Graph.Search(ctx, &zep.GraphSearchQuery{\n  \t\tUserID:   zep.String(userID),\n  \t\tQuery:    \"Eric Clapton\",\n  \t\tScope:    zep.GraphSearchScopeNodes.Ptr(),\n  \t\tLimit:    zep.Int(1),\n  \t\tReranker: zep.RerankerCrossEncoder.Ptr(),\n  \t})\n  \tif err != nil {\n  \t\tfmt.Printf(\"Error searching graph: %v\\n\", err)\n  \t\treturn\n  \t}\n\n  \tfmt.Println(searchResults.Nodes)\n  }\n  ```\n</CodeBlocks>\n\n## Checking Individual Episode Status with Episode Polling\n\nFor single episode operations or when you need to check the status of individual episodes, you can use the `graph.episode.get()` method. This approach is useful when adding data one episode at a time.\n\nFirst, let's create a user:\n\n<CodeBlocks>\n  ```python\n  import os\n  import uuid\n  import time\n  from dotenv import find_dotenv, load_dotenv\n  from zep_cloud.client import Zep\n\n  load_dotenv(dotenv_path=find_dotenv())\n\n  client = Zep(api_key=os.environ.get(\"ZEP_API_KEY\"))\n  uuid_value = uuid.uuid4().hex[:4]\n  user_id = \"-\" + uuid_value\n  client.user.add(\n      user_id=user_id,\n      first_name = \"John\",\n      last_name = \"Doe\",\n      email=\"john.doe@example.com\"\n  )\n  ```\n\n  ```typescript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n  import * as dotenv from \"dotenv\";\n  import { v4 as uuidv4 } from 'uuid';\n\n  // Load environment variables\n  dotenv.config();\n\n  const client = new ZepClient({ apiKey: process.env.ZEP_API_KEY || \"\" });\n  const uuidValue = uuidv4().substring(0, 4);\n  const userId = \"-\" + uuidValue;\n\n  async function main() {\n    // Add user\n    await client.user.add({\n      userId: userId,\n      firstName: \"John\",\n      lastName: \"Doe\",\n      email: \"john.doe@example.com\"\n    });\n  ```\n\n  ```go\n  package main\n\n  import (\n  \t\"context\"\n  \t\"fmt\"\n  \t\"os\"\n  \t\"strings\"\n  \t\"time\"\n\n  \t\"github.com/getzep/zep-go/v3\"\n  \tzepclient \"github.com/getzep/zep-go/v3/client\"\n  \t\"github.com/getzep/zep-go/v3/option\"\n  \t\"github.com/google/uuid\"\n  \t\"github.com/joho/godotenv\"\n  )\n\n  func main() {\n  \t// Load .env file\n  \terr := godotenv.Load()\n  \tif err != nil {\n  \t\tfmt.Println(\"Warning: Error loading .env file:\", err)\n  \t\t// Continue execution as environment variables might be set in the system\n  \t}\n\n  \t// Get API key from environment variable\n  \tapiKey := os.Getenv(\"ZEP_API_KEY\")\n  \tif apiKey == \"\" {\n  \t\tfmt.Println(\"ZEP_API_KEY environment variable is not set\")\n  \t\treturn\n  \t}\n\n  \t// Initialize Zep client\n  \tclient := zepclient.NewClient(\n  \t\toption.WithAPIKey(apiKey),\n  \t)\n\n  \t// Create a UUID\n  \tuuidValue := strings.ToLower(uuid.New().String()[:4])\n\n  \t// Create user ID\n  \tuserID := \"-\" + uuidValue\n\n  \t// Create context\n  \tctx := context.Background()\n\n  \t// Add a user\n  \tuserRequest := &zep.CreateUserRequest{\n  \t\tUserID:    zep.String(userID),\n  \t\tFirstName: zep.String(\"John\"),\n  \t\tLastName:  zep.String(\"Doe\"),\n  \t\tEmail:     zep.String(\"john.doe@example.com\"),\n  \t}\n  \t_, err = client.User.Add(ctx, userRequest)\n  \tif err != nil {\n  \t\tfmt.Printf(\"Error creating user: %v\\n\", err)\n  \t\treturn\n  \t}\n  ```\n</CodeBlocks>\n\nNow, let's add some data and immediately try to search for that data; because data added to Zep is processed asynchronously and can take a few seconds to a few minutes to finish processing, our search results do not have the data we just added:\n\n<CodeBlocks>\n  ```python\n  episode = client.graph.add(\n      user_id=user_id,\n      type=\"text\", \n      data=\"The user is an avid fan of Eric Clapton\"\n  )\n\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"Eric Clapton\",\n      scope=\"nodes\",\n      limit=1,\n      reranker=\"cross_encoder\",\n  )\n\n  print(search_results.nodes)\n  ```\n\n  ```typescript\n    // Add episode to graph\n    const episode = await client.graph.add({\n      userId: userId,\n      type: \"text\",\n      data: \"The user is an avid fan of Eric Clapton\"\n    });\n\n    // Search for nodes related to Eric Clapton\n    const searchResults = await client.graph.search({\n      userId: userId,\n      query: \"Eric Clapton\",\n      scope: \"nodes\",\n      limit: 1,\n      reranker: \"cross_encoder\"\n    });\n\n    console.log(searchResults.nodes);\n  ```\n\n  ```go\n  \t// Add a new episode to the graph\n  \tepisode, err := client.Graph.Add(ctx, &zep.AddDataRequest{\n  \t\tGraphID: zep.String(userID),\n  \t\tType:    zep.GraphDataTypeText.Ptr(),\n  \t\tData:    zep.String(\"The user is an avid fan of Eric Clapton\"),\n  \t})\n  \tif err != nil {\n  \t\tfmt.Printf(\"Error adding episode to graph: %v\\n\", err)\n  \t\treturn\n  \t}\n\n  \t// Search for the data\n  \tsearchResults, err := client.Graph.Search(ctx, &zep.GraphSearchQuery{\n  \t\tUserID:  zep.String(userID),\n  \t\tQuery:   \"Eric Clapton\",\n  \t\tScope:   zep.GraphSearchScopeNodes.Ptr(),\n  \t\tLimit:   zep.Int(1),\n  \t\tReranker: zep.RerankerCrossEncoder.Ptr(),\n  \t})\n  \tif err != nil {\n  \t\tfmt.Printf(\"Error searching graph: %v\\n\", err)\n  \t\treturn\n  \t}\n\n  \tfmt.Println(searchResults.Nodes)\n  ```\n</CodeBlocks>\n\n```text\nNone\n```\n\nWe can check the status of the episode to see when it has finished processing, using the episode returned from the `graph.add` method and the `graph.episode.get` method:\n\n<CodeBlocks>\n  ```python\n  while True:\n      episode = client.graph.episode.get(\n          uuid_=episode.uuid_,\n      )\n      if episode.processed:\n          print(\"Episode processed successfully\")\n          break\n      print(\"Waiting for episode to process...\")\n      time.sleep(1)\n  ```\n\n  ```typescript\n    // Check if episode is processed\n    const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n    \n    let processedEpisode = await client.graph.episode.get(episode.uuid);\n    \n    while (!processedEpisode.processed) {\n      console.log(\"Waiting for episode to process...\");\n      await sleep(1000); // Sleep for 1 second\n      processedEpisode = await client.graph.episode.get(episode.uuid);\n    }\n    \n    console.log(\"Episode processed successfully\");\n  ```\n\n  ```go\n  \t// Wait for the episode to be processed\n  \tfor {\n  \t\tepisodeStatus, err := client.Graph.Episode.Get(\n  \t\t\tctx,\n  \t\t\tepisode.UUID,\n  \t\t)\n  \t\tif err != nil {\n  \t\t\tfmt.Printf(\"Error getting episode: %v\\n\", err)\n  \t\t\treturn\n  \t\t}\n\n  \t\tif episodeStatus.Processed != nil && *episodeStatus.Processed {\n  \t\t\tfmt.Println(\"Episode processed successfully\")\n  \t\t\tbreak\n  \t\t}\n\n  \t\tfmt.Println(\"Waiting for episode to process...\")\n  \t\ttime.Sleep(1 * time.Second)\n  \t}\n  ```\n</CodeBlocks>\n\n```text\nWaiting for episode to process...\nWaiting for episode to process...\nWaiting for episode to process...\nWaiting for episode to process...\nWaiting for episode to process...\nEpisode processed successfully\n```\n\nNow that the episode has finished processing, we can search for the data we just added, and this time we get a result:\n\n<CodeBlocks>\n  ```python\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"Eric Clapton\",\n      scope=\"nodes\",\n      limit=1,\n      reranker=\"cross_encoder\",\n  )\n\n  print(search_results.nodes)\n  ```\n\n  ```typescript\n    // Search again after processing\n    const finalSearchResults = await client.graph.search({\n      userId: userId,\n      query: \"Eric Clapton\",\n      scope: \"nodes\",\n      limit: 1,\n      reranker: \"cross_encoder\"\n    });\n\n    console.log(finalSearchResults.nodes);\n  }\n\n  // Execute the main function\n  main().catch(error => console.error(\"Error:\", error));\n  ```\n\n  ```go\n  \t// Search again after processing\n  \tsearchResults, err = client.Graph.Search(ctx, &zep.GraphSearchQuery{\n  \t\tUserID:  zep.String(userID),\n  \t\tQuery:   \"Eric Clapton\",\n  \t\tScope:   zep.GraphSearchScopeNodes.Ptr(),\n  \t\tLimit:   zep.Int(1),\n  \t\tReranker: zep.RerankerCrossEncoder.Ptr(),\n  \t})\n  \tif err != nil {\n  \t\tfmt.Printf(\"Error searching graph: %v\\n\", err)\n  \t\treturn\n  \t}\n\n  \tfmt.Println(searchResults.Nodes)\n  }\n  ```\n</CodeBlocks>\n\n```text\n[EntityNode(attributes={'category': 'Music', 'labels': ['Entity', 'Preference']}, created_at='2025-04-05T00:17:59.66565Z', labels=['Entity', 'Preference'], name='Eric Clapton', summary='The user is an avid fan of Eric Clapton.', uuid_='98808054-38ad-4cba-ba07-acd5f7a12bc0', graph_id='6961b53f-df05-48bb-9b8d-b2702dd72045')]\n```",
  "content_length": 16003
}