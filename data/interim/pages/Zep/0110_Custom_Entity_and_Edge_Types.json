{
  "title": "Custom Entity and Edge Types",
  "source_url": null,
  "content": "> Enhancing Graphiti with Custom Ontologies\n\nGraphiti allows you to define custom entity types and edge types to better represent your domain-specific knowledge. This enables more structured data extraction and richer semantic relationships in your knowledge graph.\n\n## Defining Custom Entity and Edge Types\n\nCustom entity types and edge types are defined using Pydantic models. Each model represents a specific type with custom attributes.\n\n```python\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\nfrom typing import Optional\n\n### Custom Entity Types\nclass Person(BaseModel):\n    \"\"\"A person entity with biographical information.\"\"\"\n    age: Optional[int] = Field(None, description=\"Age of the person\")\n    occupation: Optional[str] = Field(None, description=\"Current occupation\")\n    location: Optional[str] = Field(None, description=\"Current location\")\n    birth_date: Optional[datetime] = Field(None, description=\"Date of birth\")\n\nclass Company(BaseModel):\n    \"\"\"A business organization.\"\"\"\n    industry: Optional[str] = Field(None, description=\"Primary industry\")\n    founded_year: Optional[int] = Field(None, description=\"Year company was founded\")\n    headquarters: Optional[str] = Field(None, description=\"Location of headquarters\")\n    employee_count: Optional[int] = Field(None, description=\"Number of employees\")\n\nclass Product(BaseModel):\n    \"\"\"A product or service.\"\"\"\n    category: Optional[str] = Field(None, description=\"Product category\")\n    price: Optional[float] = Field(None, description=\"Price in USD\")\n    release_date: Optional[datetime] = Field(None, description=\"Product release date\")\n\n### Custom Edge Types\nclass Employment(BaseModel):\n    \"\"\"Employment relationship between a person and company.\"\"\"\n    position: Optional[str] = Field(None, description=\"Job title or position\")\n    start_date: Optional[datetime] = Field(None, description=\"Employment start date\")\n    end_date: Optional[datetime] = Field(None, description=\"Employment end date\")\n    salary: Optional[float] = Field(None, description=\"Annual salary in USD\")\n    is_current: Optional[bool] = Field(None, description=\"Whether employment is current\")\n\nclass Investment(BaseModel):\n    \"\"\"Investment relationship between entities.\"\"\"\n    amount: Optional[float] = Field(None, description=\"Investment amount in USD\")\n    investment_type: Optional[str] = Field(None, description=\"Type of investment (equity, debt, etc.)\")\n    stake_percentage: Optional[float] = Field(None, description=\"Percentage ownership\")\n    investment_date: Optional[datetime] = Field(None, description=\"Date of investment\")\n\nclass Partnership(BaseModel):\n    \"\"\"Partnership relationship between companies.\"\"\"\n    partnership_type: Optional[str] = Field(None, description=\"Type of partnership\")\n    duration: Optional[str] = Field(None, description=\"Expected duration\")\n    deal_value: Optional[float] = Field(None, description=\"Financial value of partnership\")\n```\n\n## Using Custom Entity and Edge Types\n\nPass your custom entity types and edge types to the add\\_episode method:\n\n```python\nentity_types = {\n    \"Person\": Person,\n    \"Company\": Company,\n    \"Product\": Product\n}\n\nedge_types = {\n    \"Employment\": Employment,\n    \"Investment\": Investment,\n    \"Partnership\": Partnership\n}\n\nedge_type_map = {\n    (\"Person\", \"Company\"): [\"Employment\"],\n    (\"Company\", \"Company\"): [\"Partnership\", \"Investment\"],\n    (\"Person\", \"Person\"): [\"Partnership\"],\n    (\"Entity\", \"Entity\"): [\"Investment\"],  # Apply to any entity type\n}\n\nawait graphiti.add_episode(\n    name=\"Business Update\",\n    episode_body=\"Sarah joined TechCorp as CTO in January 2023 with a $200K salary. TechCorp partnered with DataCorp in a $5M deal.\",\n    source_description=\"Business news\",\n    reference_time=datetime.now(),\n    entity_types=entity_types,\n    edge_types=edge_types,\n    edge_type_map=edge_type_map\n)\n```\n\n## Searching with Custom Types\n\nYou can filter search results to specific entity types or edge types using SearchFilters:\n\n```python\nfrom graphiti_core.search.search_filters import SearchFilters\n\n### Search for only specific entity types\nsearch_filter = SearchFilters(\n    node_labels=[\"Person\", \"Company\"]  # Only return Person and Company entities\n)\n\nresults = await graphiti.search_(\n    query=\"Who works at tech companies?\",\n    search_filter=search_filter\n)\n\n### Search for only specific edge types\nsearch_filter = SearchFilters(\n    edge_types=[\"Employment\", \"Partnership\"]  # Only return Employment and Partnership edges\n)\n\nresults = await graphiti.search_(\n    query=\"Tell me about business relationships\",\n    search_filter=search_filter\n)\n```\n\n## How Custom Types Work\n\n### Entity Extraction Process\n\n1. **Extraction**: Graphiti extracts entities from text and classifies them using your custom types\n2. **Validation**: Each entity is validated against the appropriate Pydantic model\n3. **Attribute Population**: Custom attributes are extracted from the text and populated\n4. **Storage**: Entities are stored with their custom attributes\n\n### Edge Extraction Process\n\n1. **Relationship Detection**: Graphiti identifies relationships between extracted entities\n2. **Type Classification**: Based on the entity types involved and your edge\\_type\\_map, relationships are classified\n3. **Attribute Extraction**: For custom edge types, additional attributes are extracted from the context\n4. **Validation**: Edge attributes are validated against the Pydantic model\n5. **Storage**: Edges are stored with their custom attributes and relationship metadata\n\n## Edge Type Mapping\n\nThe edge\\_type\\_map parameter defines which edge types can exist between specific entity type pairs:\n\n```python\nedge_type_map = {\n    (\"Person\", \"Company\"): [\"Employment\"],\n    (\"Company\", \"Company\"): [\"Partnership\", \"Investment\"],\n    (\"Person\", \"Person\"): [\"Partnership\"],\n    (\"Entity\", \"Entity\"): [\"Investment\"],  # Apply to any entity type\n}\n```\n\nIf an entity pair doesn't have a defined edge type mapping, Graphiti will use default relationship types and the relationship will still be captured with a generic RELATES\\_TO type.\n\n## Schema Evolution\n\nYour knowledge graph's schema can evolve over time as your needs change. You can update entity types by adding new attributes to existing types without breaking existing nodes. When you add new attributes, existing nodes will preserve their original attributes while supporting the new ones for future updates. This flexible approach allows your knowledge graph to grow and adapt while maintaining backward compatibility with historical data.\n\nFor example, if you initially defined a \"Customer\" type with basic attributes like name and email, you could later add attributes like \"loyalty\\_tier\" or \"acquisition\\_channel\" without needing to modify or migrate existing customer nodes in your graph.\n\n## Best Practices\n\n### Model Design\n\n* **Clear Descriptions**: Always include detailed descriptions in docstrings and Field descriptions\n* **Optional Fields**: Make custom attributes optional to handle cases where information isn't available\n* **Appropriate Types**: Use specific types (datetime, int, float) rather than strings when possible\n* **Validation**: Consider adding Pydantic validators for complex validation rules\n* **Atomic Attributes**: Attributes should be broken down into their smallest meaningful units rather than storing compound information\n\n```python\nfrom pydantic import validator\n\nclass Person(BaseModel):\n    \"\"\"A person entity.\"\"\"\n    age: Optional[int] = Field(None, description=\"Age in years\")\n    \n    @validator('age')\n    def validate_age(cls, v):\n        if v is not None and (v < 0 or v > 150):\n            raise ValueError('Age must be between 0 and 150')\n        return v\n```\n\n**Instead of compound information:**\n\n```python\nclass Customer(BaseModel):\n    contact_info: Optional[str] = Field(None, description=\"Name and email\")  # Don't do this\n```\n\n**Use atomic attributes:**\n\n```python\nclass Customer(BaseModel):\n    name: Optional[str] = Field(None, description=\"Customer name\")\n    email: Optional[str] = Field(None, description=\"Customer email address\")\n```\n\n### Naming Conventions\n\n* **Entity Types**: Use PascalCase (e.g., Person, TechCompany)\n* **Edge Types**: Use PascalCase for custom types (e.g., Employment, Partnership)\n* **Attributes**: Use snake\\_case (e.g., start\\_date, employee\\_count)\n* **Descriptions**: Be specific and actionable for the LLM\n* **Consistency**: Maintain consistent naming conventions across related entity types\n\n### Edge Type Mapping Strategy\n\n* **Specific Mappings**: Define specific entity type pairs for targeted relationships\n* **Fallback to Entity**: Use (\"Entity\", \"Entity\") as a fallback for general relationships\n* **Balanced Scope**: Don't make edge types too specific or too general\n* **Domain Coverage**: Ensure your edge types cover the main relationships in your domain\n\n```python\n### Good: Specific and meaningful\nedge_type_map = {\n    (\"Person\", \"Company\"): [\"Employment\", \"Investment\"],\n    (\"Company\", \"Company\"): [\"Partnership\", \"Acquisition\"],\n    (\"Person\", \"Product\"): [\"Usage\", \"Review\"],\n    (\"Entity\", \"Entity\"): [\"RELATES_TO\"]  # Fallback for unexpected relationships\n}\n\n### Avoid: Too granular\nedge_type_map = {\n    (\"CEO\", \"TechCompany\"): [\"CEOEmployment\"],\n    (\"Engineer\", \"TechCompany\"): [\"EngineerEmployment\"],\n    # This creates too many specific types\n}\n```\n\n## Entity Type Exclusion\n\nYou can exclude specific entity types from extraction using the excluded\\_entity\\_types parameter:\n\n```python\nawait graphiti.add_episode(\n    name=\"Business Update\",\n    episode_body=\"The meeting discussed various topics including weather and sports.\",\n    source_description=\"Meeting notes\",\n    reference_time=datetime.now(),\n    entity_types=entity_types,\n    excluded_entity_types=[\"Person\"]  # Won't extract Person entities\n)\n```\n\n## Migration Guide\n\nIf you're upgrading from a previous version of Graphiti:\n\n* You can add entity types to new episodes, even if existing episodes in the graph did not have entity types. Existing nodes will continue to work without being classified.\n* To add types to previously ingested data, you need to re-ingest it with entity types set into a new graph.\n\n## Important Constraints\n\n### Protected Attribute Names\n\nCustom entity type attributes cannot use protected names that are already used by Graphiti's core EntityNode class:\n\n* `uuid`, `name`, `group_id`, `labels`, `created_at`, `summary`, `attributes`, `name_embedding`\n\nCustom entity types and edge types provide powerful ways to structure your knowledge graph according to your domain needs. They enable more precise extraction, better organization, and richer semantic relationships in your data.",
  "content_length": 10692
}