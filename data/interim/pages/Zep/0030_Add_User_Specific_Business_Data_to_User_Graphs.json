{
  "title": "Add User Specific Business Data to User Graphs",
  "source_url": null,
  "content": "This guide demonstrates how to add user-specific business data to a user's knowledge graph. We'll create a user, fetch their business data, and add it to their graph.\n\nFirst, we will initialize our client and create a new user:\n\n<CodeBlocks>\n  ```python Python\n  # Initialize the Zep client\n  zep_client = Zep(api_key=API_KEY)\n\n  # Add one example user\n  user_id_zep = uuid.uuid4().hex\n  zep_client.user.add(\n      user_id=user_id_zep,\n      email=\"cookbook@example.com\"\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n  import { randomUUID } from \"crypto\";\n\n  // Initialize the Zep client\n  const client = new ZepClient({ apiKey: API_KEY });\n\n  // Add one example user\n  const userIdZep = randomUUID().replace(/-/g, \"\");\n  await client.user.add({\n      userId: userIdZep,\n      email: \"cookbook@example.com\"\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"log\"\n\n      \"github.com/getzep/zep-go/v3\"\n      \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n      \"github.com/google/uuid\"\n  )\n\n  // Initialize the Zep client\n  zepClient := client.NewClient(option.WithAPIKey(API_KEY))\n\n  // Add one example user\n  userIDZep := uuid.New().String()\n  user, err := zepClient.User.Add(\n      context.TODO(),\n      &zep.CreateUserRequest{\n          UserID: userIDZep,\n          Email:  zep.String(\"cookbook@example.com\"),\n      },\n  )\n  if err != nil {\n      log.Fatalf(\"Error: %v\", err)\n  }\n  ```\n</CodeBlocks>\n\nThen, we will fetch and format the user's business data. Note that the functionality to fetch a users business data will depend on your codebase.\n\nAlso note that you could make your Zep user IDs equal to whatever internal user IDs you use to make things easier to manage. Generally, Zep user IDs, thread IDs, Graph IDs, etc. can be arbitrary strings, and can map to your app's data schema.\n\n<CodeBlocks>\n  ```python Python\n  # Define the function to fetch user business data\n  def get_user_business_data(user_id_business):\n      # This function returns JSON data for the given user\n      # This would vary based on your codebase\n      return {}\n\n  # Placeholder for business user id\n  user_id_business = \"placeholder_user_id\"  # This would vary based on your codebase\n\n  # Retrieve the user-specific business data\n  user_data_json = get_user_business_data(user_id_business)\n\n  # Convert the business data to a string\n  json_string = json.dumps(user_data_json)\n  ```\n\n  ```typescript TypeScript\n  // Define the function to fetch user business data\n  function getUserBusinessData(userIdBusiness: string): Record<string, any> {\n      // This function returns JSON data for the given user\n      // This would vary based on your codebase\n      return {};\n  }\n\n  // Placeholder for business user id\n  const userIdBusiness = \"placeholder_user_id\";  // This would vary based on your codebase\n\n  // Retrieve the user-specific business data\n  const userDataJson = getUserBusinessData(userIdBusiness);\n\n  // Convert the business data to a string\n  const jsonString = JSON.stringify(userDataJson);\n  ```\n\n  ```go Go\n  import (\n      \"encoding/json\"\n  )\n\n  // Define the function to fetch user business data\n  func getUserBusinessData(userIDBusiness string) map[string]interface{} {\n      // This function returns JSON data for the given user\n      // This would vary based on your codebase\n      return map[string]interface{}{}\n  }\n\n  // Placeholder for business user id\n  userIDBusiness := \"placeholder_user_id\"  // This would vary based on your codebase\n\n  // Retrieve the user-specific business data\n  userDataJSON := getUserBusinessData(userIDBusiness)\n\n  // Convert the business data to a string\n  jsonBytes, err := json.Marshal(userDataJSON)\n  if err != nil {\n      log.Fatalf(\"Error: %v\", err)\n  }\n  jsonString := string(jsonBytes)\n  ```\n</CodeBlocks>\n\nLastly, we will add the formatted data to the user's graph using the [graph API](/adding-data-to-the-graph):\n\n<CodeBlocks>\n  ```python Python\n  # Add the JSON data to the user's graph\n  zep_client.graph.add(\n      user_id=user_id_zep,\n      type=\"json\",\n      data=json_string,\n  )\n  ```\n\n  ```typescript TypeScript\n  // Add the JSON data to the user's graph\n  await client.graph.add({\n      userId: userIdZep,\n      type: \"json\",\n      data: jsonString,\n  });\n  ```\n\n  ```go Go\n  // Add the JSON data to the user's graph\n  episode, err := zepClient.Graph.Add(\n      context.TODO(),\n      &zep.AddDataRequest{\n          UserID: zep.String(userIDZep),\n          Type:   zep.GraphDataTypeJSON,\n          Data:   jsonString,\n      },\n  )\n  if err != nil {\n      log.Fatalf(\"Error: %v\", err)\n  }\n  ```\n</CodeBlocks>\n\nHere, we use `type=\"json\"`, but the graph API also supports `type=\"text\"` and `type=\"message\"`. The `type=\"text\"` option is useful for adding background information that is in unstructured text such as internal documents or web copy. The `type=\"message\"` option is useful for adding data that is in a message format but is not your user's chat history, such as emails. [Read more about this here](/adding-data-to-the-graph).\n\nAlso, note that when adding data to the graph, you should consider the size of the data you are adding and our payload limits. [Read more about this here](/docs/performance/performance-best-practices#optimizing-memory-operations).\n\nYou have now successfully added user-specific business data to a user's knowledge graph, which can be used alongside chat history to create comprehensive user memory.",
  "content_length": 5469
}