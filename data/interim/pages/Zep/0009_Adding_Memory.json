{
  "title": "Adding Memory",
  "source_url": null,
  "content": "> Learn how to add chat history and messages to Zep's memory.\n\nYou can add both messages and business data to User Graphs.\n\n## Adding Messages\n\nAdd your chat history to Zep using the `thread.add_messages` method. `thread.add_messages` is thread-specific and expects data in chat message format, including a `name` (e.g., user's real name), `role` (AI, human, tool), and message `content`. Zep stores the chat history and builds a user-level knowledge graph from the messages.\n\n<Tip>\n  For best results, add chat history to Zep on every chat turn. That is, add both the AI and human messages in a single operation and in the order that the messages were created.\n</Tip>\n\n<Warning>\n  It is important to provide the name of the user in the name field if possible, to help with graph construction. It's also helpful to provide a meaningful name for the assistant in its name field.\n</Warning>\n\n### Basic example\n\nThe example below adds messages to Zep's memory for the user in the given thread:\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n  from zep_cloud.types import Message\n\n  zep_client = Zep(\n      api_key=API_KEY,\n  )\n\n  messages = [\n      Message(\n          name=\"Jane\",\n          role=\"user\",\n          content=\"Who was Octavia Butler?\",\n      )\n  ]\n\n  response = zep_client.thread.add_messages(thread_id, messages=messages)\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n  import type { Message } from \"@getzep/zep-cloud/api\";\n\n  const zepClient = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const messages: Message[] = [\n      { name: \"Jane\", role: \"user\", content: \"Who was Octavia Butler?\" },\n  ];\n\n  const response = await zepClient.thread.addMessages(threadId, { messages });\n  ```\n\n  ```go Go\n  import (\n      v3 \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n  )\n\n  zepClient := zepclient.NewClient(\n      option.WithAPIKey(\"<YOUR_API_KEY>\"),\n  )\n  response, err := zepClient.Thread.AddMessages(\n      context.TODO(),\n      \"threadId\",\n      &v3.AddThreadMessagesRequest{\n          Messages: []*v3.Message{\n              {\n                  Name: v3.String(\"Jane\"),\n                  Role: \"user\",\n                  Content: \"Who was Octavia Butler?\",\n              },\n          },\n      },\n  )\n  ```\n</CodeBlocks>\n\nYou can find additional arguments to `thread.add_messages` in the [SDK reference](/sdk-reference/thread/add-messages). Notably, for latency sensitive applications, you can set `return_context` to true which will make `thread.add_messages` return a context block in the way that `thread.get_user_context` does (discussed below).\n\n### Ignore assistant messages\n\nYou can also pass in a list of roles to ignore when adding messages to a User Graph using the `ignore_roles` argument. For example, you may not want assistant messages to be added to the user graph; providing the assistant messages in the `thread.add_messages` call while setting `ignore_roles` to include \"assistant\" will make it so that only the user messages are ingested into the graph, but the assistant messages are still used to contextualize the user messages. This is important in case the user message itself does not have enough context, such as the message \"Yes.\" Additionally, the assistant messages will still be added to the thread's message history.\n\n<CodeBlocks>\n  ```python Python\n  response = zep_client.thread.add_messages(\n      thread_id,\n      messages=messages,\n      ignore_roles=[\"assistant\"]\n  )\n  ```\n\n  ```typescript TypeScript\n  const response = await zepClient.thread.addMessages(threadId, {\n      messages,\n      ignoreRoles: [\"assistant\"]\n  });\n  ```\n\n  ```go Go\n  response, err := zepClient.Thread.AddMessages(\n      context.TODO(),\n      \"threadId\",\n      &v3.AddThreadMessagesRequest{\n          Messages: messages,\n          IgnoreRoles: []string{\"assistant\"},\n      },\n  )\n  ```\n</CodeBlocks>\n\n### Creating messages with metadata\n\nMessages can have metadata attached to store additional information like sentiment scores, source identifiers, processing flags, or other custom data. Metadata is preserved when getting threads, individual messages, and when searching episodes.\n\n<Note>\n  Message metadata is currently supported only for thread messages. Messages added via the `graph.add` API do not support metadata. Zep does not support filtering or searching over message metadata.\n</Note>\n\nYou can attach metadata when creating messages by including a `metadata` field in your message objects:\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n  from zep_cloud.types import Message\n\n  zep_client = Zep(\n      api_key=API_KEY,\n  )\n\n  messages = [\n      Message(\n          name=\"Jane\",\n          role=\"user\",\n          content=\"I need help with my account.\",\n          metadata={\n              \"sentiment\": \"frustrated\",\n              \"source\": \"mobile_app\",\n              \"priority\": \"high\"\n          }\n      )\n  ]\n\n  response = zep_client.thread.add_messages(thread_id, messages=messages)\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n  import type { Message } from \"@getzep/zep-cloud/api\";\n\n  const zepClient = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const messages: Message[] = [\n      {\n          name: \"Jane\",\n          role: \"user\",\n          content: \"I need help with my account.\",\n          metadata: {\n              sentiment: \"frustrated\",\n              source: \"mobile_app\",\n              priority: \"high\"\n          }\n      },\n  ];\n\n  const response = await zepClient.thread.addMessages(threadId, { messages });\n  ```\n\n  ```go Go\n  import (\n      v3 \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n  )\n\n  zepClient := zepclient.NewClient(\n      option.WithAPIKey(\"<YOUR_API_KEY>\"),\n  )\n  response, err := zepClient.Thread.AddMessages(\n      context.TODO(),\n      \"threadId\",\n      &v3.AddThreadMessagesRequest{\n          Messages: []*v3.Message{\n              {\n                  Name: v3.String(\"Jane\"),\n                  Role: \"user\",\n                  Content: \"I need help with my account.\",\n                  Metadata: map[string]interface{}{\n                      \"sentiment\": \"frustrated\",\n                      \"source\":    \"mobile_app\",\n                      \"priority\":  \"high\",\n                  },\n              },\n          },\n      },\n  )\n  ```\n</CodeBlocks>\n\n### Updating message metadata\n\nYou can update the metadata of an existing message using the message UUID. This is useful for adding or modifying metadata after a message has been created, such as updating sentiment analysis results or processing status.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  zep_client = Zep(\n      api_key=API_KEY,\n  )\n\n  # Update message metadata\n  updated_message = zep_client.thread.message.update(\n      message_uuid=\"message-uuid-here\",\n      metadata={\n          \"sentiment\": \"positive\",\n          \"resolved\": True,\n          \"resolution_time\": \"2m 30s\"\n      }\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const zepClient = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  // Update message metadata\n  const updatedMessage = await zepClient.thread.message.update(\n      \"message-uuid-here\",\n      {\n          metadata: {\n              sentiment: \"positive\",\n              resolved: true,\n              resolutionTime: \"2m 30s\"\n          }\n      }\n  );\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      v3 \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n      \"github.com/getzep/zep-go/v3/thread\"\n  )\n\n  zepClient := zepclient.NewClient(\n      option.WithAPIKey(\"<YOUR_API_KEY>\"),\n  )\n\n  // Update message metadata\n  updatedMessage, err := zepClient.Thread.Message.Update(\n      context.TODO(),\n      \"message-uuid-here\",\n      &thread.ThreadMessageUpdate{\n          Metadata: map[string]interface{}{\n              \"sentiment\":       \"positive\",\n              \"resolved\":        true,\n              \"resolution_time\": \"2m 30s\",\n          },\n      },\n  )\n  if err != nil {\n      // Handle error\n  }\n  ```\n</CodeBlocks>\n\n### Setting message timestamps\n\nWhen creating messages via the API, you should provide the `created_at` timestamp in RFC3339 format. The `created_at` timestamp represents the time when the message was originally sent by the user. Setting the `created_at` timestamp is important to ensure the user's knowledge graph has accurate temporal understanding of user history (since this time is used in our fact invalidation process).\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n  from zep_cloud.types import Message\n\n  zep_client = Zep(\n      api_key=API_KEY,\n  )\n\n  messages = [\n      Message(\n          created_at=\"2025-06-01T13:11:12Z\",\n          name=\"Jane\",\n          role=\"user\",\n          content=\"What's the weather like today?\",\n      )\n  ]\n\n  response = zep_client.thread.add_messages(thread_id, messages=messages)\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n  import type { Message } from \"@getzep/zep-cloud/api\";\n\n  const zepClient = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  const messages: Message[] = [\n      { \n          createdAt: \"2025-06-01T13:11:12Z\",\n          name: \"Jane\", \n          role: \"user\", \n          content: \"What's the weather like today?\" \n      },\n  ];\n\n  const response = await zepClient.thread.addMessages(threadId, { messages });\n  ```\n\n  ```go Go\n  import (\n      v3 \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n  )\n\n  zepClient := zepclient.NewClient(\n      option.WithAPIKey(\"<YOUR_API_KEY>\"),\n  )\n  response, err := zepClient.Thread.AddMessages(\n      context.TODO(),\n      \"threadId\",\n      &v3.AddThreadMessagesRequest{\n          Messages: []*v3.Message{\n              {\n                  CreatedAt: v3.String(\"2025-06-01T13:11:12Z\"),\n                  Name: v3.String(\"Jane\"),\n                  Role: \"user\",\n                  Content: \"What's the weather like today?\",\n              },\n          },\n      },\n  )\n  ```\n</CodeBlocks>\n\n### Message limits\n\nWhen adding messages to a thread, there are limits on both the number of messages and message size:\n\n* **Messages per call**: You can add at most 30 messages in a single `thread.add_messages` call\n* **Message size limit**: Each message can be at most 2,500 characters\n\nIf you need to add more than 30 messages or have messages exceeding the character limits, you'll need to split them across multiple API calls or truncate the content accordingly. Our additional recommendations include:\n\n* Have users attach documents rather than paste them into the message, and then process documents separately with `graph.add`\n* Reduce the max message size for your users to match our max message size\n* Optional: allow users to paste in documents with an auto detection algorithm that turns it into an attachment as opposed to part of the message\n\n### Check when messages are finished processing\n\nYou can use the message UUIDs from the response to poll the messages and check when they are finished processing:\n\n```python\nresponse = zep_client.thread.add_messages(thread_id, messages=messages)\nmessage_uuids = response.message_uuids\n```\n\nAn example of this can be found in the [check data ingestion status cookbook](/cookbook/check-data-ingestion-status).\n\n## Adding Business Data\n\nYou can also add JSON or unstructured text as memory to a User Graph using our [Graph API](/adding-data-to-the-graph).\n\n## Customizing Memory Creation\n\nZep offers two ways to customize how memory is created. You can read more about these features at their guide pages:\n\n* [**Custom entity and edge types**](/customizing-graph-structure#custom-entity-and-edge-types): Feature allowing use of Pydantic-like classes to customize creation/retrieval of entities and relations in the knowledge graph.\n* [**User summary instructions**](/users#user-summary-instructions): Customize how Zep generates entity summaries for users in their knowledge graph with up to 5 custom instructions per user.",
  "content_length": 12159
}