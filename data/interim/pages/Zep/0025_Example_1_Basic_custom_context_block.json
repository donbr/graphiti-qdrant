{
  "title": "Example 1: Basic custom context block",
  "source_url": null,
  "content": "## Search\n\nFor a basic custom context block, we search the graph for edges and nodes relevant to our custom query string, which typically represents a user message. Note that the default [Context Block](/retrieving-memory#zeps-context-block) returned by `thread.get_user_context` uses the past few messages as the query instead.\n\n<Tip>\n  These searches can be performed in parallel to reduce latency, using our [async Python client](/quickstart#initialize-the-client), TypeScript promises, or goroutines.\n</Tip>\n\n<CodeBlocks>\n  ```python\n  query = \"Find some food around here\"\n\n  search_results_nodes = client.graph.search(\n      query=query,\n      user_id=user_id,\n      scope='nodes',\n      reranker='cross_encoder',\n      limit=10\n  )\n  search_results_edges = client.graph.search(\n      query=query,\n      user_id=user_id,\n      scope='edges',\n      reranker='cross_encoder',\n      limit=10\n  )\n  ```\n\n  ```typescript\n  let query = \"Find some food around here\";\n\n  const searchResultsNodes = await client.graph.search({\n      userId: userId,\n      query: query,\n      scope: \"nodes\",\n      reranker: \"cross_encoder\",\n      limit: 10,\n  });\n\n  const searchResultsEdges = await client.graph.search({\n      userId: userId,\n      query: query,\n      scope: \"edges\",\n      reranker: \"cross_encoder\",\n      limit: 10,\n  });\n  ```\n\n  ```go\n  import (\n  \t\"github.com/getzep/zep-go/v2/graph\"\n  )\n\n  query := \"Find some food around here\"\n\n  searchResultsNodes, err := client.Graph.Search(\n  \tctx,\n  \t&zep.GraphSearchQuery{\n  \t\tUserID:  zep.String(userID),\n  \t\tQuery:   query,\n  \t\tScope:   zep.GraphSearchScopeNodes.Ptr(),\n  \t\tReranker: zep.RerankerCrossEncoder.Ptr(),\n  \t\tLimit:   zep.Int(10),\n  \t},\n  )\n  if err != nil {\n  \tfmt.Printf(\"Error searching graph (nodes): %v\\n\", err)\n  \treturn\n  }\n\n  searchResultsEdges, err := client.Graph.Search(\n  \tctx,\n  \t&zep.GraphSearchQuery{\n  \t\tUserID:  zep.String(userID),\n  \t\tQuery:   query,\n  \t\tScope:   zep.GraphSearchScopeEdges.Ptr(),\n  \t\tReranker: zep.RerankerCrossEncoder.Ptr(),\n  \t\tLimit:   zep.Int(10),\n  \t},\n  )\n  if err != nil {\n  \tfmt.Printf(\"Error searching graph (edges): %v\\n\", err)\n  \treturn\n  }\n  ```\n</CodeBlocks>\n\n## Build the context block\n\nUsing the search results and a few helper functions, we can build the context block. Note that for nodes, we typically want to unpack the node name and node summary, and for edges we typically want to unpack the fact and the temporal validity information:\n\n<CodeBlocks>\n  ```python\n  from zep_cloud import EntityEdge, EntityNode\n\n  CONTEXT_STRING_TEMPLATE = \"\"\"\n  FACTS and ENTITIES represent relevant context to the current conversation.\n  # These are the most relevant facts and their valid date ranges\n  # format: FACT (Date range: from - to)\n  # NOTE: Facts ending in \"present\" are currently valid (e.g., \"Jane prefers her coffee with milk (2024-01-15 10:30:00 - present)\" means Jane currently prefers coffee with milk)\n  #       Facts with a past end date used to be valid but are NOT CURRENTLY VALID (e.g., \"Jane prefers her coffee with milk (2024-01-15 10:30:00 - 2024-06-20 14:00:00)\" means Jane no longer prefers coffee with milk)\n  <FACTS>\n  {facts}\n  </FACTS>\n\n  # These are the most relevant entities\n  # ENTITY_NAME: entity summary\n  <ENTITIES>\n  {entities}\n  </ENTITIES>\n  \"\"\"\n\n\n  def format_fact(edge: EntityEdge) -> str:\n      valid_at = edge.valid_at if edge.valid_at is not None else \"date unknown\"\n      invalid_at = edge.invalid_at if edge.invalid_at is not None else \"present\"\n      formatted_fact = f\"  - {edge.fact} (Date range: {valid_at} - {invalid_at})\"\n      return formatted_fact\n\n  def format_entity(node: EntityNode) -> str:\n      formatted_entity = f\"  - {node.name}: {node.summary}\"\n      return formatted_entity\n\n  def compose_context_block(edges: list[EntityEdge], nodes: list[EntityNode]) -> str:\n      facts = [format_fact(edge) for edge in edges]\n      entities = [format_entity(node) for node in nodes]\n      return CONTEXT_STRING_TEMPLATE.format(facts='\\n'.join(facts), entities='\\n'.join(entities))\n\n  edges = search_results_edges.edges\n  nodes = search_results_nodes.nodes\n\n  context_block = compose_context_block(edges, nodes)\n  print(context_block)\n  ```\n\n  ```typescript\n  import type { EntityEdge, EntityNode } from \"@getzep/zep-cloud/api\";\n\n  const CONTEXT_STRING_TEMPLATE_1 = `FACTS and ENTITIES represent relevant context to the current conversation.\n  # These are the most relevant facts and their valid date ranges\n  # format: FACT (Date range: from - to)\n  # NOTE: Facts ending in \"present\" are currently valid (e.g., \"Jane prefers her coffee with milk (2024-01-15 10:30:00 - present)\" means Jane currently prefers coffee with milk)\n  #       Facts with a past end date used to be valid but are NOT CURRENTLY VALID (e.g., \"Jane prefers her coffee with milk (2024-01-15 10:30:00 - 2024-06-20 14:00:00)\" means Jane no longer prefers coffee with milk)\n  <FACTS>\n  {facts}\n  </FACTS>\n  # These are the most relevant entities\n  # ENTITY_NAME: entity summary\n  <ENTITIES>\n  {entities}\n  </ENTITIES>`;\n\n  function formatFact(edge: EntityEdge): string {\n      const validAt = edge.validAt ?? \"date unknown\";\n      const invalidAt = edge.invalidAt ?? \"present\";\n      return `  - ${edge.fact} (Date range: ${validAt} - ${invalidAt})`;\n  }\n\n  function formatEntity(node: EntityNode): string {\n      return `  - ${node.name}: ${node.summary}`;\n  }\n\n  function composeContextBlock1(edges: EntityEdge[], nodes: EntityNode[]): string {\n      const facts = edges.map(formatFact).join('\\n');\n      const entities = nodes.map(formatEntity).join('\\n');\n      return CONTEXT_STRING_TEMPLATE_1\n          .replace('{facts}', facts)\n          .replace('{entities}', entities);\n  }\n\n  const edges: EntityEdge[] = searchResultsEdges.edges ?? [];\n  const nodes: EntityNode[] = searchResultsNodes.nodes ?? [];\n\n  const contextBlock1 = composeContextBlock1(edges, nodes);\n  console.log(contextBlock1);\n  ```\n\n  ```go\n  import (\n  \t\"strings\"\n  )\n\n  const CONTEXT_STRING_TEMPLATE_1 = `FACTS and ENTITIES represent relevant context to the current conversation.\n  # These are the most relevant facts and their valid date ranges\n  # format: FACT (Date range: from - to)\n  # NOTE: Facts ending in \"present\" are currently valid (e.g., \"Jane prefers her coffee with milk (2024-01-15 10:30:00 - present)\" means Jane currently prefers coffee with milk)\n  #       Facts with a past end date used to be valid but are NOT CURRENTLY VALID (e.g., \"Jane prefers her coffee with milk (2024-01-15 10:30:00 - 2024-06-20 14:00:00)\" means Jane no longer prefers coffee with milk)\n  <FACTS>\n  {facts}\n  </FACTS>\n\n  # These are the most relevant entities\n  # ENTITY_NAME: entity summary\n  <ENTITIES>\n  {entities}\n  </ENTITIES>\n  `\n\n  formatFact := func(edge *zep.EntityEdge) string {\n  \tvalidAt := \"date unknown\"\n  \tif edge.ValidAt != nil && *edge.ValidAt != \"\" {\n  \t\tvalidAt = *edge.ValidAt\n  \t}\n  \tinvalidAt := \"present\"\n  \tif edge.InvalidAt != nil && *edge.InvalidAt != \"\" {\n  \t\tinvalidAt = *edge.InvalidAt\n  \t}\n  \treturn fmt.Sprintf(\"  - %s (Date range: %s - %s)\", edge.Fact, validAt, invalidAt)\n  }\n\n  formatEntity := func(node *zep.EntityNode) string {\n  \treturn fmt.Sprintf(\"  - %s: %s\", node.Name, node.Summary)\n  }\n\n  composeContextBlock1 := func(edges []*zep.EntityEdge, nodes []*zep.EntityNode) string {\n  \tvar facts []string\n  \tfor _, edge := range edges {\n  \t\tfacts = append(facts, formatFact(edge))\n  \t}\n  \tvar entities []string\n  \tfor _, node := range nodes {\n  \t\tentities = append(entities, formatEntity(node))\n  \t}\n  \tresult := strings.ReplaceAll(CONTEXT_STRING_TEMPLATE_1, \"{facts}\", strings.Join(facts, \"\\n\"))\n  \tresult = strings.ReplaceAll(result, \"{entities}\", strings.Join(entities, \"\\n\"))\n  \treturn result\n  }\n\n  edges := searchResultsEdges.Edges\n  nodes := searchResultsNodes.Nodes\n\n  contextBlock1 := composeContextBlock1(edges, nodes)\n  fmt.Println(contextBlock1)\n  ```\n</CodeBlocks>\n\n```text\nFACTS and ENTITIES represent relevant context to the current conversation.\n### These are the most relevant facts and their valid date ranges\n### format: FACT (Date range: from - to)\n### NOTE: Facts ending in \"present\" are currently valid (e.g., \"Jane prefers her coffee with milk (2024-01-15 10:30:00 - present)\" means Jane currently prefers coffee with milk)\n###       Facts with a past end date used to be valid but are NOT CURRENTLY VALID (e.g., \"Jane prefers her coffee with milk (2024-01-15 10:30:00 - 2024-06-20 14:00:00)\" means Jane no longer prefers coffee with milk)\n<FACTS>\n  - User wants to go to dessert (Date range: 2025-06-16T02:17:25Z - present)\n  - John Doe wants to go to a lunch place (Date range: 2025-06-16T02:17:25Z - present)\n  - John Doe said 'Perfect, let's go to Insomnia Cookies' indicating he will visit Insomnia Cookies. (Date range: 2025-06-16T02:17:25Z - present)\n  - John Doe said 'Letâ€™s go to Green Leaf Cafe' indicating intention to visit (Date range: 2025-06-16T02:17:25Z - present)\n  - John Doe is craving a chocolate chip cookie (Date range: 2025-06-16T02:17:25Z - present)\n  - John Doe states that he is vegetarian. (Date range: 2025-06-16T02:17:25Z - present)\n  - John Doe is lactose intolerant (Date range: 2025-06-16T02:17:25Z - present)\n</FACTS>\n \n### These are the most relevant entities\n### ENTITY_NAME: entity summary\n<ENTITIES>\n  - lunch place: The entity is a lunch place, but no specific details about its cuisine or dietary accommodations are provided.\n  - dessert: The entity 'dessert' refers to a preference related to sweet courses typically served at the end of a meal. The context indicates that the user has expressed an interest in going to a dessert place, but no specific dessert or place has been named. The entity is categorized as a Preference and Entity, but no additional attributes are provided or inferred from the messages.\n  - Green Leaf Cafe: Green Leaf Cafe is a restaurant that offers vegetarian options, making it suitable for vegetarian diners.\n  - user: The user is John Doe, with the email john.doe@example.com. He has shown interest in visiting Green Leaf Cafe, which offers vegetarian options, and has also expressed a preference for lactose-free options, craving a chocolate chip cookie. The user has decided to go to Insomnia Cookies.\n  - vegetarian: The user is interested in lunch places such as Panera Bread, Chipotle, and Green Leaf Cafe. They are specifically looking for vegetarian options at these restaurants.\n  - chocolate chip cookie: The entity is a chocolate chip cookie, which the user desires as a snack. The user is lactose intolerant and cannot have ice cream, but is craving a chocolate chip cookie.\n  - Insomnia Cookies: Insomnia Cookies is a restaurant that offers cookies, including chocolate chip cookies. The user is interested in a dessert and has chosen to go to Insomnia Cookies. No specific cuisine type or dietary accommodations are mentioned in the messages.\n  - lactose intolerant: The entity is a preference indicating lactose intolerance, which is a dietary restriction that prevents the individual from consuming lactose, a sugar found in milk and dairy products. The person is specifically craving a chocolate chip cookie but cannot have ice cream due to lactose intolerance.\n  - John Doe: The user is John Doe, with user ID user-34c7a6c1-ded6-4797-9620-8b80a5e7820f, email john.doe@example.com, and role user. He inquired about nearby lunch options and vegetarian choices, and expressed a preference for a chocolate chip cookie due to lactose intolerance.\n</ENTITIES>\n```",
  "content_length": 11494
}