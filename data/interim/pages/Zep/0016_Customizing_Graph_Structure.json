{
  "title": "Customizing Graph Structure",
  "source_url": null,
  "content": "Zep enables the use of rich, domain-specific data structures in graphs through Entity Types and Edge Types, replacing generic graph nodes and edges with detailed models.\n\nZep classifies newly created nodes/edges as one of the default or custom types or leaves them unclassified. For example, a node representing a preference is classified as a Preference node, and attributes specific to that type are automatically populated. You may restrict graph queries to nodes/edges of a specific type, such as Preference.\n\nThe default entity and edge types are applied to user graphs (not all graphs) by default, but you may define additional custom types as needed.\n\nEach node/edge is classified as a single type only. Multiple classifications are not supported.\n\n## Default Entity and Edge Types\n\n### Definition\n\nZep provides default entity and edge types that are automatically applied to user graphs (not all graphs). These types help classify and structure the information extracted from conversations.\n\nYou can view the exact definition for the default ontology [here](https://github.com/getzep/zep/blob/main/ontology/default_ontology.py).\n\n#### Default Entity Types\n\nThe default entity types are:\n\n* **User**: A Zep user specified by role in chat messages. There can only be a single User entity.\n* **Assistant**: Represents the AI assistant in the conversation. This entity is a singleton.\n* **Preference**: Entities mentioned in contexts expressing user preferences, choices, opinions, or selections. This classification is prioritized over most other classifications.\n* **Location**: A physical or virtual place where activities occur or entities exist. Use this classification only after checking if the entity fits other more specific types.\n* **Event**: A time-bound activity, occurrence, or experience.\n* **Object**: A physical item, tool, device, or possession. Use this classification only as a last resort after checking other types.\n* **Topic**: A subject of conversation, interest, or knowledge domain. Use this classification only as a last resort after checking other types.\n* **Organization**: A company, institution, group, or formal entity.\n* **Document**: Information content in various forms.\n\n#### Default Edge Types\n\nThe default edge types are:\n\n* **LOCATED\\_AT**: Represents that an entity exists or occurs at a specific location. Connects any entity to a Location.\n* **OCCURRED\\_AT**: Represents that an event happened at a specific time or location. Connects an Event to any entity.\n\nDefault entity and edge types apply to user graphs. All nodes and edges in any user graph will be classified into one of these types or none.\n\n### Adding Data\n\nWhen we add data to the graph, default entity and edge types are automatically created:\n\n<CodeBlocks>\n  ```python\n  from zep_cloud.types import Message\n\n  message = {\n      \"name\": \"John Doe\",\n      \"role\": \"user\",\n      \"content\": \"I really like pop music, and I don't like metal\",\n  }\n\n  client.thread.add_messages(thread_id=thread_id, messages=[Message(**message)])\n  ```\n\n  ```typescript\n  const messages = [{\n      name: \"John Doe\",\n      role: \"user\",\n      content: \"I really like pop music, and I don't like metal\",\n  }];\n\n  await client.thread.addMessages(threadId, {messages: messages});\n  ```\n\n  ```go\n  userName := \"John Doe\"\n  messages := []*v3.Message{\n      {\n          Name:    &userName,\n          Content: \"I really like pop music, and I don't like metal\",\n          Role:    \"user\",\n      },\n  }\n\n  // Add the messages to the graph\n  _, err = zepClient.Thread.AddMessages(\n      context.TODO(),\n      threadId,\n      &v3.AddThreadMessagesRequest{\n          Messages: messages,\n      },\n  )\n  if err != nil {\n      log.Fatal(\"Error adding messages:\", err)\n  }\n  ```\n</CodeBlocks>\n\n### Searching\n\nWhen searching nodes in the graph, you may provide a list of types to filter the search by. The provided types are ORed together. Search results will only include nodes that satisfy one of the provided types:\n\n<CodeBlocks>\n  ```python\n  search_results = client.graph.search(\n      user_id=user_id,\n      query=\"the user's music preferences\",\n      scope=\"nodes\",\n      search_filters={\n          \"node_labels\": [\"Preference\"]\n      }\n  )\n  for i, node in enumerate(search_results.nodes):\n      preference = node.attributes\n      print(f\"Preference {i+1}:{preference}\")\n  ```\n\n  ```typescript\n  const searchResults = await client.graph.search({\n    userId: userId,\n    query: \"the user's music preferences\",\n    scope: \"nodes\",\n    searchFilters: {\n      nodeLabels: [\"Preference\"],\n    },\n  });\n\n  if (searchResults.nodes && searchResults.nodes.length > 0) {\n    for (let i = 0; i < searchResults.nodes.length; i++) {\n      const node = searchResults.nodes[i];\n      const preference = node.attributes;\n      console.log(`Preference ${i + 1}: ${JSON.stringify(preference)}`);\n    }\n  }\n  ```\n\n  ```go\n  searchFilters := v3.SearchFilters{NodeLabels: []string{\"Preference\"}}\n  searchResults, err := client.Graph.Search(\n  \tctx,\n  \t&v3.GraphSearchQuery{\n  \t\tUserID:        v3.String(userID),\n  \t\tQuery:         \"the user's music preferences\",\n  \t\tScope:         v3.GraphSearchScopeNodes.Ptr(),\n  \t\tSearchFilters: &searchFilters,\n  \t},\n  )\n  if err != nil {\n  \tlog.Fatal(\"Error searching graph:\", err)\n  }\n\n  for i, node := range searchResults.Nodes {\n  \t// Convert attributes map to JSON for pretty printing\n  \tattributesJSON, err := json.MarshalIndent(node.Attributes, \"\", \"  \")\n  \tif err != nil {\n  \t\tlog.Fatal(\"Error marshaling attributes:\", err)\n  \t}\n  \t\n  \tfmt.Printf(\"Preference %d:\\n%s\\n\\n\", i+1, string(attributesJSON))\n  }\n  ```\n</CodeBlocks>\n\n```text\nPreference 1: {'category': 'Music', 'description': 'Pop Music is a genre of music characterized by its catchy melodies and widespread appeal.', 'labels': ['Entity', 'Preference']}\nPreference 2: {'category': 'Music', 'description': 'Metal Music is a genre of music characterized by its heavy sound and complex compositions.', 'labels': ['Entity', 'Preference']}\n```\n\n### Disabling Default Ontology\n\nIn some cases, you may want to disable the default entity and edge types for specific users and only use custom types you define. You can do this by setting the `disable_default_ontology` flag when creating or updating a user.\n\nWhen `disable_default_ontology` is set to `true`:\n\n* Only custom entity and edge types you define will be used for classification\n* The default entity and edge types (User, Assistant, Preference, Location, etc.) will not be applied\n* Nodes and edges will only be classified as your custom types or remain unclassified\n\nThis is useful when you need precise control over your graph structure and want to ensure only domain-specific types are used.\n\n<CodeBlocks>\n  ```python Python\n  from zep_cloud.client import Zep\n\n  client = Zep(\n      api_key=API_KEY,\n  )\n\n  # Create a user with default ontology disabled\n  user = client.user.add(\n      user_id=user_id,\n      first_name=\"John\",\n      last_name=\"Doe\",\n      email=\"john.doe@example.com\",\n      disable_default_ontology=True\n  )\n\n  # Or update an existing user to disable default ontology\n  client.user.update(\n      user_id=user_id,\n      disable_default_ontology=True\n  )\n  ```\n\n  ```typescript TypeScript\n  import { ZepClient } from \"@getzep/zep-cloud\";\n\n  const client = new ZepClient({\n    apiKey: API_KEY,\n  });\n\n  // Create a user with default ontology disabled\n  const user = await client.user.add({\n    userId: userId,\n    firstName: \"John\",\n    lastName: \"Doe\",\n    email: \"john.doe@example.com\",\n    disableDefaultOntology: true\n  });\n\n  // Or update an existing user to disable default ontology\n  await client.user.update(userId, {\n    disableDefaultOntology: true\n  });\n  ```\n\n  ```go Go\n  import (\n      \"context\"\n      \"github.com/getzep/zep-go/v3\"\n      zepclient \"github.com/getzep/zep-go/v3/client\"\n      \"github.com/getzep/zep-go/v3/option\"\n  )\n\n  client := zepclient.NewClient(\n      option.WithAPIKey(API_KEY),\n  )\n\n  // Create a user with default ontology disabled\n  user, err := client.User.Add(\n      context.TODO(),\n      &zep.CreateUserRequest{\n          UserID:                  userID,\n          FirstName:              zep.String(\"John\"),\n          LastName:               zep.String(\"Doe\"),\n          Email:                  zep.String(\"john.doe@example.com\"),\n          DisableDefaultOntology: zep.Bool(true),\n      },\n  )\n\n  // Or update an existing user to disable default ontology\n  _, err = client.User.Update(\n      context.TODO(),\n      userID,\n      &zep.UpdateUserRequest{\n          DisableDefaultOntology: zep.Bool(true),\n      },\n  )\n  ```\n</CodeBlocks>\n\n## Custom Entity and Edge Types\n\n<Note>\n  Start with fewer, more generic custom types with minimal fields and simple definitions, then incrementally add complexity as needed. This functionality requires prompt engineering and iterative optimization of the class and field descriptions, so it's best to start simple.\n</Note>\n\n### Definition\n\nIn addition to the default entity and edge types, you may specify your own custom entity and custom edge types. You need to provide a description of the type and a description for each of the fields. The syntax for this is different for each language.\n\nYou may not create more than 10 custom entity types and 10 custom edge types when setting ontology for a specific graph. The same limit of 10 custom entity types and 10 custom edge types also applies when setting ontology project-wide. The limit of 10 custom entity types does not include the default types. Each model may have up to 10 fields.\n\n<Warning>\n  When creating custom entity or edge types, you may not use the following attribute names (including in Go struct tags), as they conflict with default node attributes: `uuid`, `name`, `graph_id`, `name_embedding`, `summary`, and `created_at`.\n</Warning>\n\n<Note>\n  Including attributes on custom entity and edge types is an advanced feature designed for precision context engineering where you only want to utilize specific field values when constructing your context block. [See here for an example](cookbook/advanced-context-block-construction#example-2-utilizing-custom-entity-and-edge-types). Many agent memory use cases can be solved with node summaries and facts alone. Custom attributes should only be added when you need structured field values for precise context retrieval rather than general conversational memory.\n</Note>\n\n<CodeBlocks>\n  ```python\n  from zep_cloud.external_clients.ontology import EntityModel, EntityText, EdgeModel, EntityBoolean\n  from pydantic import Field\n\n  class Restaurant(EntityModel):\n      \"\"\"\n      Represents a specific restaurant.\n      \"\"\"\n      cuisine_type: EntityText = Field(description=\"The cuisine type of the restaurant, for example: American, Mexican, Indian, etc.\", default=None)\n      dietary_accommodation: EntityText = Field(description=\"The dietary accommodation of the restaurant, if any, for example: vegetarian, vegan, etc.\", default=None)\n\n  class Audiobook(EntityModel):\n      \"\"\"\n      Represents an audiobook entity.\n      \"\"\"\n      genre: EntityText = Field(description=\"The genre of the audiobook, for example: self-help, fiction, nonfiction, etc.\", default=None)\n\n  class RestaurantVisit(EdgeModel):\n      \"\"\"\n      Represents the fact that the user visited a restaurant.\n      \"\"\"\n      restaurant_name: EntityText = Field(description=\"The name of the restaurant the user visited\", default=None)\n\n  class AudiobookListen(EdgeModel):\n      \"\"\"\n      Represents the fact that the user listened to or played an audiobook.\n      \"\"\"\n      audiobook_title: EntityText = Field(description=\"The title of the audiobook the user listened to or played\", default=None)\n\n  class DietaryPreference(EdgeModel):\n      \"\"\"\n      Represents the fact that the user has a dietary preference or dietary restriction.\n      \"\"\"\n      preference_type: EntityText = Field(description=\"Preference type of the user: anything, vegetarian, vegan, peanut allergy, etc.\", default=None)\n      allergy: EntityBoolean = Field(description=\"Whether this dietary preference represents a user allergy: True or false\", default=None)\n  ```\n\n  ```typescript\n  import { entityFields, EntityType, EdgeType } from \"@getzep/zep-cloud\";\n\n  const RestaurantSchema: EntityType = {\n      description: \"Represents a specific restaurant.\",\n      fields: {\n          cuisine_type: entityFields.text(\"The cuisine type of the restaurant, for example: American, Mexican, Indian, etc.\"),\n          dietary_accommodation: entityFields.text(\"The dietary accommodation of the restaurant, if any, for example: vegetarian, vegan, etc.\"),\n      },\n  };\n\n  const AudiobookSchema: EntityType = {\n      description: \"Represents an audiobook entity.\",\n      fields: {\n          genre: entityFields.text(\"The genre of the audiobook, for example: self-help, fiction, nonfiction, etc.\"),\n      },\n  };\n\n  const RestaurantVisit: EdgeType = {\n      description: \"Represents the fact that the user visited a restaurant.\",\n      fields: {\n          restaurant_name: entityFields.text(\"The name of the restaurant the user visited\"),\n      },\n      sourceTargets: [\n          { source: \"User\", target: \"Restaurant\" },\n      ],\n  };\n\n  const AudiobookListen: EdgeType = {\n      description: \"Represents the fact that the user listened to or played an audiobook.\",\n      fields: {\n          audiobook_title: entityFields.text(\"The title of the audiobook the user listened to or played\"),\n      },\n      sourceTargets: [\n          { source: \"User\", target: \"Audiobook\" },\n      ],\n  };\n\n  const DietaryPreference: EdgeType = {\n      description: \"Represents the fact that the user has a dietary preference or dietary restriction.\",\n      fields: {\n          preference_type: entityFields.text(\"Preference type of the user: anything, vegetarian, vegan, peanut allergy, etc.\"),\n          allergy: entityFields.boolean(\"Whether this dietary preference represents a user allergy: True or false\"),\n      },\n      sourceTargets: [\n          { source: \"User\" },\n      ],\n  };\n  ```\n\n  ```go\n  type Restaurant struct {\n      zep.BaseEntity `name:\"Restaurant\" description:\"Represents a specific restaurant.\"`\n      CuisineType           string `description:\"The cuisine type of the restaurant, for example: American, Mexican, Indian, etc.\" json:\"cuisine_type,omitempty\"`\n      DietaryAccommodation  string `description:\"The dietary accommodation of the restaurant, if any, for example: vegetarian, vegan, etc.\" json:\"dietary_accommodation,omitempty\"`\n  }\n\n  type Audiobook struct {\n      zep.BaseEntity `name:\"Audiobook\" description:\"Represents an audiobook entity.\"`\n      Genre string `description:\"The genre of the audiobook, for example: self-help, fiction, nonfiction, etc.\" json:\"genre,omitempty\"`\n  }\n\n  type RestaurantVisit struct {\n      zep.BaseEdge `name:\"RESTAURANT_VISIT\" description:\"Represents the fact that the user visited a restaurant.\"`\n      RestaurantName string `description:\"The name of the restaurant the user visited\" json:\"restaurant_name,omitempty\"`\n  }\n\n  type AudiobookListen struct {\n      zep.BaseEdge `name:\"AUDIOBOOK_LISTEN\" description:\"Represents the fact that the user listened to or played an audiobook.\"`\n      AudiobookTitle string `description:\"The title of the audiobook the user listened to or played\" json:\"audiobook_title,omitempty\"`\n  }\n\n  type DietaryPreference struct {\n      zep.BaseEdge `name:\"DIETARY_PREFERENCE\" description:\"Represents the fact that the user has a dietary preference or dietary restriction.\"`\n      PreferenceType string `description:\"Preference type of the user: anything, vegetarian, vegan, peanut allergy, etc.\" json:\"preference_type,omitempty\"`\n      Allergy        bool   `description:\"Whether this dietary preference represents a user allergy: True or false\" json:\"allergy,omitempty\"`\n  }\n  ```\n</CodeBlocks>\n\n### Setting Entity and Edge Types\n\nYou can set these custom entity and edge types as the graph ontology for your current Zep project. The ontology can be applied either project-wide to all users and graphs, or targeted to specific users and graphs only.\n\n#### Setting Types Project Wide\n\nWhen no user IDs or graph IDs are provided, the ontology is set for the entire project. All users and graphs within the project will use this ontology. Note that for custom edge types, you can require the source and destination nodes to be a certain type, or allow them to be any type:\n\n<CodeBlocks>\n  ```python\n  from zep_cloud import EntityEdgeSourceTarget\n\n  client.graph.set_ontology(\n      entities={\n          \"Restaurant\": Restaurant,\n          \"Audiobook\": Audiobook,\n      },\n      edges={\n          \"RESTAURANT_VISIT\": (\n              RestaurantVisit,\n              [EntityEdgeSourceTarget(source=\"User\", target=\"Restaurant\")]\n          ),\n          \"AUDIOBOOK_LISTEN\": (\n              AudiobookListen,\n              [EntityEdgeSourceTarget(source=\"User\", target=\"Audiobook\")]\n          ),\n          \"DIETARY_PREFERENCE\": (\n              DietaryPreference,\n              [EntityEdgeSourceTarget(source=\"User\")]\n          ),\n      }\n  )\n  ```\n\n  ```typescript\n  await client.graph.setOntology(\n      {\n          Restaurant: RestaurantSchema,\n          Audiobook: AudiobookSchema,\n      },\n      {\n          RESTAURANT_VISIT: RestaurantVisit,\n          AUDIOBOOK_LISTEN: AudiobookListen,\n          DIETARY_PREFERENCE: DietaryPreference,\n      }\n  );\n  ```\n\n  ```go\n  _, err = client.Graph.SetOntology(\n      ctx,\n      []zep.EntityDefinition{\n          Restaurant{},\n          Audiobook{},\n      },\n      []zep.EdgeDefinitionWithSourceTargets{\n          {\n              EdgeModel: RestaurantVisit{},\n              SourceTargets: []zep.EntityEdgeSourceTarget{\n                  {\n                      Source: zep.String(\"User\"),\n                      Target: zep.String(\"Restaurant\"),\n                  },\n              },\n          },\n          {\n              EdgeModel: AudiobookListen{},\n              SourceTargets: []zep.EntityEdgeSourceTarget{\n                  {\n                      Source: zep.String(\"User\"),\n                      Target: zep.String(\"Audiobook\"),\n                  },\n              },\n          },\n          {\n              EdgeModel: DietaryPreference{},\n              SourceTargets: []zep.EntityEdgeSourceTarget{\n                  {\n                      Source: zep.String(\"User\"),\n                  },\n              },\n          },\n      },\n  )\n  if err != nil {\n      fmt.Printf(\"Error setting ontology: %v\\n\", err)\n      return\n  }\n  ```\n</CodeBlocks>\n\n#### Setting Types For Specific Graphs\n\nYou can also set the ontology for specific users and/or graphs by providing user IDs and graph IDs. When these parameters are provided, the ontology will only apply to the specified users and graphs, while other users and graphs in the project will continue using the previously set ontology (whether that was due to a project-wide setting of ontology or due to a graph-specific setting of ontology):\n\n<CodeBlocks>\n  ```python\n  from zep_cloud import EntityEdgeSourceTarget\n\n  await client.graph.set_ontology(\n      user_ids=[\"user_1234\", \"user_5678\"],\n      graph_ids=[\"graph_1234\", \"graph_5678\"],\n      entities={\n          \"Restaurant\": Restaurant,\n          \"Audiobook\": Audiobook,\n      },\n      edges={\n          \"RESTAURANT_VISIT\": (\n              RestaurantVisit,\n              [EntityEdgeSourceTarget(source=\"User\", target=\"Restaurant\")]\n          ),\n          \"AUDIOBOOK_LISTEN\": (\n              AudiobookListen,\n              [EntityEdgeSourceTarget(source=\"User\", target=\"Audiobook\")]\n          ),\n          \"DIETARY_PREFERENCE\": (\n              DietaryPreference,\n              [EntityEdgeSourceTarget(source=\"User\")]\n          ),\n      }\n  )\n  ```\n\n  ```typescript\n  await client.graph.setOntology(\n      {\n          Restaurant: RestaurantSchema,\n          Audiobook: AudiobookSchema,\n      },\n      {\n          RESTAURANT_VISIT: RestaurantVisit,\n          AUDIOBOOK_LISTEN: AudiobookListen,\n          DIETARY_PREFERENCE: DietaryPreference,\n      },\n      {\n          userIds: [\"user_1234\", \"user_5678\"],\n          graphIds: [\"graph_1234\", \"graph_5678\"],\n      }\n  );\n  ```\n\n  ```go\n  _, err := client.Graph.SetOntology(\n      ctx,\n      []zep.EntityDefinition{\n          Restaurant{},\n          Audiobook{},\n      },\n      []zep.EdgeDefinitionWithSourceTargets{\n          {\n              EdgeModel: RestaurantVisit{},\n              SourceTargets: []zep.EntityEdgeSourceTarget{\n                  {\n                      Source: zep.String(\"User\"),\n                      Target: zep.String(\"Restaurant\"),\n                  },\n              },\n          },\n          {\n              EdgeModel: AudiobookListen{},\n              SourceTargets: []zep.EntityEdgeSourceTarget{\n                  {\n                      Source: zep.String(\"User\"),\n                      Target: zep.String(\"Audiobook\"),\n                  },\n              },\n          },\n          {\n              EdgeModel: DietaryPreference{},\n              SourceTargets: []zep.EntityEdgeSourceTarget{\n                  {\n                      Source: zep.String(\"User\"),\n                  },\n              },\n          },\n      },\n      zep.ForUsers([]string{\"user_1234\", \"user_5678\"}),\n      zep.ForGraphs([]string{\"graph_1234\", \"graph_5678\"}),\n  )\n  if err != nil {\n      fmt.Printf(\"Error setting ontology: %v\\n\", err)\n      return\n  }\n  ```\n</CodeBlocks>\n\n### Adding Data\n\nNow, when you add data to the graph, new nodes and edges are classified into exactly one of the overall set of entity or edge types respectively, or no type:\n\n<CodeBlocks>\n  ```python\n  from zep_cloud import Message\n  import uuid\n\n  messages_thread1 = [\n      Message(content=\"Take me to a lunch place\", role=\"user\", name=\"John Doe\"),\n      Message(content=\"How about Panera Bread, Chipotle, or Green Leaf Cafe, which are nearby?\", role=\"assistant\", name=\"Assistant\"),\n      Message(content=\"Do any of those have vegetarian options? I'm vegetarian\", role=\"user\", name=\"John Doe\"),\n      Message(content=\"Yes, Green Leaf Cafe has vegetarian options\", role=\"assistant\", name=\"Assistant\"),\n      Message(content=\"Let's go to Green Leaf Cafe\", role=\"user\", name=\"John Doe\"),\n      Message(content=\"Navigating to Green Leaf Cafe\", role=\"assistant\", name=\"Assistant\"),\n  ]\n\n  messages_thread2 = [\n      Message(content=\"Play the 7 habits of highly effective people\", role=\"user\", name=\"John Doe\"),\n      Message(content=\"Playing the 7 habits of highly effective people\", role=\"assistant\", name=\"Assistant\"),\n  ]\n\n  user_id = f\"user-{uuid.uuid4()}\"\n  client.user.add(user_id=user_id, first_name=\"John\", last_name=\"Doe\", email=\"john.doe@example.com\")\n\n  thread1_id = f\"thread-{uuid.uuid4()}\"\n  thread2_id = f\"thread-{uuid.uuid4()}\"\n  client.thread.create(thread_id=thread1_id, user_id=user_id)\n  client.thread.create(thread_id=thread2_id, user_id=user_id)\n\n  client.thread.add_messages(thread_id=thread1_id, messages=messages_thread1, ignore_roles=[\"assistant\"])\n  client.thread.add_messages(thread_id=thread2_id, messages=messages_thread2, ignore_roles=[\"assistant\"])\n  ```\n\n  ```typescript\n  import { v4 as uuidv4 } from \"uuid\";\n  import type { Message } from \"@getzep/zep-cloud/api\";\n\n  const messagesThread1: Message[] = [\n      { content: \"Take me to a lunch place\", role: \"user\", name: \"John Doe\" },\n      { content: \"How about Panera Bread, Chipotle, or Green Leaf Cafe, which are nearby?\", role: \"assistant\", name: \"Assistant\" },\n      { content: \"Do any of those have vegetarian options? I'm vegetarian\", role: \"user\", name: \"John Doe\" },\n      { content: \"Yes, Green Leaf Cafe has vegetarian options\", role: \"assistant\", name: \"Assistant\" },\n      { content: \"Let's go to Green Leaf Cafe\", role: \"user\", name: \"John Doe\" },\n      { content: \"Navigating to Green Leaf Cafe\", role: \"assistant\", name: \"Assistant\" },\n  ];\n\n  const messagesThread2: Message[] = [\n      { content: \"Play the 7 habits of highly effective people\", role: \"user\", name: \"John Doe\" },\n      { content: \"Playing the 7 habits of highly effective people\", role: \"assistant\", name: \"Assistant\" },\n  ];\n\n  let userId = `user-${uuidv4()}`;\n  await client.user.add({ userId, firstName: \"John\", lastName: \"Doe\", email: \"john.doe@example.com\" });\n\n  const thread1Id = `thread-${uuidv4()}`;\n  const thread2Id = `thread-${uuidv4()}`;\n  await client.thread.create({ threadId: thread1Id, userId });\n  await client.thread.create({ threadId: thread2Id, userId });\n\n  await client.thread.addMessages(thread1Id, { messages: messagesThread1, ignoreRoles: [\"assistant\"] });\n  await client.thread.addMessages(thread2Id, { messages: messagesThread2, ignoreRoles: [\"assistant\"] });\n  ```\n\n  ```go\n  messagesThread1 := []zep.Message{\n      {Content: \"Take me to a lunch place\", Role: \"user\", Name: zep.String(\"John Doe\")},\n      {Content: \"How about Panera Bread, Chipotle, or Green Leaf Cafe, which are nearby?\", Role: \"assistant\", Name: zep.String(\"Assistant\")},\n      {Content: \"Do any of those have vegetarian options? I'm vegetarian\", Role: \"user\", Name: zep.String(\"John Doe\")},\n      {Content: \"Yes, Green Leaf Cafe has vegetarian options\", Role: \"assistant\", Name: zep.String(\"Assistant\")},\n      {Content: \"Let's go to Green Leaf Cafe\", Role: \"user\", Name: zep.String(\"John Doe\")},\n      {Content: \"Navigating to Green Leaf Cafe\", Role: \"assistant\", Name: zep.String(\"Assistant\")},\n  }\n  messagesThread2 := []zep.Message{\n      {Content: \"Play the 7 habits of highly effective people\", Role: \"user\", Name: zep.String(\"John Doe\")},\n      {Content: \"Playing the 7 habits of highly effective people\", Role: \"assistant\", Name: zep.String(\"Assistant\")},\n  }\n  userID := \"user-\" + uuid.NewString()\n  userReq := &zep.CreateUserRequest{\n      UserID:    userID,\n      FirstName: zep.String(\"John\"),\n      LastName:  zep.String(\"Doe\"),\n      Email:     zep.String(\"john.doe@example.com\"),\n  }\n  _, err := client.User.Add(ctx, userReq)\n  if err != nil {\n      fmt.Printf(\"Error creating user: %v\\n\", err)\n      return\n  }\n\n  thread1ID := \"thread-\" + uuid.NewString()\n  thread2ID := \"thread-\" + uuid.NewString()\n\n  thread1Req := &zep.CreateThreadRequest{\n      ThreadID: thread1ID,\n      UserID:    userID,\n  }\n  thread2Req := &zep.CreateThreadRequest{\n      ThreadID: thread2ID,\n      UserID:    userID,\n  }\n  _, err = client.Thread.Create(ctx, thread1Req)\n  if err != nil {\n      fmt.Printf(\"Error creating thread 1: %v\\n\", err)\n      return\n  }\n  _, err = client.Thread.Create(ctx, thread2Req)\n  if err != nil {\n      fmt.Printf(\"Error creating thread 2: %v\\n\", err)\n      return\n  }\n\n  msgPtrs1 := make([]*zep.Message, len(messagesThread1))\n  for i := range messagesThread1 {\n      msgPtrs1[i] = &messagesThread1[i]\n  }\n  addReq1 := &zep.AddThreadMessagesRequest{\n      Messages: msgPtrs1,\n      IgnoreRoles: []zep.RoleType{\n      zep.RoleTypeAssistantRole,\n  },\n  }\n  _, err = client.Thread.AddMessages(ctx, thread1ID, addReq1)\n  if err != nil {\n      fmt.Printf(\"Error adding messages to thread 1: %v\\n\", err)\n      return\n  }\n\n  msgPtrs2 := make([]*zep.Message, len(messagesThread2))\n  for i := range messagesThread2 {\n      msgPtrs2[i] = &messagesThread2[i]\n  }\n  addReq2 := &zep.AddThreadMessagesRequest{\n      Messages: msgPtrs2,\n      IgnoreRoles: []zep.RoleType{\n      zep.RoleTypeAssistantRole,\n  },\n  }\n  _, err = client.Thread.AddMessages(ctx, thread2ID, addReq2)\n  if err != nil {\n      fmt.Printf(\"Error adding messages to thread 2: %v\\n\", err)\n      return\n  }\n  ```\n</CodeBlocks>\n\n### Retrieving Custom Types\n\nOnce you've created custom entity and edge types in your graph, you'll typically want to retrieve information filtered by these specific types. There are two primary approaches:\n\n1. **Context Templates** (Recommended): Use context templates to create reusable context blocks that automatically filter by type. This is ideal when you want consistent formatting with automatic relevance detection.\n2. **Graph Search**: Use direct graph search for more granular control over queries and when you need dynamic, query-based retrieval.\n\n#### Using Context Templates\n\nContext templates provide a convenient way to create context blocks that filter by your custom entity and edge types. You define a template once and Zep automatically retrieves and formats the relevant information.\n\nContext templates support the `types` parameter on `%{entities}` and `%{edges}` variables to filter by your custom types:\n\n<CodeBlocks>\n  ```python\n  # Create a template that filters by custom types\n  client.context.create_context_template(\n      template_id=\"restaurant-audiobook-context\",\n      template=\"\"\"# USER PREFERENCES\n  %{edges types=[DIETARY_PREFERENCE] limit=5}\n\n  # RESTAURANT VISITS\n  %{edges types=[RESTAURANT_VISIT] limit=10}\n\n  # RESTAURANTS\n  %{entities types=[Restaurant] limit=5}\n\n  # AUDIOBOOKS\n  %{entities types=[Audiobook] limit=5}\n\n  # AUDIOBOOK LISTENING HISTORY\n  %{edges types=[AUDIOBOOK_LISTEN] limit=10}\"\"\"\n  )\n\n  # Use the template to get context\n  results = client.thread.get_user_context(\n      thread_id=thread1_id,\n      template_id=\"restaurant-audiobook-context\"\n  )\n  print(results.context)\n  ```\n\n  ```typescript\n  // Create a template that filters by custom types\n  await client.context.createContextTemplate({\n      templateId: \"restaurant-audiobook-context\",\n      template: `# USER PREFERENCES\n  %{edges types=[DIETARY_PREFERENCE] limit=5}\n\n  # RESTAURANT VISITS\n  %{edges types=[RESTAURANT_VISIT] limit=10}\n\n  # RESTAURANTS\n  %{entities types=[Restaurant] limit=5}\n\n  # AUDIOBOOKS\n  %{entities types=[Audiobook] limit=5}\n\n  # AUDIOBOOK LISTENING HISTORY\n  %{edges types=[AUDIOBOOK_LISTEN] limit=10}`\n  });\n\n  // Use the template to get context\n  const results = await client.thread.getUserContext(thread1Id, {\n      templateId: \"restaurant-audiobook-context\"\n  });\n  console.log(results.context);\n  ```\n\n  ```go\n  // Create a template that filters by custom types\n  _, err = client.Context.CreateContextTemplate(\n      ctx,\n      &zep.CreateContextTemplateRequest{\n          TemplateID: \"restaurant-audiobook-context\",\n          Template: `# USER PREFERENCES\n  %{edges types=[DIETARY_PREFERENCE] limit=5}\n\n  # RESTAURANT VISITS\n  %{edges types=[RESTAURANT_VISIT] limit=10}\n\n  # RESTAURANTS\n  %{entities types=[Restaurant] limit=5}\n\n  # AUDIOBOOKS\n  %{entities types=[Audiobook] limit=5}\n\n  # AUDIOBOOK LISTENING HISTORY\n  %{edges types=[AUDIOBOOK_LISTEN] limit=10}`,\n      },\n  )\n  if err != nil {\n      fmt.Printf(\"Error creating context template: %v\\n\", err)\n      return\n  }\n\n  // Use the template to get context\n  templateID := \"restaurant-audiobook-context\"\n  results, err := client.Thread.GetUserContext(\n      ctx,\n      thread1ID,\n      &zep.ThreadGetUserContextRequest{\n          TemplateID: &templateID,\n      },\n  )\n  if err != nil {\n      fmt.Printf(\"Error getting user context: %v\\n\", err)\n      return\n  }\n  fmt.Println(results.Context)\n  ```\n</CodeBlocks>\n\nThe resulting context block will automatically include only the specified types, formatted according to your template:\n\n```text\n### USER PREFERENCES\n- (2024-11-20 10:30:00 - present) [DIETARY_PREFERENCE] <User states 'I'm vegetarian' indicating a dietary preference> { preference_type: vegetarian, allergy: false }\n\n### RESTAURANT VISITS\n- (2024-11-20 10:35:00 - present) [RESTAURANT_VISIT] <User John Doe is going to Green Leaf Cafe> { restaurant_name: Green Leaf Cafe }\n\n### RESTAURANTS\n- { name: Green Leaf Cafe, types: [Entity,Restaurant], summary: Green Leaf Cafe is a restaurant that offers vegetarian options, attributes: { dietary_accommodation: vegetarian } }\n\n### AUDIOBOOKS\n- { name: 7 habits of highly effective people, types: [Entity,Audiobook], summary: '7 habits of highly effective people' is an audiobook }\n\n### AUDIOBOOK LISTENING HISTORY\n- (2024-11-20 10:40:00 - present) [AUDIOBOOK_LISTEN] <John Doe requested to play the audiobook '7 habits of highly effective people'> { audiobook_title: 7 habits of highly effective people }\n```\n\n<Note>\n  Learn more about context templates in the [Context Templates](/context-templates) documentation.\n</Note>\n\n#### Using Graph Search\n\nFor more granular control or dynamic queries, you can use graph search to filter by entity or edge types. Graph search is ideal when you need to specify custom search queries, want direct access to individual nodes or edges, or are building dynamic filtering based on runtime conditions.\n\n<Tabs>\n  <Tab title=\"Searching Entities\">\n    Search for entities (nodes) by filtering on custom entity types using the `node_labels` parameter:\n\n    <CodeBlocks>\n      ```python\n      search_results_restaurants = client.graph.search(\n          user_id=user_id,\n          query=\"Take me to a restaurant\",\n          scope=\"nodes\",\n          search_filters={\n              \"node_labels\": [\"Restaurant\"]\n          },\n          limit=1,\n      )\n      node = search_results_restaurants.nodes[0]\n      print(f\"Node name: {node.name}\")\n      print(f\"Node labels: {node.labels}\")\n      print(f\"Cuisine type: {node.attributes.get('cuisine_type')}\")\n      print(f\"Dietary accommodation: {node.attributes.get('dietary_accommodation')}\")\n      ```\n\n      ```typescript\n      let searchResults = await client.graph.search({\n          userId: userId,\n          query: \"Take me to a restaurant\",\n          scope: \"nodes\",\n          searchFilters: { nodeLabels: [\"Restaurant\"] },\n          limit: 1,\n      });\n      if (searchResults.nodes && searchResults.nodes.length > 0) {\n          const node = searchResults.nodes[0];\n          console.log(`Node name: ${node.name}`);\n          console.log(`Node labels: ${node.labels}`);\n          console.log(`Cuisine type: ${node.attributes?.cuisine_type}`);\n          console.log(`Dietary accommodation: ${node.attributes?.dietary_accommodation}`);\n      }\n      ```\n\n      ```go\n      searchFiltersRestaurants := zep.SearchFilters{NodeLabels: []string{\"Restaurant\"}}\n      searchResultsRestaurants, err := client.Graph.Search(\n          ctx,\n          &zep.GraphSearchQuery{\n              UserID:        zep.String(userID),\n              Query:         \"Take me to a restaurant\",\n              Scope:         zep.GraphSearchScopeNodes.Ptr(),\n              SearchFilters: &searchFiltersRestaurants,\n              Limit:         zep.Int(1),\n          },\n      )\n      if err != nil {\n          fmt.Printf(\"Error searching graph: %v\\n\", err)\n          return\n      }\n      if len(searchResultsRestaurants.Nodes) > 0 {\n          node := searchResultsRestaurants.Nodes[0]\n          fmt.Printf(\"Node name: %s\\n\", node.Name)\n          fmt.Printf(\"Node labels: %v\\n\", node.Labels)\n          fmt.Printf(\"Cuisine type: %v\\n\", node.Attributes[\"cuisine_type\"])\n          fmt.Printf(\"Dietary accommodation: %v\\n\", node.Attributes[\"dietary_accommodation\"])\n      }\n      ```\n    </CodeBlocks>\n\n    ```text\n    Node name: Green Leaf Cafe\n    Node labels: Entity,Restaurant\n    Cuisine type: undefined\n    Dietary accommodation: vegetarian\n    ```\n  </Tab>\n\n  <Tab title=\"Searching Edges\">\n    Search for edges by filtering on custom edge types using the `edge_types` parameter:\n\n    <CodeBlocks>\n      ```python\n      search_results_visits = client.graph.search(\n          user_id=user_id,\n          query=\"Take me to a restaurant\",\n          scope=\"edges\",\n          search_filters={\n              \"edge_types\": [\"RESTAURANT_VISIT\"]\n          },\n          limit=1,\n      )\n      edge = search_results_visits.edges[0]\n      print(f\"Edge fact: {edge.fact}\")\n      print(f\"Edge type: {edge.name}\")\n      print(f\"Restaurant name: {edge.attributes.get('restaurant_name')}\")\n      ```\n\n      ```typescript\n      searchResults = await client.graph.search({\n          userId: userId,\n          query: \"Take me to a restaurant\",\n          scope: \"edges\",\n          searchFilters: { edgeTypes: [\"RESTAURANT_VISIT\"] },\n          limit: 1,\n      });\n      if (searchResults.edges && searchResults.edges.length > 0) {\n          const edge = searchResults.edges[0];\n          console.log(`Edge fact: ${edge.fact}`);\n          console.log(`Edge type: ${edge.name}`);\n          console.log(`Restaurant name: ${edge.attributes?.restaurant_name}`);\n      }\n      ```\n\n      ```go\n      searchFiltersVisits := zep.SearchFilters{EdgeTypes: []string{\"RESTAURANT_VISIT\"}}\n      searchResultsVisits, err := client.Graph.Search(\n          ctx,\n          &zep.GraphSearchQuery{\n              UserID:        zep.String(userID),\n              Query:         \"Take me to a restaurant\",\n              Scope:         zep.GraphSearchScopeEdges.Ptr(),\n              SearchFilters: &searchFiltersVisits,\n              Limit:         zep.Int(1),\n          },\n      )\n      if err != nil {\n          fmt.Printf(\"Error searching graph: %v\\n\", err)\n          return\n      }\n      if len(searchResultsVisits.Edges) > 0 {\n          edge := searchResultsVisits.Edges[0]\n          var visit RestaurantVisit\n          err := zep.UnmarshalEdgeAttributes(edge.Attributes, &visit)\n          if err != nil {\n              fmt.Printf(\"Error converting edge to RestaurantVisit struct: %v\\n\", err)\n          } else {\n              fmt.Printf(\"Edge fact: %s\\n\", edge.Fact)\n              fmt.Printf(\"Edge type: %s\\n\", edge.Name)\n              fmt.Printf(\"Restaurant name: %s\\n\", visit.RestaurantName)\n          }\n      }\n      ```\n    </CodeBlocks>\n\n    ```text\n    Edge fact: User John Doe is going to Green Leaf Cafe\n    Edge type: RESTAURANT_VISIT\n    Restaurant name: Green Leaf Cafe\n    ```\n  </Tab>\n</Tabs>\n\nYou can provide multiple types in search filters, and the types will be ORed together. For example, searching with `edge_types: [\"DIETARY_PREFERENCE\", \"RESTAURANT_VISIT\"]` will return edges matching either type.\n\n### Important Notes/Tips\n\nSome notes regarding custom entity and edge types:\n\n* The `set_ontology` method overwrites any previously defined custom entity and edge types, so the set of custom entity and edge types is always the list of types provided in the last `set_ontology` method call\n* The overall set of entity and edge types for a project includes both the custom entity and edge types you set and the default entity and edge types\n* You can overwrite the default entity and edge types by providing custom types with the same names\n* Changing the custom entity or edge types will not update previously created nodes or edges. The classification and attributes of existing nodes and edges will stay the same. The only thing that can change existing classifications or attributes is adding data that provides new information.\n* When creating custom entity or edge types, avoid using the following attribute names (including in Go struct tags), as they conflict with default attributes: `uuid`, `name`, `graph_id`, `name_embedding`, `summary`, and `created_at`\n* **Any custom entity or edge is required to have at least one custom property defined**\n* **Tip**: Design custom entity types to represent entities/nouns, and design custom edge types to represent relationships/verbs. Otherwise, your type might be represented in the graph as an edge more often than as a node or vice versa.\n* **Tip**: If you have overlapping entity or edge types (e.g. 'Hobby' and 'Hiking'), you can prioritize one type over another by mentioning which to prioritize in the entity or edge type descriptions",
  "content_length": 39237
}