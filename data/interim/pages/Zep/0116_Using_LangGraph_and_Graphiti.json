{
  "title": "Using LangGraph and Graphiti",
  "source_url": null,
  "content": "> Building an agent with LangChain's LangGraph and Graphiti\n\n<Note>\n  A Jupyter notebook version of this example is available [on GitHub](https://github.com/getzep/graphiti/blob/main/examples/langgraph-agent/agent.ipynb).\n</Note>\n\n<Tip>\n  Looking for a managed Graphiti service? Check out [Zep Cloud](https://www.getzep.com).\n\n  * Designed as a self-improving memory layer for Agents.\n  * No need to run Neo4j or other dependencies.\n  * Additional features for startups and enterprises alike.\n  * Fast and scalable.\n</Tip>\n\nThe following example demonstrates building an agent using LangGraph. Graphiti is used to personalize agent responses based on information learned from prior conversations. Additionally, a database of products is loaded into the Graphiti graph, enabling the agent to speak to these products.\n\nThe agent implements:\n\n* persistance of new chat turns to Graphiti and recall of relevant Facts using the most recent message.\n* a tool for querying Graphiti for shoe information\n* an in-memory `MemorySaver` to maintain agent state.\n\n## Install dependencies\n\n```shell\npip install graphiti-core langchain-openai langgraph ipywidgets\n```\n\n<Note>\n  Ensure that you've followed the [Graphiti installation instructions](/graphiti/getting-started/quick-start). In particular, installation of `neo4j`.\n</Note>\n\n```python\nimport asyncio\nimport json\nimport logging\nimport os\nimport sys\nimport uuid\nfrom contextlib import suppress\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Annotated\n\nimport ipywidgets as widgets\nfrom dotenv import load_dotenv\nfrom IPython.display import Image, display\nfrom typing_extensions import TypedDict\n\nload_dotenv()\n```\n\n```python\ndef setup_logging():\n    logger = logging.getLogger()\n    logger.setLevel(logging.ERROR)\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(logging.INFO)\n    formatter = logging.Formatter('%(name)s - %(levelname)s - %(message)s')\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n    return logger\n\n\nlogger = setup_logging()\n```\n\n## Configure Graphiti\n\nEnsure that you have `neo4j` running and a database created. You'll need the following environment variables configured:\n\n```bash\nNEO4J_URI=\nNEO4J_USER=\nNEO4J_PASSWORD=\n```\n\n```python\n### Configure Graphiti\n\nfrom graphiti_core import Graphiti\nfrom graphiti_core.edges import EntityEdge\nfrom graphiti_core.nodes import EpisodeType\nfrom graphiti_core.utils.bulk_utils import RawEpisode\nfrom graphiti_core.utils.maintenance.graph_data_operations import clear_data\n\nneo4j_uri = os.environ.get('NEO4J_URI', 'bolt://localhost:7687')\nneo4j_user = os.environ.get('NEO4J_USER', 'neo4j')\nneo4j_password = os.environ.get('NEO4J_PASSWORD', 'password')\n\nclient = Graphiti(\n    neo4j_uri,\n    neo4j_user,\n    neo4j_password,\n)\n```\n\n## Generating a database schema\n\nThe following is only required for the first run of this notebook or when you'd like to start your database over.\n\n<Warning>\n  `clear_data` is destructive and will wipe your entire database.\n</Warning>\n\n```python\n### Note: This will clear the database\nawait clear_data(client.driver)\nawait client.build_indices_and_constraints()\n```\n\n## Load Shoe Data into the Graph\n\nLoad several shoe and related products into the Graphiti. This may take a while.\n\n<Note>\n  This only needs to be done once. If you run `clear_data` you'll need to rerun this step.\n</Note>\n\n```python\nasync def ingest_products_data(client: Graphiti):\n    script_dir = Path.cwd().parent\n    json_file_path = script_dir / 'data' / 'manybirds_products.json'\n\n    with open(json_file_path) as file:\n        products = json.load(file)['products']\n\n    episodes: list[RawEpisode] = [\n        RawEpisode(\n            name=product.get('title', f'Product {i}'),\n            content=str({k: v for k, v in product.items() if k != 'images'}),\n            source_description='ManyBirds products',\n            source=EpisodeType.json,\n            reference_time=datetime.now(),\n        )\n        for i, product in enumerate(products)\n    ]\n\n    await client.add_episode_bulk(episodes)\n\n\nawait ingest_products_data(client)\n```\n\n## Create a user node in the Graphiti graph\n\nIn your own app, this step could be done later once the user has identified themselves and made their sales intent known. We do this here so we can configure the agent with the user's `node_uuid`.\n\n```python\nuser_name = 'jess'\n\nawait client.add_episode(\n    name='User Creation',\n    episode_body=(f'{user_name} is interested in buying a pair of shoes'),\n    source=EpisodeType.text,\n    reference_time=datetime.now(),\n    source_description='SalesBot',\n)\n\n### let's get Jess's node uuid\nnl = await client.get_nodes_by_query(user_name)\n\nuser_node_uuid = nl[0].uuid\n\n### and the ManyBirds node uuid\nnl = await client.get_nodes_by_query('ManyBirds')\nmanybirds_node_uuid = nl[0].uuid\n```\n\n## Helper Functions and LangChain Imports\n\n```python\ndef edges_to_facts_string(entities: list[EntityEdge]):\n    return '-' + '\\n- '.join([edge.fact for edge in entities])\n```\n\n```python\nfrom langchain_core.messages import AIMessage, SystemMessage\nfrom langchain_core.tools import tool\nfrom langchain_openai import ChatOpenAI\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom langgraph.graph import END, START, StateGraph, add_messages\nfrom langgraph.prebuilt import ToolNode\n```\n\n## `get_shoe_data` Tool\n\nThe agent will use this to search the Graphiti graph for information about shoes. We center the search on the `manybirds_node_uuid` to ensure we rank shoe-related data over user data.\n\n```python\n@tool\nasync def get_shoe_data(query: str) -> str:\n    \"\"\"Search the graphiti graph for information about shoes\"\"\"\n    edge_results = await client.search(\n        query,\n        center_node_uuid=manybirds_node_uuid,\n        num_results=10,\n    )\n    return edges_to_facts_string(edge_results)\n\n\ntools = [get_shoe_data]\ntool_node = ToolNode(tools)\n```\n\n## Initialize the LLM and bind tools\n\n```python\nllm = ChatOpenAI(model='gpt-4o-mini', temperature=0).bind_tools(tools)\n```\n\n### Test the tool node\n\n```python\nawait tool_node.ainvoke({'messages': [await llm.ainvoke('wool shoes')]})\n```\n\n```json\n{\n    \"messages\": [\n        {\n            \"content\": \"-The product 'Men's SuperLight Wool Runners - Dark Grey (Medium Grey Sole)' is made of Wool.\\n- Women's Tree Breezers Knit - Rugged Beige (Hazy Beige Sole) has sizing options related to women's move shoes half sizes.\\n- TinyBirds Wool Runners - Little Kids - Natural Black (Blizzard Sole) is a type of Shoes.\\n- The product 'Men's SuperLight Wool Runners - Dark Grey (Medium Grey Sole)' belongs to the category Shoes.\\n- The product 'Men's SuperLight Wool Runners - Dark Grey (Medium Grey Sole)' uses SuperLight Foam technology.\\n- TinyBirds Wool Runners - Little Kids - Natural Black (Blizzard Sole) is sold by Manybirds.\\n- Jess is interested in buying a pair of shoes.\\n- TinyBirds Wool Runners - Little Kids - Natural Black (Blizzard Sole) has the handle TinyBirds-wool-runners-little-kids.\\n- ManyBirds Men's Couriers are a type of Shoes.\\n- Women's Tree Breezers Knit - Rugged Beige (Hazy Beige Sole) belongs to the Shoes category.\",\n            \"name\": \"get_shoe_data\",\n            \"tool_call_id\": \"call_EPpOpD75rdq9jKRBUsfRnfxx\"\n        }\n    ]\n}\n```\n\n## Chatbot Function Explanation\n\nThe chatbot uses Graphiti to provide context-aware responses in a shoe sales scenario. Here's how it works:\n\n1. **Context Retrieval**: It searches the Graphiti graph for relevant information based on the latest message, using the user's node as the center point. This ensures that user-related facts are ranked higher than other information in the graph.\n\n2. **System Message**: It constructs a system message incorporating facts from Graphiti, setting the context for the AI's response.\n\n3. **Knowledge Persistence**: After generating a response, it asynchronously adds the interaction to the Graphiti graph, allowing future queries to reference this conversation.\n\nThis approach enables the chatbot to maintain context across interactions and provide personalized responses based on the user's history and preferences stored in the Graphiti graph.\n\n```python\nclass State(TypedDict):\n    messages: Annotated[list, add_messages]\n    user_name: str\n    user_node_uuid: str\n\n\nasync def chatbot(state: State):\n    facts_string = None\n    if len(state['messages']) > 0:\n        last_message = state['messages'][-1]\n        graphiti_query = f'{\"SalesBot\" if isinstance(last_message, AIMessage) else state[\"user_name\"]}: {last_message.content}'\n        # search graphiti using Jess's node uuid as the center node\n        # graph edges (facts) further from the Jess node will be ranked lower\n        edge_results = await client.search(\n            graphiti_query, center_node_uuid=state['user_node_uuid'], num_results=5\n        )\n        facts_string = edges_to_facts_string(edge_results)\n\n    system_message = SystemMessage(\n        content=f\"\"\"You are a skillfull shoe salesperson working for ManyBirds. Review information about the user and their prior conversation below and respond accordingly.\n        Keep responses short and concise. And remember, always be selling (and helpful!)\n\n        Things you'll need to know about the user in order to close a sale:\n        - the user's shoe size\n        - any other shoe needs? maybe for wide feet?\n        - the user's preferred colors and styles\n        - their budget\n\n        Ensure that you ask the user for the above if you don't already know.\n\n        Facts about the user and their conversation:\n        {facts_string or 'No facts about the user and their conversation'}\"\"\"\n    )\n\n    messages = [system_message] + state['messages']\n\n    response = await llm.ainvoke(messages)\n\n    # add the response to the graphiti graph.\n    # this will allow us to use the graphiti search later in the conversation\n    # we're doing async here to avoid blocking the graph execution\n    asyncio.create_task(\n        client.add_episode(\n            name='Chatbot Response',\n            episode_body=f\"{state['user_name']}: {state['messages'][-1]}\\nSalesBot: {response.content}\",\n            source=EpisodeType.message,\n            reference_time=datetime.now(),\n            source_description='Chatbot',\n        )\n    )\n\n    return {'messages': [response]}\n```\n\n## Setting up the Agent\n\nThis section sets up the Agent's LangGraph graph:\n\n1. **Graph Structure**: It defines a graph with nodes for the agent (chatbot) and tools, connected in a loop.\n\n2. **Conditional Logic**: The `should_continue` function determines whether to end the graph execution or continue to the tools node based on the presence of tool calls.\n\n3. **Memory Management**: It uses a MemorySaver to maintain conversation state across turns. This is in addition to using Graphiti for facts.\n\n```python\ngraph_builder = StateGraph(State)\n\nmemory = MemorySaver()\n\n\n### Define the function that determines whether to continue or not\nasync def should_continue(state, config):\n    messages = state['messages']\n    last_message = messages[-1]\n    # If there is no function call, then we finish\n    if not last_message.tool_calls:\n        return 'end'\n    # Otherwise if there is, we continue\n    else:\n        return 'continue'\n\n\ngraph_builder.add_node('agent', chatbot)\ngraph_builder.add_node('tools', tool_node)\n\ngraph_builder.add_edge(START, 'agent')\ngraph_builder.add_conditional_edges('agent', should_continue, {'continue': 'tools', 'end': END})\ngraph_builder.add_edge('tools', 'agent')\n\n\ngraph = graph_builder.compile(checkpointer=memory)\n```\n\nOur LangGraph agent graph is illustrated below.\n\n```python\nwith suppress(Exception):\n    display(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![LangGraph Illustration](file:71e4b795-c674-47dd-add9-73242e4cb3f3)\n\n## Running the Agent\n\nLet's test the agent with a single call\n\n```python\nawait graph.ainvoke(\n    {\n        'messages': [\n            {\n                'role': 'user',\n                'content': 'What sizes do the TinyBirds Wool Runners in Natural Black come in?',\n            }\n        ],\n        'user_name': user_name,\n        'user_node_uuid': user_node_uuid,\n    },\n    config={'configurable': {'thread_id': uuid.uuid4().hex}},\n)\n```\n\n```json\n\n{\n    \"messages\": [\n        {\n            \"content\": \"What sizes do the TinyBirds Wool Runners in Natural Black come in?\",\n            \"id\": \"6a940637-70a0-4c95-a4d7-4c4846909747\",\n            \"type\": \"HumanMessage\"\n        },\n        {\n            \"content\": \"The TinyBirds Wool Runners in Natural Black are available in the following sizes for little kids: 5T, 6T, 8T, 9T, and 10T. \\n\\nDo you have a specific size in mind, or are you looking for something else? Let me know your needs, and I can help you find the perfect pair!\",\n            \"additional_kwargs\": {\n                \"refusal\": null\n            },\n            \"response_metadata\": {\n                \"token_usage\": {\n                    \"completion_tokens\": 76,\n                    \"prompt_tokens\": 314,\n                    \"total_tokens\": 390\n                },\n                \"model_name\": \"gpt-4o-mini-2024-07-18\",\n                \"system_fingerprint\": \"fp_f33667828e\",\n                \"finish_reason\": \"stop\",\n                \"logprobs\": null\n            },\n            \"id\": \"run-d2f79c7f-4d41-4896-88dc-476a8e38bea8-0\",\n            \"usage_metadata\": {\n                \"input_tokens\": 314,\n                \"output_tokens\": 76,\n                \"total_tokens\": 390\n            },\n            \"type\": \"AIMessage\"\n        }\n    ],\n    \"user_name\": \"jess\",\n    \"user_node_uuid\": \"186a845eee4849619d1e625b178d1845\"\n}\n```\n\n## Viewing the Graph\n\nAt this stage, the graph would look something like this. The `jess` node is `INTERESTED_IN` the `TinyBirds Wool Runner` node. The image below was generated using Neo4j Desktop.\n\n![Graph State](file:c8b7fce7-08df-4ad0-8121-1dab5e208dad)\n\n## Running the Agent interactively\n\nThe following code will run the agent in a Jupyter notebook event loop. You can modify the code to suite your own needs.\n\nJust enter a message into the box and click submit.\n\n```python\nconversation_output = widgets.Output()\nconfig = {'configurable': {'thread_id': uuid.uuid4().hex}}\nuser_state = {'user_name': user_name, 'user_node_uuid': user_node_uuid}\n\n\nasync def process_input(user_state: State, user_input: str):\n    conversation_output.append_stdout(f'\\nUser: {user_input}\\n')\n    conversation_output.append_stdout('\\nAssistant: ')\n\n    graph_state = {\n        'messages': [{'role': 'user', 'content': user_input}],\n        'user_name': user_state['user_name'],\n        'user_node_uuid': user_state['user_node_uuid'],\n    }\n\n    try:\n        async for event in graph.astream(\n            graph_state,\n            config=config,\n        ):\n            for value in event.values():\n                if 'messages' in value:\n                    last_message = value['messages'][-1]\n                    if isinstance(last_message, AIMessage) and isinstance(\n                        last_message.content, str\n                    ):\n                        conversation_output.append_stdout(last_message.content)\n    except Exception as e:\n        conversation_output.append_stdout(f'Error: {e}')\n\n\ndef on_submit(b):\n    user_input = input_box.value\n    input_box.value = ''\n    asyncio.create_task(process_input(user_state, user_input))\n\n\ninput_box = widgets.Text(placeholder='Type your message here...')\nsubmit_button = widgets.Button(description='Send')\nsubmit_button.on_click(on_submit)\n\nconversation_output.append_stdout('Asssistant: Hello, how can I help you find shoes today?')\n\ndisplay(widgets.VBox([input_box, submit_button, conversation_output]))\n```",
  "content_length": 15683
}