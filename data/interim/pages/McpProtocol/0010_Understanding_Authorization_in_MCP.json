{
  "title": "Understanding Authorization in MCP",
  "source_url": "https://modelcontextprotocol.io/docs/tutorials/security/authorization",
  "content": "Learn how to implement secure authorization for MCP servers using OAuth 2.1 to protect sensitive resources and operations\n\nAuthorization in the Model Context Protocol (MCP) secures access to sensitive resources and operations exposed by MCP servers. If your MCP server handles user data or administrative actions, authorization ensures only permitted users can access its endpoints.\n\nMCP uses standardized authorization flows to build trust between MCP clients and MCP servers. Its design doesn't focus on one specific authorization or identity system, but rather follows the conventions outlined for [OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13). For detailed information, see the [Authorization specification](/specification/2025-06-18/basic/authorization).\n\n## When Should You Use Authorization?\n\nWhile authorization for MCP servers is **optional**, it is strongly recommended when:\n\n* Your server accesses user-specific data (emails, documents, databases)\n* You need to audit who performed which actions\n* Your server grants access to its APIs that require user consent\n* You're building for enterprise environments with strict access controls\n* You want to implement rate limiting or usage tracking per user\n\n<Tip>\n  **Authorization for Local MCP Servers**\n\n  For MCP servers using the [STDIO transport](/specification/2025-06-18/basic/transports#stdio), you can use environment-based credentials or credentials provided by third-party libraries embedded directly in the MCP server instead. Because a STDIO-built MCP server runs locally, it has access to a range of flexible options when it comes to acquiring user credentials that may or may not rely on in-browser authentication and authorization flows.\n\n  OAuth flows, in turn, are designed for HTTP-based transports where the MCP server is remotely-hosted and the client uses OAuth to establish that a user is authorized to access said remote server.\n</Tip>\n\n## The Authorization Flow: Step by Step\n\nLet's walk through what happens when a client wants to connect to your protected MCP server:\n\n<Steps>\n  <Step title=\"Initial Handshake\">\n    When your MCP client first tries to connect, your server responds with a `401 Unauthorized` and tells the client where to find authorization information, captured in a [Protected Resource Metadata (PRM) document](https://datatracker.ietf.org/doc/html/rfc9728). The document is hosted by the MCP server, follows a predictable path pattern, and is provided to the client in the `resource_metadata` parameter within the `WWW-Authenticate` header.\n\n    ```http  theme={null}\n    HTTP/1.1 401 Unauthorized\n    WWW-Authenticate: Bearer realm=\"mcp\",\n      resource_metadata=\"https://your-server.com/.well-known/oauth-protected-resource\"\n    ```\n\n    This tells the client that authorization is required for the MCP server and where to get the necessary information to kickstart the authorization flow.\n  </Step>\n\n  <Step title=\"Protected Resource Metadata Discovery\">\n    With the URI pointer to the PRM document, the client will fetch the metadata to learn about the authorization server, supported scopes, and other resource information. The data is typically encapsulated in a JSON blob, similar to the one below.\n\n    ```json  theme={null}\n    {\n      \"resource\": \"https://your-server.com/mcp\",\n      \"authorization_servers\": [\"https://auth.your-server.com\"],\n      \"scopes_supported\": [\"mcp:tools\", \"mcp:resources\"]\n    }\n    ```\n\n    You can see a more comprehensive example in [RFC 9728 Section 3.2](https://datatracker.ietf.org/doc/html/rfc9728#name-protected-resource-metadata-r).\n  </Step>\n\n  <Step title=\"Authorization Server Discovery\">\n    Next, the client discovers what the authorization server can do by fetching its metadata. If the PRM document lists more than one authorization server, the client can decide which one to use.\n\n    With an authorization server selected, the client will then construct a standard metadata URI and issue a request to the [OpenID Connect (OIDC) Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html) or [OAuth 2.0 Auth Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414) endpoints (depending on authorization server support)\n    and retrieve another set of metadata properties that will allow it to know the endpoints it needs to complete the authorization flow.\n\n    ```json  theme={null}\n    {\n      \"issuer\": \"https://auth.your-server.com\",\n      \"authorization_endpoint\": \"https://auth.your-server.com/authorize\",\n      \"token_endpoint\": \"https://auth.your-server.com/token\",\n      \"registration_endpoint\": \"https://auth.your-server.com/register\"\n    }\n    ```\n  </Step>\n\n  <Step title=\"Client Registration\">\n    With all the metadata out of the way, the client now needs to make sure that it's registered with the authorization server. This can be done in two ways.\n\n    First, the client can be **pre-registered** with a given authorization server, in which case it can have embedded client registration information that it uses to complete the authorization flow.\n\n    Alternatively, the client can use **Dynamic Client Registration** (DCR) to dynamically register itself with the authorization server. The latter scenario requires the authorization server to support DCR. If the authorization server does support DCR, the client will send a request to the `registration_endpoint` with its information:\n\n    ```json  theme={null}\n    {\n      \"client_name\": \"My MCP Client\",\n      \"redirect_uris\": [\"http://localhost:3000/callback\"],\n      \"grant_types\": [\"authorization_code\", \"refresh_token\"],\n      \"response_types\": [\"code\"]\n    }\n    ```\n\n    If the registration succeeds, the authorization server will return a JSON blob with client registration information.\n\n    <Tip>\n      **No DCR or Pre-Registration**\n\n      In case an MCP client connects to an MCP server that doesn't use an authorization server that supports DCR and the client is not pre-registered with said authorization server, it's the responsibility of the client developer to provide an affordance for the end-user to enter client information manually.\n    </Tip>\n  </Step>\n\n  <Step title=\"User Authorization\">\n    The client will now need to open a browser to the `/authorize` endpoint, where the user can log in and grant the required permissions. The authorization server will then redirect back to the client with an authorization code that the client exchanges for tokens:\n\n    ```json  theme={null}\n    {\n      \"access_token\": \"eyJhbGciOiJSUzI1NiIs...\",\n      \"refresh_token\": \"def502...\",\n      \"token_type\": \"Bearer\",\n      \"expires_in\": 3600\n    }\n    ```\n\n    The access token is what the client will use to authenticate requests to the MCP server. This step follows standard [OAuth 2.1 authorization code with PKCE](https://oauth.net/2/grant-types/authorization-code/) conventions.\n  </Step>\n\n  <Step title=\"Making Authenticated Requests\">\n    Finally, the client can make requests to your MCP server using the access token embedded in the `Authorization` header:\n\n    ```http  theme={null}\n    GET /mcp HTTP/1.1\n    Host: your-server.com\n    Authorization: Bearer eyJhbGciOiJSUzI1NiIs...\n    ```\n\n    The MCP server will need to validate the token and process the request if the token is valid and has the required permissions.\n  </Step>\n</Steps>\n\n## Implementation Example\n\nTo get started with a practical implementation, we will use a [Keycloak](https://www.keycloak.org/) authorization server hosted in a Docker container. Keycloak is an open-source authorization server that can be easily deployed locally for testing and experimentation.\n\nMake sure that you download and install [Docker Desktop](https://www.docker.com/products/docker-desktop/). We will need it to deploy Keycloak on our development machine.\n\n### Keycloak Setup\n\nFrom your terminal application, run the following command to start the Keycloak container:\n\n```bash  theme={null}\ndocker run -p 127.0.0.1:8080:8080 -e KC_BOOTSTRAP_ADMIN_USERNAME=admin -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak start-dev\n```\n\nThis command will pull the Keycloak container image locally and bootstrap the basic configuration. It will run on port `8080` and have an `admin` user with `admin` password.\n\n<Warning>\n  **Not for Production**\n\n  The configuration above may be suitable for testing and experimentation; however, you should never use it in production. Refer to the [Configuring Keycloak for production](https://www.keycloak.org/server/configuration-production) guide for additional details on how to deploy the authorization server for scenarios that require reliability, security, and high availability.\n</Warning>\n\nYou will be able to access the Keycloak authorization server from your browser at `http://localhost:8080`.\n\n<Frame>\n  <img src=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-browser.png?fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=cba689d986e113cbe937d732ac0558b6\" alt=\"Keycloak admin dashboard authentication dialog.\" data-og-width=\"1834\" width=\"1834\" data-og-height=\"1450\" height=\"1450\" data-path=\"images/tutorial-authorization/keycloak-browser.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-browser.png?w=280&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=6f32c1c9aa75a0533213ef708e0486f9 280w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-browser.png?w=560&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=a93c454733e5d23dea996ac4243b5ba7 560w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-browser.png?w=840&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=08f456b670f8c07ec91489abd44e1102 840w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-browser.png?w=1100&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=6f38eebb04db868078b62adc377c673d 1100w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-browser.png?w=1650&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=5e6ab1e9d62b82781152096fe6ee4c62 1650w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-browser.png?w=2500&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=26faaf97617cb789b0492ea580245dc0 2500w\" />\n</Frame>\n\nWhen running with the default configuration, Keycloak will already support many of the capabilities that we need for MCP servers, including Dynamic Client Registration. You can check this by looking at the OIDC configuration, available at:\n\n```http  theme={null}\nhttp://localhost:8080/realms/master/.well-known/openid-configuration\n```\n\nWe will also need to set up Keycloak to support our scopes and allow our host (local machine) to dynamically register clients, as the default policies restrict anonymous dynamic client registration.\n\nGo to **Client scopes** in the Keycloak dashboard and create a new `mcp:tools` scope. We will use this to access all of the tools on our MCP server.\n\n<Frame>\n  <img src=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-scopes.png?fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=3cd49dc2e070027609ae495751e0db58\" alt=\"Configuring Keycloak scopes.\" data-og-width=\"1999\" width=\"1999\" data-og-height=\"1710\" height=\"1710\" data-path=\"images/tutorial-authorization/keycloak-scopes.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-scopes.png?w=280&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=63647c72d96cc867eff23f6f193c97a3 280w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-scopes.png?w=560&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=d28690bb063e22a3f677c23df8a338bf 560w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-scopes.png?w=840&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=4e9dc9972f1449f20c2a5559fbfdde06 840w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-scopes.png?w=1100&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=b3a21b321612781d41ab018fcd19bca0 1100w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-scopes.png?w=1650&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=345993151f644fe6aca724a605c168f6 1650w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-scopes.png?w=2500&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=ac6152d64434b7cf8a8e74a4128b0f4f 2500w\" />\n</Frame>\n\nAfter creating the scope, make sure that you assign its type to **Default** and have flipped the **Include in token scope** switch, as this will be needed for token validation.\n\nLet's now also set up an **audience** for our Keycloak-issued tokens. An audience is important to configure because it embeds the intended destination directly into the issued access token. This helps your MCP server to verify that the token it got was actually meant for it rather than some other API. This is key to help avoid token passthrough scenarios.\n\nTo do this, open your `mcp:tools` client scope and click on **Mappers**, followed by **Configure a new mapper**. Select **Audience**.\n\n<Frame>\n  <img src=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/scope-add-audience.gif?s=6ea9cf20c397f4c79c491c2e39019272\" alt=\"Configuring an audience for a token in Keycloak.\" data-og-width=\"1080\" width=\"1080\" data-og-height=\"921\" height=\"921\" data-path=\"images/tutorial-authorization/scope-add-audience.gif\" data-optimize=\"true\" data-opv=\"3\" />\n</Frame>\n\nFor **Name**, use `audience-config`. Add a value for **Included Custom Audience**, set to `http://localhost:3000`. This will be the URI of our test server.\n\n<Warning>\n  **Not for Production**\n\n  The audience configuration above is meant for testing. For production scenarios, additional set-up and configuration will be required to ensure that audiences are properly constrained for issued tokens. Specifically, the audience needs to be based on the resource parameter passed from the client, not a fixed value.\n</Warning>\n\nNow, navigate to **Clients**, then **Client registration**, and then **Trusted Hosts**. Disable the **Client URIs Must Match** setting and add the hosts from which you're testing. You can get your current host IP by running the `ifconfig` command on Linux or macOS, or `ipconfig` on Windows. You can see the IP address you need to add by looking at the keycloak logs for a line that looks like `Failed to verify remote host : 192.168.215.1`. Check that the IP address is associated with your host. This may be for a bridge network depending on your docker setup.\n\n<Frame>\n  <img src=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-client.gif?s=b5d40b36a5f1ea1e818821bb8ea77f6b\" alt=\"Setting up client registration details in Keycloak.\" data-og-width=\"1199\" width=\"1199\" data-og-height=\"1027\" height=\"1027\" data-path=\"images/tutorial-authorization/keycloak-client.gif\" data-optimize=\"true\" data-opv=\"3\" />\n</Frame>\n\n<Warning>\n  **Getting the Host**\n\n  If you are running Keycloak from a container, you will also be able to see the host IP from the Terminal in the container logs.\n</Warning>\n\nLastly, we need to register a new client that we can use with the **MCP server itself** to talk to Keycloak for things like [token introspection](https://oauth.net/2/token-introspection/). To do that:\n\n1. Go to **Clients**.\n2. Click **Create client**.\n3. Give your client a unique **Client ID** and click **Next**.\n4. Enable **Client authentication** and click **Next**.\n5. Click **Save**.\n\nWorth noting that token introspection is just *one of* the available approaches to validate tokens. This can also be done with the help of standalone libraries, specific to each language and platform.\n\nWhen you open the client details, go to **Credentials** and take note of the **Client Secret**.\n\n<Frame>\n  <img src=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-client-auth.gif?s=7152c41a5746994fd399024bc4659e40\" alt=\"Creating a new client in Keycloak.\" data-og-width=\"1200\" width=\"1200\" data-og-height=\"1023\" height=\"1023\" data-path=\"images/tutorial-authorization/keycloak-client-auth.gif\" data-optimize=\"true\" data-opv=\"3\" />\n</Frame>\n\n<Warning>\n  **Handling Secrets**\n\n  Never embed client credentials directly in your code. We recommend using environment variables or specialized solutions for secret storage.\n</Warning>\n\nWith Keycloak configured, every time the authorization flow is triggered, your MCP server will receive a token like this:\n\n```text  theme={null}\neyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICI1TjcxMGw1WW5MWk13WGZ1VlJKWGtCS3ZZMzZzb3JnRG5scmlyZ2tlTHlzIn0.eyJleHAiOjE3NTU1NDA4MTcsImlhdCI6MTc1NTU0MDc1NywiYXV0aF90aW1lIjoxNzU1NTM4ODg4LCJqdGkiOiJvbnJ0YWM6YjM0MDgwZmYtODQwNC02ODY3LTgxYmUtMTIzMWI1MDU5M2E4IiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwL3JlYWxtcy9tYXN0ZXIiLCJhdWQiOiJodHRwOi8vbG9jYWxob3N0OjMwMDAiLCJzdWIiOiIzM2VkNmM2Yi1jNmUwLTQ5MjgtYTE2MS1mMmY2OWM3YTAzYjkiLCJ0eXAiOiJCZWFyZXIiLCJhenAiOiI3OTc1YTViNi04YjU5LTRhODUtOWNiYS04ZmFlYmRhYjg5NzQiLCJzaWQiOiI4ZjdlYzI3Ni0zNThmLTRjY2MtYjMxMy1kYjA4MjkwZjM3NmYiLCJzY29wZSI6Im1jcDp0b29scyJ9.P5xCRtXORly0R0EXjyqRCUx-z3J4uAOWNAvYtLPXroykZuVCCJ-K1haiQSwbURqfsVOMbL7jiV-sD6miuPzI1tmKOkN_Yct0Vp-azvj7U5rEj7U6tvPfMkg2Uj_jrIX0KOskyU2pVvGZ-5BgqaSvwTEdsGu_V3_E0xDuSBq2uj_wmhqiyTFm5lJ1WkM3Hnxxx1_AAnTj7iOKMFZ4VCwMmk8hhSC7clnDauORc0sutxiJuYUZzxNiNPkmNeQtMCGqWdP1igcbWbrfnNXhJ6NswBOuRbh97_QraET3hl-CNmyS6C72Xc0aOwR_uJ7xVSBTD02OaQ1JA6kjCATz30kGYg\n```\n\nDecoded, it will look like this:\n\n```json  theme={null}\n{\n  \"alg\": \"RS256\",\n  \"typ\": \"JWT\",\n  \"kid\": \"5N710l5YnLZMwXfuVRJXkBKvY36sorgDnlrirgkeLys\"\n}.{\n  \"exp\": 1755540817,\n  \"iat\": 1755540757,\n  \"auth_time\": 1755538888,\n  \"jti\": \"onrtac:b34080ff-8404-6867-81be-1231b50593a8\",\n  \"iss\": \"http://localhost:8080/realms/master\",\n  \"aud\": \"http://localhost:3000\",\n  \"sub\": \"33ed6c6b-c6e0-4928-a161-f2f69c7a03b9\",\n  \"typ\": \"Bearer\",\n  \"azp\": \"7975a5b6-8b59-4a85-9cba-8faebdab8974\",\n  \"sid\": \"8f7ec276-358f-4ccc-b313-db08290f376f\",\n  \"scope\": \"mcp:tools\"\n}.[Signature]\n```\n\n<Warning>\n  **Embedded Audience**\n\n  Notice the `aud` claim embedded in the token - it's currently set to be the URI of the test MCP server and it's inferred from the scope that we've previously configured. This will be important in our implementation to validate.\n</Warning>\n\n### MCP Server Setup\n\nWe will now set up our MCP server to use the locally-running Keycloak authorization server. Depending on your programming language preference, you can use one of the supported [MCP SDKs](/docs/sdk).\n\nFor our testing purposes, we will create an extremely simple MCP server that exposes two tools - one for addition and another for multiplication. The server will require authorization to access these.\n\n<Tabs>\n  <Tab title=\"TypeScript\">\n    You can see the complete TypeScript project in the [sample repository](https://github.com/localden/min-ts-mcp-auth).\n\n    Prior to running the code below, ensure that you have a `.env` file with the following content:\n\n    ```env  theme={null}\n    # Server host/port\n    HOST=localhost\n    PORT=3000\n\n    # Auth server location\n    AUTH_HOST=localhost\n    AUTH_PORT=8080\n    AUTH_REALM=master\n\n    # Keycloak OAuth client credentials\n    OAUTH_CLIENT_ID=<YOUR_SERVER_CLIENT_ID>\n    OAUTH_CLIENT_SECRET=<YOUR_SERVER_CLIENT_SECRET>\n    ```\n\n    `OAUTH_CLIENT_ID` and `OAUTH_CLIENT_SECRET` are associated with the MCP server client we created earlier.\n\n    In addition to implementing the MCP authorization specification, the server below also does token introspection via Keycloak to make sure that the token it receives from the client is valid. It also implements basic logging to allow you to easily diagnose any issues.\n\n    ```typescript  theme={null}\n    import \"dotenv/config\";\n    import express from \"express\";\n    import { randomUUID } from \"node:crypto\";\n    import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\n    import { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\n    import { isInitializeRequest } from \"@modelcontextprotocol/sdk/types.js\";\n    import { z } from \"zod\";\n    import cors from \"cors\";\n    import {\n      mcpAuthMetadataRouter,\n      getOAuthProtectedResourceMetadataUrl,\n    } from \"@modelcontextprotocol/sdk/server/auth/router.js\";\n    import { requireBearerAuth } from \"@modelcontextprotocol/sdk/server/auth/middleware/bearerAuth.js\";\n    import { OAuthMetadata } from \"@modelcontextprotocol/sdk/shared/auth.js\";\n    import { checkResourceAllowed } from \"@modelcontextprotocol/sdk/shared/auth-utils.js\";\n    const CONFIG = {\n      host: process.env.HOST || \"localhost\",\n      port: Number(process.env.PORT) || 3000,\n      auth: {\n        host: process.env.AUTH_HOST || process.env.HOST || \"localhost\",\n        port: Number(process.env.AUTH_PORT) || 8080,\n        realm: process.env.AUTH_REALM || \"master\",\n        clientId: process.env.OAUTH_CLIENT_ID || \"mcp-server\",\n        clientSecret: process.env.OAUTH_CLIENT_SECRET || \"\",\n      },\n    };\n\n    function createOAuthUrls() {\n      const authBaseUrl = new URL(\n        `http://${CONFIG.auth.host}:${CONFIG.auth.port}/realms/${CONFIG.auth.realm}/`,\n      );\n      return {\n        issuer: authBaseUrl.toString(),\n        introspection_endpoint: new URL(\n          \"protocol/openid-connect/token/introspect\",\n          authBaseUrl,\n        ).toString(),\n        authorization_endpoint: new URL(\n          \"protocol/openid-connect/auth\",\n          authBaseUrl,\n        ).toString(),\n        token_endpoint: new URL(\n          \"protocol/openid-connect/token\",\n          authBaseUrl,\n        ).toString(),\n      };\n    }\n\n    function createRequestLogger() {\n      return (req: any, res: any, next: any) => {\n        const start = Date.now();\n        res.on(\"finish\", () => {\n          const ms = Date.now() - start;\n          console.log(\n            `${req.method} ${req.originalUrl} -> ${res.statusCode} ${ms}ms`,\n          );\n        });\n        next();\n      };\n    }\n\n    const app = express();\n\n    app.use(\n      express.json({\n        verify: (req: any, _res, buf) => {\n          req.rawBody = buf?.toString() ?? \"\";\n        },\n      }),\n    );\n\n    app.use(\n      cors({\n        origin: \"*\",\n        exposedHeaders: [\"Mcp-Session-Id\"],\n      }),\n    );\n\n    app.use(createRequestLogger());\n\n    const mcpServerUrl = new URL(`http://${CONFIG.host}:${CONFIG.port}`);\n    const oauthUrls = createOAuthUrls();\n\n    const oauthMetadata: OAuthMetadata = {\n      ...oauthUrls,\n      response_types_supported: [\"code\"],\n    };\n\n    const tokenVerifier = {\n      verifyAccessToken: async (token: string) => {\n        const endpoint = oauthMetadata.introspection_endpoint;\n\n        if (!endpoint) {\n          console.error(\"[auth] no introspection endpoint in metadata\");\n          throw new Error(\"No token verification endpoint available in metadata\");\n        }\n\n        const params = new URLSearchParams({\n          token: token,\n          client_id: CONFIG.auth.clientId,\n        });\n\n        if (CONFIG.auth.clientSecret) {\n          params.set(\"client_secret\", CONFIG.auth.clientSecret);\n        }\n\n        let response: Response;\n        try {\n          response = await fetch(endpoint, {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/x-www-form-urlencoded\",\n            },\n            body: params.toString(),\n          });\n        } catch (e) {\n          console.error(\"[auth] introspection fetch threw\", e);\n          throw e;\n        }\n\n        if (!response.ok) {\n          const txt = await response.text();\n          console.error(\"[auth] introspection non-OK\", { status: response.status });\n\n          try {\n            const obj = JSON.parse(txt);\n            console.log(JSON.stringify(obj, null, 2));\n          } catch {\n            console.error(txt);\n          }\n          throw new Error(`Invalid or expired token: ${txt}`);\n        }\n\n        let data: any;\n        try {\n          data = await response.json();\n        } catch (e) {\n          const txt = await response.text();\n          console.error(\"[auth] failed to parse introspection JSON\", {\n            error: String(e),\n            body: txt,\n          });\n          throw e;\n        }\n\n        if (data.active === false) {\n          throw new Error(\"Inactive token\");\n        }\n\n        if (!data.aud) {\n          throw new Error(\"Resource indicator (aud) missing\");\n        }\n\n        const audiences: string[] = Array.isArray(data.aud) ? data.aud : [data.aud];\n        const allowed = audiences.some((a) =>\n          checkResourceAllowed({\n            requestedResource: a,\n            configuredResource: mcpServerUrl,\n          }),\n        );\n        if (!allowed) {\n          throw new Error(\n            `None of the provided audiences are allowed. Expected ${mcpServerUrl}, got: ${audiences.join(\", \")}`,\n          );\n        }\n\n        return {\n          token,\n          clientId: data.client_id,\n          scopes: data.scope ? data.scope.split(\" \") : [],\n          expiresAt: data.exp,\n        };\n      },\n    };\n    app.use(\n      mcpAuthMetadataRouter({\n        oauthMetadata,\n        resourceServerUrl: mcpServerUrl,\n        scopesSupported: [\"mcp:tools\"],\n        resourceName: \"MCP Demo Server\",\n      }),\n    );\n\n    const authMiddleware = requireBearerAuth({\n      verifier: tokenVerifier,\n      requiredScopes: [],\n      resourceMetadataUrl: getOAuthProtectedResourceMetadataUrl(mcpServerUrl),\n    });\n\n    const transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};\n\n    function createMcpServer() {\n      const server = new McpServer({\n        name: \"example-server\",\n        version: \"1.0.0\",\n      });\n\n      server.registerTool(\n        \"add\",\n        {\n          title: \"Addition Tool\",\n          description: \"Add two numbers together\",\n          inputSchema: {\n            a: z.number().describe(\"First number to add\"),\n            b: z.number().describe(\"Second number to add\"),\n          },\n        },\n        async ({ a, b }) => ({\n          content: [{ type: \"text\", text: `${a} + ${b} = ${a + b}` }],\n        }),\n      );\n\n      server.registerTool(\n        \"multiply\",\n        {\n          title: \"Multiplication Tool\",\n          description: \"Multiply two numbers together\",\n          inputSchema: {\n            x: z.number().describe(\"First number to multiply\"),\n            y: z.number().describe(\"Second number to multiply\"),\n          },\n        },\n        async ({ x, y }) => ({\n          content: [{ type: \"text\", text: `${x} √ó ${y} = ${x * y}` }],\n        }),\n      );\n\n      return server;\n    }\n\n    const mcpPostHandler = async (req: express.Request, res: express.Response) => {\n      const sessionId = req.headers[\"mcp-session-id\"] as string | undefined;\n      let transport: StreamableHTTPServerTransport;\n\n      if (sessionId && transports[sessionId]) {\n        transport = transports[sessionId];\n      } else if (!sessionId && isInitializeRequest(req.body)) {\n        transport = new StreamableHTTPServerTransport({\n          sessionIdGenerator: () => randomUUID(),\n          onsessioninitialized: (sessionId) => {\n            transports[sessionId] = transport;\n          },\n        });\n\n        transport.onclose = () => {\n          if (transport.sessionId) {\n            delete transports[transport.sessionId];\n          }\n        };\n\n        const server = createMcpServer();\n        await server.connect(transport);\n      } else {\n        res.status(400).json({\n          jsonrpc: \"2.0\",\n          error: {\n            code: -32000,\n            message: \"Bad Request: No valid session ID provided\",\n          },\n          id: null,\n        });\n        return;\n      }\n\n      await transport.handleRequest(req, res, req.body);\n    };\n\n    const handleSessionRequest = async (\n      req: express.Request,\n      res: express.Response,\n    ) => {\n      const sessionId = req.headers[\"mcp-session-id\"] as string | undefined;\n      if (!sessionId || !transports[sessionId]) {\n        res.status(400).send(\"Invalid or missing session ID\");\n        return;\n      }\n\n      const transport = transports[sessionId];\n      await transport.handleRequest(req, res);\n    };\n\n    app.post(\"/\", authMiddleware, mcpPostHandler);\n    app.get(\"/\", authMiddleware, handleSessionRequest);\n    app.delete(\"/\", authMiddleware, handleSessionRequest);\n\n    app.listen(CONFIG.port, CONFIG.host, () => {\n      console.log(`üöÄ MCP Server running on ${mcpServerUrl.origin}`);\n      console.log(`üì° MCP endpoint available at ${mcpServerUrl.origin}`);\n      console.log(\n        `üîê OAuth metadata available at ${getOAuthProtectedResourceMetadataUrl(mcpServerUrl)}`,\n      );\n    });\n    ```\n\n    When you run the server, you can add it to your MCP client, such as Visual Studio Code, by providing the MCP server endpoint.\n\n    For more details about implementing MCP servers in TypeScript, refer to the [TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk).\n  </Tab>\n\n  <Tab title=\"Python\">\n    You can see the complete Python project in the [sample repository](https://github.com/localden/min-py-mcp-auth).\n\n    To simplify our authorization interaction, in Python scenarios we rely on [FastMCP](https://gofastmcp.com/getting-started/welcome). A lot of the conventions around authorization, like the endpoints and token validation logic, are consistent across languages, but some offer simpler ways in integrating them in production scenarios.\n\n    Prior to writing the actual server, we need to set up our configuration in `config.py` - the contents are entirely based on your local server setup:\n\n    ```python  theme={null}\n    \"\"\"Configuration settings for the MCP auth server.\"\"\"\n\n    import os\n    from typing import Optional\n\n\n    class Config:\n        \"\"\"Configuration class that loads from environment variables with sensible defaults.\"\"\"\n\n        # Server settings\n        HOST: str = os.getenv(\"HOST\", \"localhost\")\n        PORT: int = int(os.getenv(\"PORT\", \"3000\"))\n\n        # Auth server settings\n        AUTH_HOST: str = os.getenv(\"AUTH_HOST\", \"localhost\")\n        AUTH_PORT: int = int(os.getenv(\"AUTH_PORT\", \"8080\"))\n        AUTH_REALM: str = os.getenv(\"AUTH_REALM\", \"master\")\n\n        # OAuth client settings\n        OAUTH_CLIENT_ID: str = os.getenv(\"OAUTH_CLIENT_ID\", \"mcp-server\")\n        OAUTH_CLIENT_SECRET: str = os.getenv(\"OAUTH_CLIENT_SECRET\", \"UO3rmozkFFkXr0QxPTkzZ0LMXDidIikB\")\n\n        # Server settings\n        MCP_SCOPE: str = os.getenv(\"MCP_SCOPE\", \"mcp:tools\")\n        OAUTH_STRICT: bool = os.getenv(\"OAUTH_STRICT\", \"false\").lower() in (\"true\", \"1\", \"yes\")\n        TRANSPORT: str = os.getenv(\"TRANSPORT\", \"streamable-http\")\n\n        @property\n        def server_url(self) -> str:\n            \"\"\"Build the server URL.\"\"\"\n            return f\"http://{self.HOST}:{self.PORT}\"\n\n        @property\n        def auth_base_url(self) -> str:\n            \"\"\"Build the auth server base URL.\"\"\"\n            return f\"http://{self.AUTH_HOST}:{self.AUTH_PORT}/realms/{self.AUTH_REALM}/\"\n\n        def validate(self) -> None:\n            \"\"\"Validate configuration.\"\"\"\n            if self.TRANSPORT not in [\"sse\", \"streamable-http\"]:\n                raise ValueError(f\"Invalid transport: {self.TRANSPORT}. Must be 'sse' or 'streamable-http'\")\n\n\n    # Global configuration instance\n    config = Config()\n\n    ```\n\n    The server implementation is as follows:\n\n    ```python  theme={null}\n    import datetime\n    import logging\n    from typing import Any\n\n    from pydantic import AnyHttpUrl\n\n    from mcp.server.auth.settings import AuthSettings\n    from mcp.server.fastmcp.server import FastMCP\n\n    from .config import config\n    from .token_verifier import IntrospectionTokenVerifier\n\n    logger = logging.getLogger(__name__)\n\n\n    def create_oauth_urls() -> dict[str, str]:\n        \"\"\"Create OAuth URLs based on configuration (Keycloak-style).\"\"\"\n        from urllib.parse import urljoin\n\n        auth_base_url = config.auth_base_url\n\n        return {\n            \"issuer\": auth_base_url,\n            \"introspection_endpoint\": urljoin(auth_base_url, \"protocol/openid-connect/token/introspect\"),\n            \"authorization_endpoint\": urljoin(auth_base_url, \"protocol/openid-connect/auth\"),\n            \"token_endpoint\": urljoin(auth_base_url, \"protocol/openid-connect/token\"),\n        }\n\n\n    def create_server() -> FastMCP:\n        \"\"\"Create and configure the FastMCP server.\"\"\"\n\n        config.validate()\n\n        oauth_urls = create_oauth_urls()\n\n        token_verifier = IntrospectionTokenVerifier(\n            introspection_endpoint=oauth_urls[\"introspection_endpoint\"],\n            server_url=config.server_url,\n            client_id=config.OAUTH_CLIENT_ID,\n            client_secret=config.OAUTH_CLIENT_SECRET,\n        )\n\n        app = FastMCP(\n            name=\"MCP Resource Server\",\n            instructions=\"Resource Server that validates tokens via Authorization Server introspection\",\n            host=config.HOST,\n            port=config.PORT,\n            debug=True,\n            streamable_http_path=\"/\",\n            token_verifier=token_verifier,\n            auth=AuthSettings(\n                issuer_url=AnyHttpUrl(oauth_urls[\"issuer\"]),\n                required_scopes=[config.MCP_SCOPE],\n                resource_server_url=AnyHttpUrl(config.server_url),\n            ),\n        )\n\n        @app.tool()\n        async def add_numbers(a: float, b: float) -> dict[str, Any]:\n            \"\"\"\n            Add two numbers together.\n            This tool demonstrates basic arithmetic operations with OAuth authentication.\n\n            Args:\n                a: The first number to add\n                b: The second number to add\n            \"\"\"\n            result = a + b\n            return {\n                \"operation\": \"addition\",\n                \"operand_a\": a,\n                \"operand_b\": b,\n                \"result\": result,\n                \"timestamp\": datetime.datetime.now().isoformat()\n            }\n\n        @app.tool()\n        async def multiply_numbers(x: float, y: float) -> dict[str, Any]:\n            \"\"\"\n            Multiply two numbers together.\n            This tool demonstrates basic arithmetic operations with OAuth authentication.\n\n            Args:\n                x: The first number to multiply\n                y: The second number to multiply\n            \"\"\"\n            result = x * y\n            return {\n                \"operation\": \"multiplication\",\n                \"operand_x\": x,\n                \"operand_y\": y,\n                \"result\": result,\n                \"timestamp\": datetime.datetime.now().isoformat()\n            }\n\n        return app\n\n\n    def main() -> int:\n        \"\"\"\n        Run the MCP Resource Server.\n\n        This server:\n        - Provides RFC 9728 Protected Resource Metadata\n        - Validates tokens via Authorization Server introspection\n        - Serves MCP tools requiring authentication\n\n        Configuration is loaded from config.py and environment variables.\n        \"\"\"\n        logging.basicConfig(level=logging.INFO)\n\n        try:\n            config.validate()\n            oauth_urls = create_oauth_urls()\n\n        except ValueError as e:\n            logger.error(\"Configuration error: %s\", e)\n            return 1\n\n        try:\n            mcp_server = create_server()\n\n            logger.info(\"Starting MCP Server on %s:%s\", config.HOST, config.PORT)\n            logger.info(\"Authorization Server: %s\", oauth_urls[\"issuer\"])\n            logger.info(\"Transport: %s\", config.TRANSPORT)\n\n            mcp_server.run(transport=config.TRANSPORT)\n            return 0\n\n        except Exception:\n            logger.exception(\"Server error\")\n            return 1\n\n\n    if __name__ == \"__main__\":\n        exit(main())\n    ```\n\n    Lastly, the token verification logic is delegated entirely to `token_verifier.py`, ensuring that we can use the Keycloak introspection endpoint to verify the validity of any credential artifacts\n\n    ```python  theme={null}\n    \"\"\"Token verifier implementation using OAuth 2.0 Token Introspection (RFC 7662).\"\"\"\n\n    import logging\n    from typing import Any\n\n    from mcp.server.auth.provider import AccessToken, TokenVerifier\n    from mcp.shared.auth_utils import check_resource_allowed, resource_url_from_server_url\n\n    logger = logging.getLogger(__name__)\n\n\n    class IntrospectionTokenVerifier(TokenVerifier):\n        \"\"\"Token verifier that uses OAuth 2.0 Token Introspection (RFC 7662).\n        \"\"\"\n\n        def __init__(\n            self,\n            introspection_endpoint: str,\n            server_url: str,\n            client_id: str,\n            client_secret: str,\n        ):\n            self.introspection_endpoint = introspection_endpoint\n            self.server_url = server_url\n            self.client_id = client_id\n            self.client_secret = client_secret\n            self.resource_url = resource_url_from_server_url(server_url)\n\n        async def verify_token(self, token: str) -> AccessToken | None:\n            \"\"\"Verify token via introspection endpoint.\"\"\"\n            import httpx\n\n            if not self.introspection_endpoint.startswith((\"https://\", \"http://localhost\", \"http://127.0.0.1\")):\n                return None\n\n            timeout = httpx.Timeout(10.0, connect=5.0)\n            limits = httpx.Limits(max_connections=10, max_keepalive_connections=5)\n\n            async with httpx.AsyncClient(\n                timeout=timeout,\n                limits=limits,\n                verify=True,\n            ) as client:\n                try:\n                    form_data = {\n                        \"token\": token,\n                        \"client_id\": self.client_id,\n                        \"client_secret\": self.client_secret,\n                    }\n                    headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n\n                    response = await client.post(\n                        self.introspection_endpoint,\n                        data=form_data,\n                        headers=headers,\n                    )\n\n                    if response.status_code != 200:\n                        return None\n\n                    data = response.json()\n                    if not data.get(\"active\", False):\n                        return None\n\n                    if not self._validate_resource(data):\n                        return None\n\n                    return AccessToken(\n                        token=token,\n                        client_id=data.get(\"client_id\", \"unknown\"),\n                        scopes=data.get(\"scope\", \"\").split() if data.get(\"scope\") else [],\n                        expires_at=data.get(\"exp\"),\n                        resource=data.get(\"aud\"),  # Include resource in token\n                    )\n\n                except Exception as e:\n                    return None\n\n        def _validate_resource(self, token_data: dict[str, Any]) -> bool:\n            \"\"\"Validate token was issued for this resource server.\n\n            Rules:\n            - Reject if 'aud' missing.\n            - Accept if any audience entry matches the derived resource URL.\n            - Supports string or list forms per JWT spec.\n            \"\"\"\n            if not self.server_url or not self.resource_url:\n                return False\n\n            aud: list[str] | str | None = token_data.get(\"aud\")\n            if isinstance(aud, list):\n                return any(self._is_valid_resource(a) for a in aud)\n            if isinstance(aud, str):\n                return self._is_valid_resource(aud)\n            return False\n\n        def _is_valid_resource(self, resource: str) -> bool:\n            \"\"\"Check if the given resource matches our server.\"\"\"\n            return check_resource_allowed(self.resource_url, resource)\n    ```\n\n    For more details, see the [Python SDK documentation](https://github.com/modelcontextprotocol/python-sdk).\n  </Tab>\n\n  <Tab title=\"C#\">\n    You can see the complete C# project in the [sample repository](https://github.com/localden/min-cs-mcp-auth).\n\n    To set up authorization in your MCP server using the MCP C# SDK, you can lean on the standard ASP.NET Core builder pattern. Instead of using the introspection endpoint provided by Keycloak, we will use built-in ASP.NET Core capabilities for token validation.\n\n    ```csharp  theme={null}\n    using Microsoft.AspNetCore.Authentication.JwtBearer;\n    using Microsoft.IdentityModel.Tokens;\n    using ModelContextProtocol.AspNetCore.Authentication;\n    using ProtectedMcpServer.Tools;\n    using System.Security.Claims;\n\n    var builder = WebApplication.CreateBuilder(args);\n\n    var serverUrl = \"http://localhost:3000/\";\n    var authorizationServerUrl = \"http://localhost:8080/realms/master/\";\n\n    builder.Services.AddAuthentication(options =>\n    {\n        options.DefaultChallengeScheme = McpAuthenticationDefaults.AuthenticationScheme;\n        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n    })\n    .AddJwtBearer(options =>\n    {\n        options.Authority = authorizationServerUrl;\n        var normalizedServerAudience = serverUrl.TrimEnd('/');\n        options.TokenValidationParameters = new TokenValidationParameters\n        {\n            ValidIssuer = authorizationServerUrl,\n            ValidAudiences = new[] { normalizedServerAudience, serverUrl },\n            AudienceValidator = (audiences, securityToken, validationParameters) =>\n            {\n                if (audiences == null) return false;\n                foreach (var aud in audiences)\n                {\n                    if (string.Equals(aud.TrimEnd('/'), normalizedServerAudience, StringComparison.OrdinalIgnoreCase))\n                    {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n\n        options.RequireHttpsMetadata = false; // Set to true in production\n\n        options.Events = new JwtBearerEvents\n        {\n            OnTokenValidated = context =>\n            {\n                var name = context.Principal?.Identity?.Name ?? \"unknown\";\n                var email = context.Principal?.FindFirstValue(\"preferred_username\") ?? \"unknown\";\n                Console.WriteLine($\"Token validated for: {name} ({email})\");\n                return Task.CompletedTask;\n            },\n            OnAuthenticationFailed = context =>\n            {\n                Console.WriteLine($\"Authentication failed: {context.Exception.Message}\");\n                return Task.CompletedTask;\n            },\n        };\n    })\n    .AddMcp(options =>\n    {\n        options.ResourceMetadata = new()\n        {\n            Resource = new Uri(serverUrl),\n            ResourceDocumentation = new Uri(\"https://docs.example.com/api/math\"),\n            AuthorizationServers = { new Uri(authorizationServerUrl) },\n            ScopesSupported = [\"mcp:tools\"]\n        };\n    });\n\n    builder.Services.AddAuthorization();\n\n    builder.Services.AddHttpContextAccessor();\n    builder.Services.AddMcpServer()\n        .WithTools<MathTools>()\n        .WithHttpTransport();\n\n    var app = builder.Build();\n\n    app.UseAuthentication();\n    app.UseAuthorization();\n\n    app.MapMcp().RequireAuthorization();\n\n    Console.WriteLine($\"Starting MCP server with authorization at {serverUrl}\");\n    Console.WriteLine($\"Using Keycloak server at {authorizationServerUrl}\");\n    Console.WriteLine($\"Protected Resource Metadata URL: {serverUrl}.well-known/oauth-protected-resource\");\n    Console.WriteLine(\"Exposed Math tools: Add, Multiply\");\n    Console.WriteLine(\"Press Ctrl+C to stop the server\");\n\n    app.Run(serverUrl);\n    ```\n\n    For more details, see the [C# SDK documentation](https://github.com/modelcontextprotocol/csharp-sdk).\n  </Tab>\n</Tabs>\n\n## Testing the MCP Server\n\nFor testing purposes, we will be using [Visual Studio Code](https://code.visualstudio.com), but any client that supports MCP and the new authorization specification will fit.\n\nPress <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> and select **MCP: Add server...**. Select **HTTP** and enter `http://localhost:3000`. Give the server a unique name to be used inside Visual Studio Code. In `mcp.json` you should now see an entry like this:\n\n```json  theme={null}\n\"my-mcp-server-18676652\": {\n  \"url\": \"http://localhost:3000\",\n  \"type\": \"http\"\n}\n```\n\nOn connection, you will be taken to the browser, where you will be prompted to consent to Visual Studio Code having access to the `mcp:tools` scope.\n\n<Frame>\n  <img src=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-vscode.png?fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=d5183fb7c257993aed1b2246f0bbbb27\" alt=\"Keycloak consent form for VS Code.\" data-og-width=\"1915\" width=\"1915\" data-og-height=\"1536\" height=\"1536\" data-path=\"images/tutorial-authorization/keycloak-vscode.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-vscode.png?w=280&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=93bb132878b75189c0cf198a59d3b053 280w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-vscode.png?w=560&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=155520f0a1b88422247d9910cb59899f 560w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-vscode.png?w=840&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=4fd24398061374fd940b05d97701dcbc 840w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-vscode.png?w=1100&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=e949784fc78e1f44bc8d3edeb218220b 1100w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-vscode.png?w=1650&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=30fc4dbf14307aac8a2ae938b112ef5b 1650w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/keycloak-vscode.png?w=2500&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=3a0b543da5988dd95b1a447b138c83be 2500w\" />\n</Frame>\n\nAfter consenting, you will see the tools listed right above the server entry in `mcp.json`.\n\n<Frame>\n  <img src=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code.png?fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=f7c34d1bf115fe6934e01b4a5a91168b\" alt=\"Tools listed in VS Code.\" data-og-width=\"496\" width=\"496\" data-og-height=\"160\" height=\"160\" data-path=\"images/tutorial-authorization/tools-vs-code.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code.png?w=280&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=9e66d87c84323d4efafb9fa80b58b611 280w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code.png?w=560&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=4b2ef221709a1696272241badcfd7c42 560w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code.png?w=840&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=ce16053621cc5b24a5f5a83fe541feaa 840w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code.png?w=1100&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=59f05ee1ee685b60b0b3fe884cd732f8 1100w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code.png?w=1650&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=ea1afa55bd8f26278d2317ef0ef1a8fb 1650w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code.png?w=2500&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=1f6dd6a4d23ee579f73421689c4c2daa 2500w\" />\n</Frame>\n\nYou will be able to invoke individual tools with the help of the `#` sign in the chat view.\n\n<Frame>\n  <img src=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code-invoke.png?fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=76cbef68e48821a3c5467bd20c7e89fe\" alt=\"Invoking MCP tools in VS Code.\" data-og-width=\"1276\" width=\"1276\" data-og-height=\"396\" height=\"396\" data-path=\"images/tutorial-authorization/tools-vs-code-invoke.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code-invoke.png?w=280&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=7f5687389fe8bf48369a45738ec07795 280w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code-invoke.png?w=560&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=dcc4a1857264bda9f2566e50db51704f 560w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code-invoke.png?w=840&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=2774a73e612220975ee6d491430b9ee5 840w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code-invoke.png?w=1100&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=014f88a40adddb9faf5f93306dea376c 1100w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code-invoke.png?w=1650&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=d938978e4507cd933695cce01ee49901 1650w, https://mintcdn.com/mcp/sAd4SGUO-cEUqgzn/images/tutorial-authorization/tools-vs-code-invoke.png?w=2500&fit=max&auto=format&n=sAd4SGUO-cEUqgzn&q=85&s=0250d29b2e115324e0b94a4796938bad 2500w\" />\n</Frame>\n\n## Common Pitfalls and How to Avoid Them\n\nFor comprehensive security guidance, including attack vectors, mitigation strategies, and implementation best practices, make sure to read through [Security Best Practices](/specification/draft/basic/security_best_practices). A few key issues are called out below.\n\n* **Do not implement token validation or authorization logic by yourself**. Use off-the-shelf, well-tested, and secure libraries for things like token validation or authorization decisions. Doing everything from scratch means that you're more likely to implement things incorrectly unless you are a security expert.\n* **Use short-lived access tokens**. Depending on the authorization server used, this setting might be customizable. We recommend to not use long-lived tokens - if a malicious actor steals them, they will be able to maintain their access for longer periods.\n* **Always validate tokens**. Just because your server received a token does not mean that the token is valid or that it's meant for your server. Always verify that what your MCP server is getting from the client matches the required constraints.\n* **Store tokens in secure, encrypted storage**. In certain scenarios, you might need to cache tokens server-side. If that is the case, ensure that the storage has the right access controls and cannot be easily exfiltrated by malicious parties with access to your server. You should also implement robust cache eviction policies to ensure that your MCP server is not re-using expired or otherwise invalid tokens.\n* **Enforce HTTPS in production**. Do not accept tokens or redirect callbacks over plain HTTP except for `localhost` during development.\n* **Least-privilege scopes**. Don't use catch‚Äëall scopes. Split access per tool or capability where possible and verify required scopes per route/tool on the resource server.\n* **Don't log credentials**. Never log `Authorization` headers, tokens, codes, or secrets. Scrub query strings and headers. Redact sensitive fields in structured logs.\n* **Separate app vs. resource server credentials**. Don't reuse your MCP server's client secret for end‚Äëuser flows. Store all secrets in a proper secret manager, not in source control.\n* **Return proper challenges**. On 401, include `WWW-Authenticate` with `Bearer`, `realm`, and `resource_metadata` so clients can discover how to authenticate.\n* **DCR (Dynamic Client Registration) controls**. If enabled, be aware of constraints specific to your organization, such as trusted hosts, required vetting, and audited registrations. Unauthenticated DCR means that anyone can register any client with your authorization server.\n* **Multi‚Äëtenant/realm mix-ups**. Pin to a single issuer/tenant unless explicitly multi‚Äëtenant. Reject tokens from other realms even if signed by the same authorization server.\n* **Audience/resource indicator misuse**. Don't configure or accept generic audiences (like `api`) or unrelated resources. Require the audience/resource to match your configured server.\n* **Error detail leakage**. Return generic messages to clients, but log detailed reasons with correlation IDs internally to aid troubleshooting without exposing internals.\n* **Session identifier hardening**. Treat `Mcp-Session-Id` as untrusted input; never tie authorization to it. Regenerate on auth changes and validate lifecycle server‚Äëside.\n\n## Related Standards and Documentation\n\nMCP authorization builds on these well-established standards:\n\n* **[OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13)**: The core authorization framework\n* **[RFC 8414](https://datatracker.ietf.org/doc/html/rfc8414)**: Authorization Server Metadata discovery\n* **[RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591)**: Dynamic Client Registration\n* **[RFC 9728](https://datatracker.ietf.org/doc/html/rfc9728)**: Protected Resource Metadata\n* **[RFC 8707](https://datatracker.ietf.org/doc/html/rfc8707)**: Resource Indicators\n\nFor additional details, refer to:\n\n* [Authorization Specification](/specification/draft/basic/authorization)\n* [Security Best Practices](/specification/draft/basic/security_best_practices)\n* [Available MCP SDKs](/docs/sdk)\n\nUnderstanding these standards will help you implement authorization correctly and troubleshoot issues when they arise.",
  "content_length": 53536
}