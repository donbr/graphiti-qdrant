{
  "title": "Architecture overview",
  "source_url": "https://modelcontextprotocol.io/docs/learn/architecture",
  "content": "This overview of the Model Context Protocol (MCP) discusses its [scope](#scope) and [core concepts](#concepts-of-mcp), and provides an [example](#example) demonstrating each core concept.\n\nBecause MCP SDKs abstract away many concerns, most developers will likely find the [data layer protocol](#data-layer-protocol) section to be the most useful. It discusses how MCP servers can provide context to an AI application.\n\nFor specific implementation details, please refer to the documentation for your [language-specific SDK](/docs/sdk).\n\n## Scope\n\nThe Model Context Protocol includes the following projects:\n\n* [MCP Specification](https://modelcontextprotocol.io/specification/latest): A specification of MCP that outlines the implementation requirements for clients and servers.\n* [MCP SDKs](/docs/sdk): SDKs for different programming languages that implement MCP.\n* **MCP Development Tools**: Tools for developing MCP servers and clients, including the [MCP Inspector](https://github.com/modelcontextprotocol/inspector)\n* [MCP Reference Server Implementations](https://github.com/modelcontextprotocol/servers): Reference implementations of MCP servers.\n\n<Note>\n  MCP focuses solely on the protocol for context exchange—it does not dictate\n  how AI applications use LLMs or manage the provided context.\n</Note>\n\n## Concepts of MCP\n\n### Participants\n\nMCP follows a client-server architecture where an MCP host — an AI application like [Claude Code](https://www.anthropic.com/claude-code) or [Claude Desktop](https://www.claude.ai/download) — establishes connections to one or more MCP servers. The MCP host accomplishes this by creating one MCP client for each MCP server. Each MCP client maintains a dedicated one-to-one connection with its corresponding MCP server.\n\nThe key participants in the MCP architecture are:\n\n* **MCP Host**: The AI application that coordinates and manages one or multiple MCP clients\n* **MCP Client**: A component that maintains a connection to an MCP server and obtains context from an MCP server for the MCP host to use\n* **MCP Server**: A program that provides context to MCP clients\n\n**For example**: Visual Studio Code acts as an MCP host. When Visual Studio Code establishes a connection to an MCP server, such as the [Sentry MCP server](https://docs.sentry.io/product/sentry-mcp/), the Visual Studio Code runtime instantiates an MCP client object that maintains the connection to the Sentry MCP server.\nWhen Visual Studio Code subsequently connects to another MCP server, such as the [local filesystem server](https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem), the Visual Studio Code runtime instantiates an additional MCP client object to maintain this connection, hence maintaining a one-to-one\nrelationship of MCP clients to MCP servers.\n\n```mermaid  theme={null}\ngraph TB\n    subgraph \"MCP Host (AI Application)\"\n        Client1[\"MCP Client 1\"]\n        Client2[\"MCP Client 2\"]\n        Client3[\"MCP Client 3\"]\n    end\n\n    Server1[\"MCP Server 1<br/>(e.g., Sentry)\"]\n    Server2[\"MCP Server 2<br/>(e.g., Filesystem)\"]\n    Server3[\"MCP Server 3<br/>(e.g., Database)\"]\n\n    Client1 ---|\"One-to-one<br/>connection\"| Server1\n    Client2 ---|\"One-to-one<br/>connection\"| Server2\n    Client3 ---|\"One-to-one<br/>connection\"| Server3\n```\n\nNote that **MCP server** refers to the program that serves context data, regardless of\nwhere it runs. MCP servers can execute locally or remotely. For example, when\nClaude Desktop launches the [filesystem\nserver](https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem),\nthe server runs locally on the same machine because it uses the STDIO\ntransport. This is commonly referred to as a \"local\" MCP server. The official\n[Sentry MCP server](https://docs.sentry.io/product/sentry-mcp/) runs on the\nSentry platform, and uses the Streamable HTTP transport. This is commonly\nreferred to as a \"remote\" MCP server.\n\n### Layers\n\nMCP consists of two layers:\n\n* **Data layer**: Defines the JSON-RPC based protocol for client-server communication, including lifecycle management, and core primitives, such as tools, resources, prompts and notifications.\n* **Transport layer**: Defines the communication mechanisms and channels that enable data exchange between clients and servers, including transport-specific connection establishment, message framing, and authorization.\n\nConceptually the data layer is the inner layer, while the transport layer is the outer layer.\n\n#### Data layer\n\nThe data layer implements a [JSON-RPC 2.0](https://www.jsonrpc.org/) based exchange protocol that defines the message structure and semantics.\nThis layer includes:\n\n* **Lifecycle management**: Handles connection initialization, capability negotiation, and connection termination between clients and servers\n* **Server features**: Enables servers to provide core functionality including tools for AI actions, resources for context data, and prompts for interaction templates from and to the client\n* **Client features**: Enables servers to ask the client to sample from the host LLM, elicit input from the user, and log messages to the client\n* **Utility features**: Supports additional capabilities like notifications for real-time updates and progress tracking for long-running operations\n\n#### Transport layer\n\nThe transport layer manages communication channels and authentication between clients and servers. It handles connection establishment, message framing, and secure communication between MCP participants.\n\nMCP supports two transport mechanisms:\n\n* **Stdio transport**: Uses standard input/output streams for direct process communication between local processes on the same machine, providing optimal performance with no network overhead.\n* **Streamable HTTP transport**: Uses HTTP POST for client-to-server messages with optional Server-Sent Events for streaming capabilities. This transport enables remote server communication and supports standard HTTP authentication methods including bearer tokens, API keys, and custom headers. MCP recommends using OAuth to obtain authentication tokens.\n\nThe transport layer abstracts communication details from the protocol layer, enabling the same JSON-RPC 2.0 message format across all transport mechanisms.\n\n### Data Layer Protocol\n\nA core part of MCP is defining the schema and semantics between MCP clients and MCP servers. Developers will likely find the data layer — in particular, the set of [primitives](#primitives) — to be the most interesting part of MCP. It is the part of MCP that defines the ways developers can share context from MCP servers to MCP clients.\n\nMCP uses [JSON-RPC 2.0](https://www.jsonrpc.org/) as its underlying RPC protocol. Client and servers send requests to each other and respond accordingly. Notifications can be used when no response is required.\n\n#### Lifecycle management\n\nMCP is a <Tooltip tip=\"A subset of MCP can be made stateless using the Streamable HTTP transport\">stateful protocol</Tooltip> that requires lifecycle management. The purpose of lifecycle management is to negotiate the <Tooltip tip=\"Features and operations that a client or server supports, such as tools, resources, or prompts\">capabilities</Tooltip> that both client and server support. Detailed information can be found in the [specification](/specification/2025-06-18/basic/lifecycle), and the [example](#example) showcases the initialization sequence.\n\n#### Primitives\n\nMCP primitives are the most important concept within MCP. They define what clients and servers can offer each other. These primitives specify the types of contextual information that can be shared with AI applications and the range of actions that can be performed.\n\nMCP defines three core primitives that *servers* can expose:\n\n* **Tools**: Executable functions that AI applications can invoke to perform actions (e.g., file operations, API calls, database queries)\n* **Resources**: Data sources that provide contextual information to AI applications (e.g., file contents, database records, API responses)\n* **Prompts**: Reusable templates that help structure interactions with language models (e.g., system prompts, few-shot examples)\n\nEach primitive type has associated methods for discovery (`*/list`), retrieval (`*/get`), and in some cases, execution (`tools/call`).\nMCP clients will use the `*/list` methods to discover available primitives. For example, a client can first list all available tools (`tools/list`) and then execute them. This design allows listings to be dynamic.\n\nAs a concrete example, consider an MCP server that provides context about a database. It can expose tools for querying the database, a resource that contains the schema of the database, and a prompt that includes few-shot examples for interacting with the tools.\n\nFor more details about server primitives see [server concepts](./server-concepts).\n\nMCP also defines primitives that *clients* can expose. These primitives allow MCP server authors to build richer interactions.\n\n* **Sampling**: Allows servers to request language model completions from the client's AI application. This is useful when servers' authors want access to a language model, but want to stay model independent and not include a language model SDK in their MCP server. They can use the `sampling/complete` method to request a language model completion from the client's AI application.\n* **Elicitation**: Allows servers to request additional information from users. This is useful when servers' authors want to get more information from the user, or ask for confirmation of an action. They can use the `elicitation/request` method to request additional information from the user.\n* **Logging**: Enables servers to send log messages to clients for debugging and monitoring purposes.\n\nFor more details about client primitives see [client concepts](./client-concepts).\n\nBesides server and client primitives, the protocol offers cross-cutting utility primitives that augment how requests are executed:\n\n* **Tasks (Experimental)**: Durable execution wrappers that enable deferred result retrieval and status tracking for MCP requests (e.g., expensive computations, workflow automation, batch processing, multi-step operations)\n\n#### Notifications\n\nThe protocol supports real-time notifications to enable dynamic updates between servers and clients. For example, when a server's available tools change—such as when new functionality becomes available or existing tools are modified—the server can send tool update notifications to inform connected clients about these changes. Notifications are sent as JSON-RPC 2.0 notification messages (without expecting a response) and enable MCP servers to provide real-time updates to connected clients.\n\n## Example\n\n### Data Layer\n\nThis section provides a step-by-step walkthrough of an MCP client-server interaction, focusing on the data layer protocol. We'll demonstrate the lifecycle sequence, tool operations, and notifications using JSON-RPC 2.0 messages.\n\n<Steps>\n  <Step title=\"Initialization (Lifecycle Management)\">\n    MCP begins with lifecycle management through a capability negotiation handshake. As described in the [lifecycle management](#lifecycle-management) section, the client sends an `initialize` request to establish the connection and negotiate supported features.\n\n    <CodeGroup>\n      ```json Initialize Request theme={null}\n      {\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"initialize\",\n        \"params\": {\n          \"protocolVersion\": \"2025-06-18\",\n          \"capabilities\": {\n            \"elicitation\": {}\n          },\n          \"clientInfo\": {\n            \"name\": \"example-client\",\n            \"version\": \"1.0.0\"\n          }\n        }\n      }\n      ```\n\n      ```json Initialize Response theme={null}\n      {\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"result\": {\n          \"protocolVersion\": \"2025-06-18\",\n          \"capabilities\": {\n            \"tools\": {\n              \"listChanged\": true\n            },\n            \"resources\": {}\n          },\n          \"serverInfo\": {\n            \"name\": \"example-server\",\n            \"version\": \"1.0.0\"\n          }\n        }\n      }\n      ```\n    </CodeGroup>\n\n    #### Understanding the Initialization Exchange\n\n    The initialization process is a key part of MCP's lifecycle management and serves several critical purposes:\n\n    1. **Protocol Version Negotiation**: The `protocolVersion` field (e.g., \"2025-06-18\") ensures both client and server are using compatible protocol versions. This prevents communication errors that could occur when different versions attempt to interact. If a mutually compatible version is not negotiated, the connection should be terminated.\n\n    2. **Capability Discovery**: The `capabilities` object allows each party to declare what features they support, including which [primitives](#primitives) they can handle (tools, resources, prompts) and whether they support features like [notifications](#notifications). This enables efficient communication by avoiding unsupported operations.\n\n    3. **Identity Exchange**: The `clientInfo` and `serverInfo` objects provide identification and versioning information for debugging and compatibility purposes.\n\n    In this example, the capability negotiation demonstrates how MCP primitives are declared:\n\n    **Client Capabilities**:\n\n    * `\"elicitation\": {}` - The client declares it can work with user interaction requests (can receive `elicitation/create` method calls)\n\n    **Server Capabilities**:\n\n    * `\"tools\": {\"listChanged\": true}` - The server supports the tools primitive AND can send `tools/list_changed` notifications when its tool list changes\n    * `\"resources\": {}` - The server also supports the resources primitive (can handle `resources/list` and `resources/read` methods)\n\n    After successful initialization, the client sends a notification to indicate it's ready:\n\n    ```json Notification theme={null}\n    {\n      \"jsonrpc\": \"2.0\",\n      \"method\": \"notifications/initialized\"\n    }\n    ```\n\n    #### How This Works in AI Applications\n\n    During initialization, the AI application's MCP client manager establishes connections to configured servers and stores their capabilities for later use. The application uses this information to determine which servers can provide specific types of functionality (tools, resources, prompts) and whether they support real-time updates.\n\n    ```python Pseudo-code for AI application initialization theme={null}\n    # Pseudo Code\n    async with stdio_client(server_config) as (read, write):\n        async with ClientSession(read, write) as session:\n            init_response = await session.initialize()\n            if init_response.capabilities.tools:\n                app.register_mcp_server(session, supports_tools=True)\n            app.set_server_ready(session)\n    ```\n  </Step>\n\n  <Step title=\"Tool Discovery (Primitives)\">\n    Now that the connection is established, the client can discover available tools by sending a `tools/list` request. This request is fundamental to MCP's tool discovery mechanism — it allows clients to understand what tools are available on the server before attempting to use them.\n\n    <CodeGroup>\n      ```json Tools List Request theme={null}\n      {\n        \"jsonrpc\": \"2.0\",\n        \"id\": 2,\n        \"method\": \"tools/list\"\n      }\n      ```\n\n      ```json Tools List Response theme={null}\n      {\n        \"jsonrpc\": \"2.0\",\n        \"id\": 2,\n        \"result\": {\n          \"tools\": [\n            {\n              \"name\": \"calculator_arithmetic\",\n              \"title\": \"Calculator\",\n              \"description\": \"Perform mathematical calculations including basic arithmetic, trigonometric functions, and algebraic operations\",\n              \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"expression\": {\n                    \"type\": \"string\",\n                    \"description\": \"Mathematical expression to evaluate (e.g., '2 + 3 * 4', 'sin(30)', 'sqrt(16)')\"\n                  }\n                },\n                \"required\": [\"expression\"]\n              }\n            },\n            {\n              \"name\": \"weather_current\",\n              \"title\": \"Weather Information\",\n              \"description\": \"Get current weather information for any location worldwide\",\n              \"inputSchema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"location\": {\n                    \"type\": \"string\",\n                    \"description\": \"City name, address, or coordinates (latitude,longitude)\"\n                  },\n                  \"units\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"metric\", \"imperial\", \"kelvin\"],\n                    \"description\": \"Temperature units to use in response\",\n                    \"default\": \"metric\"\n                  }\n                },\n                \"required\": [\"location\"]\n              }\n            }\n          ]\n        }\n      }\n      ```\n    </CodeGroup>\n\n    #### Understanding the Tool Discovery Request\n\n    The `tools/list` request is simple, containing no parameters.\n\n    #### Understanding the Tool Discovery Response\n\n    The response contains a `tools` array that provides comprehensive metadata about each available tool. This array-based structure allows servers to expose multiple tools simultaneously while maintaining clear boundaries between different functionalities.\n\n    Each tool object in the response includes several key fields:\n\n    * **`name`**: A unique identifier for the tool within the server's namespace. This serves as the primary key for tool execution and should follow a clear naming pattern (e.g., `calculator_arithmetic` rather than just `calculate`)\n    * **`title`**: A human-readable display name for the tool that clients can show to users\n    * **`description`**: Detailed explanation of what the tool does and when to use it\n    * **`inputSchema`**: A JSON Schema that defines the expected input parameters, enabling type validation and providing clear documentation about required and optional parameters\n\n    #### How This Works in AI Applications\n\n    The AI application fetches available tools from all connected MCP servers and combines them into a unified tool registry that the language model can access. This allows the LLM to understand what actions it can perform and automatically generates the appropriate tool calls during conversations.\n\n    ```python Pseudo-code for AI application tool discovery theme={null}\n    # Pseudo-code using MCP Python SDK patterns\n    available_tools = []\n    for session in app.mcp_server_sessions():\n        tools_response = await session.list_tools()\n        available_tools.extend(tools_response.tools)\n    conversation.register_available_tools(available_tools)\n    ```\n  </Step>\n\n  <Step title=\"Tool Execution (Primitives)\">\n    The client can now execute a tool using the `tools/call` method. This demonstrates how MCP primitives are used in practice: after discovering available tools, the client can invoke them with appropriate arguments.\n\n    #### Understanding the Tool Execution Request\n\n    The `tools/call` request follows a structured format that ensures type safety and clear communication between client and server. Note that we're using the proper tool name from the discovery response (`weather_current`) rather than a simplified name:\n\n    <CodeGroup>\n      ```json Tool Call Request theme={null}\n      {\n        \"jsonrpc\": \"2.0\",\n        \"id\": 3,\n        \"method\": \"tools/call\",\n        \"params\": {\n          \"name\": \"weather_current\",\n          \"arguments\": {\n            \"location\": \"San Francisco\",\n            \"units\": \"imperial\"\n          }\n        }\n      }\n      ```\n\n      ```json Tool Call Response theme={null}\n      {\n        \"jsonrpc\": \"2.0\",\n        \"id\": 3,\n        \"result\": {\n          \"content\": [\n            {\n              \"type\": \"text\",\n              \"text\": \"Current weather in San Francisco: 68°F, partly cloudy with light winds from the west at 8 mph. Humidity: 65%\"\n            }\n          ]\n        }\n      }\n      ```\n    </CodeGroup>\n\n    #### Key Elements of Tool Execution\n\n    The request structure includes several important components:\n\n    1. **`name`**: Must match exactly the tool name from the discovery response (`weather_current`). This ensures the server can correctly identify which tool to execute.\n\n    2. **`arguments`**: Contains the input parameters as defined by the tool's `inputSchema`. In this example:\n       * `location`: \"San Francisco\" (required parameter)\n       * `units`: \"imperial\" (optional parameter, defaults to \"metric\" if not specified)\n\n    3. **JSON-RPC Structure**: Uses standard JSON-RPC 2.0 format with unique `id` for request-response correlation.\n\n    #### Understanding the Tool Execution Response\n\n    The response demonstrates MCP's flexible content system:\n\n    1. **`content` Array**: Tool responses return an array of content objects, allowing for rich, multi-format responses (text, images, resources, etc.)\n\n    2. **Content Types**: Each content object has a `type` field. In this example, `\"type\": \"text\"` indicates plain text content, but MCP supports various content types for different use cases.\n\n    3. **Structured Output**: The response provides actionable information that the AI application can use as context for language model interactions.\n\n    This execution pattern allows AI applications to dynamically invoke server functionality and receive structured responses that can be integrated into conversations with language models.\n\n    #### How This Works in AI Applications\n\n    When the language model decides to use a tool during a conversation, the AI application intercepts the tool call, routes it to the appropriate MCP server, executes it, and returns the results back to the LLM as part of the conversation flow. This enables the LLM to access real-time data and perform actions in the external world.\n\n    ```python  theme={null}\n    # Pseudo-code for AI application tool execution\n    async def handle_tool_call(conversation, tool_name, arguments):\n        session = app.find_mcp_session_for_tool(tool_name)\n        result = await session.call_tool(tool_name, arguments)\n        conversation.add_tool_result(result.content)\n    ```\n  </Step>\n\n  <Step title=\"Real-time Updates (Notifications)\">\n    MCP supports real-time notifications that enable servers to inform clients about changes without being explicitly requested. This demonstrates the notification system, a key feature that keeps MCP connections synchronized and responsive.\n\n    #### Understanding Tool List Change Notifications\n\n    When the server's available tools change—such as when new functionality becomes available, existing tools are modified, or tools become temporarily unavailable—the server can proactively notify connected clients:\n\n    ```json Request theme={null}\n    {\n      \"jsonrpc\": \"2.0\",\n      \"method\": \"notifications/tools/list_changed\"\n    }\n    ```\n\n    #### Key Features of MCP Notifications\n\n    1. **No Response Required**: Notice there's no `id` field in the notification. This follows JSON-RPC 2.0 notification semantics where no response is expected or sent.\n\n    2. **Capability-Based**: This notification is only sent by servers that declared `\"listChanged\": true` in their tools capability during initialization (as shown in Step 1).\n\n    3. **Event-Driven**: The server decides when to send notifications based on internal state changes, making MCP connections dynamic and responsive.\n\n    #### Client Response to Notifications\n\n    Upon receiving this notification, the client typically reacts by requesting the updated tool list. This creates a refresh cycle that keeps the client's understanding of available tools current:\n\n    ```json Request theme={null}\n    {\n      \"jsonrpc\": \"2.0\",\n      \"id\": 4,\n      \"method\": \"tools/list\"\n    }\n    ```\n\n    #### Why Notifications Matter\n\n    This notification system is crucial for several reasons:\n\n    1. **Dynamic Environments**: Tools may come and go based on server state, external dependencies, or user permissions\n    2. **Efficiency**: Clients don't need to poll for changes; they're notified when updates occur\n    3. **Consistency**: Ensures clients always have accurate information about available server capabilities\n    4. **Real-time Collaboration**: Enables responsive AI applications that can adapt to changing contexts\n\n    This notification pattern extends beyond tools to other MCP primitives, enabling comprehensive real-time synchronization between clients and servers.\n\n    #### How This Works in AI Applications\n\n    When the AI application receives a notification about changed tools, it immediately refreshes its tool registry and updates the LLM's available capabilities. This ensures that ongoing conversations always have access to the most current set of tools, and the LLM can dynamically adapt to new functionality as it becomes available.\n\n    ```python  theme={null}\n    # Pseudo-code for AI application notification handling\n    async def handle_tools_changed_notification(session):\n        tools_response = await session.list_tools()\n        app.update_available_tools(session, tools_response.tools)\n        if app.conversation.is_active():\n            app.conversation.notify_llm_of_new_capabilities()\n    ```\n  </Step>\n</Steps>",
  "content_length": 25358
}