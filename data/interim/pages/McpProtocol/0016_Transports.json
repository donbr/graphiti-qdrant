{
  "title": "Transports",
  "source_url": "https://modelcontextprotocol.io/specification/2025-11-25/basic/transports",
  "content": "<div id=\"enable-section-numbers\" />\n\n<Info>**Protocol Revision**: 2025-11-25</Info>\n\nMCP uses JSON-RPC to encode messages. JSON-RPC messages **MUST** be UTF-8 encoded.\n\nThe protocol currently defines two standard transport mechanisms for client-server\ncommunication:\n\n1. [stdio](#stdio), communication over standard in and standard out\n2. [Streamable HTTP](#streamable-http)\n\nClients **SHOULD** support stdio whenever possible.\n\nIt is also possible for clients and servers to implement\n[custom transports](#custom-transports) in a pluggable fashion.\n\n## stdio\n\nIn the **stdio** transport:\n\n* The client launches the MCP server as a subprocess.\n* The server reads JSON-RPC messages from its standard input (`stdin`) and sends messages\n  to its standard output (`stdout`).\n* Messages are individual JSON-RPC requests, notifications, or responses.\n* Messages are delimited by newlines, and **MUST NOT** contain embedded newlines.\n* The server **MAY** write UTF-8 strings to its standard error (`stderr`) for any\n  logging purposes including informational, debug, and error messages.\n* The client **MAY** capture, forward, or ignore the server's `stderr` output\n  and **SHOULD NOT** assume `stderr` output indicates error conditions.\n* The server **MUST NOT** write anything to its `stdout` that is not a valid MCP message.\n* The client **MUST NOT** write anything to the server's `stdin` that is not a valid MCP\n  message.\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant Client\n    participant Server Process\n\n    Client->>+Server Process: Launch subprocess\n    loop Message Exchange\n        Client->>Server Process: Write to stdin\n        Server Process->>Client: Write to stdout\n        Server Process--)Client: Optional logs on stderr\n    end\n    Client->>Server Process: Close stdin, terminate subprocess\n    deactivate Server Process\n```\n\n## Streamable HTTP\n\n<Info>\n  This replaces the [HTTP+SSE\n  transport](/specification/2024-11-05/basic/transports#http-with-sse) from\n  protocol version 2024-11-05. See the [backwards compatibility](#backwards-compatibility)\n  guide below.\n</Info>\n\nIn the **Streamable HTTP** transport, the server operates as an independent process that\ncan handle multiple client connections. This transport uses HTTP POST and GET requests.\nServer can optionally make use of\n[Server-Sent Events](https://en.wikipedia.org/wiki/Server-sent_events) (SSE) to stream\nmultiple server messages. This permits basic MCP servers, as well as more feature-rich\nservers supporting streaming and server-to-client notifications and requests.\n\nThe server **MUST** provide a single HTTP endpoint path (hereafter referred to as the\n**MCP endpoint**) that supports both POST and GET methods. For example, this could be a\nURL like `https://example.com/mcp`.\n\n#### Security Warning\n\nWhen implementing Streamable HTTP transport:\n\n1. Servers **MUST** validate the `Origin` header on all incoming connections to prevent DNS rebinding attacks\n   * If the `Origin` header is present and invalid, servers **MUST** respond with HTTP 403 Forbidden. The HTTP response\n     body **MAY** comprise a JSON-RPC *error response* that has no `id`\n2. When running locally, servers **SHOULD** bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)\n3. Servers **SHOULD** implement proper authentication for all connections\n\nWithout these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.\n\n### Sending Messages to the Server\n\nEvery JSON-RPC message sent from the client **MUST** be a new HTTP POST request to the\nMCP endpoint.\n\n1. The client **MUST** use HTTP POST to send JSON-RPC messages to the MCP endpoint.\n2. The client **MUST** include an `Accept` header, listing both `application/json` and\n   `text/event-stream` as supported content types.\n3. The body of the POST request **MUST** be a single JSON-RPC *request*, *notification*, or *response*.\n4. If the input is a JSON-RPC *response* or *notification*:\n   * If the server accepts the input, the server **MUST** return HTTP status code 202\n     Accepted with no body.\n   * If the server cannot accept the input, it **MUST** return an HTTP error status code\n     (e.g., 400 Bad Request). The HTTP response body **MAY** comprise a JSON-RPC *error\n     response* that has no `id`.\n5. If the input is a JSON-RPC *request*, the server **MUST** either\n   return `Content-Type: text/event-stream`, to initiate an SSE stream, or\n   `Content-Type: application/json`, to return one JSON object. The client **MUST**\n   support both these cases.\n6. If the server initiates an SSE stream:\n   * The server **SHOULD** immediately send an SSE event consisting of an event\n     ID and an empty `data` field in order to prime the client to reconnect\n     (using that event ID as `Last-Event-ID`).\n   * After the server has sent an SSE event with an event ID to the client, the\n     server **MAY** close the *connection* (without terminating the *SSE stream*)\n     at any time in order to avoid holding a long-lived connection. The client\n     **SHOULD** then \"poll\" the SSE stream by attempting to reconnect.\n   * If the server does close the *connection* prior to terminating the *SSE stream*,\n     it **SHOULD** send an SSE event with a standard [`retry`](https://html.spec.whatwg.org/multipage/server-sent-events.html#:~:text=field%20name%20is%20%22retry%22) field before\n     closing the connection. The client **MUST** respect the `retry` field,\n     waiting the given number of milliseconds before attempting to reconnect.\n   * The SSE stream **SHOULD** eventually include a JSON-RPC *response* for the\n     JSON-RPC *request* sent in the POST body.\n   * The server **MAY** send JSON-RPC *requests* and *notifications* before sending the\n     JSON-RPC *response*. These messages **SHOULD** relate to the originating client\n     *request*.\n   * The server **MAY** terminate the SSE stream if the [session](#session-management)\n     expires.\n   * After the JSON-RPC *response* has been sent, the server **SHOULD** terminate the\n     SSE stream.\n   * Disconnection **MAY** occur at any time (e.g., due to network conditions).\n     Therefore:\n     * Disconnection **SHOULD NOT** be interpreted as the client cancelling its request.\n     * To cancel, the client **SHOULD** explicitly send an MCP `CancelledNotification`.\n     * To avoid message loss due to disconnection, the server **MAY** make the stream\n       [resumable](#resumability-and-redelivery).\n\n### Listening for Messages from the Server\n\n1. The client **MAY** issue an HTTP GET to the MCP endpoint. This can be used to open an\n   SSE stream, allowing the server to communicate to the client, without the client first\n   sending data via HTTP POST.\n2. The client **MUST** include an `Accept` header, listing `text/event-stream` as a\n   supported content type.\n3. The server **MUST** either return `Content-Type: text/event-stream` in response to\n   this HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server\n   does not offer an SSE stream at this endpoint.\n4. If the server initiates an SSE stream:\n   * The server **MAY** send JSON-RPC *requests* and *notifications* on the stream.\n   * These messages **SHOULD** be unrelated to any concurrently-running JSON-RPC\n     *request* from the client.\n   * The server **MUST NOT** send a JSON-RPC *response* on the stream **unless**\n     [resuming](#resumability-and-redelivery) a stream associated with a previous client\n     request.\n   * The server **MAY** close the SSE stream at any time.\n   * If the server closes the *connection* without terminating the *stream*, it\n     **SHOULD** follow the same polling behavior as described for POST requests:\n     sending a `retry` field and allowing the client to reconnect.\n   * The client **MAY** close the SSE stream at any time.\n\n### Multiple Connections\n\n1. The client **MAY** remain connected to multiple SSE streams simultaneously.\n2. The server **MUST** send each of its JSON-RPC messages on only one of the connected\n   streams; that is, it **MUST NOT** broadcast the same message across multiple streams.\n   * The risk of message loss **MAY** be mitigated by making the stream\n     [resumable](#resumability-and-redelivery).\n\n### Resumability and Redelivery\n\nTo support resuming broken connections, and redelivering messages that might otherwise be\nlost:\n\n1. Servers **MAY** attach an `id` field to their SSE events, as described in the\n   [SSE standard](https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation).\n   * If present, the ID **MUST** be globally unique across all streams within that\n     [session](#session-management)â€”or all streams with that specific client, if session\n     management is not in use.\n   * Event IDs **SHOULD** encode sufficient information to identify the originating\n     stream, enabling the server to correlate a `Last-Event-ID` to the correct stream.\n2. If the client wishes to resume after a disconnection (whether due to network failure\n   or server-initiated closure), it **SHOULD** issue an HTTP GET to the MCP endpoint,\n   and include the\n   [`Last-Event-ID`](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-last-event-id-header)\n   header to indicate the last event ID it received.\n   * The server **MAY** use this header to replay messages that would have been sent\n     after the last event ID, *on the stream that was disconnected*, and to resume the\n     stream from that point.\n   * The server **MUST NOT** replay messages that would have been delivered on a\n     different stream.\n   * This mechanism applies regardless of how the original stream was initiated (via\n     POST or GET). Resumption is always via HTTP GET with `Last-Event-ID`.\n\nIn other words, these event IDs should be assigned by servers on a *per-stream* basis, to\nact as a cursor within that particular stream.\n\n### Session Management\n\nAn MCP \"session\" consists of logically related interactions between a client and a\nserver, beginning with the [initialization phase](/specification/2025-11-25/basic/lifecycle). To support\nservers which want to establish stateful sessions:\n\n1. A server using the Streamable HTTP transport **MAY** assign a session ID at\n   initialization time, by including it in an `MCP-Session-Id` header on the HTTP\n   response containing the `InitializeResult`.\n   * The session ID **SHOULD** be globally unique and cryptographically secure (e.g., a\n     securely generated UUID, a JWT, or a cryptographic hash).\n   * The session ID **MUST** only contain visible ASCII characters (ranging from 0x21 to\n     0x7E).\n   * The client **MUST** handle the session ID in a secure manner, see [Session Hijacking mitigations](/specification/2025-11-25/basic/security_best_practices#session-hijacking) for more details.\n2. If an `MCP-Session-Id` is returned by the server during initialization, clients using\n   the Streamable HTTP transport **MUST** include it in the `MCP-Session-Id` header on\n   all of their subsequent HTTP requests.\n   * Servers that require a session ID **SHOULD** respond to requests without an\n     `MCP-Session-Id` header (other than initialization) with HTTP 400 Bad Request.\n3. The server **MAY** terminate the session at any time, after which it **MUST** respond\n   to requests containing that session ID with HTTP 404 Not Found.\n4. When a client receives HTTP 404 in response to a request containing an\n   `MCP-Session-Id`, it **MUST** start a new session by sending a new `InitializeRequest`\n   without a session ID attached.\n5. Clients that no longer need a particular session (e.g., because the user is leaving\n   the client application) **SHOULD** send an HTTP DELETE to the MCP endpoint with the\n   `MCP-Session-Id` header, to explicitly terminate the session.\n   * The server **MAY** respond to this request with HTTP 405 Method Not Allowed,\n     indicating that the server does not allow clients to terminate sessions.\n\n### Sequence Diagram\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant Client\n    participant Server\n\n    note over Client, Server: initialization\n\n    Client->>+Server: POST InitializeRequest\n    Server->>-Client: InitializeResponse<br>MCP-Session-Id: 1868a90c...\n\n    Client->>+Server: POST InitializedNotification<br>MCP-Session-Id: 1868a90c...\n    Server->>-Client: 202 Accepted\n\n    note over Client, Server: client requests\n    Client->>+Server: POST ... request ...<br>MCP-Session-Id: 1868a90c...\n\n    alt single HTTP response\n      Server->>Client: ... response ...\n    else server opens SSE stream\n      loop while connection remains open\n          Server-)Client: ... SSE messages from server ...\n      end\n      Server-)Client: SSE event: ... response ...\n    end\n    deactivate Server\n\n    note over Client, Server: client notifications/responses\n    Client->>+Server: POST ... notification/response ...<br>MCP-Session-Id: 1868a90c...\n    Server->>-Client: 202 Accepted\n\n    note over Client, Server: server requests\n    Client->>+Server: GET<br>MCP-Session-Id: 1868a90c...\n    loop while connection remains open\n        Server-)Client: ... SSE messages from server ...\n    end\n    deactivate Server\n\n```\n\n### Protocol Version Header\n\nIf using HTTP, the client **MUST** include the `MCP-Protocol-Version: <protocol-version>` HTTP header on all subsequent requests to the MCP\nserver, allowing the MCP server to respond based on the MCP protocol version.\n\nFor example: `MCP-Protocol-Version: 2025-11-25`\n\nThe protocol version sent by the client **SHOULD** be the one [negotiated during\ninitialization](/specification/2025-11-25/basic/lifecycle#version-negotiation).\n\nFor backwards compatibility, if the server does *not* receive an `MCP-Protocol-Version`\nheader, and has no other way to identify the version - for example, by relying on the\nprotocol version negotiated during initialization - the server **SHOULD** assume protocol\nversion `2025-03-26`.\n\nIf the server receives a request with an invalid or unsupported\n`MCP-Protocol-Version`, it **MUST** respond with `400 Bad Request`.\n\n### Backwards Compatibility\n\nClients and servers can maintain backwards compatibility with the deprecated [HTTP+SSE\ntransport](/specification/2024-11-05/basic/transports#http-with-sse) (from\nprotocol version 2024-11-05) as follows:\n\n**Servers** wanting to support older clients should:\n\n* Continue to host both the SSE and POST endpoints of the old transport, alongside the\n  new \"MCP endpoint\" defined for the Streamable HTTP transport.\n  * It is also possible to combine the old POST endpoint and the new MCP endpoint, but\n    this may introduce unneeded complexity.\n\n**Clients** wanting to support older servers should:\n\n1. Accept an MCP server URL from the user, which may point to either a server using the\n   old transport or the new transport.\n2. Attempt to POST an `InitializeRequest` to the server URL, with an `Accept` header as\n   defined above:\n   * If it succeeds, the client can assume this is a server supporting the new Streamable\n     HTTP transport.\n   * If it fails with the following HTTP status codes \"400 Bad Request\", \"404 Not\n     Found\" or \"405 Method Not Allowed\":\n     * Issue a GET request to the server URL, expecting that this will open an SSE stream\n       and return an `endpoint` event as the first event.\n     * When the `endpoint` event arrives, the client can assume this is a server running\n       the old HTTP+SSE transport, and should use that transport for all subsequent\n       communication.\n\n## Custom Transports\n\nClients and servers **MAY** implement additional custom transport mechanisms to suit\ntheir specific needs. The protocol is transport-agnostic and can be implemented over any\ncommunication channel that supports bidirectional message exchange.\n\nImplementers who choose to support custom transports **MUST** ensure they preserve the\nJSON-RPC message format and lifecycle requirements defined by MCP. Custom transports\n**SHOULD** document their specific connection establishment and message exchange patterns\nto aid interoperability.",
  "content_length": 16038
}