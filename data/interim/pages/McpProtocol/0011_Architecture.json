{
  "title": "Architecture",
  "source_url": "https://modelcontextprotocol.io/specification/2025-11-25/architecture/index",
  "content": "<div id=\"enable-section-numbers\" />\n\nThe Model Context Protocol (MCP) follows a client-host-server architecture where each\nhost can run multiple client instances. This architecture enables users to integrate AI\ncapabilities across applications while maintaining clear security boundaries and\nisolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused\non context exchange and sampling coordination between clients and servers.\n\n## Core Components\n\n```mermaid  theme={null}\ngraph LR\n    subgraph \"Application Host Process\"\n        H[Host]\n        C1[Client 1]\n        C2[Client 2]\n        C3[Client 3]\n        H --> C1\n        H --> C2\n        H --> C3\n    end\n\n    subgraph \"Local machine\"\n        S1[Server 1<br>Files & Git]\n        S2[Server 2<br>Database]\n        R1[(\"Local<br>Resource A\")]\n        R2[(\"Local<br>Resource B\")]\n\n        C1 --> S1\n        C2 --> S2\n        S1 <--> R1\n        S2 <--> R2\n    end\n\n    subgraph \"Internet\"\n        S3[Server 3<br>External APIs]\n        R3[(\"Remote<br>Resource C\")]\n\n        C3 --> S3\n        S3 <--> R3\n    end\n```\n\n### Host\n\nThe host process acts as the container and coordinator:\n\n* Creates and manages multiple client instances\n* Controls client connection permissions and lifecycle\n* Enforces security policies and consent requirements\n* Handles user authorization decisions\n* Coordinates AI/LLM integration and sampling\n* Manages context aggregation across clients\n\n### Clients\n\nEach client is created by the host and maintains an isolated server connection:\n\n* Establishes one stateful session per server\n* Handles protocol negotiation and capability exchange\n* Routes protocol messages bidirectionally\n* Manages subscriptions and notifications\n* Maintains security boundaries between servers\n\nA host application creates and manages multiple clients, with each client having a 1:1\nrelationship with a particular server.\n\n### Servers\n\nServers provide specialized context and capabilities:\n\n* Expose resources, tools and prompts via MCP primitives\n* Operate independently with focused responsibilities\n* Request sampling through client interfaces\n* Must respect security constraints\n* Can be local processes or remote services\n\n## Design Principles\n\nMCP is built on several key design principles that inform its architecture and\nimplementation:\n\n1. **Servers should be extremely easy to build**\n   * Host applications handle complex orchestration responsibilities\n   * Servers focus on specific, well-defined capabilities\n   * Simple interfaces minimize implementation overhead\n   * Clear separation enables maintainable code\n\n2. **Servers should be highly composable**\n   * Each server provides focused functionality in isolation\n   * Multiple servers can be combined seamlessly\n   * Shared protocol enables interoperability\n   * Modular design supports extensibility\n\n3. **Servers should not be able to read the whole conversation, nor \"see into\" other\n   servers**\n   * Servers receive only necessary contextual information\n   * Full conversation history stays with the host\n   * Each server connection maintains isolation\n   * Cross-server interactions are controlled by the host\n   * Host process enforces security boundaries\n\n4. **Features can be added to servers and clients progressively**\n   * Core protocol provides minimal required functionality\n   * Additional capabilities can be negotiated as needed\n   * Servers and clients evolve independently\n   * Protocol designed for future extensibility\n   * Backwards compatibility is maintained\n\n## Capability Negotiation\n\nThe Model Context Protocol uses a capability-based negotiation system where clients and\nservers explicitly declare their supported features during initialization. Capabilities\ndetermine which protocol features and primitives are available during a session.\n\n* Servers declare capabilities like resource subscriptions, tool support, and prompt\n  templates\n* Clients declare capabilities like sampling support and notification handling\n* Both parties must respect declared capabilities throughout the session\n* Additional capabilities can be negotiated through extensions to the protocol\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant Host\n    participant Client\n    participant Server\n\n    Host->>+Client: Initialize client\n    Client->>+Server: Initialize session with capabilities\n    Server-->>Client: Respond with supported capabilities\n\n    Note over Host,Server: Active Session with Negotiated Features\n\n    loop Client Requests\n        Host->>Client: User- or model-initiated action\n        Client->>Server: Request (tools/resources)\n        Server-->>Client: Response\n        Client-->>Host: Update UI or respond to model\n    end\n\n    loop Server Requests\n        Server->>Client: Request (sampling)\n        Client->>Host: Forward to AI\n        Host-->>Client: AI response\n        Client-->>Server: Response\n    end\n\n    loop Notifications\n        Server--)Client: Resource updates\n        Client--)Server: Status changes\n    end\n\n    Host->>Client: Terminate\n    Client->>-Server: End session\n    deactivate Server\n```\n\nEach capability unlocks specific protocol features for use during the session. For\nexample:\n\n* Implemented [server features](/specification/2025-11-25/server) must be advertised in the\n  server's capabilities\n* Emitting resource subscription notifications requires the server to declare\n  subscription support\n* Tool invocation requires the server to declare tool capabilities\n* [Sampling](/specification/2025-11-25/client) requires the client to declare support in its\n  capabilities\n\nThis capability negotiation ensures clients and servers have a clear understanding of\nsupported functionality while maintaining protocol extensibility.",
  "content_length": 5736
}