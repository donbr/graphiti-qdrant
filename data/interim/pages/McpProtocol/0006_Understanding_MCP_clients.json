{
  "title": "Understanding MCP clients",
  "source_url": "https://modelcontextprotocol.io/docs/learn/client-concepts",
  "content": "MCP clients are instantiated by host applications to communicate with particular MCP servers. The host application, like Claude.ai or an IDE, manages the overall user experience and coordinates multiple clients. Each client handles one direct communication with one server.\n\nUnderstanding the distinction is important: the *host* is the application users interact with, while *clients* are the protocol-level components that enable server connections.\n\n## Core Client Features\n\nIn addition to making use of context provided by servers, clients may provide several features to servers. These client features allow server authors to build richer interactions.\n\n| Feature         | Explanation                                                                                                                                                                                       | Example                                                                                                                                |\n| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\n| **Elicitation** | Elicitation enables servers to request specific information from users during interactions, providing a structured way for servers to gather information on demand.                               | A server booking travel may ask for the user's preferences on airplane seats, room type or their contact number to finalise a booking. |\n| **Roots**       | Roots allow clients to specify which directories servers should focus on, communicating intended scope through a coordination mechanism.                                                          | A server for booking travel may be given access to a specific directory, from which it can read a user's calendar.                     |\n| **Sampling**    | Sampling allows servers to request LLM completions through the client, enabling an agentic workflow. This approach puts the client in complete control of user permissions and security measures. | A server for booking travel may send a list of flights to an LLM and request that the LLM pick the best flight for the user.           |\n\n### Elicitation\n\nElicitation enables servers to request specific information from users during interactions, creating more dynamic and responsive workflows.\n\n#### Overview\n\nElicitation provides a structured way for servers to gather necessary information on demand. Instead of requiring all information up front or failing when data is missing, servers can pause their operations to request specific inputs from users. This creates more flexible interactions where servers adapt to user needs rather than following rigid patterns.\n\n**Elicitation flow:**\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant User\n    participant Client\n    participant Server\n\n    Note over Server,Client: Server initiates elicitation\n    Server->>Client: elicitation/create\n\n    Note over Client,User: Human interaction\n    Client->>User: Present elicitation UI\n    User-->>Client: Provide requested information\n\n    Note over Server,Client: Complete request\n    Client-->>Server: Return user response\n\n    Note over Server: Continue processing with new information\n```\n\nThe flow enables dynamic information gathering. Servers can request specific data when needed, users provide information through appropriate UI, and servers continue processing with the newly acquired context.\n\n**Elicitation components example:**\n\n```typescript  theme={null}\n{\n  method: \"elicitation/requestInput\",\n  params: {\n    message: \"Please confirm your Barcelona vacation booking details:\",\n    schema: {\n      type: \"object\",\n      properties: {\n        confirmBooking: {\n          type: \"boolean\",\n          description: \"Confirm the booking (Flights + Hotel = $3,000)\"\n        },\n        seatPreference: {\n          type: \"string\",\n          enum: [\"window\", \"aisle\", \"no preference\"],\n          description: \"Preferred seat type for flights\"\n        },\n        roomType: {\n          type: \"string\",\n          enum: [\"sea view\", \"city view\", \"garden view\"],\n          description: \"Preferred room type at hotel\"\n        },\n        travelInsurance: {\n          type: \"boolean\",\n          default: false,\n          description: \"Add travel insurance ($150)\"\n        }\n      },\n      required: [\"confirmBooking\"]\n    }\n  }\n}\n```\n\n#### Example: Holiday Booking Approval\n\nA travel booking server demonstrates elicitation's power through the final booking confirmation process. When a user has selected their ideal vacation package to Barcelona, the server needs to gather final approval and any missing details before proceeding.\n\nThe server elicits booking confirmation with a structured request that includes the trip summary (Barcelona flights June 15-22, beachfront hotel, total \\$3,000) and fields for any additional preferences—such as seat selection, room type, or travel insurance options.\n\nAs the booking progresses, the server elicits contact information needed to complete the reservation. It might ask for traveler details for flight bookings, special requests for the hotel, or emergency contact information.\n\n#### User Interaction Model\n\nElicitation interactions are designed to be clear, contextual, and respectful of user autonomy:\n\n**Request presentation**: Clients display elicitation requests with clear context about which server is asking, why the information is needed, and how it will be used. The request message explains the purpose while the schema provides structure and validation.\n\n**Response options**: Users can provide the requested information through appropriate UI controls (text fields, dropdowns, checkboxes), decline to provide information with optional explanation, or cancel the entire operation. Clients validate responses against the provided schema before returning them to servers.\n\n**Privacy considerations**: Elicitation never requests passwords or API keys. Clients warn about suspicious requests and let users review data before sending.\n\n### Roots\n\nRoots define filesystem boundaries for server operations, allowing clients to specify which directories servers should focus on.\n\n#### Overview\n\nRoots are a mechanism for clients to communicate filesystem access boundaries to servers. They consist of file URIs that indicate directories where servers can operate, helping servers understand the scope of available files and folders. While roots communicate intended boundaries, they do not enforce security restrictions. Actual security must be enforced at the operating system level, via file permissions and/or sandboxing.\n\n**Root structure:**\n\n```json  theme={null}\n{\n  \"uri\": \"file:///Users/agent/travel-planning\",\n  \"name\": \"Travel Planning Workspace\"\n}\n```\n\nRoots are exclusively filesystem paths and always use the `file://` URI scheme. They help servers understand project boundaries, workspace organization, and accessible directories. The roots list can be updated dynamically as users work with different projects or folders, with servers receiving notifications through `roots/list_changed` when boundaries change.\n\n#### Example: Travel Planning Workspace\n\nA travel agent working with multiple client trips benefits from roots to organize filesystem access. Consider a workspace with different directories for various aspects of travel planning.\n\nThe client provides filesystem roots to the travel planning server:\n\n* `file:///Users/agent/travel-planning` - Main workspace containing all travel files\n* `file:///Users/agent/travel-templates` - Reusable itinerary templates and resources\n* `file:///Users/agent/client-documents` - Client passports and travel documents\n\nWhen the agent creates a Barcelona itinerary, well-behaved servers respect these boundaries—accessing templates, saving the new itinerary, and referencing client documents within the specified roots. Servers typically access files within roots by using relative paths from the root directories or by utilizing file search tools that respect the root boundaries.\n\nIf the agent opens an archive folder like `file:///Users/agent/archive/2023-trips`, the client updates the roots list via `roots/list_changed`.\n\nFor a complete implementation of a server that respects roots, see the [filesystem server](https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem) in the official servers repository.\n\n#### Design Philosophy\n\nRoots serve as a coordination mechanism between clients and servers, not a security boundary. The specification requires that servers \"SHOULD respect root boundaries,\" and not that they \"MUST enforce\" them, because servers run code the client cannot control.\n\nRoots work best when servers are trusted or vetted, users understand their advisory nature, and the goal is preventing accidents rather than stopping malicious behavior. They excel at context scoping (telling servers where to focus), accident prevention (helping well-behaved servers stay in bounds), and workflow organization (such as managing project boundaries automatically).\n\n#### User Interaction Model\n\nRoots are typically managed automatically by host applications based on user actions, though some applications may expose manual root management:\n\n**Automatic root detection**: When users open folders, clients automatically expose them as roots. Opening a travel workspace allows the client to expose that directory as a root, helping servers understand which itineraries and documents are in scope for the current work.\n\n**Manual root configuration**: Advanced users can specify roots through configuration. For example, adding `/travel-templates` for reusable resources while excluding directories with financial records.\n\n### Sampling\n\nSampling allows servers to request language model completions through the client, enabling agentic behaviors while maintaining security and user control.\n\n#### Overview\n\nSampling enables servers to perform AI-dependent tasks without directly integrating with or paying for AI models. Instead, servers can request that the client—which already has AI model access—handle these tasks on their behalf. This approach puts the client in complete control of user permissions and security measures. Because sampling requests occur within the context of other operations—like a tool analyzing data—and are processed as separate model calls, they maintain clear boundaries between different contexts, allowing for more efficient use of the context window.\n\n**Sampling flow:**\n\n```mermaid  theme={null}\nsequenceDiagram\n    participant LLM\n    participant User\n    participant Client\n    participant Server\n\n    Note over Server,Client: Server initiates sampling\n    Server->>Client: sampling/createMessage\n\n    Note over Client,User: Human-in-the-loop review\n    Client->>User: Present request for approval\n    User-->>Client: Review and approve/modify\n\n    Note over Client,LLM: Model interaction\n    Client->>LLM: Forward approved request\n    LLM-->>Client: Return generation\n\n    Note over Client,User: Response review\n    Client->>User: Present response for approval\n    User-->>Client: Review and approve/modify\n\n    Note over Server,Client: Complete request\n    Client-->>Server: Return approved response\n```\n\nThe flow ensures security through multiple human-in-the-loop checkpoints. Users review and can modify both the initial request and the generated response before it returns to the server.\n\n**Request parameters example:**\n\n```typescript  theme={null}\n{\n  messages: [\n    {\n      role: \"user\",\n      content: \"Analyze these flight options and recommend the best choice:\\n\" +\n               \"[47 flights with prices, times, airlines, and layovers]\\n\" +\n               \"User preferences: morning departure, max 1 layover\"\n    }\n  ],\n  modelPreferences: {\n    hints: [{\n      name: \"claude-sonnet-4-20250514\"  // Suggested model\n    }],\n    costPriority: 0.3,      // Less concerned about API cost\n    speedPriority: 0.2,     // Can wait for thorough analysis\n    intelligencePriority: 0.9  // Need complex trade-off evaluation\n  },\n  systemPrompt: \"You are a travel expert helping users find the best flights based on their preferences\",\n  maxTokens: 1500\n}\n```\n\n#### Example: Flight Analysis Tool\n\nConsider a travel booking server with a tool called `findBestFlight` that uses sampling to analyze available flights and recommend the optimal choice. When a user asks \"Book me the best flight to Barcelona next month,\" the tool needs AI assistance to evaluate complex trade-offs.\n\nThe tool queries airline APIs and gathers 47 flight options. It then requests AI assistance to analyze these options: \"Analyze these flight options and recommend the best choice: \\[47 flights with prices, times, airlines, and layovers] User preferences: morning departure, max 1 layover.\"\n\nThe client initiates the sampling request, allowing the AI to evaluate trade-offs—like cheaper red-eye flights versus convenient morning departures. The tool uses this analysis to present the top three recommendations.\n\n#### User Interaction Model\n\nWhile not a requirement, sampling is designed to allow human-in-the-loop control. Users can maintain oversight through several mechanisms:\n\n**Approval controls**: Sampling requests may require explicit user consent. Clients can show what the server wants to analyze and why. Users can approve, deny, or modify requests.\n\n**Transparency features**: Clients can display the exact prompt, model selection, and token limits, allowing users to review AI responses before they return to the server.\n\n**Configuration options**: Users can set model preferences, configure auto-approval for trusted operations, or require approval for everything. Clients may provide options to redact sensitive information.\n\n**Security considerations**: Both clients and servers must handle sensitive data appropriately during sampling. Clients should implement rate limiting and validate all message content. The human-in-the-loop design ensures that server-initiated AI interactions cannot compromise security or access sensitive data without explicit user consent.",
  "content_length": 14325
}