{
  "title": "How to respond to state changes",
  "source_url": "https://docs-3.prefect.io/v3/how-to-guides/workflows/state-change-hooks",
  "content": "Learn how to execute code in response to entering states in your workflows.\n\n### Available state change hooks\n\n| Type                                           | Flow | Task | Description                                                  |\n| ---------------------------------------------- | ---- | ---- | ------------------------------------------------------------ |\n| `on_completion`                                | ✓    | ✓    | Executes when a flow or task run enters a `Completed` state. |\n| `on_failure`                                   | ✓    | ✓    | Executes when a flow or task run enters a `Failed` state.    |\n| <span class=\"no-wrap\">`on_cancellation`</span> | ✓    | -    | Executes when a flow run enters a `Cancelling` state.        |\n| `on_crashed`                                   | ✓    | -    | Executes when a flow run enters a `Crashed` state.           |\n| `on_running`                                   | ✓    | ✓    | Executes when a flow or task run enters a `Running` state.   |\n\n<Note>\n  Note that the `on_rollback` hook for tasks is *not* a proper state change hook but instead\n  is a transaction lifecycle hook.\n  Rollback hooks accept one argument representing the transaction for the task.\n</Note>\n\n### Send a notification when a workflow run fails\n\nTo send a notification when a flow or task run fails, you can specify a `on_failure` hook.\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.blocks.core import Block\nfrom prefect.settings import get_current_settings\n\n\n@flow(retries=1)\ndef failing_flow():\n    raise ValueError(\"oops!\")\n\n\n@failing_flow.on_failure\ndef notify_slack(flow, flow_run, state):\n    slack_webhook_block = Block.load(\n        \"slack-webhook/my-slack-webhook\"\n    )\n\n    PREFECT_API_URL = get_current_settings().api.url\n\n    slack_webhook_block.notify(\n        (\n            f\"Your job {flow_run.name} entered {state.name} \"\n            f\"with message:\\n\\n\"\n            f\"See <https://{PREFECT_API_URL}/flow-runs/\"\n            f\"flow-run/{flow_run.id}|the flow run in the UI>\\n\\n\"\n            f\"Tags: {flow_run.tags}\\n\\n\"\n            f\"Scheduled start: {flow_run.expected_start_time}\"\n        )\n    )\n\nif __name__ == \"__main__\":\n    failing_flow()\n```\n\nRetries are configured in this example, so the `on_failure` hook will not run until all `retries` have completed and the flow run enters a `Failed` state.\n\n<Warning>\n  **State change hooks execute client side**\n\n  State change hooks run in the same process as your workflow and execution cannot be guaranteed. For more robust execution of logic in response to state changes, use an Automation.\n</Warning>\n\n### Execute code when a task starts running\n\nThe `on_running` hook executes when a task enters a `Running` state, before the task body executes. This is useful for logging, metrics, or setting up runtime state:\n\n```python  theme={null}\nfrom prefect import flow, task\nimport time\n\ndef record_start_time(task, task_run, state):\n    print(f\"Task {task.name} started at {time.time()}\")\n\n@task(on_running=[record_start_time])\ndef my_task():\n    return \"hello\"\n\n# Or use the decorator pattern\n@task\ndef another_task():\n    return \"world\"\n\n@another_task.on_running\ndef log_start(task, task_run, state):\n    print(f\"Starting {task.name}!\")\n\n@flow\ndef my_flow():\n    my_task()\n    another_task()\n```\n\nNote that `on_running` hooks execute **synchronously** before the task body runs. If your hook takes 10 seconds, the task waits 10 seconds before starting.\n\nWhen retries are configured, `on_running` hooks fire on **each retry attempt**, including the initial run. For example, a task configured with `retries=2` will trigger its `on_running` hooks up to three times: once on the initial run and once for each retry attempt.\n\n### Pass `kwargs` to state change hooks\n\nYou can compose the `with_options` method to effectively pass arbitrary `**kwargs` to your hooks:\n\n```python  theme={null}\nfrom functools import partial\nfrom prefect import flow, task\n\ndata = {}\n\ndef my_hook(task, task_run, state, **kwargs):\n    data.update(state=state, **kwargs)\n\n@task\ndef bad_task():\n    raise ValueError(\"meh\")\n\n@flow\ndef ok_with_failure_flow(x: str = \"foo\", y: int = 42):\n    bad_task_with_a_hook = bad_task.with_options(\n        on_failure=[partial(my_hook, **dict(x=x, y=y))]\n    )\n    # return a tuple of \"bar\" and the task run state\n    # to avoid raising the task's exception\n    return \"bar\", bad_task_with_a_hook(return_state=True)\n\n_, task_run_state = ok_with_failure_flow()\n\nassert data == {\"x\": \"foo\", \"y\": 42, \"state\": task_run_state}\n```",
  "content_length": 4556
}