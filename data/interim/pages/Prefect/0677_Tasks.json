{
  "title": "Tasks",
  "source_url": "https://docs-3.prefect.io/v3/concepts/tasks",
  "content": "Tasks are atomic units of work with transactional semantics.\n\n```python  theme={null}\nfrom prefect import task\n\n@task(log_prints=True)\ndef explain_tasks():\n    print(\"run any python code here!\")\n    print(\"but maybe just a little bit\")\n\nif __name__ == \"__main__\":\n    explain_tasks()\n```\n\n## What is a task?\n\nTasks are defined as decorated Python functions. Above, `explain_tasks` is an instance of a task.\n\nTasks are cache-able and retryable units of work that are easy to execute concurrently, in parallel, and/or with [transactional semantics](/v3/advanced/transactions).\n\nLike flows, tasks are free to call other tasks or flows, there is no required nesting pattern.\n\nGenerally, tasks behave like normal Python functions, but they have some additional capabilities:\n\n* Metadata about task runs, such as run time and final state, is automatically tracked\n* Each [state](/v3/concepts/states/) the task enters is recorded, enabling observability and state-based logic\n* [Futures](/v3/how-to-guides/workflows/run-work-concurrently#handling-futures) from upstream tasks are automatically resolved by downstream tasks\n* [Retries](/v3/how-to-guides/workflows/retries) can be performed on failure, with configurable delay and retry limits\n* [Caching](/v3/how-to-guides/workflows/cache-workflow-steps) enables result reuse across workflow executions\n* [Concurrency](/v3/how-to-guides/workflows/run-work-concurrently) via `.submit()` and `.map()` allow concurrent execution within and across workflows\n* [Timeouts](/v3/how-to-guides/workflows/write-and-run#cancel-a-workflow-if-it-runs-for-too-long) can be enforced to prevent unintentional, long-running operations\n\nTasks are uniquely identified by a task key, which is a hash composed of the task name and the fully qualified name of the function.\n\n## Running a task\n\nA **task run** is a representation of a single invocation of a task.\n\n### The life of a task run\n\nLike flow runs, each task run has its own state lifecycle. Task states provide observability into execution progress and enable sophisticated runtime logic based on upstream outcomes.\n\nLike flow runs, each task run can be observed in the Prefect UI or CLI.\n\nA normal task run lifecycle looks like this:\n\n```mermaid  theme={null}\nflowchart TD\n    A[Pending] -->|ðŸš€ Starting execution| B[Running]\n    A -->|ðŸ“¦ Cached result available| C[Completed]\n    B -->|âœ… Success| C[Completed]\n    B -.->|âŒ Error occurred| D[Retrying/AwaitingRetry]\n    B -.->|ðŸ’¥ Infrastructure failure| E[Crashed]\n    D -->|ðŸ”„ Retry attempt| B\n    D -.->|ðŸ˜µ Retries exhausted| F[Failed]\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px,color:#000\n    style B fill:#9ff,stroke:#333,stroke-width:2px,color:#000\n    style C fill:#9f9,stroke:#333,stroke-width:2px,color:#000\n    style D fill:#ff9,stroke:#333,stroke-width:2px,color:#000\n    style E fill:#f66,stroke:#333,stroke-width:2px,color:#fff\n    style F fill:#f99,stroke:#333,stroke-width:2px,color:#000\n\n    classDef default fill-opacity:0.9\n```\n\n<Note>\n  **[Background tasks](#background-tasks) have an additional state**\n\n  When using `.delay()`, background tasks start in a `Scheduled` state before transitioning to `Pending`. This allows them to be queued and distributed to available workers.\n</Note>\n\n### Different ways to create a task run\n\nThe simplest way to create a task run is to call a `@task` decorated function (i.e. `__call__`), just like a normal Python function.\n\n```python  theme={null}\nfrom prefect import task\n\n@task\ndef add_integers(a: int, b: int) -> int:\n    return a + b\n\nif __name__ == \"__main__\":\n    add_integers(1, 2)\n```\n\nTasks may be submitted to a [task runner](/v3/how-to-guides/workflows/run-work-concurrently#task-runners) for concurrent execution where the eventual result is desired.\n\nWhen the result of a task is not required by the caller, it may be delayed to static infrastructure in the background for execution by an available [task worker](/v3/how-to-guides/workflows/run-background-tasks#task-workers).\n\n## Task orchestration model\n\n### Client-side orchestration\n\nPrefect tasks are orchestrated client-side, which means that task runs are created and updated locally. This allows for efficient handling of large-scale workflows with many tasks and improves reliability when connectivity fails intermittently.\n\nTask updates are logged in batch, leading to eventual consistency for task states in the UI and API queries.\n\n### State dependencies\n\nTasks automatically resolve dependencies based on data flow between them. When a task receives the result or future of an upstream task as input, Prefect establishes an implicit state dependency such that a downstream task cannot begin until the upstream task has `Completed`.\n\nExplicit state dependencies can be introduced with [the `wait_for` parameter.](/v3/how-to-guides/workflows/run-work-concurrently#creating-state-dependencies)\n\n## Task composition within flows\n\nTasks are typically organized into [flows](/v3/concepts/flows#organize-flows-with-subflows-and-tasks) to create comprehensive workflows.\nEach task offers isolated observability within the Prefect UI. Task-level metrics, logs, and state information help identify bottlenecks and troubleshoot issues at a granular level. Tasks can also be reused across multiple flows, promoting consistency and modularity across an organization's data ecosystem.\n\n<Note>\n  **How big should a task be?**\n\n  Prefect encourages \"small tasks.\" As a rule of thumb, each task should represent a logical step or significant \"side effect\" in your workflow.\n  This allows task-level observability and orchestration to narrate your workflow out-of-the-box.\n\n  <img src=\"https://mintcdn.com/prefect-bd373955/rm4-_dTLtkmSX6eG/v3/img/concepts/narrative-encapsulation.png?fit=max&auto=format&n=rm4-_dTLtkmSX6eG&q=85&s=0375ef77dac4dbf1fb99b31fb1582aab\" alt=\"Narrative encapsulation\" data-og-width=\"684\" width=\"684\" data-og-height=\"367\" height=\"367\" data-path=\"v3/img/concepts/narrative-encapsulation.png\" data-optimize=\"true\" data-opv=\"3\" srcset=\"https://mintcdn.com/prefect-bd373955/rm4-_dTLtkmSX6eG/v3/img/concepts/narrative-encapsulation.png?w=280&fit=max&auto=format&n=rm4-_dTLtkmSX6eG&q=85&s=fe1c8efcb393efdb8e44a1d62f03a60e 280w, https://mintcdn.com/prefect-bd373955/rm4-_dTLtkmSX6eG/v3/img/concepts/narrative-encapsulation.png?w=560&fit=max&auto=format&n=rm4-_dTLtkmSX6eG&q=85&s=0a4d210602b3fb5f707e4621872845d1 560w, https://mintcdn.com/prefect-bd373955/rm4-_dTLtkmSX6eG/v3/img/concepts/narrative-encapsulation.png?w=840&fit=max&auto=format&n=rm4-_dTLtkmSX6eG&q=85&s=954b944463e2214bc7ccc75548be9e25 840w, https://mintcdn.com/prefect-bd373955/rm4-_dTLtkmSX6eG/v3/img/concepts/narrative-encapsulation.png?w=1100&fit=max&auto=format&n=rm4-_dTLtkmSX6eG&q=85&s=f503db6fe162c6347c5161d3e86296b8 1100w, https://mintcdn.com/prefect-bd373955/rm4-_dTLtkmSX6eG/v3/img/concepts/narrative-encapsulation.png?w=1650&fit=max&auto=format&n=rm4-_dTLtkmSX6eG&q=85&s=31745b7e6a5b5e97fb7226acf4e51b42 1650w, https://mintcdn.com/prefect-bd373955/rm4-_dTLtkmSX6eG/v3/img/concepts/narrative-encapsulation.png?w=2500&fit=max&auto=format&n=rm4-_dTLtkmSX6eG&q=85&s=b3e3a6de701c1161071f195c7ea58eec 2500w\" />\n</Note>\n\nFor detailed configuration options and implementation guidance, see [how to write and run workflows](/v3/how-to-guides/workflows/write-and-run).\n\n## Background tasks\n\nBackground tasks are an alternate task execution model where tasks are submitted in a non-blocking manner by one process and executed by a pool of processes. This execution model is particularly valuable for web applications and workflows that need to dispatch heavy or long-running work without waiting for completion to dedicated, horizontally scaled infrastructure.\n\nWhen a task is executed with `.delay()`, it pushes the resulting task run onto a server-side topic, which is distributed to an available [task worker](/v3/how-to-guides/workflows/run-background-tasks#task-workers) for execution.\n\n<Note>\n  Prefect background tasks can be used in place of tools like [Celery](https://docs.celeryq.dev/en/stable/getting-started/introduction.html) and [RabbitMQ](https://www.rabbitmq.com/) for task queue functionality.\n</Note>\n\nBackground tasks are useful for scenarios such as:\n\n* Web applications that need to trigger long-running processes without blocking HTTP responses\n* Workflows that dispatch work to specialized infrastructure or resource pools\n* Systems that need to scale task execution independently from the main application\n\nFor implementation details, see [how to run background tasks](/v3/how-to-guides/workflows/run-background-tasks).",
  "content_length": 8579
}