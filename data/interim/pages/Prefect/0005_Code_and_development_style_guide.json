{
  "title": "Code and development style guide",
  "source_url": "https://docs-3.prefect.io/contribute/styles-practices",
  "content": "Generally, we follow the [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html).\nThis document covers Prefect-specific styles and practices.\n\n## Imports\n\nThis is a brief collection of rules and guidelines for handling imports in this repository.\n\n### Imports in `__init__` files\n\nLeave `__init__` files empty unless exposing an interface. If you must expose objects to present a simpler API,\nplease follow these rules.\n\n#### Exposing objects from submodules\n\nIf importing objects from submodules, the `__init__` file should use a relative import. This is\n[required for type checkers](https://github.com/microsoft/pyright/blob/main/docs/typed-libraries.md#library-interface)\nto understand the exposed interface.\n\n```python  theme={null}\n# Correct\nfrom .flows import flow\n\n```\n\n```python  theme={null}\n# Wrong\nfrom prefect.flows import flow\n\n```\n\n#### Exposing submodules\n\nGenerally, submodules should *not* be imported in the `__init__` file. You should only expose submodules when the module\nis designed to be imported and used as a namespaced object.\n\nFor example, we do this for our schema and model modules. This is because it's important to know if you are working with an API\nschema or database modelâ€”both of which may have similar names.\n\n```python  theme={null}\nimport prefect.server.schemas as schemas\n\n# The full module is accessible now\nschemas.core.FlowRun\n\n```\n\nIf exposing a submodule, use a relative import like when you're exposing an object.\n\n```python  theme={null}\n# Correct\nfrom . import flows\n\n```\n\n```python  theme={null}\n# Wrong\nimport prefect.flows\n\n```\n\n#### Importing to run side-effects\n\nAnother use case for importing submodules is to perform global side-effects that occur when they are imported.\n\nOften, global side-effects on import are a dangerous pattern. But there are a couple acceptable\nuse cases for this:\n\n* To register dispatchable types, for example, `prefect.serializers`.\n* To extend a CLI app, for example, `prefect.cli`.\n\n### Imports in modules\n\n#### Importing other modules\n\nThe `from` syntax is recommended for importing objects from modules. You should not import modules\nwith the `from` syntax.\n\n```python  theme={null}\n# Correct\nimport prefect.server.schemas  # use with the full name\nimport prefect.server.schemas as schemas  # use the shorter name\n\n```\n\n```python  theme={null}\n# Wrong\nfrom prefect.server import schemas\n\n```\n\nYou should not use relative imports unless it's in an `__init__.py` file.\n\n```python  theme={null}\n# Correct\nfrom prefect.utilities.foo import bar\n```\n\n```python  theme={null}\n# Wrong\nfrom .utilities.foo import bar\n\n```\n\nYou should never use imports that are dependent on file location without explicit indication it is relative. This avoids\nconfusion about the source of a module.\n\n```python  theme={null}\n# Correct\nfrom . import test\n\n```\n\n#### Resolving circular dependencies\n\nSometimes, you must defer an import and perform it *within* a function to avoid a circular dependency:\n\n```python  theme={null}\n## This function in `settings.py` requires a method from the global `context` but the context\n## uses settings\ndef from_context():\n    from prefect.context import get_profile_context\n\n    ...\n\n```\n\nAvoid circular dependencies. They often reveal entanglement in the design.\n\nPlace all deferred imports at the top of the function.\n\nIf you are just using the imported object for a type signature, use the `TYPE_CHECKING` flag:\n\n```python  theme={null}\n# Correct\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from prefect.server.schemas.states import State\n\ndef foo(state: \"State\"):\n    pass\n\n```\n\nUsage of the type within the module requires quotes; for example, `\"State\"`, since it is not available at runtime.\n\n#### Importing optional requirements\n\nWe do not have a best practice for this yet. See the `kubernetes`, `docker`, and `distributed` implementations for now.\n\n#### Delaying expensive imports\n\nSometimes imports are slow, but it's important to keep the `prefect` module import times fast. In these cases, lazily\nimport the slow module by deferring import to the relevant function body. For modules consumed by many functions,\nuse the optional requirements pattern instead.\n\n## Command line interface (CLI) output messages\n\nWhen executing a command that creates an object, the output message should offer:\n\n* A short description of what the command just did.\n* A bullet point list, rehashing user inputs, if possible.\n* Next steps, like the next command to run, if applicable.\n* Other relevant, pre-formatted commands that can be copied and pasted, if applicable.\n* A new line before the first line, and after the last line.\n\nOutput Example:\n\n```js  theme={null}\n$ prefect work-queue create testing\n\nCreated work queue with properties:\n    name - 'abcde'\n    uuid - 940f9828-c820-4148-9526-ea8107082bda\n    tags - None\n    deployment_ids - None\n\nStart an agent to pick up flows from the created work queue:\n    prefect agent start -q 'abcde'\n\nInspect the created work queue:\n    prefect work-queue inspect 'abcde'\n\n```\n\nAdditionally:\n\n* Wrap generated arguments in apostrophes (') to ensure validity by using suffixing formats with `!r`.\n* Indent example commands, instead of wrapping in backticks (\\`).\n* Use placeholders if you cannot completely pre-format the example.\n* Capitalize placeholder labels and wrap them in less than (\\<) and greater than (>) signs.\n* Utilize `textwrap.dedent` to remove extraneous spacing for strings with triple quotes (\"\"\").\n\nPlaceholder Example:\n\n```\nCreate a work queue with tags:\n    prefect work-queue create '<WORK QUEUE NAME>' -t '<OPTIONAL TAG 1>' -t '<OPTIONAL TAG 2>'\n\n```\n\nDedent Example:\n\n```python  theme={null}\nfrom textwrap import dedent\n...\noutput_msg = dedent(\n    f\"\"\"\n    Created work queue with properties:\n        name - {name!r}\n        uuid - {result}\n        tags - {tags or None}\n        deployment_ids - {deployment_ids or None}\n\n    Start an agent to pick up flows from the created work queue:\n        prefect agent start -q {name!r}\n\n    Inspect the created work queue:\n        prefect work-queue inspect {name!r}\n    \"\"\"\n)\n\n```\n\n## API versioning\n\n### Client and server communication\n\nYou can run the Prefect client separately from Prefect server, and communicate entirely through an API.\nThe Prefect client includes anything that runs task or flow code, (for example, agents and the Python client);\nor any consumer of Prefect metadata (for example, the Prefect UI and CLI).\n\nPrefect server stores this metadata and serves it through the REST API.\n\n### API version header\n\nSometimes, we have to make breaking changes to the API. To check a Prefect client's compatibility\nwith the API it's making requests to, every API call the client makes includes a three-component `API_VERSION` header with major,\nminor, and patch versions.\n\nFor example, a request with the `X-PREFECT-API-VERSION=3.2.1` header has a major version of `3`, minor version `2`, and patch\nversion `1`.\n\nChange this version header by modifying the `API_VERSION` constant in `prefect.server.api.server`.\n\n### Breaking changes to the API\n\nA breaking change means that your code needs to change to use a new version of Prefect. We avoid breaking\nchanges whenever possible.\n\nWhen making a breaking change to the API, we consider if the change is *backwards compatible for clients*.\nThis means that the previous version of the client can still make calls against the updated version of the server code.\nThis might happen if the changes are purely additive, such as adding a non-critical API route. In these cases, we aim\nto bump the patch version.\n\nIn almost all other cases, we bump the minor version, which denotes a non-backwards-compatible API change. We have reserved\nthe major version changes to denote a backwards compatible change that is significant in some way, such as a major release\nmilestone.\n\n### Version composition\n\nVersions are composed of three parts: MAJOR.MINOR.PATCH. For example, the version 2.5.0 has a major version of 2, a minor version\nof 5, and patch version of 0.\n\nOccasionally, we add a suffix to the version such as `rc`, `a`, or `b`. These indicate pre-release versions that users can\nopt into for testing and experimentation prior to a generally available release.\n\nEach release will increase one of the version numbers. If we increase a number other than the patch version, the versions to the\nright of it reset to zero.\n\n## Prefect's versioning scheme\n\nPrefect increases the major version when significant and widespread changes are made to the core product.\n\nPrefect increases the minor version when:\n\n* Introducing a new concept that changes how to use Prefect\n* Changing an existing concept in a way that fundamentally alters its usage\n* Removing a deprecated feature\n\nPrefect increases the patch version when:\n\n* Making enhancements to existing features\n* Fixing behavior in existing features\n* Adding new capabilities to existing concepts\n* Updating dependencies\n\n## Deprecation\n\nAt times, Prefect will deprecate a feature. A feature is deprecated when it will no longer be maintained. Frequently,\na deprecated feature will have a new and improved alternative. Deprecated features will be retained for at least **3** minor\nversion increases or **6 months**, whichever is longer. We may retain deprecated features longer than this time period.\n\nPrefect will sometimes include changes to behavior to fix a bug. These changes are not categorized as breaking changes.\n\n## Client compatibility with Prefect\n\nWhen running a Prefect server, you are in charge of ensuring the version is compatible with those of the clients that are\nusing the server. Prefect aims to maintain backwards compatibility with old clients for each server release. In contrast,\nsometimes you cannot use new clients with an old server. The new client may expect the server to support capabilities that\nit does not yet include. For this reason, we recommend that all clients are the same version as the server or older.\n\nFor example, you can use a client on 2.1.0 with a server on 2.5.0. You cannot use a client on 2.5.0 with a server on 2.1.0.\n\n## Client compatibility with Cloud\n\nPrefect Cloud targets compatibility with all versions of Prefect clients. If you encounter a compatibility issue, please\n[file a bug report](https://github.com/prefectHQ/prefect/issues/new/choose).",
  "content_length": 10333
}