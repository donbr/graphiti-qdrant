{
  "title": "Database Cleanup with Human or AI Approval",
  "source_url": "https://docs-3.prefect.io/v3/examples/ai-database-cleanup-with-approval",
  "content": "Build database cleanup workflows that evolve from human oversight to AI autonomy.\n\n<a href=\"https://github.com/zzstoatzz/prefect-mcp-server-demo\" target=\"_blank\">View full project on GitHub</a>\n\nDatabase cleanup is critical for self-hosted Prefect deployments (see [database maintenance guide](/v3/advanced/database-maintenance)),\nbut it's risky: too automated and you might delete important data, too manual and it becomes a constant burden.\n\nThis example shows how to build a cleanup workflow that evolves with your confidence:\n\n* **Start with human approval**: Preview what will be deleted, pause the flow, and manually approve/reject via a UI form\n* **Graduate to AI autonomy**: Switch to an AI agent that investigates system health using Prefect MCP tools and returns structured decisions with confidence scores\n\nBuild trust incrementally by monitoring decisions in lower-risk environments before enabling AI autonomy in production.\n\nFor a full deployment example with scheduling and environment configuration, see:\n[github.com/zzstoatzz/prefect-mcp-server-demo](https://github.com/zzstoatzz/prefect-mcp-server-demo)\n\n## Setup\n\n```bash  theme={null}\n# For human approval only\nuv add prefect\n\n# For AI approval, add pydantic-ai\nuv add 'pydantic-ai[prefect]'\nexport ANTHROPIC_API_KEY='your-key'\n```\n\nThe Prefect MCP server provides AI agents with read-only tools for investigating your Prefect instance.\nSee [How to use the Prefect MCP server](/v3/how-to-guides/ai/use-prefect-mcp-server) for setup.\n\n```python  theme={null}\nfrom __future__ import annotations\n\nimport asyncio\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Literal\n\nfrom pydantic import BaseModel, Field\nfrom pydantic_ai import Agent\nfrom pydantic_ai.durable_exec.prefect import PrefectAgent, TaskConfig\nfrom pydantic_ai.models.anthropic import AnthropicModel\nfrom pydantic_ai_mcp import MCPServerStdio\n\nfrom prefect import flow, get_client\nfrom prefect.client.schemas.filters import (\n    FlowRunFilter,\n    FlowRunFilterStartTime,\n    FlowRunFilterStateName,\n)\nfrom prefect.flow_runs import pause_flow_run\nfrom prefect.input import RunInput\n\n```\n\n## Configuration: Make Cleanup Policy Explicit\n\nInstead of scattering configuration across your code, define it as a structured Pydantic model.\nThis becomes a UI form automatically - see [form building guide](/v3/advanced/form-building).\n\n```python  theme={null}\nclass RetentionConfig(BaseModel):\n    \"\"\"Define what to clean and how.\"\"\"\n\n    retention_period: timedelta = Field(\n        default=timedelta(days=30), description=\"How far back to keep flow runs\"\n    )\n    states_to_clean: list[str] = Field(\n        default=[\"Completed\", \"Failed\", \"Cancelled\"],\n        description=\"Which states to clean\",\n    )\n    batch_size: int = Field(default=100, ge=10, le=1000)\n    dry_run: bool = Field(default=False, description=\"Preview without deleting\")\n    approval_type: Literal[\"human\", \"ai\"] = Field(\n        default=\"human\", description=\"Human form or AI agent approval\"\n    )\n\n\n```\n\n<AccordionGroup>\n  <Accordion title=\"Human Approval: Pause and Review\">\n    When using `approval_type=\"human\"`, the flow pauses and shows a form in the UI.\n\n    ```python  theme={null}\n    class CleanupApproval(RunInput):\n        \"\"\"Human approval form for cleanup operations.\"\"\"\n\n        approve: bool = Field(default=False)\n        notes: str = Field(default=\"\", description=\"Why approve/reject?\")\n\n\n    @flow(name=\"human-approval\")\n    def get_human_approval(preview: str, count: int) -> tuple[bool, str]:\n        \"\"\"Pause and wait for human decision via UI form.\"\"\"\n        print(f\"‚è∏Ô∏è  pausing for human review of {count} flow runs...\")\n\n        approval = pause_flow_run(\n            wait_for_input=CleanupApproval.with_initial_data(\n                description=f\"**Preview ({count} runs):**\\n{preview}\"\n            ),\n            timeout=3600,\n        )\n\n        return approval.approve, approval.notes\n\n\n    ```\n  </Accordion>\n\n  <Accordion title=\"AI Approval: Autonomous Investigation\">\n    When using `approval_type=\"ai\"`, a pydantic-ai agent investigates using Prefect MCP tools to decide if cleanup is safe.\n\n    ```python  theme={null}\n    AGENT_PROMPT = \"\"\"you are a prefect infrastructure operations agent reviewing a proposed database cleanup.\n\n    use the prefect mcp tools to investigate system health:\n    - query recent flow run patterns\n    - check deployment schedules\n    - review system status\n\n    return your decision with confidence (0-1), reasoning, and any concerns.\n\n    approve routine cleanup unless you detect risks like ongoing incidents or critical deployments needing history.\"\"\"\n\n\n    class CleanupDecision(BaseModel):\n        \"\"\"Structured AI decision.\"\"\"\n\n        approved: bool\n        confidence: float = Field(ge=0.0, le=1.0)\n        reasoning: str\n        concerns: list[str] | None = None\n\n\n    def create_cleanup_agent() -> PrefectAgent[None, CleanupDecision]:\n        \"\"\"Create AI agent with Prefect MCP tools for autonomous approval.\"\"\"\n        # Connect to Prefect MCP server - provides read-only Prefect tools\n        mcp_server = MCPServerStdio(\n            \"prefect\", \"uvx\", args=[\"--from\", \"prefect-mcp\", \"prefect-mcp-server\"]\n        )\n\n        agent = Agent(\n            model=AnthropicModel(\"claude-sonnet-4-5-20250929\"),\n            output_type=CleanupDecision,\n            system_prompt=AGENT_PROMPT,\n            mcp_servers=[mcp_server],\n        )\n\n        # Wrap with PrefectAgent for retry/timeout handling\n        return PrefectAgent(\n            agent,\n            model_task_config=TaskConfig(retries=2, timeout_seconds=120.0),\n        )\n\n\n    @flow(name=\"ai-approval\", log_prints=True)\n    async def get_ai_approval(\n        preview: str, count: int, config: RetentionConfig\n    ) -> tuple[bool, str]:\n        \"\"\"Use AI agent to autonomously decide approval.\"\"\"\n        print(\"ü§ñ requesting ai agent decision...\")\n\n        agent = create_cleanup_agent()\n\n        context = f\"\"\"\n    proposed cleanup:\n    - retention: {config.retention_period}\n    - states: {\", \".join(config.states_to_clean)}\n    - count: {count} flow runs\n\n    preview:\n    {preview}\n\n    investigate using your prefect mcp tools and decide if safe to proceed.\n    \"\"\"\n\n        result = await agent.run(context)\n        decision = result.output\n\n        print(f\"decision: {'‚úÖ approved' if decision.approved else '‚ùå rejected'}\")\n        print(f\"confidence: {decision.confidence:.0%}\")\n        print(f\"reasoning: {decision.reasoning}\")\n\n        return decision.approved, decision.reasoning\n\n\n    ```\n  </Accordion>\n\n  <Accordion title=\"Main Cleanup Flow\">\n    ```python  theme={null}\n    @flow(name=\"database-cleanup\", log_prints=True)\n    async def database_cleanup_flow(config: RetentionConfig | None = None) -> dict:\n        \"\"\"Database cleanup with configurable approval workflow.\"\"\"\n        if config is None:\n            config = RetentionConfig()\n\n        print(f\"üöÄ starting cleanup (approval: {config.approval_type})\")\n\n        # Fetch flow runs matching retention policy\n        async with get_client() as client:\n            cutoff = datetime.now(timezone.utc) - config.retention_period\n            flow_runs = await client.read_flow_runs(\n                flow_run_filter=FlowRunFilter(\n                    start_time=FlowRunFilterStartTime(before_=cutoff),\n                    state=FlowRunFilterStateName(any_=config.states_to_clean),\n                ),\n                limit=config.batch_size * 5,\n            )\n\n        if not flow_runs:\n            print(\"‚ú® nothing to clean\")\n            return {\"status\": \"no_action\", \"deleted\": 0}\n\n        # Preview what will be deleted\n        preview = \"\\n\".join(\n            f\"- {r.name} ({r.state.type.value}) - {r.start_time}\" for r in flow_runs[:5]\n        )\n        if len(flow_runs) > 5:\n            preview += f\"\\n... and {len(flow_runs) - 5} more\"\n\n        print(f\"\\nüìã preview:\\n{preview}\\n\")\n\n        # Get approval (human or AI based on config)\n        if config.approval_type == \"human\":\n            approved, notes = get_human_approval(preview, len(flow_runs))\n        else:\n            approved, notes = await get_ai_approval(preview, len(flow_runs), config)\n\n        if not approved:\n            print(f\"‚ùå cleanup rejected: {notes}\")\n            return {\"status\": \"rejected\", \"reason\": notes}\n\n        print(f\"‚úÖ cleanup approved: {notes}\")\n\n        if config.dry_run:\n            print(\"üîç dry run - no deletions\")\n            return {\"status\": \"dry_run\", \"would_delete\": len(flow_runs)}\n\n        # Perform deletion with batching and rate limiting\n        deleted = 0\n        async with get_client() as client:\n            for i in range(0, len(flow_runs), config.batch_size):\n                batch = flow_runs[i : i + config.batch_size]\n                for run in batch:\n                    try:\n                        await client.delete_flow_run(run.id)\n                        deleted += 1\n                    except Exception as e:\n                        print(f\"failed to delete {run.id}: {e}\")\n                    await asyncio.sleep(0.1)  # rate limiting\n\n        print(f\"‚úÖ deleted {deleted}/{len(flow_runs)} flow runs\")\n        return {\"status\": \"completed\", \"deleted\": deleted}\n\n\n    ```\n  </Accordion>\n</AccordionGroup>\n\n## Deployment Examples\n\n```python  theme={null}\nif __name__ == \"__main__\":\n    # Start with human approval in production\n    prod_config = RetentionConfig(\n        retention_period=timedelta(days=30),\n        dry_run=False,\n        approval_type=\"human\",\n    )\n\n    # Graduate to AI approval in dev/staging\n    dev_config = RetentionConfig(\n        retention_period=timedelta(minutes=5),\n        dry_run=False,\n        approval_type=\"ai\",  # requires ANTHROPIC_API_KEY\n    )\n\n    database_cleanup_flow.serve(\n        name=\"database-cleanup-deployment\",\n        tags=[\"database-maintenance\", \"cleanup\"],\n    )\n\n```\n\n## Related Documentation\n\n* [Database Maintenance Guide](/v3/advanced/database-maintenance) - SQL queries, retention strategies, VACUUM\n* [Form Building](/v3/advanced/form-building) - Create validated UI forms from Pydantic models\n* [Interactive Workflows](/v3/advanced/interactive) - Pause flows and wait for human input\n* [Prefect MCP Server](/v3/how-to-guides/ai/use-prefect-mcp-server) - Connect AI agents to Prefect\n* [pydantic-ai + Prefect](https://ai.pydantic.dev/durable_execution/prefect/) - Durable AI agents with retries",
  "content_length": 10400
}