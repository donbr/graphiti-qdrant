{
  "title": "tasks",
  "source_url": "https://docs-3.prefect.io/v3/api-ref/python/prefect-tasks",
  "content": "# `prefect.tasks`\n\nModule containing the base workflow task class and decorator - for most use cases, using the `@task` decorator is preferred.\n\n## Functions\n\n### `task_input_hash` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L162\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ntask_input_hash(context: 'TaskRunContext', arguments: dict[str, Any]) -> Optional[str]\n```\n\nA task cache key implementation which hashes all inputs to the task using a JSON or\ncloudpickle serializer. If any arguments are not JSON serializable, the pickle\nserializer is used as a fallback. If cloudpickle fails, this will return a null key\nindicating that a cache key could not be generated for the given inputs.\n\n**Args:**\n\n* `context`: the active `TaskRunContext`\n* `arguments`: a dictionary of arguments to be passed to the underlying task\n\n**Returns:**\n\n* a string hash if hashing succeeded, else `None`\n\n### `exponential_backoff` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L188\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nexponential_backoff(backoff_factor: float) -> Callable[[int], list[float]]\n```\n\nA task retry backoff utility that configures exponential backoff for task retries.\nThe exponential backoff design matches the urllib3 implementation.\n\n**Args:**\n\n* `backoff_factor`: the base delay for the first retry, subsequent retries will\n  increase the delay time by powers of 2.\n\n**Returns:**\n\n* a callable that can be passed to the task constructor\n\n### `task` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1923\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ntask(__fn: Optional[Callable[P, R]] = None)\n```\n\nDecorator to designate a function as a task in a Prefect workflow.\n\nThis decorator may be used for asynchronous or synchronous functions.\n\n**Args:**\n\n* `name`: An optional name for the task; if not provided, the name will be inferred\n  from the given function.\n* `description`: An optional string description for the task.\n* `tags`: An optional set of tags to be associated with runs of this task. These\n  tags are combined with any tags defined by a `prefect.tags` context at\n  task runtime.\n* `version`: An optional string specifying the version of this task definition\n* `cache_key_fn`: An optional callable that, given the task run context and call\n  parameters, generates a string key; if the key matches a previous completed\n  state, that state result will be restored instead of running the task again.\n* `cache_expiration`: An optional amount of time indicating how long cached states\n  for this task should be restorable; if not provided, cached states will\n  never expire.\n* `task_run_name`: An optional name to distinguish runs of this task; this name can be provided\n  as a string template with the task's keyword arguments as variables,\n  or a function that returns a string.\n* `retries`: An optional number of times to retry on task run failure\n* `retry_delay_seconds`: Optionally configures how long to wait before retrying the\n  task after failure. This is only applicable if `retries` is nonzero. This\n  setting can either be a number of seconds, a list of retry delays, or a\n  callable that, given the total number of retries, generates a list of retry\n  delays. If a number of seconds, that delay will be applied to all retries.\n  If a list, each retry will wait for the corresponding delay before retrying.\n  When passing a callable or a list, the number of\n  configured retry delays cannot exceed 50.\n* `retry_jitter_factor`: An optional factor that defines the factor to which a\n  retry can be jittered in order to avoid a \"thundering herd\".\n* `persist_result`: A toggle indicating whether the result of this task\n  should be persisted to result storage. Defaults to `None`, which\n  indicates that the global default should be used (which is `True` by\n  default).\n* `result_storage`: An optional block to use to persist the result of this task.\n  Defaults to the value set in the flow the task is called in.\n* `result_storage_key`: An optional key to store the result in storage at when persisted.\n  Defaults to a unique identifier.\n* `result_serializer`: An optional serializer to use to serialize the result of this\n  task for persistence. Defaults to the value set in the flow the task is\n  called in.\n* `timeout_seconds`: An optional number of seconds indicating a maximum runtime for\n  the task. If the task exceeds this runtime, it will be marked as failed.\n* `log_prints`: If set, `print` statements in the task will be redirected to the\n  Prefect logger for the task run. Defaults to `None`, which indicates\n  that the value from the flow should be used.\n* `refresh_cache`: If set, cached results for the cache key are not used.\n  Defaults to `None`, which indicates that a cached result from a previous\n  execution with matching cache key is used.\n* `on_failure`: An optional list of callables to run when the task enters a failed state.\n* `on_completion`: An optional list of callables to run when the task enters a completed state.\n* `retry_condition_fn`: An optional callable run when a task run returns a Failed state. Should\n  return `True` if the task should continue to its retry policy (e.g. `retries=3`), and `False` if the task\n  should end as failed. Defaults to `None`, indicating the task should always continue\n  to its retry policy.\n* `viz_return_value`: An optional value to return when the task dependency tree is visualized.\n* `asset_deps`: An optional list of upstream assets that this task depends on.\n\n**Returns:**\n\n* A callable `Task` object which, when called, will submit the task for execution.\n\n**Examples:**\n\nDefine a simple task\n\n```python  theme={null}\n@task\ndef add(x, y):\n    return x + y\n```\n\nDefine an async task\n\n```python  theme={null}\n@task\nasync def add(x, y):\n    return x + y\n```\n\nDefine a task with tags and a description\n\n```python  theme={null}\n@task(tags={\"a\", \"b\"}, description=\"This task is empty but its my first!\")\ndef my_task():\n    pass\n```\n\nDefine a task with a custom name\n\n```python  theme={null}\n@task(name=\"The Ultimate Task\")\ndef my_task():\n    pass\n```\n\nDefine a task that retries 3 times with a 5 second delay between attempts\n\n```python  theme={null}\nfrom random import randint\n\n@task(retries=3, retry_delay_seconds=5)\ndef my_task():\n    x = randint(0, 5)\n    if x >= 3:  # Make a task that fails sometimes\n        raise ValueError(\"Retry me please!\")\n    return x\n```\n\nDefine a task that is cached for a day based on its inputs\n\n```python  theme={null}\nfrom prefect.tasks import task_input_hash\nfrom datetime import timedelta\n\n@task(cache_key_fn=task_input_hash, cache_expiration=timedelta(days=1))\ndef my_task():\n    return \"hello\"\n```\n\n## Classes\n\n### `TaskRunNameCallbackWithParameters` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L102\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n**Methods:**\n\n#### `is_callback_with_parameters` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L104\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nis_callback_with_parameters(cls, callable: Callable[..., str]) -> TypeIs[Self]\n```\n\n### `TaskOptions` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L122\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nA TypedDict representing all available task configuration options.\n\nThis can be used with `Unpack` to provide type hints for \\*\\*kwargs.\n\n### `Task` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L300\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nA Prefect task definition.\n\nWraps a function with an entrypoint to the Prefect engine. Calling this class within a flow function\ncreates a new task run.\n\nTo preserve the input and output types, we use the generic type variables P and R for \"Parameters\" and\n\"Returns\" respectively.\n\n**Args:**\n\n* `fn`: The function defining the task.\n* `name`: An optional name for the task; if not provided, the name will be inferred\n  from the given function.\n* `description`: An optional string description for the task.\n* `tags`: An optional set of tags to be associated with runs of this task. These\n  tags are combined with any tags defined by a `prefect.tags` context at\n  task runtime.\n* `version`: An optional string specifying the version of this task definition\n* `cache_policy`: A cache policy that determines the level of caching for this task\n* `cache_key_fn`: An optional callable that, given the task run context and call\n  parameters, generates a string key; if the key matches a previous completed\n  state, that state result will be restored instead of running the task again.\n* `cache_expiration`: An optional amount of time indicating how long cached states\n  for this task should be restorable; if not provided, cached states will\n  never expire.\n* `task_run_name`: An optional name to distinguish runs of this task; this name can be provided\n  as a string template with the task's keyword arguments as variables,\n  or a function that returns a string.\n* `retries`: An optional number of times to retry on task run failure.\n* `retry_delay_seconds`: Optionally configures how long to wait before retrying the\n  task after failure. This is only applicable if `retries` is nonzero. This\n  setting can either be a number of seconds, a list of retry delays, or a\n  callable that, given the total number of retries, generates a list of retry\n  delays. If a number of seconds, that delay will be applied to all retries.\n  If a list, each retry will wait for the corresponding delay before retrying.\n  When passing a callable or a list, the number of configured retry delays\n  cannot exceed 50.\n* `retry_jitter_factor`: An optional factor that defines the factor to which a retry\n  can be jittered in order to avoid a \"thundering herd\".\n* `persist_result`: A toggle indicating whether the result of this task\n  should be persisted to result storage. Defaults to `None`, which\n  indicates that the global default should be used (which is `True` by\n  default).\n* `result_storage`: An optional block to use to persist the result of this task.\n  Defaults to the value set in the flow the task is called in.\n* `result_storage_key`: An optional key to store the result in storage at when persisted.\n  Defaults to a unique identifier.\n* `result_serializer`: An optional serializer to use to serialize the result of this\n  task for persistence. Defaults to the value set in the flow the task is\n  called in.\n* `timeout_seconds`: An optional number of seconds indicating a maximum runtime for\n  the task. If the task exceeds this runtime, it will be marked as failed.\n* `log_prints`: If set, `print` statements in the task will be redirected to the\n  Prefect logger for the task run. Defaults to `None`, which indicates\n  that the value from the flow should be used.\n* `refresh_cache`: If set, cached results for the cache key are not used.\n  Defaults to `None`, which indicates that a cached result from a previous\n  execution with matching cache key is used.\n* `on_failure`: An optional list of callables to run when the task enters a failed state.\n* `on_completion`: An optional list of callables to run when the task enters a completed state.\n* `on_commit`: An optional list of callables to run when the task's idempotency record is committed.\n* `on_rollback`: An optional list of callables to run when the task rolls back.\n* `retry_condition_fn`: An optional callable run when a task run returns a Failed state. Should\n  return `True` if the task should continue to its retry policy (e.g. `retries=3`), and `False` if the task\n  should end as failed. Defaults to `None`, indicating the task should always continue\n  to its retry policy.\n* `viz_return_value`: An optional value to return when the task dependency tree is visualized.\n* `asset_deps`: An optional list of upstream assets that this task depends on.\n\n**Methods:**\n\n#### `apply_async` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1620\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\napply_async(self, args: Optional[tuple[Any, ...]] = None, kwargs: Optional[dict[str, Any]] = None, wait_for: Optional[Iterable[PrefectFuture[R]]] = None, dependencies: Optional[dict[str, set[RunInput]]] = None) -> PrefectDistributedFuture[R]\n```\n\nCreate a pending task run for a task worker to execute.\n\n**Args:**\n\n* `args`: Arguments to run the task with\n* `kwargs`: Keyword arguments to run the task with\n\n**Returns:**\n\n* A PrefectDistributedFuture object representing the pending task run\n\nExamples:\n\nDefine a task\n\n```python  theme={null}\nfrom prefect import task\n@task\ndef my_task(name: str = \"world\"):\n    return f\"hello {name}\"\n```\n\nCreate a pending task run for the task\n\n```python  theme={null}\nfrom prefect import flow\n@flow\ndef my_flow():\n    my_task.apply_async((\"marvin\",))\n```\n\nWait for a task to finish\n\n```python  theme={null}\n@flow\ndef my_flow():\n    my_task.apply_async((\"marvin\",)).wait()\n```\n\n```python  theme={null}\n@flow\ndef my_flow():\n    print(my_task.apply_async((\"marvin\",)).result())\n\nmy_flow()\n# hello marvin\n```\n\nTODO: Enforce ordering between tasks that do not exchange data\n\n```python  theme={null}\n@task\ndef task_1():\n    pass\n\n@task\ndef task_2():\n    pass\n\n@flow\ndef my_flow():\n    x = task_1.apply_async()\n\n    # task 2 will wait for task_1 to complete\n    y = task_2.apply_async(wait_for=[x])\n```\n\n#### `create_local_run` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L955\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ncreate_local_run(self, client: Optional['PrefectClient'] = None, id: Optional[UUID] = None, parameters: Optional[dict[str, Any]] = None, flow_run_context: Optional[FlowRunContext] = None, parent_task_run_context: Optional[TaskRunContext] = None, wait_for: Optional[OneOrManyFutureOrResult[Any]] = None, extra_task_inputs: Optional[dict[str, set[RunInput]]] = None, deferred: bool = False) -> TaskRun\n```\n\n#### `create_run` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L852\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ncreate_run(self, client: Optional['PrefectClient'] = None, id: Optional[UUID] = None, parameters: Optional[dict[str, Any]] = None, flow_run_context: Optional[FlowRunContext] = None, parent_task_run_context: Optional[TaskRunContext] = None, wait_for: Optional[OneOrManyFutureOrResult[Any]] = None, extra_task_inputs: Optional[dict[str, set[RunInput]]] = None, deferred: bool = False) -> TaskRun\n```\n\n#### `delay` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1734\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ndelay(self, *args: P.args, **kwargs: P.kwargs) -> PrefectDistributedFuture[R]\n```\n\nAn alias for `apply_async` with simpler calling semantics.\n\nAvoids having to use explicit \"args\" and \"kwargs\" arguments. Arguments\nwill pass through as-is to the task.\n\nExamples:\n\nDefine a task\n\n```python  theme={null}\nfrom prefect import task\n@task\ndef my_task(name: str = \"world\"):\n    return f\"hello {name}\"\n```\n\nCreate a pending task run for the task\n\n```python  theme={null}\nfrom prefect import flow\n@flow\ndef my_flow():\n    my_task.delay(\"marvin\")\n```\n\nWait for a task to finish\n\n```python  theme={null}\n@flow\ndef my_flow():\n    my_task.delay(\"marvin\").wait()\n```\n\nUse the result from a task in a flow\n\n```python  theme={null}\n@flow\ndef my_flow():\n    print(my_task.delay(\"marvin\").result())\n\nmy_flow()\n# hello marvin\n```\n\n#### `isclassmethod` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L619\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nisclassmethod(self) -> bool\n```\n\n#### `ismethod` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L615\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nismethod(self) -> bool\n```\n\n#### `isstaticmethod` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L623\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nisstaticmethod(self) -> bool\n```\n\n#### `map` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1380\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nmap(self: 'Task[P, R]', *args: Any, **kwargs: Any) -> list[State[R]]\n```\n\n#### `map` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1390\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nmap(self: 'Task[P, R]', *args: Any, **kwargs: Any) -> PrefectFutureList[R]\n```\n\n#### `map` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1399\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nmap(self: 'Task[P, R]', *args: Any, **kwargs: Any) -> list[State[R]]\n```\n\n#### `map` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1409\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nmap(self: 'Task[P, R]', *args: Any, **kwargs: Any) -> PrefectFutureList[R]\n```\n\n#### `map` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1418\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nmap(self: 'Task[P, Coroutine[Any, Any, R]]', *args: Any, **kwargs: Any) -> list[State[R]]\n```\n\n#### `map` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1428\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nmap(self: 'Task[P, Coroutine[Any, Any, R]]', *args: Any, **kwargs: Any) -> PrefectFutureList[R]\n```\n\n#### `map` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1437\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nmap(self, *args: Any, **kwargs: Any) -> Union[list[State[R]], PrefectFutureList[R]]\n```\n\nSubmit a mapped run of the task to a worker.\n\nMust be called within a flow run context. Will return a list of futures\nthat should be waited on before exiting the flow context to ensure all\nmapped tasks have completed.\n\nMust be called with at least one iterable and all iterables must be\nthe same length. Any arguments that are not iterable will be treated as\na static value and each task run will receive the same value.\n\nWill create as many task runs as the length of the iterable(s) in the\nbacking API and submit the task runs to the flow's task runner. This\ncall blocks if given a future as input while the future is resolved. It\nalso blocks while the tasks are being submitted, once they are\nsubmitted, the flow function will continue executing.\n\nThis method is always synchronous, even if the underlying user function is asynchronous.\n\n**Args:**\n\n* `*args`: Iterable and static arguments to run the tasks with\n* `return_state`: Return a list of Prefect States that wrap the results\n  of each task run.\n* `wait_for`: Upstream task futures to wait for before starting the\n  task\n* `**kwargs`: Keyword iterable arguments to run the task with\n\n**Returns:**\n\n* A list of futures allowing asynchronous access to the state of the\n* tasks\n\nExamples:\n\nDefine a task\n\n```python  theme={null}\nfrom prefect import task\n@task\ndef my_task(x):\n    return x + 1\n```\n\nCreate mapped tasks\n\n```python  theme={null}\nfrom prefect import flow\n@flow\ndef my_flow():\n    return my_task.map([1, 2, 3])\n```\n\nWait for all mapped tasks to finish\n\n```python  theme={null}\n@flow\ndef my_flow():\n    futures = my_task.map([1, 2, 3])\n    futures.wait():\n    # Now all of the mapped tasks have finished\n    my_task(10)\n```\n\nUse the result from mapped tasks in a flow\n\n```python  theme={null}\n@flow\ndef my_flow():\n    futures = my_task.map([1, 2, 3])\n    for x in futures.result():\n        print(x)\nmy_flow()\n# 2\n# 3\n# 4\n```\n\nEnforce ordering between tasks that do not exchange data\n\n```python  theme={null}\n@task\ndef task_1(x):\n    pass\n\n@task\ndef task_2(y):\n    pass\n\n@flow\ndef my_flow():\n    x = task_1.submit()\n\n    # task 2 will wait for task_1 to complete\n    y = task_2.map([1, 2, 3], wait_for=[x])\n    return y\n```\n\nUse a non-iterable input as a constant across mapped tasks\n\n```python  theme={null}\n@task\ndef display(prefix, item):\n   print(prefix, item)\n\n@flow\ndef my_flow():\n    return display.map(\"Check it out: \", [1, 2, 3])\n\nmy_flow()\n# Check it out: 1\n# Check it out: 2\n# Check it out: 3\n```\n\nUse `unmapped` to treat an iterable argument as a constant\n\n```python  theme={null}\nfrom prefect import unmapped\n\n@task\ndef add_n_to_items(items, n):\n    return [item + n for item in items]\n\n@flow\ndef my_flow():\n    return add_n_to_items.map(unmapped([10, 20]), n=[1, 2, 3])\n\nmy_flow()\n# [[11, 21], [12, 22], [13, 23]]\n```\n\n#### `on_commit` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L840\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\non_commit(self, fn: Callable[['Transaction'], None]) -> Callable[['Transaction'], None]\n```\n\n#### `on_completion` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L828\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\non_completion(self, fn: StateHookCallable) -> StateHookCallable\n```\n\n#### `on_failure` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L832\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\non_failure(self, fn: StateHookCallable) -> StateHookCallable\n```\n\n#### `on_rollback` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L846\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\non_rollback(self, fn: Callable[['Transaction'], None]) -> Callable[['Transaction'], None]\n```\n\n#### `on_running` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L836\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\non_running(self, fn: StateHookCallable) -> StateHookCallable\n```\n\n#### `serve` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1783\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nserve(self) -> NoReturn\n```\n\nServe the task using the provided task runner. This method is used to\nestablish a websocket connection with the Prefect server and listen for\nsubmitted task runs to execute.\n\n**Args:**\n\n* `task_runner`: The task runner to use for serving the task. If not provided,\n  the default task runner will be used.\n\n**Examples:**\n\nServe a task using the default task runner\n\n```python  theme={null}\n@task\ndef my_task():\n    return 1\n\nmy_task.serve()\n```\n\n#### `submit` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1198\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsubmit(self: 'Task[P, R]', *args: P.args, **kwargs: P.kwargs) -> PrefectFuture[R]\n```\n\n#### `submit` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1205\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsubmit(self: 'Task[P, Coroutine[Any, Any, R]]', *args: P.args, **kwargs: P.kwargs) -> PrefectFuture[R]\n```\n\n#### `submit` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1214\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsubmit(self: 'Task[P, R]', *args: P.args, **kwargs: P.kwargs) -> PrefectFuture[R]\n```\n\n#### `submit` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1223\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsubmit(self: 'Task[P, Coroutine[Any, Any, R]]', *args: P.args, **kwargs: P.kwargs) -> State[R]\n```\n\n#### `submit` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1232\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsubmit(self: 'Task[P, R]', *args: P.args, **kwargs: P.kwargs) -> State[R]\n```\n\n#### `submit` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L1240\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsubmit(self: 'Union[Task[P, R], Task[P, Coroutine[Any, Any, R]]]', *args: Any, **kwargs: Any)\n```\n\nSubmit a run of the task to the engine.\n\nWill create a new task run in the backing API and submit the task to the flow's\ntask runner. This call only blocks execution while the task is being submitted,\nonce it is submitted, the flow function will continue executing.\n\nThis method is always synchronous, even if the underlying user function is asynchronous.\n\n**Args:**\n\n* `*args`: Arguments to run the task with\n* `return_state`: Return the result of the flow run wrapped in a\n  Prefect State.\n* `wait_for`: Upstream task futures to wait for before starting the task\n* `**kwargs`: Keyword arguments to run the task with\n\n**Returns:**\n\n* If `return_state` is False a future allowing asynchronous access to\n  the state of the task\n* If `return_state` is True a future wrapped in a Prefect State allowing asynchronous access to\n  the state of the task\n\nExamples:\n\nDefine a task\n\n```python  theme={null}\nfrom prefect import task\n@task\ndef my_task():\n    return \"hello\"\n```\n\nRun a task in a flow\n\n```python  theme={null}\nfrom prefect import flow\n@flow\ndef my_flow():\n    my_task.submit()\n```\n\nWait for a task to finish\n\n```python  theme={null}\n@flow\ndef my_flow():\n    my_task.submit().wait()\n```\n\nUse the result from a task in a flow\n\n```python  theme={null}\n@flow\ndef my_flow():\n    print(my_task.submit().result())\n\nmy_flow()\n# hello\n```\n\nRun an async task in an async flow\n\n```python  theme={null}\n@task\nasync def my_async_task():\n    pass\n\n@flow\nasync def my_flow():\n    my_async_task.submit()\n```\n\nRun a sync task in an async flow\n\n```python  theme={null}\n@flow\nasync def my_flow():\n    my_task.submit()\n```\n\nEnforce ordering between tasks that do not exchange data\n\n```python  theme={null}\n@task\ndef task_1():\n    pass\n\n@task\ndef task_2():\n    pass\n\n@flow\ndef my_flow():\n    x = task_1.submit()\n\n    # task 2 will wait for task_1 to complete\n    y = task_2.submit(wait_for=[x])\n```\n\n#### `with_options` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L647\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nwith_options(self) -> 'Task[P, R]'\n```\n\nCreate a new task from the current object, updating provided options.\n\n**Args:**\n\n* `name`: A new name for the task.\n* `description`: A new description for the task.\n* `tags`: A new set of tags for the task. If given, existing tags are ignored,\n  not merged.\n* `cache_key_fn`: A new cache key function for the task.\n* `cache_expiration`: A new cache expiration time for the task.\n* `task_run_name`: An optional name to distinguish runs of this task; this name can be provided\n  as a string template with the task's keyword arguments as variables,\n  or a function that returns a string.\n* `retries`: A new number of times to retry on task run failure.\n* `retry_delay_seconds`: Optionally configures how long to wait before retrying\n  the task after failure. This is only applicable if `retries` is nonzero.\n  This setting can either be a number of seconds, a list of retry delays,\n  or a callable that, given the total number of retries, generates a list\n  of retry delays. If a number of seconds, that delay will be applied to\n  all retries. If a list, each retry will wait for the corresponding delay\n  before retrying. When passing a callable or a list, the number of\n  configured retry delays cannot exceed 50.\n* `retry_jitter_factor`: An optional factor that defines the factor to which a\n  retry can be jittered in order to avoid a \"thundering herd\".\n* `persist_result`: A new option for enabling or disabling result persistence.\n* `result_storage`: A new storage type to use for results.\n* `result_serializer`: A new serializer to use for results.\n* `result_storage_key`: A new key for the persisted result to be stored at.\n* `timeout_seconds`: A new maximum time for the task to complete in seconds.\n* `log_prints`: A new option for enabling or disabling redirection of `print` statements.\n* `refresh_cache`: A new option for enabling or disabling cache refresh.\n* `on_completion`: A new list of callables to run when the task enters a completed state.\n* `on_failure`: A new list of callables to run when the task enters a failed state.\n* `retry_condition_fn`: An optional callable run when a task run returns a Failed state.\n  Should return `True` if the task should continue to its retry policy, and `False`\n  if the task should end as failed. Defaults to `None`, indicating the task should\n  always continue to its retry policy.\n* `viz_return_value`: An optional value to return when the task dependency tree is visualized.\n\n**Returns:**\n\n* A new `Task` instance.\n\nExamples:\n\nCreate a new task from an existing task and update the name:\n\n```python  theme={null}\n@task(name=\"My task\")\ndef my_task():\n    return 1\n\nnew_task = my_task.with_options(name=\"My new task\")\n```\n\nCreate a new task from an existing task and update the retry settings:\n\n```python  theme={null}\nfrom random import randint\n\n@task(retries=1, retry_delay_seconds=5)\ndef my_task():\n    x = randint(0, 5)\n    if x >= 3:  # Make a task that fails sometimes\n        raise ValueError(\"Retry me please!\")\n    return x\n\nnew_task = my_task.with_options(retries=5, retry_delay_seconds=2)\n```\n\nUse a task with updated options within a flow:\n\n```python  theme={null}\n@task(name=\"My task\")\ndef my_task():\n    return 1\n\n@flow\nmy_flow():\n    new_task = my_task.with_options(name=\"My new task\")\n    new_task()\n```\n\n### `MaterializingTask` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L2141\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nA task that materializes Assets.\n\n**Args:**\n\n* `assets`: List of Assets that this task materializes (can be str or Asset)\n* `materialized_by`: An optional tool that materialized the asset e.g. \"dbt\" or \"spark\"\n* `**task_kwargs`: All other Task arguments\n\n**Methods:**\n\n#### `with_options` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/tasks.py#L2166\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nwith_options(self, assets: Optional[Sequence[Union[str, Asset]]] = None, **task_kwargs: Unpack[TaskOptions]) -> 'MaterializingTask[P, R]'\n```",
  "content_length": 31959
}