{
  "title": "How to upgrade to Prefect 3.0",
  "source_url": "https://docs-3.prefect.io/v3/how-to-guides/migrate/upgrade-to-prefect-3",
  "content": "Learn how to upgrade from Prefect 2.x to Prefect 3.0.\n\nPrefect 3.0 introduces a number of enhancements to the OSS product: a new events & automations backend for event-driven workflows and observability, improved runtime performance, autonomous task execution and a streamlined caching layer based on transactional semantics.\n\nThe majority of these enhancements maintain compatibility with most Prefect 2.0 workflows, but there are a few caveats that you may need to adjust for.\n\nTo learn more about the enhanced performance and new features, see [What's new in Prefect 3.0](/v3/get-started/whats-new-prefect-3).\n\nFor the majority of users, upgrading to Prefect 3.0 will be a seamless process that requires few or no code changes.\nThis guide highlights key changes that you may need to consider when upgrading.\n\n<Info>\n  **Prefect 2.0** refers to the 2.x lineage of the open source prefect package, and **Prefect 3.0** refers exclusively to the 3.x lineage of the prefect package. Neither version is strictly tied to any aspect of Prefect's commercial product, [Prefect Cloud](/v3/how-to-guides/cloud/connect-to-cloud).\n</Info>\n\n## Quickstart\n\nTo upgrade to Prefect 3.0, run:\n\n```bash  theme={null}\npip install -U prefect\n```\n\nIf you self-host a Prefect server, run this command to update your database:\n\n```bash  theme={null}\nprefect server database upgrade\n```\n\nIf you use a Prefect integration or extra, remember to upgrade it as well. For example:\n\n```bash  theme={null}\npip install -U 'prefect[aws]'\n```\n\n## Upgrade notes\n\n### Pydantic V2\n\nPrefect 3.0 is built with Pydantic 2.0 for improved performance. All Prefect objects will automatically upgrade, but if you use custom Pydantic models for flow parameters or custom blocks, you'll need to ensure they are compatible with Pydantic 2.0. You can continue to use Pydantic 1.0 models in your own code if they do not interact directly with Prefect.\n\nRefer to [Pydantic's migration guide](https://docs.pydantic.dev/latest/migration/) for detailed information on necessary changes.\n\n<Warning>\n  We recommend pausing all deployment schedules prior to upgrading.\n  Because of differences in Pydantic datetime handling that affect the scheduler's idempotency logic, there is a small risk of the scheduler duplicating runs in its first loop.\n</Warning>\n\n### Module location and name changes\n\nSome less-commonly used modules have been renamed, reorganized, or removed for clarity. The old import paths will continue to be supported for 6 months, but emit deprecation warnings. You can look at the [deprecation code](https://github.com/PrefectHQ/prefect/blob/main/src/prefect/_internal/compatibility/migration.py) to see a full list of affected paths.\n\n### Async tasks in synchronous flows\n\n<info>\n  This change affects you if: you use advanced asynchronous behaviors in your flows.\n</info>\n\nIn Prefect 2.0, it was possible to call native `async` tasks from synchronous flows, a pattern that is not normally supported in Python. Prefect 3.0.0 removes this behavior to reduce complexity and potential issues and edge cases. If you relied on asynchronous tasks in synchronous flows, you must either make your flow asynchronous or use a task runner that supports asynchronous execution.\n\n### Flow final states\n\n<info>\n  This change affects you if: you want your flow to fail if any task in the flow fails, and you invoke your tasks in a way that doesn't automatically raise an error (including submitting them to a `TaskRunners`).\n</info>\n\nIn Prefect 2.0, the final state of a flow run was influenced by the states of its task runs; if any task run failed, the flow run was marked as failed.\n\nIn Prefect 3.0, the final state of a flow run is entirely determined by:\n\n1. The `return` value of the flow function (same as in Prefect 2.0):\n   * Literal values are considered successful.\n   * Any explicit `State` that is returned will be considered the final state of the flow run. If an iterable of `State` objects is returned, all must be `Completed` for the flow run to be considered `Completed`. If any are `Failed`, the flow run will be marked as `Failed`.\n\n2. Whether the flow function allows an exception to `raise`:\n   * Exceptions that are allowed to propagate will result in a `Failed` state.\n   * Exceptions suppressed with `raise_on_failure=False` will not affect the flow run state.\n\nThis change means that task failures within a flow do not automatically cause the flow run to fail unless they affect the flow's return value or raise an uncaught exception.\n\n<Warning>\n  When migrating from Prefect 2.0 to Prefect 3, be aware that flows may now complete successfully even if they contain failed tasks, unless you explicitly handle task failures.\n</Warning>\n\nTo ensure your flow fails when critical tasks fail, consider these approaches:\n\n1. Allow task exceptions to propagate by not using `raise_on_failure=False`.\n2. Use `return_state=True` and explicitly check task states to conditionally `raise` the underlying exception or return a failed state.\n3. Use try/except blocks to handle task failures and return appropriate states.\n\n#### Examples\n\n<CodeGroup>\n  ```python Allow Unhandled Exceptions theme={null}\n  from prefect import flow, task\n\n  @task\n  def failing_task():\n      raise ValueError(\"Task failed\")\n\n  @flow\n  def my_flow():\n      failing_task()  # Exception propagates, causing flow failure\n\n  try:\n      my_flow()\n  except ValueError as e:\n      print(f\"Flow failed: {e}\")  # Output: Flow failed: Task failed\n  ```\n\n  ```python Use return_state theme={null}\n  from prefect import flow, task\n  from prefect.states import Failed\n\n  @task\n  def failing_task():\n      raise ValueError(\"Task failed\")\n\n  @flow\n  def my_flow():\n      state = failing_task(return_state=True)\n      if state.is_failed():\n          raise ValueError(state.result())\n      return \"Flow completed successfully\"\n\n  try:\n      print(my_flow())\n  except ValueError as e:\n      print(f\"Flow failed: {e}\")  # Output: Flow failed: Task failed\n  ```\n\n  ```python Use try/except theme={null}\n  from prefect import flow, task\n  from prefect.states import Failed\n\n  @task\n  def failing_task():\n      raise ValueError(\"Task failed\")\n\n  @flow\n  def my_flow():\n      try:\n          failing_task()\n      except ValueError:\n          return Failed(message=\"Flow failed due to task failure\")\n      return \"Flow completed successfully\"\n\n  print(my_flow())  # Output: Failed(message='Flow failed due to task failure')\n  ```\n</CodeGroup>\n\nChoose the strategy that best fits your specific use case and error handling requirements.\n\n***\n\n### Futures interface\n\n<info>\n  This change affects you if: you directly interact with `PrefectFuture` objects.\n</info>\n\nPrefectFutures now have a standard synchronous interface, with an asynchronous one [planned soon](https://github.com/PrefectHQ/prefect/issues/15008).\n\n### Automatic task caching\n\n<info>\n  This change affects you if: you rely on side effects in your tasks\n</info>\n\nPrefect 3.0 introduces a powerful idempotency engine. By default, tasks in a flow run are automatically cached if they are called more than once with the same inputs. If you rely on tasks with side effects, this may result in surprising behavior. To disable caching, pass `cache_policy=None` to your task.\n\n### Unmapped mutable objects in mapped tasks\n\n<info>\n  This change affects you if: you use `unmapped()` to pass mutable objects (like lists or dicts) to mapped tasks.\n</info>\n\nIn Prefect 2.0, when passing a mutable object (such as a list or dict) using `unmapped()` to a mapped task, each task instance appeared to receive an independent copy of the object. In Prefect 3.0, the unmapped object is shared by reference across all mapped task runs. If any task mutates the object, all other concurrently running tasks will see those mutations, potentially causing race conditions and unexpected behavior.\n\n<Warning>\n  When migrating from Prefect 2.0 to Prefect 3, be aware that mutable objects passed via `unmapped()` are now shared across all mapped tasks. Mutating these objects can lead to race conditions.\n</Warning>\n\nTo avoid this issue, create a copy of the mutable object within each task before modifying it:\n\n<CodeGroup>\n  ```python Problematic (Prefect 3.0) theme={null}\n  from prefect import flow, task, unmapped\n\n  @task\n  def process_item(item: str, shared_state: dict):\n      # This mutation affects ALL tasks!\n      shared_state[\"current_item\"] = item\n      # Race condition: another task may overwrite this before we read it\n      print(f\"Processing {shared_state['current_item']}\")\n\n  @flow\n  def my_flow():\n      shared_state = {\"current_item\": None}\n\n      # All tasks share the same dict reference\n      process_item.map(\n          item=[\"A\", \"B\", \"C\"],\n          shared_state=unmapped(shared_state)\n      )\n  ```\n\n  ```python Recommended (Prefect 3.0) theme={null}\n  from prefect import flow, task, unmapped\n  from copy import deepcopy\n\n  @task\n  def process_item(item: str, shared_state: dict):\n      # Create a copy for this task\n      local_state = deepcopy(shared_state)\n      local_state[\"current_item\"] = item\n      print(f\"Processing {local_state['current_item']}\")\n\n  @flow\n  def my_flow():\n      shared_state = {\"current_item\": None}\n\n      process_item.map(\n          item=[\"A\", \"B\", \"C\"],\n          shared_state=unmapped(shared_state)\n      )\n  ```\n\n  ```python Alternative: Pass immutable values theme={null}\n  from prefect import flow, task, unmapped\n\n  @task\n  def process_item(item: str, config_value: str):\n      # Immutable strings are safe to share\n      print(f\"Processing {item} with config: {config_value}\")\n\n  @flow\n  def my_flow():\n      config = \"production\"\n\n      process_item.map(\n          item=[\"A\", \"B\", \"C\"],\n          config_value=unmapped(config)\n      )\n  ```\n</CodeGroup>\n\nIf you need to share read-only configuration or settings across tasks, consider using immutable types (strings, tuples, frozen dataclasses) instead of mutable objects.\n\n### Workers\n\n<info>\n  This change affects you if: you're using agents from an early version of Prefect 2.0.\n</info>\n\nIn Prefect 2.0, agents were deprecated in favor of next-generation workers. Workers are now standard in Prefect 3. For detailed information on upgrading from agents to workers, please refer to our [upgrade guide](https://docs-3.prefect.io/v3/resources/upgrade-agents-to-workers).\n\n### Resolving common gotchas\n\n#### `AttributeError: 'coroutine' object has no attribute <some attribute>`\n\nWhen within an asynchronous task or flow context, if you do **not** `await` an asynchronous function or method, this error will be raised when you try to use the object.\n\nTo fix it, `await` the asynchronous function or method or use `_sync=True`.\n\nFor example, `Block`'s `load` method is asynchronous in an async context:\n\n<CodeGroup>\n  ```python Incorrect theme={null}\n  from prefect.blocks.system import Secret\n\n  async def my_async_function():\n      my_secret = Secret.load(\"my-secret\")\n      print(my_secret.get()) # AttributeError: 'coroutine' object has no attribute 'get'\n  ```\n\n  ```python Correct theme={null}\n  from prefect.blocks.system import Secret\n\n  async def my_async_function():\n      my_secret = await Secret.load(\"my-secret\")\n      print(my_secret.get()) # This will work\n  ```\n\n  ```python Also Correct theme={null}\n  from prefect.blocks.system import Secret\n\n  async def my_async_function():\n      my_secret = Secret.load(\"my-secret\", _sync=True)\n      print(my_secret.get()) # This will work\n  ```\n</CodeGroup>\n\nSimilarly, if you never use an un-awaited coroutine, you may see a warning like this:\n\n```python  theme={null}\nRuntimeWarning: coroutine 'some_async_callable' was never awaited\n...\nRuntimeWarning: Enable tracemalloc to get the object allocation traceback\n```\n\nThis is the same problem as above, and you may `await` the coroutine to fix it or use `_sync=True`.\n\n#### `TypeError: object <some Type> can't be used in 'await' expression`\n\nThis error occurs when using the `await` keyword before an object that is not a coroutine.\n\nTo fix it, remove the `await`.\n\nFor example, `my_task.submit(...)` is *always* synchronous in Prefect 3.x:\n\n<CodeGroup>\n  ```python Incorrect theme={null}\n  from prefect import flow, task\n\n  @task\n  async def my_task():\n      pass\n\n  @flow\n  async def my_flow():\n      future = await my_task.submit() # TypeError: object PrefectConcurrentFuture can't be used in 'await' expression\n  ```\n\n  ```python Correct theme={null}\n  from prefect import flow, task\n\n  @task\n  async def my_task():\n      pass\n\n  @flow\n  async def my_flow():\n      future = my_task.submit() # This will work\n  ```\n</CodeGroup>\n\nSee the [Futures interface section](#futures-interface) for more information on this particular gotcha.\n\n#### `TypeError: Flow.deploy() got an unexpected keyword argument 'schedule'`\n\nIn Prefect 3.0, the `schedule` argument has been removed in favor of the `schedules` argument.\n\nThis applies to both the `Flow.serve` and `Flow.deploy` methods.\n\n<CodeGroup>\n  ```python Prefect 2.0 {11} theme={null}\n  from datetime import timedelta\n  from prefect import flow\n  from prefect.client.schemas.schedules import IntervalSchedule\n\n  @flow\n  def my_flow():\n      pass\n\n  my_flow.serve(\n      name=\"my-flow\",\n      schedule=IntervalSchedule(interval=timedelta(minutes=1))\n  )\n  ```\n\n  ```python Prefect 3.0 {11} theme={null}\n  from datetime import timedelta\n  from prefect import flow\n  from prefect.schedules import Interval\n\n  @flow\n  def my_flow():\n      pass\n\n  my_flow.serve(\n      name=\"my-flow\",\n      schedules=[Interval(timedelta(minutes=1))]\n  )\n  ```\n</CodeGroup>",
  "content_length": 13573
}