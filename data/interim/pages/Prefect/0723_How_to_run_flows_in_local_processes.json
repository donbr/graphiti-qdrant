{
  "title": "How to run flows in local processes",
  "source_url": "https://docs-3.prefect.io/v3/how-to-guides/deployment_infra/run-flows-in-local-processes",
  "content": "Create a deployment for a flow by calling the `serve` method.\n\nThe simplest way to create a [deployment](/v3/deploy) for your flow is by calling its `serve` method.\n\n## Serve a flow\n\nThe serve method creates a deployment for the flow and starts a long-running process\nthat monitors for work from the Prefect server.\nWhen work is found, it is executed within its own isolated subprocess.\n\n```python hello_world.py theme={null}\nfrom prefect import flow\n\n\n@flow(log_prints=True)\ndef hello_world(name: str = \"world\", goodbye: bool = False):\n    print(f\"Hello {name} from Prefect! ðŸ¤—\")\n\n    if goodbye:\n        print(f\"Goodbye {name}!\")\n\n\nif __name__ == \"__main__\":\n    # creates a deployment and starts a long-running\n    # process that listens for scheduled work\n    hello_world.serve(name=\"my-first-deployment\",\n        tags=[\"onboarding\"],\n        parameters={\"goodbye\": True},\n        interval=60\n    )\n```\n\nThis interface provides the configuration for a deployment (with no\nstrong infrastructure requirements), such as:\n\n* schedules\n* event triggers\n* metadata such as tags and description\n* default parameter values\n\n<Tip>\n  **Schedules are auto-paused on shutdown**\n\n  By default, stopping the process running `flow.serve` will pause the schedule\n  for the deployment (if it has one).\n\n  When running this in environments where restarts are expected use the\n\n  `pause_on_shutdown=False` flag to prevent this behavior:\n\n  ```python  theme={null}\n  if __name__ == \"__main__\":\n      hello_world.serve(\n          name=\"my-first-deployment\",\n          tags=[\"onboarding\"],\n          parameters={\"goodbye\": True},\n          pause_on_shutdown=False,\n          interval=60\n      )\n  ```\n</Tip>\n\n## Additional serve options\n\nThe `serve` method on flows exposes many options for the deployment.\nHere's how to use some of those options:\n\n* `cron`: a keyword that allows you to set a cron string schedule for the deployment; see\n  [schedules](/v3/automate/add-schedules/) for more advanced scheduling options\n* `tags`: a keyword that allows you to tag this deployment and its runs for bookkeeping and filtering purposes\n* `description`: a keyword that allows you to document what this deployment does; by default the\n  description is set from the docstring of the flow function (if documented)\n* `version`: a keyword that allows you to track changes to your deployment; uses a hash of the\n  file containing the flow by default; popular options include semver tags or git commit hashes\n* `triggers`: a keyword that allows you to define a set of conditions for when the deployment should run; see\n  [triggers](/v3/concepts/event-triggers/) for more on Prefect Events concepts\n\nNext, add these options to your deployment:\n\n```python  theme={null}\nif __name__ == \"__main__\":\n    get_repo_info.serve(\n        name=\"my-first-deployment\",\n        cron=\"* * * * *\",\n        tags=[\"testing\", \"tutorial\"],\n        description=\"Given a GitHub repository, logs repository statistics for that repo.\",\n        version=\"tutorial/deployments\",\n    )\n```\n\n<Tip>\n  **Triggers with `.serve`**\n\n  See this [example](/v3/how-to-guides/automations/chaining-deployments-with-events) that triggers downstream work on upstream events.\n</Tip>\n\n<Note>\n  **`serve()` is a long-running process**\n\n  To execute remotely triggered or scheduled runs, your script with `flow.serve` must be actively running.\n  Stop the script with `CTRL+C` and your schedule will automatically pause.\n</Note>\n\n## Serve multiple flows at once\n\nServe multiple flows with the same process using the `serve` utility along with the `to_deployment` method of flows:\n\n```python serve_two_flows.py theme={null}\nimport time\nfrom prefect import flow, serve\n\n\n@flow\ndef slow_flow(sleep: int = 60):\n    \"Sleepy flow - sleeps the provided amount of time (in seconds).\"\n    time.sleep(sleep)\n\n\n@flow\ndef fast_flow():\n    \"Fastest flow this side of the Mississippi.\"\n    return\n\n\nif __name__ == \"__main__\":\n    slow_deploy = slow_flow.to_deployment(name=\"sleeper\", interval=45)\n    fast_deploy = fast_flow.to_deployment(name=\"fast\")\n    serve(slow_deploy, fast_deploy)\n```\n\nThe behavior and interfaces are identical to the single flow case.\nA few things to note:\n\n* the `flow.to_deployment` interface exposes the *exact same* options as `flow.serve`; this method\n  produces a deployment object\n* the deployments are only registered with the API once `serve(...)` is called\n* when serving multiple deployments, the only requirement is that they share a Python environment;\n  they can be executed and scheduled independently of each other\n\nA few optional steps for exploration include:\n\n* pause and unpause the schedule for the `\"sleeper\"` deployment\n* use the UI to submit ad-hoc runs for the `\"sleeper\"` deployment with different values for `sleep`\n* cancel an active run for the `\"sleeper\"` deployment from the UI\n\n<Tip>\n  **Hybrid execution option**\n\n  Prefect's deployment interface allows you to choose a hybrid execution model.\n  Whether you use Prefect Cloud or self-host Prefect server, you can run workflows in the\n  environments best suited to their execution.\n  This model enables efficient use of your infrastructure resources while maintaining the privacy\n  of your code and data.\n  There is no ingress required.\n  Read more about our [hybrid model](https://www.prefect.io/security/overview/#hybrid-model).\n</Tip>\n\n## Serve instance methods\n\nYou can serve flow methods that are part of a class instance. This is useful when you want to configure a flow once at initialization time and reuse that configuration across all runs.\n\n```python data_processor.py theme={null}\nfrom prefect import flow\n\n\nclass DataProcessor:\n    \"\"\"Processor configured at initialization time.\"\"\"\n\n    def __init__(self, environment: str):\n        # Configuration is set once when the instance is created\n        if environment == \"prod\":\n            self.api_url = \"https://api.example.com\"\n            self.batch_size = 1000\n        else:\n            self.api_url = \"https://staging.example.com\"\n            self.batch_size = 100\n\n    @flow(log_prints=True)\n    def process_batch(self, batch_id: str):\n        \"\"\"Process a batch using the configured settings.\"\"\"\n        print(f\"Processing batch {batch_id}\")\n        print(f\"API URL: {self.api_url}\")\n        print(f\"Batch size: {self.batch_size}\")\n        # processing logic here using self.api_url and self.batch_size\n\n\nif __name__ == \"__main__\":\n    # Create processor configured for staging environment\n    processor = DataProcessor(environment=\"staging\")\n    # All flow runs will use the staging configuration\n    processor.process_batch.serve(name=\"batch-processor\")\n```\n\nThe instance configuration (set during `__init__`) is available to all flow runs. This is useful for environment-specific settings, connection parameters, or any configuration that should be consistent across all runs of the deployment.\n\n## Retrieve a flow from remote storage\n\nJust like the `.deploy` method, the `flow.from_source` method is used to define how to retrieve the flow that you want to serve.\n\n### `from_source`\n\nThe `flow.from_source` method on `Flow` objects requires a `source` and an `entrypoint`.\n\n#### `source`\n\nThe `source` of your deployment can be:\n\n* a path to a local directory such as `path/to/a/local/directory`\n* a repository URL such as `https://github.com/org/repo.git`\n* a `GitRepository` object that accepts\n  * a repository URL\n  * a reference to a branch, tag, or commit hash\n  * `GitCredentials` for private repositories\n\n#### `entrypoint`\n\nA flow `entrypoint` is the path to the file where the flow is located within that `source`, in the form\n\n```python  theme={null}\n{path}:{flow_name}\n```\n\nFor example, the following code will load the `hello` flow from the `flows/hello_world.py` file in the `PrefectHQ/examples` repository:\n\n```python load_from_url.py theme={null}\nfrom prefect import flow\n\n\nmy_flow = flow.from_source(\n    source=\"https://github.com/PrefectHQ/examples.git\",\n    entrypoint=\"flows/hello_world.py:hello\"\n)\n\n\nif __name__ == \"__main__\":\n    my_flow()\n```\n\n```bash  theme={null}\n16:40:33.818 | INFO    | prefect.engine - Created flow run 'muscular-perch' for flow 'hello'\n16:40:34.048 | INFO    | Flow run 'muscular-perch' - Hello world!\n16:40:34.706 | INFO    | Flow run 'muscular-perch' - Finished in state Completed()\n```\n\nFor more ways to store and access flow code, see the [Retrieve code from storage page](/v3/deploy/infrastructure-concepts/store-flow-code).\n\n<Tip>\n  **You can serve loaded flows**\n\n  You can serve a flow loaded from remote storage with the same [`serve`](#serve-a-flow) method as a local flow:\n\n  ```python serve_loaded_flow.py theme={null}\n  from prefect import flow\n\n\n  if __name__ == \"__main__\":\n      flow.from_source(\n          source=\"https://github.com/org/repo.git\",\n          entrypoint=\"flows.py:my_flow\"\n      ).serve(name=\"my-deployment\")\n  ```\n</Tip>\n\n### Remote storage polling\n\nWhen you serve a flow loaded from remote storage, the serving process periodically polls your remote storage for updates to the flow's code.\nThis pattern allows you to update your flow code without restarting the serving process.\nNote that if you change metadata associated with your flow's deployment such as parameters, you *will* need to restart the serve process.\n\n## Further reading\n\n* [Serve flows in a long-lived Docker container](/v3/deploy/static-infrastructure-examples/docker)\n* [Work pools and deployments with dynamic infrastructure](/v3/deploy/infrastructure-concepts/work-pools)",
  "content_length": 9509
}