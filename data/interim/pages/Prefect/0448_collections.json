{
  "title": "collections",
  "source_url": "https://docs-3.prefect.io/v3/api-ref/python/prefect-utilities-collections",
  "content": "# `prefect.utilities.collections`\n\nUtilities for extensions of and operations on Python collections.\n\n## Functions\n\n### `dict_to_flatdict` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L88\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ndict_to_flatdict(dct: NestedDict[KT, VT]) -> dict[tuple[KT, ...], VT]\n```\n\nConverts a (nested) dictionary to a flattened representation.\n\nEach key of the flat dict will be a CompoundKey tuple containing the \"chain of keys\"\nfor the corresponding value.\n\n**Args:**\n\n* `dct`: The dictionary to flatten\n\n**Returns:**\n\n* A flattened dict of the same type as dct\n\n### `flatdict_to_dict` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L117\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nflatdict_to_dict(dct: dict[tuple[KT, ...], VT]) -> NestedDict[KT, VT]\n```\n\nConverts a flattened dictionary back to a nested dictionary.\n\n**Args:**\n\n* `dct`: The dictionary to be nested. Each key should be a tuple of keys\n  as generated by `dict_to_flatdict`\n\nReturns\nA nested dict of the same type as dct\n\n### `isiterable` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L154\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nisiterable(obj: Any) -> bool\n```\n\nReturn a boolean indicating if an object is iterable.\n\nExcludes types that are iterable but typically used as singletons:\n\n* str\n* bytes\n* IO objects\n\n### `ensure_iterable` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L171\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nensure_iterable(obj: Union[T, Iterable[T]]) -> Collection[T]\n```\n\n### `listrepr` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L178\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nlistrepr(objs: Iterable[Any], sep: str = ' ') -> str\n```\n\n### `extract_instances` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L182\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nextract_instances(objects: Iterable[Any], types: Union[type[T], tuple[type[T], ...]] = object) -> Union[list[T], dict[type[T], list[T]]]\n```\n\nExtract objects from a file and returns a dict of type -> instances\n\n**Args:**\n\n* `objects`: An iterable of objects\n* `types`: A type or tuple of types to extract, defaults to all objects\n\n**Returns:**\n\n* If a single type is given: a list of instances of that type\n* If a tuple of types is given: a mapping of type to a list of instances\n\n### `batched_iterable` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L215\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nbatched_iterable(iterable: Iterable[T], size: int) -> Generator[tuple[T, ...], None, None]\n```\n\nYield batches of a certain size from an iterable\n\n**Args:**\n\n* `iterable`: An iterable\n* `size`: The batch size to return\n\n### `visit_collection` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L310\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nvisit_collection(expr: Any, visit_fn: Union[Callable[[Any, dict[str, VT]], Any], Callable[[Any], Any]]) -> Optional[Any]\n```\n\nVisits and potentially transforms every element of an arbitrary Python collection.\n\nIf an element is a Python collection, it will be visited recursively. If an element\nis not a collection, `visit_fn` will be called with the element. The return value of\n`visit_fn` can be used to alter the element if `return_data` is set to `True`.\n\nNote:\n\n* When `return_data` is `True`, a copy of each collection is created only if\n  `visit_fn` modifies an element within that collection. This approach minimizes\n  performance penalties by avoiding unnecessary copying.\n* When `return_data` is `False`, no copies are created, and only side effects from\n  `visit_fn` are applied. This mode is faster and should be used when no transformation\n  of the collection is required, because it never has to copy any data.\n\nSupported types:\n\n* List (including iterators)\n* Tuple\n* Set\n* Dict (note: keys are also visited recursively)\n* Dataclass\n* Pydantic model\n* Prefect annotations\n\nNote that visit\\_collection will not consume generators or async generators, as it would prevent\nthe caller from iterating over them.\n\n**Args:**\n\n* `expr`: A Python object or expression.\n* `visit_fn`: A function\n  that will be applied to every non-collection element of `expr`. The function can\n  accept one or two arguments. If two arguments are accepted, the second argument\n  will be the context dictionary.\n* `return_data`: If `True`, a copy of `expr` containing data modified by `visit_fn`\n  will be returned. This is slower than `return_data=False` (the default).\n* `max_depth`: Controls the depth of recursive visitation. If set to zero, no\n  recursion will occur. If set to a positive integer `N`, visitation will only\n  descend to `N` layers deep. If set to any negative integer, no limit will be\n  enforced and recursion will continue until terminal items are reached. By\n  default, recursion is unlimited.\n* `context`: An optional dictionary. If passed, the context will be sent\n  to each call to the `visit_fn`. The context can be mutated by each visitor and\n  will be available for later visits to expressions at the given depth. Values\n  will not be available \"up\" a level from a given expression.\n  The context will be automatically populated with an 'annotation' key when\n  visiting collections within a `BaseAnnotation` type. This requires the caller to\n  pass `context={}` and will not be activated by default.\n* `remove_annotations`: If set, annotations will be replaced by their contents. By\n  default, annotations are preserved but their contents are visited.\n* `_seen`: A set of object ids that have already been visited. This\n  prevents infinite recursion when visiting recursive data structures.\n\n**Returns:**\n\n* The modified collection if `return_data` is `True`, otherwise `None`.\n\n### `remove_nested_keys` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L554\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nremove_nested_keys(keys_to_remove: list[HashableT], obj: Union[NestedDict[HashableT, VT], Any]) -> Union[NestedDict[HashableT, VT], Any]\n```\n\nRecurses a dictionary returns a copy without all keys that match an entry in\n`key_to_remove`. Return `obj` unchanged if not a dictionary.\n\n**Args:**\n\n* `keys_to_remove`: A list of keys to remove from obj obj: The object to remove keys\n  from.\n\n**Returns:**\n\n* `obj` without keys matching an entry in `keys_to_remove` if `obj` is a\n  dictionary. `obj` if `obj` is not a dictionary.\n\n### `distinct` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L588\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ndistinct(iterable: Iterable[Union[T, HashableT]], key: Optional[Callable[[T], Hashable]] = None) -> Iterator[Union[T, HashableT]]\n```\n\n### `get_from_dict` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L618\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nget_from_dict(dct: NestedDict[str, VT], keys: Union[str, list[str]], default: Optional[R] = None) -> Union[VT, R, None]\n```\n\nFetch a value from a nested dictionary or list using a sequence of keys.\n\nThis function allows to fetch a value from a deeply nested structure\nof dictionaries and lists using either a dot-separated string or a list\nof keys. If a requested key does not exist, the function returns the\nprovided default value.\n\n**Args:**\n\n* `dct`: The nested dictionary or list from which to fetch the value.\n* `keys`: The sequence of keys to use for access. Can be a\n  dot-separated string or a list of keys. List indices can be included\n  in the sequence as either integer keys or as string indices in square\n  brackets.\n* `default`: The default value to return if the requested key path does not\n  exist. Defaults to None.\n\n**Returns:**\n\n* The fetched value if the key exists, or the default value if it does not.\n\nExamples:\n\n```python  theme={null}\nget_from_dict({'a': {'b': {'c': [1, 2, 3, 4]}}}, 'a.b.c[1]') # 2\nget_from_dict({'a': {'b': [0, {'c': [1, 2]}]}}, ['a', 'b', 1, 'c', 1]) # 2\nget_from_dict({'a': {'b': [0, {'c': [1, 2]}]}}, 'a.b.1.c.2', 'default') # 'default'\n```\n\n### `set_in_dict` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L667\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nset_in_dict(dct: NestedDict[str, VT], keys: Union[str, list[str]], value: VT) -> None\n```\n\nSets a value in a nested dictionary using a sequence of keys.\n\nThis function allows to set a value in a deeply nested structure\nof dictionaries and lists using either a dot-separated string or a list\nof keys. If a requested key does not exist, the function will create it as\na new dictionary.\n\n**Args:**\n\n* `dct`: The dictionary to set the value in.\n* `keys`: The sequence of keys to use for access. Can be a\n  dot-separated string or a list of keys.\n* `value`: The value to set in the dictionary.\n\n**Returns:**\n\n* The modified dictionary with the value set at the specified key path.\n\n**Raises:**\n\n* `KeyError`: If the key path exists and is not a dictionary.\n\n### `deep_merge` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L701\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ndeep_merge(dct: NestedDict[str, VT1], merge: NestedDict[str, VT2]) -> NestedDict[str, Union[VT1, VT2]]\n```\n\nRecursively merges `merge` into `dct`.\n\n**Args:**\n\n* `dct`: The dictionary to merge into.\n* `merge`: The dictionary to merge from.\n\n**Returns:**\n\n* A new dictionary with the merged contents.\n\n### `deep_merge_dicts` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L728\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ndeep_merge_dicts(*dicts: NestedDict[str, Any]) -> NestedDict[str, Any]\n```\n\nRecursively merges multiple dictionaries.\n\n**Args:**\n\n* `dicts`: The dictionaries to merge.\n\n**Returns:**\n\n* A new dictionary with the merged contents.\n\n## Classes\n\n### `AutoEnum` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L44\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nAn enum class that automatically generates value from variable names.\n\nThis guards against common errors where variable names are updated but values are\nnot.\n\nIn addition, because AutoEnums inherit from `str`, they are automatically\nJSON-serializable.\n\nSee [https://docs.python.org/3/library/enum.html#using-automatic-values](https://docs.python.org/3/library/enum.html#using-automatic-values)\n\n**Methods:**\n\n#### `auto` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L69\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nauto() -> str\n```\n\nExposes `enum.auto()` to avoid requiring a second import to use `AutoEnum`\n\n### `StopVisiting` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L236\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nA special exception used to stop recursive visits in `visit_collection`.\n\nWhen raised, the expression is returned without modification and recursive visits\nin that path will end.",
  "content_length": 12411
}