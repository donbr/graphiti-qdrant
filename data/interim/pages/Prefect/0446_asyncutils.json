{
  "title": "asyncutils",
  "source_url": "https://docs-3.prefect.io/v3/api-ref/python/prefect-utilities-asyncutils",
  "content": "# `prefect.utilities.asyncutils`\n\nUtilities for interoperability with async functions and workers from various contexts.\n\n## Functions\n\n### `get_thread_limiter` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L69\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nget_thread_limiter() -> anyio.CapacityLimiter\n```\n\n### `is_async_fn` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L78\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nis_async_fn(func: _SyncOrAsyncCallable[P, R]) -> TypeGuard[Callable[P, Coroutine[Any, Any, Any]]]\n```\n\nReturns `True` if a function returns a coroutine.\n\nSee [https://github.com/microsoft/pyright/issues/2142](https://github.com/microsoft/pyright/issues/2142) for an example use\n\n### `is_async_gen_fn` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L90\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nis_async_gen_fn(func: Callable[P, Any]) -> TypeGuard[Callable[P, AsyncGenerator[Any, Any]]]\n```\n\nReturns `True` if a function is an async generator.\n\n### `create_task` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L100\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ncreate_task(coroutine: Coroutine[Any, Any, R]) -> asyncio.Task[R]\n```\n\nReplacement for asyncio.create\\_task that will ensure that tasks aren't\ngarbage collected before they complete. Allows for \"fire and forget\"\nbehavior in which tasks can be created and the application can move on.\nTasks can also be awaited normally.\n\nSee [https://docs.python.org/3/library/asyncio-task.html#asyncio.create\\_task](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task)\nfor details (and essentially this implementation)\n\n### `run_coro_as_sync` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L144\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nrun_coro_as_sync(coroutine: Coroutine[Any, Any, R]) -> Optional[R]\n```\n\nRuns a coroutine from a synchronous context, as if it were a synchronous\nfunction.\n\nThe coroutine is scheduled to run in the \"run sync\" event loop, which is\nrunning in its own thread and is started the first time it is needed. This\nallows us to share objects like async httpx clients among all coroutines\nrunning in the loop.\n\nIf run\\_sync is called from within the run\\_sync loop, it will run the\ncoroutine in a new thread, because otherwise a deadlock would occur. Note\nthat this behavior should not appear anywhere in the Prefect codebase or in\nuser code.\n\n**Args:**\n\n* `coroutine`: The coroutine to be run as a synchronous function.\n* `force_new_thread`: If True, the coroutine will always be run in a new thread.\n  Defaults to False.\n* `wait_for_result`: If True, the function will wait for the coroutine to complete\n  and return the result. If False, the function will submit the coroutine to the \"run sync\"\n  event loop and return immediately, where it will eventually be run. Defaults to True.\n\n**Returns:**\n\n* The result of the coroutine if wait\\_for\\_result is True, otherwise None.\n\n### `run_sync_in_worker_thread` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L215\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nrun_sync_in_worker_thread(__fn: Callable[P, R], *args: P.args, **kwargs: P.kwargs) -> R\n```\n\nRuns a sync function in a new worker thread so that the main thread's event loop\nis not blocked.\n\nUnlike the anyio function, this defaults to a cancellable thread and does not allow\npassing arguments to the anyio function so users can pass kwargs to their function.\n\nNote that cancellation of threads will not result in interrupted computation, the\nthread may continue running â€” the outcome will just be ignored.\n\n### `call_with_mark` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L241\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ncall_with_mark(call: Callable[..., R]) -> R\n```\n\n### `run_async_from_worker_thread` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L246\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nrun_async_from_worker_thread(__fn: Callable[P, Awaitable[R]], *args: P.args, **kwargs: P.kwargs) -> R\n```\n\nRuns an async function in the main thread's event loop, blocking the worker\nthread until completion\n\n### `run_async_in_new_loop` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L257\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nrun_async_in_new_loop(__fn: Callable[P, Awaitable[R]], *args: P.args, **kwargs: P.kwargs) -> R\n```\n\n### `mark_as_worker_thread` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L263\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nmark_as_worker_thread() -> None\n```\n\n### `in_async_worker_thread` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L267\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nin_async_worker_thread() -> bool\n```\n\n### `in_async_main_thread` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L271\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nin_async_main_thread() -> bool\n```\n\n### `sync_compatible` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L281\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsync_compatible(async_fn: Callable[P, Coroutine[Any, Any, R]]) -> Callable[P, Union[R, Coroutine[Any, Any, R]]]\n```\n\nConverts an async function into a dual async and sync function.\n\nWhen the returned function is called, we will attempt to determine the best way\nto enter the async function.\n\n* If in a thread with a running event loop, we will return the coroutine for the\n  caller to await. This is normal async behavior.\n* If in a blocking worker thread with access to an event loop in another thread, we\n  will submit the async method to the event loop.\n* If we cannot find an event loop, we will create a new one and run the async method\n  then tear down the loop.\n\nNote: Type checkers will infer functions decorated with `@sync_compatible` are synchronous. If\nyou want to use the decorated function in an async context, you will need to ignore the types\nand \"cast\" the return type to a coroutine. For example:\n\n```\npython result: Coroutine = sync_compatible(my_async_function)(arg1, arg2) # type: ignore\n```\n\n### `asyncnullcontext` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L377\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nasyncnullcontext(value: Optional[R] = None, *args: Any, **kwargs: Any) -> AsyncGenerator[Any, Optional[R]]\n```\n\n### `sync` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L383\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsync(__async_fn: Callable[P, Awaitable[T]], *args: P.args, **kwargs: P.kwargs) -> T\n```\n\nCall an async function from a synchronous context. Block until completion.\n\nIf in an asynchronous context, we will run the code in a separate loop instead of\nfailing but a warning will be displayed since this is not recommended.\n\n### `add_event_loop_shutdown_callback` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L407\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nadd_event_loop_shutdown_callback(coroutine_fn: Callable[[], Awaitable[Any]]) -> None\n```\n\nAdds a callback to the given callable on event loop closure. The callable must be\na coroutine function. It will be awaited when the current event loop is shutting\ndown.\n\nRequires use of `asyncio.run()` which waits for async generator shutdown by\ndefault or explicit call of `asyncio.shutdown_asyncgens()`. If the application\nis entered with `asyncio.run_until_complete()` and the user calls\n`asyncio.close()` without the generator shutdown call, this will not trigger\ncallbacks.\n\nasyncio does not provided *any* other way to clean up a resource when the event\nloop is about to close.\n\n### `create_gather_task_group` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L525\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ncreate_gather_task_group() -> GatherTaskGroup\n```\n\nCreate a new task group that gathers results\n\n### `gather` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L533\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ngather(*calls: Callable[[], Coroutine[Any, Any, T]]) -> list[T]\n```\n\nRun calls concurrently and gather their results.\n\nUnlike `asyncio.gather` this expects to receive *callables* not *coroutines*.\nThis matches `anyio` semantics.\n\n## Classes\n\n### `GatherIncomplete` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L456\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nUsed to indicate retrieving gather results before completion\n\n### `GatherTaskGroup` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L460\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nA task group that gathers results.\n\nAnyIO does not include `gather` support. This class extends the `TaskGroup`\ninterface to allow simple gathering.\n\nSee [https://github.com/agronholm/anyio/issues/100](https://github.com/agronholm/anyio/issues/100)\n\nThis class should be instantiated with `create_gather_task_group`.\n\n**Methods:**\n\n#### `get_result` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L504\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nget_result(self, key: UUID) -> Any\n```\n\n#### `start` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L497\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nstart(self, func: object, *args: object) -> NoReturn\n```\n\nSince `start` returns the result of `task_status.started()` but here we must\nreturn the key instead, we just won't support this method for now.\n\n#### `start_soon` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L485\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nstart_soon(self, func: Callable[[Unpack[PosArgsT]], Awaitable[Any]], *args: Unpack[PosArgsT]) -> UUID\n```\n\n### `LazySemaphore` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/asyncutils.py#L547\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>",
  "content_length": 12054
}