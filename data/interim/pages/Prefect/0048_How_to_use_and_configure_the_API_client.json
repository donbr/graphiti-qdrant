{
  "title": "How to use and configure the API client",
  "source_url": "https://docs-3.prefect.io/v3/advanced/api-client",
  "content": "## Overview\n\nThe [`PrefectClient`](https://reference.prefect.io/prefect/client/)\noffers methods to simplify common operations against Prefect's REST API that may not be abstracted away by the SDK.\n\nFor example, to [reschedule flow runs](/v3/develop/interact-with-api/#reschedule-late-flow-runs), one might use methods like:\n\n* `read_flow_runs` with a `FlowRunFilter` to read certain flow runs\n* `create_flow_run_from_deployment` to schedule new flow runs\n* `delete_flow_run` to delete a very `Late` flow run\n\n### Getting a client\n\nBy default, `get_client()` returns an asynchronous client to be used as a context manager, but you may also use a synchronous client.\n\n<CodeGroup>\n  ```python async theme={null}\n  from prefect import get_client\n\n  async with get_client() as client:\n      response = await client.hello()\n      print(response.json()) # ðŸ‘‹\n  ```\n\n  You can also use a synchronous client:\n\n  ```python sync theme={null}\n  from prefect import get_client\n\n  with get_client(sync_client=True) as client:\n      response = client.hello()\n      print(response.json()) # ðŸ‘‹\n  ```\n</CodeGroup>\n\n## Configure custom headers\n\nYou can configure custom HTTP headers to be sent with every API request by setting the `PREFECT_CLIENT_CUSTOM_HEADERS` setting. This is useful for adding authentication headers, API keys, or other custom headers required by proxies, CDNs, or security systems.\n\n### Setting custom headers\n\nCustom headers can be configured via environment variables or settings. The headers are specified as key-value pairs in JSON format.\n\n<CodeGroup>\n  ```bash Environment variable theme={null}\n  export PREFECT_CLIENT_CUSTOM_HEADERS='{\"CF-Access-Client-Id\": \"your-client-id\", \"CF-Access-Client-Secret\": \"your-secret\"}'\n  ```\n\n  ```bash CLI theme={null}\n  prefect config set PREFECT_CLIENT_CUSTOM_HEADERS='{\"CF-Access-Client-Id\": \"your-client-id\", \"CF-Access-Client-Secret\": \"your-secret\"}'\n  ```\n\n  ```toml prefect.toml theme={null}\n  [client]\n  custom_headers = '''{\n      \"CF-Access-Client-Id\": \"your-client-id\",\n      \"CF-Access-Client-Secret\": \"your-secret\",\n      \"X-API-Key\": \"your-api-key\"\n  }'''\n  ```\n</CodeGroup>\n\n<Warning>\n  **Protected headers**\n\n  Certain headers are protected and cannot be overridden by custom headers for security reasons:\n\n  * `User-Agent` - Managed by Prefect to identify client version\n  * `Prefect-Csrf-Token` - Used for CSRF protection\n  * `Prefect-Csrf-Client` - Used for CSRF protection\n\n  If you attempt to override these headers, Prefect will log a warning and ignore the custom header value.\n</Warning>\n\n## Examples\n\nThese examples are meant to illustrate how one might develop their own utilities for interacting with the API.\n\n<Note>\n  If you believe a client method is missing, or you'd like to see a specific pattern better represented in the SDK generally, please [open an issue](https://github.com/PrefectHQ/prefect/issues/new/choose).\n</Note>\n\n### Reschedule late flow runs\n\nTo bulk reschedule flow runs that are late, delete the late flow runs and create new ones in a\n`Scheduled` state with a delay. This is useful if you accidentally scheduled many\nflow runs of a deployment to an inactive work pool, for example.\n\nThe following example reschedules the last three late flow runs of a deployment named\n`healthcheck-storage-test` to run six hours later than their original expected start time.\nIt also deletes any remaining late flow runs of that deployment.\n\nFirst, define the rescheduling function:\n\n```python  theme={null}\nasync def reschedule_late_flow_runs(\n    deployment_name: str,\n    delay: timedelta,\n    most_recent_n: int,\n    delete_remaining: bool = True,\n    states: list[str] | None = None\n) -> list[FlowRun]:\n    states = states or [\"Late\"]\n\n    async with get_client() as client:\n        flow_runs = await client.read_flow_runs(\n            flow_run_filter=FlowRunFilter(\n                state=dict(name=dict(any_=states)),\n                expected_start_time=dict(before_=datetime.now(timezone.utc)),\n            ),\n            deployment_filter=DeploymentFilter(name={'like_': deployment_name}),\n            sort=FlowRunSort.START_TIME_DESC,\n            limit=most_recent_n if not delete_remaining else None\n        )\n\n        rescheduled_flow_runs: list[FlowRun] = []\n        for i, run in enumerate(flow_runs):\n            await client.delete_flow_run(flow_run_id=run.id)\n            if i < most_recent_n:\n                new_run = await client.create_flow_run_from_deployment(\n                    deployment_id=run.deployment_id,\n                    state=Scheduled(scheduled_time=run.expected_start_time + delay),\n                )\n                rescheduled_flow_runs.append(new_run)\n            \n        return rescheduled_flow_runs\n```\n\nThen use it to reschedule flows:\n\n```python  theme={null}\nrescheduled_flow_runs = asyncio.run(\n    reschedule_late_flow_runs(\n        deployment_name=\"healthcheck-storage-test\",\n        delay=timedelta(hours=6),\n        most_recent_n=3,\n    )\n)\n```\n\n<Accordion title=\"View the complete example\">\n  ```python reschedule_late_flows.py theme={null}\n  from __future__ import annotations\n\n  import asyncio\n  from datetime import datetime, timedelta, timezone\n\n  from prefect import get_client\n  from prefect.client.schemas.filters import DeploymentFilter, FlowRunFilter\n  from prefect.client.schemas.objects import FlowRun\n  from prefect.client.schemas.sorting import FlowRunSort\n  from prefect.states import Scheduled\n\n  async def reschedule_late_flow_runs(\n      deployment_name: str,\n      delay: timedelta,\n      most_recent_n: int,\n      delete_remaining: bool = True,\n      states: list[str] | None = None\n  ) -> list[FlowRun]:\n      states = states or [\"Late\"]\n\n      async with get_client() as client:\n          flow_runs = await client.read_flow_runs(\n              flow_run_filter=FlowRunFilter(\n                  state=dict(name=dict(any_=states)),\n                  expected_start_time=dict(before_=datetime.now(timezone.utc)),\n              ),\n              deployment_filter=DeploymentFilter(name={'like_': deployment_name}),\n              sort=FlowRunSort.START_TIME_DESC,\n              limit=most_recent_n if not delete_remaining else None\n          )\n\n          if not flow_runs:\n              print(f\"No flow runs found in states: {states!r}\")\n              return []\n          \n          rescheduled_flow_runs: list[FlowRun] = []\n          for i, run in enumerate(flow_runs):\n              await client.delete_flow_run(flow_run_id=run.id)\n              if i < most_recent_n:\n                  new_run = await client.create_flow_run_from_deployment(\n                      deployment_id=run.deployment_id,\n                      state=Scheduled(scheduled_time=run.expected_start_time + delay),\n                  )\n                  rescheduled_flow_runs.append(new_run)\n              \n          return rescheduled_flow_runs\n\n\n  if __name__ == \"__main__\":\n      rescheduled_flow_runs = asyncio.run(\n          reschedule_late_flow_runs(\n              deployment_name=\"healthcheck-storage-test\",\n              delay=timedelta(hours=6),\n              most_recent_n=3,\n          )\n      )\n      \n      print(f\"Rescheduled {len(rescheduled_flow_runs)} flow runs\")\n      \n      assert all(run.state.is_scheduled() for run in rescheduled_flow_runs)\n      assert all(\n          run.expected_start_time > datetime.now(timezone.utc)\n          for run in rescheduled_flow_runs\n      )\n  ```\n</Accordion>\n\n### Get the last `N` completed flow runs from your workspace\n\nTo get the last `N` completed flow runs from your workspace, use `read_flow_runs` and `prefect.client.schemas`.\n\nThis example gets the last three completed flow runs from your workspace:\n\n```python  theme={null}\nasync def get_most_recent_flow_runs(\n    n: int,\n    states: list[str] | None = None\n) -> list[FlowRun]:    \n    async with get_client() as client:\n        return await client.read_flow_runs(\n            flow_run_filter=FlowRunFilter(\n                state={'type': {'any_': states or [\"COMPLETED\"]}}\n            ),\n            sort=FlowRunSort.END_TIME_DESC,\n            limit=n,\n        )\n```\n\nUse it to get the last 3 completed runs:\n\n```python  theme={null}\nflow_runs: list[FlowRun] = asyncio.run(\n    get_most_recent_flow_runs(n=3)\n)\n```\n\n<Accordion title=\"View the complete example\">\n  ```python get_recent_flows.py theme={null}\n  from __future__ import annotations\n\n  import asyncio\n\n  from prefect import get_client\n  from prefect.client.schemas.filters import FlowRunFilter\n  from prefect.client.schemas.objects import FlowRun\n  from prefect.client.schemas.sorting import FlowRunSort\n\n  async def get_most_recent_flow_runs(\n      n: int,\n      states: list[str] | None = None\n  ) -> list[FlowRun]:    \n      async with get_client() as client:\n          return await client.read_flow_runs(\n              flow_run_filter=FlowRunFilter(\n                  state={'type': {'any_': states or [\"COMPLETED\"]}}\n              ),\n              sort=FlowRunSort.END_TIME_DESC,\n              limit=n,\n          )\n\n\n  if __name__ == \"__main__\":\n      flow_runs: list[FlowRun] = asyncio.run(\n          get_most_recent_flow_runs(n=3)\n      )\n      assert len(flow_runs) == 3\n      \n      assert all(\n          run.state.is_completed() for run in flow_runs\n      )\n      assert (\n          end_times := [run.end_time for run in flow_runs]\n      ) == sorted(end_times, reverse=True)\n  ```\n</Accordion>\n\nInstead of the last three from the whole workspace, you can also use the `DeploymentFilter`\nto get the last three completed flow runs of a specific deployment.\n\n### Transition all running flows to cancelled through the Client\n\nUse `get_client`to set multiple runs to a `Cancelled` state.\nThis example cancels all flow runs that are in `Pending`, `Running`, `Scheduled`, or `Late` states when the script is run.\n\n```python  theme={null}\nasync def list_flow_runs_with_states(states: list[str]) -> list[FlowRun]:\n    async with get_client() as client:\n        return await client.read_flow_runs(\n            flow_run_filter=FlowRunFilter(\n                state=FlowRunFilterState(\n                    name=FlowRunFilterStateName(any_=states)\n                )\n            )\n        )\n\nasync def cancel_flow_runs(flow_runs: list[FlowRun]):\n    async with get_client() as client:\n        for flow_run in flow_runs:\n            state = flow_run.state.copy(\n                update={\"name\": \"Cancelled\", \"type\": StateType.CANCELLED}\n            )\n            await client.set_flow_run_state(flow_run.id, state, force=True)\n```\n\nCancel all pending, running, scheduled or late flows:\n\n```python  theme={null}\nasync def bulk_cancel_flow_runs():\n    states = [\"Pending\", \"Running\", \"Scheduled\", \"Late\"]\n    flow_runs = await list_flow_runs_with_states(states)\n\n    while flow_runs:\n        print(f\"Cancelling {len(flow_runs)} flow runs\")\n        await cancel_flow_runs(flow_runs)\n        flow_runs = await list_flow_runs_with_states(states)\n\nasyncio.run(bulk_cancel_flow_runs())\n```\n\n<Accordion title=\"View the complete example\">\n  ```python cancel_flows.py theme={null}\n  import asyncio\n\n  from prefect import get_client\n  from prefect.client.schemas.filters import FlowRunFilter, FlowRunFilterState, FlowRunFilterStateName\n  from prefect.client.schemas.objects import FlowRun, StateType\n\n  async def list_flow_runs_with_states(states: list[str]) -> list[FlowRun]:\n      async with get_client() as client:\n          return await client.read_flow_runs(\n              flow_run_filter=FlowRunFilter(\n                  state=FlowRunFilterState(\n                      name=FlowRunFilterStateName(any_=states)\n                  )\n              )\n          )\n\n\n  async def cancel_flow_runs(flow_runs: list[FlowRun]):\n      async with get_client() as client:\n          for idx, flow_run in enumerate(flow_runs):\n              print(f\"[{idx + 1}] Cancelling flow run '{flow_run.name}' with ID '{flow_run.id}'\")\n              state_updates: dict[str, str] = {}\n              state_updates.setdefault(\"name\", \"Cancelled\")\n              state_updates.setdefault(\"type\", StateType.CANCELLED)\n              state = flow_run.state.copy(update=state_updates)\n              await client.set_flow_run_state(flow_run.id, state, force=True)\n\n\n  async def bulk_cancel_flow_runs():\n      states = [\"Pending\", \"Running\", \"Scheduled\", \"Late\"]\n      flow_runs = await list_flow_runs_with_states(states)\n\n      while len(flow_runs) > 0:\n          print(f\"Cancelling {len(flow_runs)} flow runs\\n\")\n          await cancel_flow_runs(flow_runs)\n          flow_runs = await list_flow_runs_with_states(states)\n      print(\"Done!\")\n\n\n  if __name__ == \"__main__\":\n      asyncio.run(bulk_cancel_flow_runs())\n  ```\n</Accordion>\n\n### Query events with pagination\n\nQuery historical events from the Prefect API with support for filtering and pagination. This is useful for analyzing past activity, debugging issues, or building custom monitoring tools.\n\nThe following example queries events from the last hour and demonstrates how to paginate through results:\n\n```python  theme={null}\nfrom datetime import datetime, timedelta, timezone\n\nfrom prefect import get_client\nfrom prefect.events.filters import EventFilter, EventOccurredFilter\n\n\nasync def query_recent_events():\n    async with get_client() as client:\n        # query events from the last hour\n        now = datetime.now(timezone.utc)\n        event_filter = EventFilter(\n            occurred=EventOccurredFilter(\n                since=now - timedelta(hours=1),\n                until=now,\n            )\n        )\n\n        # get first page\n        page = await client.read_events(filter=event_filter, limit=10)\n        print(f\"Total events: {page.total}\")\n\n        # iterate through all pages\n        while page:\n            for event in page.events:\n                print(f\"{event.occurred} - {event.event}\")\n            page = await page.get_next_page(client)\n```\n\n<Accordion title=\"View the complete example\">\n  ```python query_events.py theme={null}\n  import asyncio\n  from datetime import datetime, timedelta, timezone\n\n  from prefect import get_client\n  from prefect.events.filters import EventFilter, EventOccurredFilter\n\n\n  async def query_recent_events():\n      async with get_client() as client:\n          # query events from the last hour\n          now = datetime.now(timezone.utc)\n          event_filter = EventFilter(\n              occurred=EventOccurredFilter(\n                  since=now - timedelta(hours=1),\n                  until=now,\n              )\n          )\n\n          # get first page with small limit to demonstrate pagination\n          print(\"=== first page ===\")\n          event_page = await client.read_events(filter=event_filter, limit=5)\n          print(f\"total events: {event_page.total}\")\n          print(f\"events on this page: {len(event_page.events)}\")\n          for event in event_page.events:\n              print(f\"  {event.occurred} - {event.event}\")\n          print()\n\n          # if there are more pages, fetch the next one\n          second_page = await event_page.get_next_page(client)\n          if second_page:\n              print(\"=== second page ===\")\n              print(f\"events on this page: {len(second_page.events)}\")\n              for event in second_page.events:\n                  print(f\"  {event.occurred} - {event.event}\")\n              print()\n\n          # demonstrate iterating through all pages\n          print(\"=== collecting all events ===\")\n          all_events = []\n          page = await client.read_events(filter=event_filter, limit=5)\n\n          page_count = 0\n          while page:\n              all_events.extend(page.events)\n              page_count += 1\n              page = await page.get_next_page(client)\n\n          print(f\"collected {len(all_events)} events across {page_count} pages\")\n\n\n  if __name__ == \"__main__\":\n      asyncio.run(query_recent_events())\n  ```\n</Accordion>\n\n### Create, read, or delete artifacts\n\nCreate, read, or delete artifacts programmatically through the [Prefect REST API](/v3/api-ref/rest-api/).\nWith the Artifacts API, you can automate the creation and management of artifacts as part of your workflow.\n\nFor example, to read the five most recently created Markdown, table, and link artifacts, you can run the following:\n\n```python fixture:mock_post_200 theme={null}\nimport requests\n\n\nPREFECT_API_URL=\"https://api.prefect.cloud/api/accounts/abc/workspaces/xyz\"\nPREFECT_API_KEY=\"pnu_ghijk\"\ndata = {\n    \"sort\": \"CREATED_DESC\",\n    \"limit\": 5,\n    \"artifacts\": {\n        \"key\": {\n            \"exists_\": True\n        }\n    }\n}\n\nheaders = {\"Authorization\": f\"Bearer {PREFECT_API_KEY}\"}\nendpoint = f\"{PREFECT_API_URL}/artifacts/filter\"\n\nresponse = requests.post(endpoint, headers=headers, json=data)\nassert response.status_code == 200\nfor artifact in response.json():\n    print(artifact)\n```\n\nIf you don't specify a key or that a key must exist, you will also return results, which are a type of key-less artifact.\n\nSee the [Prefect REST API documentation](/v3/api-ref/rest-api/) on artifacts for more information.",
  "content_length": 17012
}