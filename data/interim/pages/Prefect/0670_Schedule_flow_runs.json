{
  "title": "Schedule flow runs",
  "source_url": "https://docs-3.prefect.io/v3/concepts/schedules",
  "content": "Prefect can schedule when to automatically create new flow runs.\n\nPrefect allows you to specify schedules on which your flows run.\nYou can add one or more schedules to any deployed flow.\nSchedules tell Prefect when and how to create new flow runs.\nYou can add a schedule to a deployed flow in the Prefect UI, in the CLI through the `prefect deployment schedule` command, or the `prefect.yaml` configuration file.\n\n## Schedule types\n\nPrefect supports three types of schedules:\n\n* [`Cron`](#cron) is most appropriate for users who are already familiar with `cron` from previous use.\n* [`Interval`](#interval) is best suited for deployments that run at some consistent cadence that isn't related to absolute time.\n* [`RRule`](#rrule) is best suited for deployments that rely on calendar logic for simple recurring schedules, irregular intervals, exclusions,\n  or day-of-month adjustments.\n\n<Tip>\n  **Schedules can be inactive**\n\n  When you create or edit a schedule, you can set the `active` property to `False` in Python (or `false` in a YAML file) to\n  deactivate the schedule.\n  This is useful to keep the schedule configuration but temporarily stop the schedule from creating new flow runs.\n</Tip>\n\n### Cron\n\nA `Cron` schedule uses a standard [`cron`](https://en.wikipedia.org/wiki/Cron) string to define when flow runs should occur. This is ideal for schedules tied to specific clock times and dates (e.g., \"every Monday at 9:00 AM\"). You may also provide a timezone to enforce daylight saving time (DST) behaviors.\n\nPrefect's cron scheduling is based on the `croniter` library, allowing it to interpret familiar cron expressions. For example, the expression `0 9 * * MON-FRI` means \"at 9:00 AM on every Monday through Friday\".\n\n<Tip>\n  **Supported `croniter` features**\n\n  While Prefect supports most features of `croniter` for creating `cron`-like schedules, it does not support \"R\"\n  random or \"H\" hashed keyword expressions or the schedule jittering possible with those expressions.\n</Tip>\n\n`Cron` properties include:\n\n| Property | Description                                                                                                            |\n| -------- | ---------------------------------------------------------------------------------------------------------------------- |\n| cron     | A valid `cron` string. (Required)                                                                                      |\n| day\\_or  | Boolean indicating how `croniter` handles `day` and `day_of_week` entries. Default is `True`.                          |\n| timezone | String name of a time zone. (See the [IANA Time Zone Database](https://www.iana.org/time-zones) for valid time zones.) |\n\n#### How the `day_or` property works\n\nThe `day_or` property defaults to `True`, matching the behavior of `cron`.\n\nIn this mode, if you specify a `day` (of the month)\nentry and a `day_of_week` entry, the schedule runs a flow on both the specified day of the month *and* on the specified day of the\nweek.\n\nThe \"or\" in `day_or` refers to the two entries treated like an `OR` statement. The schedule should include\nboth, as in the SQL statement:\n\n```sql  theme={null}\nSELECT * FROM employees WHERE first_name = 'Ford' OR last_name = 'Prefect';\n```\n\nFor example, with `day_or` set to `True`, the cron schedule `* * 3 1 2` runs a flow every minute on the third day of the month\nand on Tuesday (the second day of the week) in January (the first month of the year).\n\nWith `day_or` set to `False`, the `day` (of the month) and `day_of_week` entries are joined with the more restrictive `AND`\noperation, as in the SQL statement:\n\n```sql  theme={null}\nSELECT * from employees WHERE first_name = 'Zaphod' AND last_name = 'Beeblebrox';\n```\n\nFor example, the same schedule, when `day_or` is `False`, runs a flow on every minute on the **third Tuesday** in January.\nThis behavior matches `fcron` instead of `cron`.\n\n<Note>\n  **Daylight saving time considerations**\n\n  If the `timezone` is a DST-observing one, then the schedule adjusts itself appropriately.\n\n  The `cron` rules for DST are based on schedule times, not intervals. This means that an hourly `cron` schedule fires on\n  every new schedule hour, not every elapsed hour.\n  For example, when clocks are set back, this results in a two-hour pause as the schedule will fire *the first time* 1 AM is reached and *the first time* 2 AM is reached, 120 minutes later.\n\n  Longer schedules, such as one that fires at 9 AM every morning, adjust for DST automatically.\n</Note>\n\n### Interval\n\nAs the name suggests, an `Interval` schedule is best for deployments that need to run at a consistent cadence not strictly tied to absolute clock time (e.g., \"every 10 minutes\" or \"every 3 hours\"). It creates new flow runs on a regular interval, measured in seconds, which can be anchored to a specific `anchor_date`.\n\n```yaml  theme={null}\nschedule:\n  interval: 600\n  timezone: America/Chicago\n```\n\n`Interval` properties include:\n\n| Property     | Description                                                                                                                                                                        |\n| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| interval     | `datetime.timedelta` indicating the time between flow runs. (Required)                                                                                                             |\n| anchor\\_date | `datetime.datetime` indicating the starting or \"anchor\" date to begin the schedule. If no `anchor_date` is supplied, the current UTC time is used.                                 |\n| timezone     | String name of a time zone, used to enforce localization behaviors like DST boundaries. (See the [IANA Time Zone Database](https://www.iana.org/time-zones) for valid time zones.) |\n\nThe `anchor_date` does not indicate a \"start time\" for the schedule, but a fixed point to\ncompute intervals.\nIf the anchor date is in the future, then schedule dates are computed by subtracting the `interval` from it.\n\n<Note>\n  **Daylight saving time considerations**\n\n  If the schedule's `anchor_date` or `timezone` are provided with a DST-observing timezone, then the schedule adjusts itself\n  appropriately.\n  Intervals greater than 24 hours will follow DST conventions, while intervals of less than 24 hours will follow UTC intervals.\n\n  For example, an hourly schedule will fire every UTC hour, even across DST boundaries. When clocks are set back, this results in two runs that *appear* to be scheduled for 1 AM local time, even though they are an hour apart in UTC time.\n\n  For longer intervals, like a daily schedule, the interval schedule adjusts for DST boundaries so that the clock-hour remains constant.\n  This means that a daily schedule that always fires at 9 AM will observe DST and continue to fire at 9 AM in the local time zone.\n</Note>\n\n### RRule\n\nFor complex scheduling needs that go beyond simple cron expressions or fixed intervals, `RRule` (Recurrence Rule) is the most powerful option. It's ideal for deployments that rely on calendar-based logic, such as \"the last weekday of each month,\" \"every other Tuesday,\" or schedules with specific exclusions.\n\n`RRule` scheduling supports [iCal recurrence rules](https://icalendar.org/iCalendar-RFC-5545/3-8-5-3-recurrence-rule.html), providing a rich syntax for defining a wide array of repetitive schedules, from yearly down to every minute.\n\nRRules are appropriate for any kind of calendar-date manipulation, including simple repetition, irregular intervals, exclusions,\nweek day or day-of-month adjustments, and more. RRules can represent complex logic like:\n\n* The last weekday of each month\n* The fourth Thursday of November\n* Every other day of the week\n\n`RRule` properties include:\n\n| Property | Description                                                                                                                                                   |\n| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| rrule    | String representation of an RRule schedule. See the [`rrulestr` examples](https://dateutil.readthedocs.io/en/stable/rrule.html#rrulestr-examples) for syntax. |\n| timezone | String name of a time zone. See the [IANA Time Zone Database](https://www.iana.org/time-zones) for valid time zones.                                          |\n\nYou may find it useful to use an RRule string generator such as the [iCalendar.org RRule Tool](https://icalendar.org/rrule-tool.html) to help create valid RRules.\n\n```yaml  theme={null}\nschedule:\n  rrule: 'FREQ=WEEKLY;BYDAY=MO,WE,FR;UNTIL=20240730T040000Z'\n```\n\n<Note>\n  **RRule restrictions**\n  The max supported character length of an `rrulestr` is 6,500 characters\n\n  `COUNT` is not supported. Please use `UNTIL` or the `/deployments/{id}/runs` endpoint to schedule a fixed number of\n  flow runs.\n</Note>\n\n<Note>\n  **Daylight saving time considerations**\n\n  As a calendar-oriented standard, `RRules` are sensitive to the initial timezone provided.\n  A 9 AM daily schedule with a DST-aware start date maintains a local 9 AM time through DST boundaries. A 9 AM daily schedule\n  with a UTC start date maintains a 9 AM UTC time.\n</Note>\n\n## How scheduling works\n\nPrefect's `Scheduler` service evaluates each deployment's schedules and creates new runs appropriately. It starts\nautomatically when `prefect server start` is run and it is a built-in service of Prefect Cloud.\n\nThe `Scheduler` creates the fewest runs that satisfy the following constraints, in order:\n\n* No more than 100 runs will be scheduled.\n* Runs will not be scheduled more than 100 days in the future.\n* At least three runs will be scheduled.\n* Runs will be scheduled until at least one hour in the future.\n\nThese behaviors are adjustable through the relevant settings with the `prefect config\nview --show-defaults` command:\n\n```bash  theme={null}\nPREFECT_API_SERVICES_SCHEDULER_DEPLOYMENT_BATCH_SIZE='100'\nPREFECT_API_SERVICES_SCHEDULER_ENABLED='True'\nPREFECT_API_SERVICES_SCHEDULER_INSERT_BATCH_SIZE='500'\nPREFECT_API_SERVICES_SCHEDULER_LOOP_SECONDS='60.0'\nPREFECT_API_SERVICES_SCHEDULER_MIN_RUNS='3'\nPREFECT_API_SERVICES_SCHEDULER_MAX_RUNS='100'\nPREFECT_API_SERVICES_SCHEDULER_MIN_SCHEDULED_TIME='1:00:00'\nPREFECT_API_SERVICES_SCHEDULER_MAX_SCHEDULED_TIME='100 days, 0:00:00'\n```\n\nSee the [Settings docs](/v3/develop/settings-and-profiles/) for more information on altering your settings.\n\nThese settings mean that if a deployment has an hourly schedule, the default settings will create runs for the next four days (or 100 hours).\nIf it has a weekly schedule, the default settings will maintain the next 14 runs (up to 100 days in the future).\n\n<Tip>\n  **`Scheduler` does not affect execution**\n\n  The Prefect `Scheduler` service only creates new flow runs and places them in `Scheduled` states.\n  It is not involved in flow or task execution.\n</Tip>\n\nIf you change a schedule, previously scheduled flow runs that have not started are removed, and new scheduled flow runs are\ncreated to reflect the new schedule.\n\nTo remove all scheduled runs for a flow deployment, you can remove the schedule.\n\n## Further reading\n\n* [How to create schedules](/v3/how-to-guides/deployments/create-schedules)",
  "content_length": 11459
}