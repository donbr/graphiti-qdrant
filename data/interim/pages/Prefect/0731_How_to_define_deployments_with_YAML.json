{
  "title": "How to define deployments with YAML",
  "source_url": "https://docs-3.prefect.io/v3/how-to-guides/deployments/prefect-yaml",
  "content": "Use YAML to schedule and trigger flow runs and manage your code and deployments.\n\nThe `prefect.yaml` file is a YAML file describing base settings for your deployments, procedural steps for preparing deployments,\nand instructions for preparing the execution environment for a deployment run.\n\nInitialize your deployment configuration, which creates the `prefect.yaml` file, with the CLI command `prefect init`\nin any directory or repository that stores your flow code.\n\n<Tip>\n  **Deployment configuration recipes**\n\n  Prefect ships with many off-the-shelf \"recipes\" that allow you to get started with more structure within\n  your `prefect.yaml` file. Run `prefect init` to be prompted with available recipes in your installation.\n  You can provide a recipe name in your initialization command with the `--recipe` flag, otherwise Prefect will attempt to\n  guess an appropriate recipe based on the structure of your working directory (for example if you initialize within a `git`\n  repository, Prefect will use the `git` recipe).\n</Tip>\n\nThe `prefect.yaml` file contains:\n\n* deployment configuration for deployments created from this file\n* default instructions for how to build and push any necessary code artifacts (such as Docker images)\n* default instructions for pulling a deployment in remote  execution environments (for example, cloning a GitHub repository).\n\nYou can override any deployment configuration through options available on the `prefect deploy` CLI command when creating a deployment.\n\n<Tip>\n  **`prefect.yaml` file flexibility**\n\n  In older versions of Prefect, this file must be in the root of your repository or project directory and named `prefect.yaml`.\n  With Prefect 3, this file can be located in a directory outside the project or a subdirectory inside the project.\n  It can be named differently if the filename ends in `.yaml`. You can have multiple `prefect.yaml` files with the same name\n  in different directories.\n\n  By default, `prefect deploy` uses a `prefect.yaml` file in the project's root directory. To use a custom deployment\n  configuration file, supply the new  `--prefect-file` CLI argument when running the `deploy` command from the root of your\n  project directory:\n\n  `prefect deploy --prefect-file path/to/my_file.yaml`\n</Tip>\n\nThe base structure for `prefect.yaml` looks like this:\n\n```yaml  theme={null}\n# generic metadata\nprefect-version: null\nname: null\n\n# preparation steps\nbuild: null\npush: null\n\n# runtime steps\npull: null\n\n# deployment configurations\ndeployments:\n- # base metadata\n  name: null\n  version: null\n  tags: []\n  description: null\n  schedule: null\n\n  # flow-specific fields\n  entrypoint: null\n  parameters: {}\n\n  # infra-specific fields\n  work_pool:\n    name: null\n    work_queue_name: null\n    job_variables: {}\n```\n\nThe metadata fields are always pre-populated for you. These fields are for bookkeeping purposes only. The other sections are\npre-populated based on recipe; if no recipe is provided, Prefect attempts to guess an appropriate one based on local configuration.\n\nYou can create deployments with the CLI command `prefect deploy` without altering the `deployments` section of your\n`prefect.yaml` file. The `prefect deploy` command helps in deployment creation through interactive prompts. The `prefect.yaml`\nfile facilitates version-controlling your deployment configuration and managing multiple deployments.\n\n## Deployment actions\n\nDeployment actions defined in your `prefect.yaml` file control the lifecycle of the creation and execution of your deployments.\nThe three actions available are `build`, `push`, and `pull`.\n`pull` is the only required deployment action. It defines how Prefect pulls your deployment in remote execution\nenvironments.\n\nEach action is defined as a list of steps executed in sequence. Each step has the following format:\n\n```yaml  theme={null}\nsection:\n- prefect_package.path.to.importable.step:\n  id: \"step-id\" # optional\n  requires: \"pip-installable-package-spec\" # optional\n  kwarg1: value\n  kwarg2: more-values\n```\n\nEvery step optionally provides a `requires` field. Prefect uses this to auto-install if the step is not\nfound in the current environment. Each step can specify an `id` to reference outputs in\nfuture steps. The additional fields map directly to Python keyword arguments to the step function. Within a given section,\nsteps always run in their order within the `prefect.yaml` file.\n\n<Tip>\n  **Deployment instruction overrides**\n\n  You can override `build`, `push`, and `pull` sections on a per-deployment basis; define `build`, `push`, and `pull`\n  fields within a deployment definition in the `prefect.yaml` file.\n\n  The `prefect deploy` command uses any `build`, `push`, or `pull` instructions from the deployment's definition in the\n  `prefect.yaml` file.\n\n  This capability is useful for multiple deployments that require different deployment instructions.\n</Tip>\n\n### The build action\n\nUse the build section of `prefect.yaml` to specify setup steps or dependencies,\n(like creating a Docker image), required to run your deployments.\n\nIf you initialize with the Docker recipe, you are prompted to provide\nrequired information, such as image name and tag:\n\n```bash  theme={null}\nprefect init --recipe docker\n>> image_name: < insert image name here >\n>> tag: < insert image tag here >\n```\n\n<Tip>\n  **Use `--field` to avoid the interactive experience**\n\n  We recommend that you only initialize a recipe when first creating your deployment structure. Then store\n  your configuration files within version control.\n  Sometimes you may need to initialize programmatically and avoid the interactive prompts.\n  To do this, provide all required fields for your recipe using the `--field` flag:\n\n  ```bash  theme={null}\n  prefect init --recipe docker \\\n      --field image_name=my-repo/my-image \\\n      --field tag=my-tag\n  ```\n\n  ```yaml  theme={null}\n  build:\n  - prefect_docker.deployments.steps.build_docker_image:\n    requires: prefect-docker>=0.3.0\n    image_name: my-repo/my-image\n    tag: my-tag\n    dockerfile: auto\n  ```\n</Tip>\n\nOnce you confirm that these fields are set to their desired values, this step automatically builds a Docker image with\nthe provided name and tag and pushes it to the repository referenced by the image name.\nThis step produces optional fields for future steps, or within `prefect.yaml` as template values.\n\nWe recommend using a templated `{{ image }}` within `prefect.yaml` (specifically in the work pool's `job_variables` section).\nBy avoiding hardcoded values, the build step and deployment specification won't have mismatched values.\n\n<Note>\n  **Some steps require Prefect integrations**\n\n  In the build step example above, you relied on the `prefect-docker` package; in cases that deal with external services,\n  additional required packages are auto-installed for you.\n</Note>\n\n<Tip>\n  **Passing Docker build arguments**\n\n  The `build_docker_image` step accepts any keyword arguments supported by the Docker Python SDK's [`build` method](https://docker-py.readthedocs.io/en/stable/images.html#docker.models.images.ImageCollection.build). This allows you to customize the Docker build process beyond the explicitly documented parameters.\n\n  Common examples:\n\n  ```yaml  theme={null}\n  build:\n    - prefect_docker.deployments.steps.build_docker_image:\n        image_name: my-repo/my-image\n        tag: my-tag\n        dockerfile: auto\n        nocache: true           # Disable Docker layer caching (--no-cache)\n        pull: true              # Always pull the latest base image\n        platform: linux/amd64   # Specify target platform\n        buildargs:              # Pass build-time variables\n          MY_ARG: value\n  ```\n\n  Note: `ignore_cache` is a separate parameter that controls **Prefect's step-level caching** (whether to reuse the entire build step result across `prefect deploy --all` runs), not Docker's layer caching.\n</Tip>\n\n**Pass output to downstream steps**\n\nEach deployment action can be composed of multiple steps. For example, to build a Docker image tagged with the\ncurrent commit hash, use the `run_shell_script` step and feed the output into the `build_docker_image` step:\n\n```yaml  theme={null}\nbuild:\n- prefect.deployments.steps.run_shell_script:\n    id: get-commit-hash\n    script: git rev-parse --short HEAD\n    stream_output: false\n- prefect_docker.deployments.steps.build_docker_image:\n    requires: prefect-docker\n    image_name: my-image\n    image_tag: \"{{ get-commit-hash.stdout }}\"\n    dockerfile: auto\n```\n\nThe `id` field is used in the `run_shell_script` step to reference its output in the next step.\n\n### The push action\n\nThe push section is most critical for situations where code is not stored on persistent filesystems or in version control.\nIn this scenario, code is often pushed and pulled from a Cloud storage bucket (for example, S3, GCS, Azure Blobs).\nThe push section allows users to specify and customize the logic for pushing this code repository to arbitrary remote locations.\n\nFor example, a user who stores their code in an S3 bucket and relies on default worker settings for its runtime environment\ncould use the `s3` recipe:\n\n```bash  theme={null}\nprefect init --recipe s3\n>> bucket: < insert bucket name here >\n```\n\nIn your newly created`prefect.yaml` file, you should find that the `push` and `pull` sections have been templated out\nas follows:\n\n```yaml  theme={null}\npush:\n- prefect_aws.deployments.steps.push_to_s3:\n    id: push-code\n    requires: prefect-aws>=0.3.0\n    bucket: my-bucket\n    folder: project-name\n    credentials: null\n\npull:\n- prefect_aws.deployments.steps.pull_from_s3:\n    requires: prefect-aws>=0.3.0\n    bucket: my-bucket\n    folder: \"{{ push-code.folder }}\"\n    credentials: null\n```\n\nThe bucket is populated with the provided value (which also could have been provided with the `--field` flag); note that the\n`folder` property of the `pull` step is a template - the `push_to_s3` step outputs both a `bucket` value as well as a `folder`\nvalue for the template downstream steps. This helps you keep your steps consistent across edits.\n\nAs discussed above, if you use [blocks](/v3/concepts/blocks/), you can template the credentials section with\na block reference for secure and dynamic credentials access:\n\n```yaml  theme={null}\npush:\n- prefect_aws.deployments.steps.push_to_s3:\n    requires: prefect-aws>=0.3.0\n    bucket: my-bucket\n    folder: project-name\n    credentials: \"{{ prefect.blocks.aws-credentials.dev-credentials }}\"\n```\n\nAnytime you run `prefect deploy`, this `push` section executes upon successful completion of your `build` section.\n\n### The pull action\n\nThe pull section is the most important section within the `prefect.yaml` file. It contains instructions for preparing your\nflows for a deployment run. These instructions execute each time a deployment in this folder is run through a worker.\n\nThere are three main types of steps that typically show up in a `pull` section:\n\n* `set_working_directory`: this step sets the working directory for the process prior to importing your flow\n* `git_clone`: this step clones the provided repository on the provided branch\n* `pull_from_{cloud}`: this step pulls the working directory from a Cloud storage location (for example, S3)\n\n<Tip>\n  **Use block and variable references**\n\n  All [block and variable references](#templating-options) within your pull step will remain unresolved until runtime and\n  are pulled each time your deployment runs. This avoids storing sensitive information insecurely; it\n  also allows you to manage certain types of configuration from the API and UI without having to rebuild your deployment every time.\n</Tip>\n\nBelow is an example of how to use an existing `GitHubCredentials` block to clone a private GitHub repository:\n\n```yaml  theme={null}\npull:\n- prefect.deployments.steps.git_clone:\n    repository: https://github.com/org/repo.git\n    credentials: \"{{ prefect.blocks.github-credentials.my-credentials }}\"\n```\n\nAlternatively, you can specify a `BitBucketCredentials` or `GitLabCredentials` block to clone from Bitbucket or GitLab. In\nlieu of a credentials block, you can also provide a GitHub, GitLab, or Bitbucket token directly to the 'access\\_token\\` field.\nUse a Secret block to do this securely:\n\n```yaml  theme={null}\npull:\n- prefect.deployments.steps.git_clone:\n    repository: https://bitbucket.org/org/repo.git\n    access_token: \"{{ prefect.blocks.secret.bitbucket-token }}\"\n```\n\n## Utility steps\n\nUse utility steps within a build, push, or pull action to assist in managing the deployment lifecycle:\n\n* `run_shell_script` allows for the execution of one or more shell commands in a subprocess, and returns the standard output\n  and standard error of the script. This step is useful for scripts that require execution in a specific environment, or those\n  which have specific input and output requirements. Note that setting `stream_output: true` for `run_shell_script` writes the\n  output and error to stdout in the execution environment, which will not be sent to the Prefect API.\n\nHere is an example of retrieving the short Git commit hash of the current repository to use as a Docker image tag:\n\n```yaml  theme={null}\nbuild:\n- prefect.deployments.steps.run_shell_script:\n    id: get-commit-hash\n    script: git rev-parse --short HEAD\n    stream_output: false\n- prefect_docker.deployments.steps.build_docker_image:\n    requires: prefect-docker>=0.3.0\n    image_name: my-image\n    tag: \"{{ get-commit-hash.stdout }}\"\n    dockerfile: auto\n```\n\n<Warning>\n  **Provided environment variables are not expanded by default**\n\n  To expand environment variables in your shell script, set `expand_env_vars: true` in your `run_shell_script` step. For example:\n\n  ```yaml  theme={null}\n  - prefect.deployments.steps.run_shell_script:\n      id: get-user\n      script: echo $USER\n      stream_output: true\n      expand_env_vars: true\n  ```\n\n  Without `expand_env_vars: true`, the above step returns a literal string `$USER` instead of the current user.\n</Warning>\n\n* `pip_install_requirements` installs dependencies from a `requirements.txt` file within a specified directory.\n\nHere is an example of installing dependencies from a `requirements.txt` file after cloning:\n\n```yaml  theme={null}\npull:\n- prefect.deployments.steps.git_clone:\n    id: clone-step # needed to be referenced in subsequent steps\n    repository: https://github.com/org/repo.git\n- prefect.deployments.steps.pip_install_requirements:\n    directory: \"{{ clone-step.directory }}\" # `clone-step` is a user-provided `id` field\n    requirements_file: requirements.txt\n```\n\nHere is an example that retrieves an access token from a third party key vault and uses it in a private clone step:\n\n```yaml  theme={null}\npull:\n- prefect.deployments.steps.run_shell_script:\n    id: get-access-token\n    script: az keyvault secret show --name <secret name> --vault-name <secret vault> --query \"value\" --output tsv\n    stream_output: false\n- prefect.deployments.steps.git_clone:\n    repository: https://bitbucket.org/samples/deployments.git\n    branch: master\n    access_token: \"{{ get-access-token.stdout }}\"\n```\n\nYou can also run custom steps by packaging them. In the example below, `retrieve_secrets` is a custom python module packaged\ninto the default working directory of a Docker image (which is /opt/prefect by default).\n`main` is the function entry point, which returns an access token (for example, `return {\"access_token\": access_token}`) like the\npreceding example, but utilizing the Azure Python SDK for retrieval.\n\n```yaml  theme={null}\n- retrieve_secrets.main:\n    id: get-access-token\n- prefect.deployments.steps.git_clone:\n    repository: https://bitbucket.org/samples/deployments.git\n    branch: master\n    access_token: '{{ get-access-token.access_token }}'\n```\n\n## Templating options\n\nValues that you place within your `prefect.yaml` file can reference dynamic values in several different ways:\n\n* **step outputs**: every step of both `build` and `push` produce named fields such as `image_name`; you can reference these\n  fields within `prefect.yaml` and `prefect deploy` will populate them with each call. References must be enclosed in double\n  brackets and in `\"{{ field_name }}\"` format\n* **blocks**: you can reference [Prefect blocks](/v3/concepts/blocks) with the\n  `{{ prefect.blocks.block_type.block_slug }}` syntax. It is highly recommended that you use block references for any sensitive\n  information (such as a GitHub access token or any credentials) to avoid hardcoding these values in plaintext\n* **variables**: you can reference [Prefect variables](/v3/concepts/variables) with the\n  `{{ prefect.variables.variable_name }}` syntax. Use variables to reference non-sensitive, reusable pieces of information\n  such as a default image name or a default work pool name.\n* **environment variables**: you can also reference environment variables with the special syntax `{{ $MY_ENV_VAR }}`.\n  This is especially useful for referencing environment variables that are set at runtime.\n\nHere's a `prefect.yaml` file as an example:\n\n```yaml  theme={null}\nbuild:\n- prefect_docker.deployments.steps.build_docker_image:\n    id: build-image\n    requires: prefect-docker>=0.6.0\n    image_name: my-repo/my-image\n    tag: my-tag\n    dockerfile: auto\n\npush:\n- prefect_docker.deployments.steps.push_docker_image:\n    requires: prefect-docker>=0.6.0\n    image_name: my-repo/my-image\n    tag: my-tag\n    credentials: \"{{ prefect.blocks.docker-registry-credentials.dev-registry }}\"\n\ndeployments:\n- # base metadata\n  name: null\n  version: \"{{ build-image.tag }}\"\n  tags:\n  - \"{{ $my_deployment_tag }}\"\n  - \"{{ prefect.variables.some_common_tag }}\"\n  description: null\n  schedule: null\n  concurrency_limit: null\n\n  # flow-specific fields\n  entrypoint: null\n  parameters: {}\n\n  # infra-specific fields\n  work_pool:\n    name: \"my-k8s-work-pool\"\n    work_queue_name: null\n    job_variables:\n      image: \"{{ build-image.image }}\"\n      cluster_config: \"{{ prefect.blocks.kubernetes-cluster-config.my-favorite-config }}\"\n```\n\nSo long as your `build` steps produce fields called `image_name` and `tag`, every time you deploy a new version of our deployment,\nthe `{{ build-image.image }}` variable is dynamically populated with the relevant values.\n\n<Note>\n  **Docker step**\n\n  The most commonly used build step is `prefect_docker.deployments.steps.build_docker_image` which produces both the `image_name` and `tag` fields.\n</Note>\n\nA `prefect.yaml` file can have multiple deployment configurations that control the behavior of several deployments.\nYou can manage these deployments independently of one another, allowing you to deploy the same flow with different\nconfigurations in the same codebase.\n\n## Work with multiple deployments with prefect.yaml\n\nPrefect supports multiple deployment declarations within the `prefect.yaml` file. This method of declaring multiple\ndeployments supports version control for all deployments through a single command.\n\nAdd new deployment declarations to the `prefect.yaml` file with a new entry to the `deployments` list.\nEach deployment declaration must have a unique `name` field to select deployment declarations when using the\n`prefect deploy` command.\n\n<Warning>\n  When using a `prefect.yaml` file that is in another directory or differently named, the value for\n  the deployment `entrypoint` must be relative to the root directory of the project.\n</Warning>\n\nFor example, consider the following `prefect.yaml` file:\n\n```yaml  theme={null}\nbuild: ...\npush: ...\npull: ...\n\ndeployments:\n  - name: deployment-1\n    entrypoint: flows/hello.py:my_flow\n    parameters:\n        number: 42,\n        message: Don't panic!\n    work_pool:\n        name: my-process-work-pool\n        work_queue_name: primary-queue\n\n  - name: deployment-2\n    entrypoint: flows/goodbye.py:my_other_flow\n    work_pool:\n        name: my-process-work-pool\n        work_queue_name: secondary-queue\n\n  - name: deployment-3\n    entrypoint: flows/hello.py:yet_another_flow\n    work_pool:\n        name: my-docker-work-pool\n        work_queue_name: tertiary-queue\n```\n\nThis file has three deployment declarations, each referencing a different flow. Each deployment declaration has a unique `name`\nfield and can be deployed individually with the `--name` flag when deploying.\n\nFor example, to deploy `deployment-1`, run:\n\n```bash  theme={null}\nprefect deploy --name deployment-1\n```\n\nTo deploy multiple deployments, provide multiple `--name` flags:\n\n```bash  theme={null}\nprefect deploy --name deployment-1 --name deployment-2\n```\n\nTo deploy multiple deployments with the same name, prefix the deployment name with its flow name:\n\n```bash  theme={null}\nprefect deploy --name my_flow/deployment-1 --name my_other_flow/deployment-1\n```\n\nTo deploy all deployments, use the `--all` flag:\n\n```bash  theme={null}\nprefect deploy --all\n```\n\nTo deploy deployments that match a pattern, run:\n\n```bash  theme={null}\nprefect deploy -n my-flow/* -n *dev/my-deployment -n dep*prod\n```\n\nThe above command deploys:\n\n* all deployments from the flow `my-flow`\n* all flows ending in `dev` with a deployment named\n  `my-deployment`\n* all deployments starting with `dep` and ending in `prod`.\n\n### Non-interactive deployment\n\nFor CI/CD pipelines and automated environments, use the `--no-prompt` flag to skip interactive prompts:\n\n```bash  theme={null}\nprefect --no-prompt deploy --name my-deployment\n```\n\nThis prevents the command from hanging on prompts and will fail clearly if required information is missing.\n\n<Note>\n  **CLI Options When deploying multiple deployments**\n\n  When deploying more than one deployment with a single `prefect deploy` command, any additional attributes provided are ignored.\n\n  To provide overrides to a deployment through the CLI, you must deploy that deployment individually.\n</Note>\n\n### Reuse configuration across deployments\n\nBecause a `prefect.yaml` file is a standard YAML file, you can use [YAML aliases](https://yaml.org/spec/1.2.2/#71-alias-nodes)\nto reuse configuration across deployments.\n\nThis capability allows multiple deployments to share the work pool configuration, deployment actions, or other\nconfigurations.\n\nDeclare a YAML alias with the `&{alias_name}` syntax and insert that alias elsewhere in the file with the `*{alias_name}`\nsyntax. When aliasing YAML maps, you can override specific fields of the aliased map with the `<<: *{alias_name}` syntax and\nadding additional fields below.\n\nWe recommend adding a `definitions` section to your `prefect.yaml` file at the same level as the `deployments` section to store your\naliases.\n\nFor example:\n\n```yaml  theme={null}\nbuild: ...\npush: ...\npull: ...\n\ndefinitions:\n    work_pools:\n        my_docker_work_pool: &my_docker_work_pool\n            name: my-docker-work-pool\n            work_queue_name: default\n            job_variables:\n                image: \"{{ build-image.image }}\"\n    schedules:\n        every_ten_minutes: &every_10_minutes\n            interval: 600\n    actions:\n        docker_build: &docker_build\n            - prefect_docker.deployments.steps.build_docker_image: &docker_build_config\n                id: build-image\n                requires: prefect-docker>=0.3.0\n                image_name: my-example-image\n                tag: dev\n                dockerfile: auto\n\n        docker_push: &docker_push\n            - prefect_docker.deployments.steps.push_docker_image: &docker_push_config\n                requires: prefect-docker>=0.6.0\n                image_name: my-example-image\n                tag: dev\n                credentials: \"{{ prefect.blocks.docker-registry-credentials.dev-registry }}\"\n\ndeployments:\n  - name: deployment-1\n    entrypoint: flows/hello.py:my_flow\n    schedule: *every_10_minutes\n    parameters:\n        number: 42,\n        message: Don't panic!\n    work_pool: *my_docker_work_pool\n    build: *docker_build # Uses the full docker_build action with no overrides\n    push: *docker_push\n\n  - name: deployment-2\n    entrypoint: flows/goodbye.py:my_other_flow\n    work_pool: *my_docker_work_pool\n    build:\n        - prefect_docker.deployments.steps.build_docker_image:\n            <<: *docker_build_config # Uses the docker_build_config alias and overrides the dockerfile field\n            dockerfile: Dockerfile.custom\n    push: *docker_push\n\n  - name: deployment-3\n    entrypoint: flows/hello.py:yet_another_flow\n    schedule: *every_10_minutes\n    work_pool:\n        name: my-process-work-pool\n        work_queue_name: primary-queue\n\n```\n\nIn the above example, YAML aliases reuse work pool, schedule, and build configuration across multiple deployments:\n\n* `deployment-1` and `deployment-2` use the same work pool configuration\n* `deployment-1` and `deployment-3` use the same schedule\n* `deployment-1` and `deployment-2` use the same build deployment action, but `deployment-2` overrides the `dockerfile` field to use a custom Dockerfile\n\n## Deployment declaration reference\n\n### Deployment fields\n\nThese are fields you can add to each deployment declaration.\n\n| Property                                                | Description                                                                                                                                                                                                                         |\n| ------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `name`                                                  | The name to give to the created deployment. Used with the `prefect deploy` command to create or update specific deployments.                                                                                                        |\n| `version`                                               | An optional version for the deployment.                                                                                                                                                                                             |\n| `tags`                                                  | A list of strings to assign to the deployment as tags.                                                                                                                                                                              |\n| <span class=\"no-wrap\">`description`</span>              | An optional description for the deployment.                                                                                                                                                                                         |\n| `schedule`                                              | An optional [schedule](/v3/how-to-guides/deployments/create-schedules) to assign to the deployment. Fields for this section are documented in the [Schedule Fields](#schedule-fields) section.                                      |\n| `concurrency_limit`                                     | An optional [deployment concurrency limit](/v3/deploy/index#concurrency-limiting). Fields for this section are documented in the [Concurrency Limit Fields](#concurrency-limit-fields) section.                                     |\n| `triggers`                                              | An optional array of [triggers](/v3/how-to-guides/automations/creating-deployment-triggers) to assign to the deployment                                                                                                             |\n| `entrypoint`                                            | Required path to the `.py` file containing the flow you want to deploy (relative to the root directory of your development folder) combined with the name of the flow function. In the format `path/to/file.py:flow_function_name`. |\n| `parameters`                                            | Optional default values to provide for the parameters of the deployed flow. Should be an object with key/value pairs.                                                                                                               |\n| <span class=\"no-wrap\">`enforce_parameter_schema`</span> | Boolean flag that determines whether the API should validate the parameters passed to a flow run against the parameter schema generated for the deployed flow.                                                                      |\n| `work_pool`                                             | Information of where to schedule flow runs for the deployment. Fields for this section are documented in the [Work Pool Fields](#work-pool-fields) section.                                                                         |\n\n### Schedule fields\n\nThese are fields you can add to a deployment declaration's `schedule` section.\n\n| Property                                   | Description                                                                                                                                                                                                              |\n| ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `interval`                                 | Number of seconds indicating the time between flow runs. Cannot use them in conjunction with `cron` or `rrule`.                                                                                                          |\n| <span class=\"no-wrap\">`anchor_date`</span> | Datetime string indicating the starting or \"anchor\" date to begin the schedule. If no `anchor_date` is supplied, the current UTC time is used. Can only use with `interval`.                                             |\n| `timezone`                                 | String name of a time zone, used to enforce localization behaviors like DST boundaries. See the [IANA Time Zone Database](https://www.iana.org/time-zones) for valid time zones.                                         |\n| `cron`                                     | A valid cron string. Cannot use in conjunction with `interval` or `rrule`.                                                                                                                                               |\n| `day_or`                                   | Boolean indicating how croniter handles day and day\\_of\\_week entries. Must use with `cron`. Defaults to `True`.                                                                                                         |\n| `rrule`                                    | String representation of an RRule schedule. See the [`rrulestr` examples](https://dateutil.readthedocs.io/en/stable/rrule.html#rrulestr-examples) for syntax. Cannot used them in conjunction with `interval` or `cron`. |\n\n### Concurrency limit fields\n\nThese are fields you can add to a deployment declaration's `concurrency_limit` section.\n\n| Property             | Description                                                                                                                            |\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\n| `limit`              | The maximum number of concurrent flow runs for the deployment.                                                                         |\n| `collision_strategy` | Configure the behavior for runs once the concurrency limit is reached. Options are `ENQUEUE`, and `CANCEL_NEW`. Defaults to `ENQUEUE`. |\n\n### Work pool fields\n\nThese are fields you can add to a deployment declaration's `work_pool` section.\n\n| Property                                       | Description                                                                                                                                                                                                  |\n| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `name`                                         | The name of the work pool to schedule flow runs in for the deployment.                                                                                                                                       |\n| <span class=\"no-wrap\">`work_queue_name`</span> | The name of the work queue within the specified work pool to schedule flow runs in for the deployment. If not provided, the default queue for the specified work pool is used.                               |\n| `job_variables`                                | Values used to override the default values in the specified work pool's [base job template](/v3/concepts/work-pools/#base-job-template). Maps directly to a created deployments `infra_overrides` attribute. |\n\n### Deployment mechanics\n\nAnytime you run `prefect deploy` in a directory that contains a `prefect.yaml` file, the following actions take place in order:\n\n* The `prefect.yaml` file load. First, the `build` section loads and all variable and block references resolve. The steps then run in the order provided.\n* Next, the `push` section loads and all variable and block references resolve; the steps within this section then run in the order provided.\n* Next, the `pull` section is templated with any step outputs but *is not run*. Block references are *not* hydrated for security purposes: they are always resolved at runtime.\n* Next, all variable and block references resolve with the deployment declaration. All flags provided through the `prefect deploy` CLI are then overlaid on the values loaded from the file.\n* The final step occurs when the fully realized deployment specification is registered with the Prefect API.\n\n<Tip>\n  **Deployment instruction overrides**\n\n  The `build`, `push`, and `pull` sections in deployment definitions take precedence over the corresponding sections above them in\n  `prefect.yaml`.\n</Tip>\n\nEach time a step runs, the following actions take place in order:\n\n* The step's inputs and block / variable references resolve.\n* The step's function is imported; if it cannot be found, the special `requires` keyword installs the necessary packages.\n* The step's function is called with the resolved inputs.\n* The step's output is returned and used to resolve inputs for subsequent steps.\n\n## Update a deployment\n\nTo update a deployment, make any desired changes to the `prefect.yaml` file, and run `prefect deploy`. Running just this command will prompt you to select a deployment interactively, or you may specify the deployment to update with `--name your-deployment`.\n\n## Further reading\n\nNow that you are familiar with creating deployments, you can explore infrastructure options for running your deployments:\n\n* [Managed work pools](/v3/how-to-guides/deployment_infra/managed/)\n* [Push work pools](/v3/how-to-guides/deployment_infra/serverless/)\n* [Kubernetes work pools](/v3/how-to-guides/deployment_infra/kubernetes/)",
  "content_length": 35295
}