{
  "title": "States",
  "source_url": "https://docs-3.prefect.io/v3/concepts/states",
  "content": "Prefect states contain information about the status of a flow or task run.\n\nStates are rich objects that contain information about the status of a particular [task](/v3/develop/write-tasks)\nrun or [flow](/v3/develop/write-flows/) run.\n\nYou can learn many things about a task or flow by examining its current state or the\nhistory of its states. For example, you might observe that a given run:\n\n* is `Scheduled` to run for the third time in an hour\n* is `Late` because the associated worker process is not responding\n* was `Scheduled` to run, but later `Cancelled` via button in the UI\n* was `Cached` from a previous run instead of `Running` again\n* has `Completed` after `Running` among its fellow task runs\n* ended up `Failed` because Claude left pydantic 1.x syntax in your code\n* ended up `Crashed` because you Ctrl-C'd the process\n\n<Note>\n  **Only runs have states**:\n  Flows and tasks are templates that describe what a system does;\n  only when we **run** the system does it also take on a state.\n</Note>\n\n## State types\n\nPrefect states have names and types.\nA state's name is often, but not always, synonymous with its type. For example, a task run\nthat is running for the first time has a state with the name Running and the type `RUNNING`. However, if the task retries,\nthat same task run will have the name Retrying and the type `RUNNING`.\n\nState *types* drive orchestration logic, whereas state *names* provide visual bookkeeping.\n\nThe full list of states and state types includes:\n\n| Name                                                   | Type         | Terminal? | Description                                                                                                |\n| ------------------------------------------------------ | ------------ | --------- | ---------------------------------------------------------------------------------------------------------- |\n| `Scheduled`                                            | `SCHEDULED`  | No        | The run will begin at a particular time in the future.                                                     |\n| `Late`                                                 | `SCHEDULED`  | No        | The run's scheduled start time has passed, but it has not transitioned to PENDING (15 seconds by default). |\n| <span class=\"no-wrap\">`AwaitingRetry`</span>           | `SCHEDULED`  | No        | The run did not complete successfully because of a code issue and had remaining retry attempts.            |\n| <span class=\"no-wrap\">`AwaitingConcurrencySlot`</span> | `SCHEDULED`  | No        | The run is waiting to occupy a concurrency slot prior to submission.                                       |\n| `Resuming`                                             | `SCHEDULED`  | No        | The run is scheduled to resume execution.                                                                  |\n| `Pending`                                              | `PENDING`    | No        | The run has been submitted to execute, but is waiting on necessary preconditions to be satisfied.          |\n| `Running`                                              | `RUNNING`    | No        | The run code is currently executing.                                                                       |\n| `Retrying`                                             | `RUNNING`    | No        | The run code is currently executing after previously not completing successfully.                          |\n| `Paused`                                               | `PAUSED`     | No        | The run code has stopped executing until it receives manual approval to proceed.                           |\n| `Suspended`                                            | `PAUSED`     | No        | The run code has stopped executing and the process has exited.                                             |\n| `Cancelling`                                           | `CANCELLING` | No        | The infrastructure on which the code was running is being cleaned up.                                      |\n| `Cancelled`                                            | `CANCELLED`  | Yes       | The run did not complete because a user determined that it should not.                                     |\n| `Completed`                                            | `COMPLETED`  | Yes       | The run completed successfully.                                                                            |\n| `Cached`                                               | `COMPLETED`  | Yes       | The run result was loaded from a previously cached value.                                                  |\n| `RolledBack`                                           | `COMPLETED`  | Yes       | The run completed successfully but the transaction rolled back and executed rollback hooks.                |\n| `Failed`                                               | `FAILED`     | Yes       | The run did not complete because of a code issue and had no remaining retry attempts.                      |\n| `TimedOut`                                             | `FAILED`     | Yes       | The run did not complete because it exceeded its time out.                                                 |\n| `Crashed`                                              | `CRASHED`    | Yes       | The run did not complete because of an infrastructure issue.                                               |\n\n## State transitions\n\nWhen a flow run changes states, you can often tell if it is behaving normally or not.\nHere are some common state transitions and what they mean:\n\n|   | From      | To        | Triggered By                        | Explanation                                                                                                                                                                                                                                            |\n| - | --------- | --------- | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ✅ | None      | Scheduled | Manual run, automation, or schedule | A flow run has been created and scheduled for future execution.                                                                                                                                                                                        |\n| ✅ | Scheduled | Pending   | Worker                              | A worker is attempting to start the infrastructure for your flow run.                                                                                                                                                                                  |\n| ⛔ | Scheduled | Late      | Cloud or self-hosted server         | Typically means that a worker did not pick up the run because 1) no workers are healthy, 2) workers are not polling the right work pool or work queue, or 3) workers are concurrency limited.                                                          |\n| ✅ | Pending   | Running   | Worker                              | The infrastructure was provisioned and the flow is running                                                                                                                                                                                             |\n| ⛔ | Pending   | Crashed   | Worker or runner                    | Something went wrong. Some possibilities are 1) the worker could have failed to create the infrastructure, 2) the code is not present in storage or the worker failed to authenticate, or 3) the code has missing or broken imports, or syntax errors. |\n| ✅ | Running   | Completed | Flow run                            | The flow completed successfully.                                                                                                                                                                                                                       |\n| ⛔ | Running   | Failed    | Flow run                            | This usually means that your code raised an exception, check the flow run logs.                                                                                                                                                                        |\n| ⛔ | Running   | Crashed   | Worker or flow run                  | Probably not a raised exception in your code, but could be an infrastructure issue such as 1) an out of memory error, 2) an evicted pod, or 3) a timeout.                                                                                              |\n\n## Final state determination\n\nThe final state of a flow or task run depends on a number of factors; generally speaking there are three categories of terminal states:\n\n* `COMPLETED`: a run in any `COMPLETED` state did not encounter any errors or exceptions and returned successfully\n* `FAILED`: a run in any `FAILED` state encountered an error during execution, such as a raised exception\n* `CRASHED`: a run in any `CRASHED` state was interrupted by an OS signal such as a `KeyboardInterrupt` or `SIGTERM`\n\nThe flow of state transitions can be visualized here:\n\n<Note>\n  States are represented by their name, with boxes behind states clarifying their underlying type. Dotted lines lead to terminal states.\n</Note>\n\n```mermaid  theme={null}\n%%{\n  init: {\n    'theme': 'neutral',\n    'flowchart': {\n      'curve' : 'linear',\n      'rankSpacing': 80,\n      'nodeSpacing': 70,\n      'width': 5\n    }\n  }\n}%%\n\nflowchart TD\n    %% Style definitions\n    classDef scheduled fill:#fcd14edb,stroke:#fcd14edb\n    classDef pending fill:#A99FADdb,stroke:#A99FAD\n    classDef running fill:#1860f2db,stroke:#1860f2db\n    classDef paused fill:#a99faddb,stroke:#a99faddb\n    classDef completed fill:#2ac769db,stroke:#2ac769db,stroke-width:2px\n    classDef failed fill:#fb4e4ef5,stroke:#fb4e4ef5,stroke-width:2px\n    classDef crashed fill:#f97316db,stroke:#f97316db,stroke-width:2px\n    classDef cancelled fill:#3d3d3da8,stroke:#3d3d3da8,stroke-width:2px\n    classDef awaiting_concurrency_slot fill:#ede7f6,stroke:#4527a0,stroke-width:2px\n\n    %% States\n    subgraph scheduled_type[Scheduled]\n    Scheduled[Scheduled]:::scheduled\n    Late[Late]:::scheduled\n    AwaitingConcurrencySlot[AwaitingConcurrencySlot]:::scheduled\n    end\n\n    Running[Running]:::running\n\n    Failed[Failed]:::failed\n\n    subgraph scheduled_type2[Scheduled]\n    AwaitingRetry[Awaiting Retry]:::scheduled\n    end\n\n    subgraph running_type[Running]\n    Retrying[Retrying]:::running\n    end\n\n    Pending[Pending]:::pending\n\n\n\n    Cancelling[Cancelling]:::cancelled\n    Cancelled[Cancelled]:::cancelled\n    \n    Cached[Cached]:::completed\n    RolledBack[Rolled Back]:::completed\n    Crashed[Crashed]:::crashed\n\n    Paused[Paused]:::paused\n\n    Completed[Completed]:::completed\n\n    %% Connections\n    Scheduled --> |Scheduled start time passes without entering Pending| Late\n    Scheduled --> |Worker/Runner successfully submits run| Pending\n    Scheduled --> |Worker encounters concurrency limit| AwaitingConcurrencySlot\n\n    AwaitingConcurrencySlot --> Pending\n    \n    Late -->  Pending\n\n    Pending --> |Preconditions met| Running    \n\n\n    Running -.-> |Success| Completed\n\n    %%problematic section:\n    Retrying -.-> |Success| Completed\n    Failed --> |Retries remaining| AwaitingRetry\n    AwaitingRetry --> |Retry attempt| Retrying\n    Retrying -.-> |Failure| Failed\n    \n    \n\n    Running -.-> |Error| Failed\n\n    Running -.-> |Infrastructure issue| Crashed\n    Running -.-> |Cache hit| Cached\n    Running -.-> |Transaction rollback| RolledBack\n    Running --> |User cancels| Cancelling\n\n    Running --> |Manual pause| Paused\n    Paused --> |Resume| Running\n    \n    Cancelling -.-> |Cleanup complete| Cancelled\n\n\n\n```\n\n### Task return values\n\nA task will be placed into a `Completed` state if it returns  *any* Python object, with one exception:\nif a task explicitly returns a Prefect `Failed` state, the task will be marked `Failed`.\n\n```python  theme={null}\nfrom prefect import task, flow\nfrom prefect.states import Completed, Failed\n\n\n@task\ndef toggle_task(fail: bool):\n    if fail:\n        return Failed(message=\"I was instructed to fail.\")\n    else:\n        return Completed(message=\"I was instructed to succeed.\")\n\n\n@flow\ndef example():\n    # this run will be set to a `Failed` state\n    state_one = toggle_task(fail=True)\n\n    # this run will be set to a `Completed` state\n    state_two = toggle_task(fail=False)\n\n    # similarly, the flow run will fail because we return a `Failed` state\n    return state_one, state_two\n```\n\nYou can also access state objects directly within a flow through the `return_state` flag:\n\n```python  theme={null}\nfrom prefect import flow, task\n\n\n@task\ndef add_one(x):\n    return x + 1\n\n\n@flow\ndef my_flow():\n    result = add_one(1)\n    assert isinstance(result, int) and result == 2\n\n    state = add_one(1, return_state=True)\n    assert state.is_completed() is True\n    assert state.result() == 2\n```\n\n<Tip>\n  Returning a `State` via `return_state=True` is useful when you want to conditionally respond to the terminal states of a task or flow. For example, `if state.is_failed(): ...`.\n</Tip>\n\n### Flow return values\n\nThe final state of a flow is determined by its ***return value***. The following rules apply:\n\n* If an exception is raised directly in the flow function, the flow run is marked as `FAILED`.\n* If a flow returns a manually created state, it is used as the state of the final flow run. This allows for manual determination of final state.\n* If a flow returns an iterable of states, the presence of *any* `FAILED` state will cause the run to be marked as `FAILED`.\n\nIn *any other situation* in which the flow returns without error, it will be marked as `COMPLETED`.\n\n<Warning>\n  If you manipulate states programmatically, you can create situations in which tasks\n  within a flow can fail and not cause flow run failure.\n  For example:\n\n  ```python  theme={null}\n  from prefect import flow, task \n\n\n  @task \n  def add_one(x):\n      return x + 1\n\n\n  @flow \n  def my_flow():\n      # avoided raising an exception via `return_state=True`\n      state = add_one(\"1\", return_state=True)\n      assert state.is_failed()\n\n      # the flow function returns successfully!\n      return\n  ```\n\n  If `state` were returned from the flow function, the run would be marked as `FAILED`.\n</Warning>\n\n## State change hooks\n\nState change hooks execute code in response to ***client side*** changes in flow or task run states, enabling you to define actions for\nspecific state transitions in a workflow.\n\nState hooks have the following signature:\n\n```python  theme={null}\nfrom prefect import Task, Flow\nfrom prefect.states import State\nfrom prefect.client.schemas.objects import TaskRun, FlowRun\n\ndef my_task_state_hook(task: Task, run: TaskRun, state: State) -> None:\n    ...\n\ndef my_flow_state_hook(flow: Flow, run: FlowRun, state: State) -> None:\n    ...\n```\n\nState change hooks are versatile, allowing you to specify multiple state change hooks for the same state transition,\nor to use the same state change hook for different transitions.\n\n### Further reading\n\n* See examples of [how to execute code in response to entering states](/v3/how-to-guides/workflows/state-change-hooks) in your flows and tasks.",
  "content_length": 15430
}