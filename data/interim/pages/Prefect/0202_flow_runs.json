{
  "title": "flow_runs",
  "source_url": "https://docs-3.prefect.io/v3/api-ref/python/prefect-flow_runs",
  "content": "# `prefect.flow_runs`\n\n## Functions\n\n### `wait_for_flow_run` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/flow_runs.py#L57\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nwait_for_flow_run(flow_run_id: UUID, timeout: int | None = 10800, poll_interval: int | None = None, client: 'PrefectClient | None' = None, log_states: bool = False) -> FlowRun\n```\n\nWaits for the prefect flow run to finish and returns the FlowRun\n\n**Args:**\n\n* `flow_run_id`: The flow run ID for the flow run to wait for.\n* `timeout`: The wait timeout in seconds. Defaults to 10800 (3 hours).\n* `poll_interval`: Deprecated; polling is no longer used to wait for flow runs.\n* `client`: Optional Prefect client. If not provided, one will be injected.\n* `log_states`: If True, log state changes. Defaults to False.\n\n**Returns:**\n\n* The finished flow run.\n\n**Raises:**\n\n* `prefect.exceptions.FlowWaitTimeout`: If flow run goes over the timeout.\n\n**Examples:**\n\nCreate a flow run for a deployment and wait for it to finish:\n\n```python  theme={null}\nimport asyncio\n\nfrom prefect.client.orchestration import get_client\nfrom prefect.flow_runs import wait_for_flow_run\n\nasync def main():\n    async with get_client() as client:\n        flow_run = await client.create_flow_run_from_deployment(deployment_id=\"my-deployment-id\")\n        flow_run = await wait_for_flow_run(flow_run_id=flow_run.id)\n        print(flow_run.state)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n```\n\nTrigger multiple flow runs and wait for them to finish:\n\n```python  theme={null}\nimport asyncio\n\nfrom prefect.client.orchestration import get_client\nfrom prefect.flow_runs import wait_for_flow_run\n\nasync def main(num_runs: int):\n    async with get_client() as client:\n        flow_runs = [\n            await client.create_flow_run_from_deployment(deployment_id=\"my-deployment-id\")\n            for _\n            in range(num_runs)\n        ]\n        coros = [wait_for_flow_run(flow_run_id=flow_run.id) for flow_run in flow_runs]\n        finished_flow_runs = await asyncio.gather(*coros)\n        print([flow_run.state for flow_run in finished_flow_runs])\n\nif __name__ == \"__main__\":\n    asyncio.run(main(num_runs=10))\n\n```\n\n### `pause_flow_run` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/flow_runs.py#L184\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\npause_flow_run(wait_for_input: Type[T] | None = None, timeout: int = 3600, poll_interval: int = 10, key: str | None = None) -> T | None\n```\n\nPauses the current flow run by blocking execution until resumed.\n\nWhen called within a flow run, execution will block and no downstream tasks will\nrun until the flow is resumed. Task runs that have already started will continue\nrunning. A timeout parameter can be passed that will fail the flow run if it has not\nbeen resumed within the specified time.\n\n**Args:**\n\n* `timeout`: the number of seconds to wait for the flow to be resumed before\n  failing. Defaults to 1 hour (3600 seconds). If the pause timeout exceeds\n  any configured flow-level timeout, the flow might fail even after resuming.\n* `poll_interval`: The number of seconds between checking whether the flow has been\n  resumed. Defaults to 10 seconds.\n* `key`: An optional key to prevent calling pauses more than once. This defaults to\n  the number of pauses observed by the flow so far, and prevents pauses that\n  use the \"reschedule\" option from running the same pause twice. A custom key\n  can be supplied for custom pausing behavior.\n* `wait_for_input`: a subclass of `RunInput` or any type supported by\n  Pydantic. If provided when the flow pauses, the flow will wait for the\n  input to be provided before resuming. If the flow is resumed without\n  providing the input, the flow will fail. If the flow is resumed with the\n  input, the flow will resume and the input will be loaded and returned\n  from this function.\n\nExample:\n\n```python  theme={null}\n@task\ndef task_one():\n    for i in range(3):\n        sleep(1)\n\n@flow\ndef my_flow():\n    terminal_state = task_one.submit(return_state=True)\n    if terminal_state.type == StateType.COMPLETED:\n        print(\"Task one succeeded! Pausing flow run..\")\n        pause_flow_run(timeout=2)\n    else:\n        print(\"Task one failed. Skipping pause flow run..\")\n```\n\n### `suspend_flow_run` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/flow_runs.py#L355\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsuspend_flow_run(wait_for_input: Type[T] | None = None, flow_run_id: UUID | None = None, timeout: int | None = 3600, key: str | None = None, client: 'PrefectClient | None' = None) -> T | None\n```\n\nSuspends a flow run by stopping code execution until resumed.\n\nWhen suspended, the flow run will continue execution until the NEXT task is\norchestrated, at which point the flow will exit. Any tasks that have\nalready started will run until completion. When resumed, the flow run will\nbe rescheduled to finish execution. In order suspend a flow run in this\nway, the flow needs to have an associated deployment and results need to be\nconfigured with the `persist_result` option.\n\n**Args:**\n\n* `flow_run_id`: a flow run id. If supplied, this function will attempt to\n  suspend the specified flow run. If not supplied will attempt to\n  suspend the current flow run.\n* `timeout`: the number of seconds to wait for the flow to be resumed before\n  failing. Defaults to 1 hour (3600 seconds). If the pause timeout\n  exceeds any configured flow-level timeout, the flow might fail even\n  after resuming.\n* `key`: An optional key to prevent calling suspend more than once. This\n  defaults to a random string and prevents suspends from running the\n  same suspend twice. A custom key can be supplied for custom\n  suspending behavior.\n* `wait_for_input`: a subclass of `RunInput` or any type supported by\n  Pydantic. If provided when the flow suspends, the flow will remain\n  suspended until receiving the input before resuming. If the flow is\n  resumed without providing the input, the flow will fail. If the flow is\n  resumed with the input, the flow will resume and the input will be\n  loaded and returned from this function.\n\n### `resume_flow_run` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/flow_runs.py#L463\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nresume_flow_run(flow_run_id: UUID, run_input: dict[str, Any] | None = None) -> None\n```\n\nResumes a paused flow.\n\n**Args:**\n\n* `flow_run_id`: the flow\\_run\\_id to resume\n* `run_input`: a dictionary of inputs to provide to the flow run.",
  "content_length": 6783
}