{
  "title": "base",
  "source_url": "https://docs-3.prefect.io/v3/api-ref/python/prefect-client-base",
  "content": "# `prefect.client.base`\n\n## Functions\n\n### `app_lifespan_context` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L63\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\napp_lifespan_context(app: ASGIApp) -> AsyncGenerator[None, None]\n```\n\nA context manager that calls startup/shutdown hooks for the given application.\n\nLifespan contexts are cached per application to avoid calling the lifespan hooks\nmore than once if the context is entered in nested code. A no-op context will be\nreturned if the context for the given application is already being managed.\n\nThis manager is robust to concurrent access within the event loop. For example,\nif you have concurrent contexts for the same application, it is guaranteed that\nstartup hooks will be called before their context starts and shutdown hooks will\nonly be called after their context exits.\n\nA reference count is used to support nested use of clients without running\nlifespan hooks excessively. The first client context entered will create and enter\na lifespan context. Each subsequent client will increment a reference count but will\nnot create a new lifespan context. When each client context exits, the reference\ncount is decremented. When the last client context exits, the lifespan will be\nclosed.\n\nIn simple nested cases, the first client context will be the one to exit the\nlifespan. However, if client contexts are entered concurrently they may not exit\nin a consistent order. If the first client context was responsible for closing\nthe lifespan, it would have to wait until all other client contexts to exit to\navoid firing shutdown hooks while the application is in use. Waiting for the other\nclients to exit can introduce deadlocks, so, instead, the first client will exit\nwithout closing the lifespan context and reference counts will be used to ensure\nthe lifespan is closed once all of the clients are done.\n\n### `determine_server_type` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L672\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ndetermine_server_type() -> ServerType\n```\n\nDetermine the server type based on the current settings.\n\n**Returns:**\n\n* * `ServerType.EPHEMERAL` if the ephemeral server is enabled\n* * `ServerType.SERVER` if a API URL is configured and it is not a cloud URL\n* * `ServerType.CLOUD` if an API URL is configured and it is a cloud URL\n* * `ServerType.UNCONFIGURED` if no API URL is configured and ephemeral mode is\n    not enabled\n\n## Classes\n\n### `ASGIApp` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L58\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n### `PrefectResponse` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L146\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nA Prefect wrapper for the `httpx.Response` class.\n\nProvides more informative error messages.\n\n**Methods:**\n\n#### `from_httpx_response` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L166\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nfrom_httpx_response(cls: type[Self], response: httpx.Response) -> Response\n```\n\nCreate a `PrefectResponse` from an `httpx.Response`.\n\nBy changing the `__class__` attribute of the Response, we change the method\nresolution order to look for methods defined in PrefectResponse, while leaving\neverything else about the original Response instance intact.\n\n#### `raise_for_status` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L153\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nraise_for_status(self) -> Response\n```\n\nRaise an exception if the response contains an HTTPStatusError.\n\nThe `PrefectHTTPStatusError` contains useful additional information that\nis not contained in the `HTTPStatusError`.\n\n### `PrefectHttpxAsyncClient` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L179\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nA Prefect wrapper for the async httpx client with support for retry-after headers\nfor the provided status codes (typically 429, 502 and 503).\n\nAdditionally, this client will always call `raise_for_status` on responses.\n\nFor more details on rate limit headers, see:\n[Configuring Cloudflare Rate Limiting](https://support.cloudflare.com/hc/en-us/articles/115001635128-Configuring-Rate-Limiting-from-UI)\n\n**Methods:**\n\n#### `send` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L335\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsend(self, request: Request, *args: Any, **kwargs: Any) -> Response\n```\n\nSend a request with automatic retry behavior for the following status codes:\n\n* 403 Forbidden, if the request failed due to CSRF protection\n* 408 Request Timeout\n* 429 CloudFlare-style rate limiting\n* 502 Bad Gateway\n* 503 Service unavailable\n* Any additional status codes provided in `PREFECT_CLIENT_RETRY_EXTRA_CODES`\n\n### `PrefectHttpxSyncClient` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L422\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nA Prefect wrapper for the async httpx client with support for retry-after headers\nfor the provided status codes (typically 429, 502 and 503).\n\nAdditionally, this client will always call `raise_for_status` on responses.\n\nFor more details on rate limit headers, see:\n[Configuring Cloudflare Rate Limiting](https://support.cloudflare.com/hc/en-us/articles/115001635128-Configuring-Rate-Limiting-from-UI)\n\n**Methods:**\n\n#### `send` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L578\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nsend(self, request: Request, *args: Any, **kwargs: Any) -> Response\n```\n\nSend a request with automatic retry behavior for the following status codes:\n\n* 403 Forbidden, if the request failed due to CSRF protection\n* 408 Request Timeout\n* 429 CloudFlare-style rate limiting\n* 502 Bad Gateway\n* 503 Service unavailable\n* Any additional status codes provided in `PREFECT_CLIENT_RETRY_EXTRA_CODES`\n\n### `ServerType` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/client/base.py#L665\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n**Methods:**\n\n#### `auto` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/collections.py#L69\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nauto() -> str\n```\n\nExposes `enum.auto()` to avoid requiring a second import to use `AutoEnum`",
  "content_length": 7164
}