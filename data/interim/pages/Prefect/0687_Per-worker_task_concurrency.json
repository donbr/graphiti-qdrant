{
  "title": "Per-worker task concurrency",
  "source_url": "https://docs-3.prefect.io/v3/examples/per-worker-task-concurrency",
  "content": "Use Global Concurrency Limits to control how many tasks can use a worker's local resources simultaneously.\n\n<a href=\"https://github.com/PrefectHQ/prefect/blob/main/examples/per_worker_task_concurrency.py\" target=\"_blank\">View on GitHub</a>\n\nWhen a worker runs multiple flow runs concurrently, those flow runs share the\nworker machine's resources—CPU, memory, GPU, local software. Some tasks may\nneed to limit how many can run at once to avoid overloading these resources.\n\n**The problem:** Using `--limit 1` on the worker forces entire flow runs to be\nsequential. But often only specific tasks need limits—other tasks could overlap.\n\n**The solution:** Use [Global Concurrency Limits](https://docs.prefect.io/v3/develop/global-concurrency-limits)\nwith worker-specific names. GCLs are coordinated by the Prefect server, so they\nwork across the separate subprocesses that each flow run executes in.\n\n## Example: Image processing with ML inference\n\nConsider a pipeline that processes images through an ML model:\n\n1. **Download image** — network-bound, can run many in parallel\n2. **Run ML model** — uses GPU memory, need to limit concurrent runs\n3. **Save results** — disk I/O, can run many in parallel\n\nWithout limits, if 5 flow runs hit the ML step simultaneously, they'd all try\nto load the model into GPU memory and crash. With per-worker limits, only 1-2\nrun at a time while others wait.\n\n## Setup\n\n```python  theme={null}\nimport os\nimport time\n\nfrom prefect import flow, get_run_logger, task\nfrom prefect.concurrency.sync import concurrency\n\n\ndef get_worker_id() -> str:\n    \"\"\"\n    Get worker identity from environment.\n\n    Set this when starting the worker:\n        WORKER_ID=gpu-1 prefect worker start --pool ml-pool\n    \"\"\"\n    return os.getenv(\"WORKER_ID\", \"default\")\n\n\n```\n\n## Tasks without limits\n\nThese tasks don't contend for limited resources, so they run freely.\n\n```python  theme={null}\n@task\ndef download_image(image_id: int) -> dict:\n    \"\"\"Download an image from storage. Network-bound, no local resource contention.\"\"\"\n    logger = get_run_logger()\n    logger.info(f\"Image {image_id}: downloading...\")\n    time.sleep(1)  # simulate download\n    return {\"image_id\": image_id, \"path\": f\"/tmp/image_{image_id}.jpg\"}\n\n\n@task\ndef save_results(data: dict) -> str:\n    \"\"\"Save processed results. Fast operation, no limits needed.\"\"\"\n    logger = get_run_logger()\n    logger.info(f\"Image {data['image_id']}: saving results...\")\n    time.sleep(0.5)\n    return f\"processed-{data['image_id']}\"\n\n\n```\n\n## Task with per-worker limit\n\nThis task uses a local resource (GPU) that can only handle limited concurrent\nusage. The limit is scoped to this worker so each machine has independent limits.\n\n```python  theme={null}\n@task\ndef run_ml_model(data: dict) -> dict:\n    \"\"\"\n    Run image through ML model.\n\n    GPU memory is limited—only 1-2 can run at once per worker machine.\n    Uses a Global Concurrency Limit scoped to this worker's identity.\n    \"\"\"\n    logger = get_run_logger()\n    worker_id = get_worker_id()\n    image_id = data[\"image_id\"]\n\n    # Limit key includes worker ID: each worker has its own limit\n    with concurrency(f\"gpu:{worker_id}\", occupy=1):\n        logger.info(f\"Image {image_id}: running ML inference (GPU)...\")\n        time.sleep(3)  # simulate model inference\n\n    return {**data, \"predictions\": [0.9, 0.1]}\n\n\n```\n\n## The flow\n\n```python  theme={null}\n@flow(log_prints=True)\ndef process_image(image_id: int = 1) -> str:\n    \"\"\"\n    Process an image through the ML pipeline.\n\n    When multiple instances run concurrently on the same worker:\n    - download and save tasks overlap freely\n    - run_ml_model tasks are limited by the per-worker GPU concurrency limit\n    \"\"\"\n    logger = get_run_logger()\n    logger.info(f\"Processing image {image_id} on worker '{get_worker_id()}'\")\n\n    image = download_image(image_id)\n    predictions = run_ml_model(image)\n    result = save_results(predictions)\n\n    return result\n\n\n```\n\n## Running the example\n\n### 1. Create a Global Concurrency Limit for each worker\n\nEach worker machine needs its own limit. The limit value controls how many\nML tasks can run simultaneously on that machine.\n\n```bash  theme={null}\n# GPU machine 1: allow 2 concurrent ML tasks\nprefect gcl create gpu:gpu-1 --limit 2\n\n# GPU machine 2: allow 2 concurrent ML tasks\nprefect gcl create gpu:gpu-2 --limit 2\n```\n\n### 2. Create work pool and deploy\n\n```bash  theme={null}\nprefect work-pool create ml-pool --type process\nprefect deploy --all\n```\n\n### 3. Start workers with unique IDs\n\nEach worker needs a unique ID that matches its GCL name:\n\n```bash  theme={null}\n# Machine 1\nWORKER_ID=gpu-1 prefect worker start --pool ml-pool --limit 10\n\n# Machine 2\nWORKER_ID=gpu-2 prefect worker start --pool ml-pool --limit 10\n```\n\nThe `--limit 10` allows up to 10 concurrent flow runs, but the GCL ensures\nonly 2 are in the ML step at any time.\n\n### 4. Submit jobs\n\n```bash  theme={null}\nfor i in {1..20}; do\n  prefect deployment run process-image/process-image --param image_id=$i --timeout 0\ndone\n```\n\n## What you'll see\n\nWith 10 concurrent flow runs on a worker:\n\n* **Download tasks** from all 10 start immediately and overlap\n* **ML tasks** queue up—only 2 run at a time (per the GCL limit)\n* **Save tasks** run as soon as their ML task completes\n\nFlow runs aren't blocked entirely—just the resource-intensive step is limited.\nThis maximizes throughput while protecting the GPU from overload.\n\n## Why this works\n\n1. **GCLs are server-coordinated** — The Prefect server tracks who holds what\n   limit. It doesn't matter that flow runs are separate processes.\n\n2. **Worker-specific names** — By including `worker_id` in the limit name,\n   each worker machine has independent limits. GPU-1's limit doesn't affect GPU-2.\n\n3. **Selective application** — Only the tasks that need limits acquire them.\n   Everything else runs at full concurrency.\n\n## Adapting this pattern\n\nThe same pattern works for any local resource constraint:\n\n* **Software licenses**: A tool that only allows N concurrent instances\n* **Memory-intensive processing**: Limit concurrent jobs to avoid OOM\n* **Disk I/O**: Limit concurrent writes to a local SSD\n* **Local services**: A sidecar database with connection limits\n\nJust change the limit name and value to match your constraint.\n\n## Related docs\n\n* [Global Concurrency Limits](https://docs.prefect.io/v3/develop/global-concurrency-limits)\n* [Workers](https://docs.prefect.io/v3/deploy/infrastructure-concepts/workers)\n\n```python  theme={null}\nif __name__ == \"__main__\":\n    process_image(image_id=1)\n\n```",
  "content_length": 6561
}