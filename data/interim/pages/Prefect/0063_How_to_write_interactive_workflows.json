{
  "title": "How to write interactive workflows",
  "source_url": "https://docs-3.prefect.io/v3/advanced/interactive",
  "content": "Flows can pause or suspend execution and automatically resume when they receive type-checked input in Prefect's UI.\nFlows can also send and receive type-checked input at any time while running—without pausing or suspending.\n\nThis guide explains how to use these features to build *interactive workflows*.\n\n## Pause or suspend a flow until it receives input\n\nYou can pause or suspend a flow until it receives input from a user in Prefect's UI. This is useful when you need to ask for\nadditional information or feedback before resuming a flow. These workflows are often called\n[human-in-the-loop](https://hai.stanford.edu/news/humans-loop-design-interactive-ai-systems) (HITL) systems.\n\n<Note>\n  **Human-in-the-loop interactivity**\n  Approval workflows that pause to ask a human to confirm whether a workflow should continue are very common in the business world.\n  Certain types of [machine learning training](https://link.springer.com/article/10.1007/s10462-022-10246-w) and artificial intelligence\n  workflows benefit from incorporating HITL design.\n</Note>\n\n### Wait for input\n\nTo receive input while paused or suspended use the `wait_for_input` parameter in the `pause_flow_run` or `suspend_flow_run` functions.\nThis parameter accepts one of the following:\n\n* A built-in type like `int` or `str`, or a built-in collection like `List[int]`\n* A `pydantic.BaseModel` subclass\n* A subclass of `prefect.input.RunInput`\n\n<Tip>\n  When to use a `RunModel` or `BaseModel` instead of a built-in type\"\n  There are a few reasons to use a `RunModel` or `BaseModel`. The first is that when you let Prefect automatically create one of these\n  classes for your input type, the field that users see in Prefect's UI when they click \"Resume\" on a flow run is named `value` and\n  has no help text to suggest what the field is. If you create a `RunInput` or `BaseModel`, you can change details like the field name,\n  help text, and default value, and users see those reflected in the \"Resume\" form.\n</Tip>\n\nThe simplest way to pause or suspend and wait for input is to pass a built-in type:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.flow_runs import pause_flow_run\nfrom prefect.logging import get_run_logger\n\n@flow\ndef greet_user():\n    logger = get_run_logger()\n\n    user = pause_flow_run(wait_for_input=str)\n\n    logger.info(f\"Hello, {user}!\")\n```\n\nIn this example, the flow run pauses until a user clicks the Resume button in the Prefect UI, enters a name, and submits the form.\n\n<Note>\n  **Types can you pass for `wait_for_input`**\n\n  When you pass a built-in type such as `int` as an argument for the `wait_for_input` parameter to `pause_flow_run` or `suspend_flow_run`,\n  Prefect automatically creates a Pydantic model containing one field annotated with the type you specified. This means you can use\n  [any type annotation that Pydantic accepts for model fields](https://docs.pydantic.dev/1.10/usage/types/) with these functions.\n</Note>\n\nInstead of a built-in type, you can pass in a `pydantic.BaseModel` class. This is useful if you already have a `BaseModel` you want to use:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.flow_runs import pause_flow_run\nfrom prefect.logging import get_run_logger\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n    age: int\n\n\n@flow\nasync def greet_user():\n    logger = get_run_logger()\n\n    user = await pause_flow_run(wait_for_input=User)\n\n    logger.info(f\"Hello, {user.name}!\")\n```\n\n<Note>\n  **`BaseModel` classes are upgraded to `RunInput` classes automatically**\n\n  When you pass a `pydantic.BaseModel` class as the `wait_for_input` argument to `pause_flow_run` or `suspend_flow_run`, Prefect\n  automatically creates a `RunInput` class with the same behavior as your `BaseModel` and uses that instead.\n\n  `RunInput` classes contain extra logic that allows flows to send and receive them at runtime. You shouldn't notice any difference.\n</Note>\n\nFor advanced use cases such as overriding how Prefect stores flow run inputs, create a `RunInput` class:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.logging import get_run_logger\nfrom prefect.input import RunInput\n\nclass UserInput(RunInput):\n    name: str\n    age: int\n\n    # Imagine overridden methods here.\n    def override_something(self, *args, **kwargs):\n        super().override_something(*args, **kwargs)\n\n@flow\nasync def greet_user():\n    logger = get_run_logger()\n\n    user = await pause_flow_run(wait_for_input=UserInput)\n\n    logger.info(f\"Hello, {user.name}!\")\n```\n\n### Provide initial data\n\nSet default values for fields in your model with the `with_initial_data` method. This is useful for providing default values\nfor the fields in your own `RunInput` class.\n\nExpanding on the example above, you can make the `name` field default to \"anonymous\":\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.logging import get_run_logger\nfrom prefect.input import RunInput\n\nclass UserInput(RunInput):\n    name: str\n    age: int\n\n@flow\nasync def greet_user():\n    logger = get_run_logger()\n\n    user_input = await pause_flow_run(\n        wait_for_input=UserInput.with_initial_data(name=\"anonymous\")\n    )\n\n    if user_input.name == \"anonymous\":\n        logger.info(\"Hello, stranger!\")\n    else:\n        logger.info(f\"Hello, {user_input.name}!\")\n```\n\nWhen a user sees the form for this input, the name field contains \"anonymous\" as the default.\n\n### Provide a description with runtime data\n\nYou can provide a dynamic, Markdown description that appears in the Prefect UI when the flow run pauses.\nThis feature enables context-specific prompts, enhancing clarity and user interaction. Building on the example above:\n\n```python  theme={null}\nfrom datetime import datetime\nfrom prefect import flow\nfrom prefect.flow_runs import pause_flow_run\nfrom prefect.logging import get_run_logger\nfrom prefect.input import RunInput\n\n\nclass UserInput(RunInput):\n    name: str\n    age: int\n\n\n@flow\nasync def greet_user():\n    logger = get_run_logger()\n    current_date = datetime.now().strftime(\"%B %d, %Y\")\n\n    description_md = f\"\"\"\n**Welcome to the User Greeting Flow!**\nToday's Date: {current_date}\n\nPlease enter your details below:\n- **Name**: What should we call you?\n- **Age**: Just a number, nothing more.\n\"\"\"\n\n    user_input = await pause_flow_run(\n        wait_for_input=UserInput.with_initial_data(\n            description=description_md, name=\"anonymous\"\n        )\n    )\n\n    if user_input.name == \"anonymous\":\n        logger.info(\"Hello, stranger!\")\n    else:\n        logger.info(f\"Hello, {user_input.name}!\")\n```\n\nWhen a user sees the form for this input, the given Markdown appears above the input fields.\n\n### Handle custom validation\n\nPrefect uses the fields and type hints on your `RunInput` or `BaseModel` class to validate the general structure of input your flow receives.\nIf you require more complex validation, use Pydantic [model\\_validators](https://docs.pydantic.dev/latest/concepts/validators/#model-validators).\n\n<Warning>\n  **Calling custom validation runs after the flow resumes**\n\n  Prefect transforms the type annotations in your `RunInput` or `BaseModel` class to a JSON schema and uses that schema in\n  the UI for client-side validation. However, custom validation requires running *Python* logic defined in your `RunInput` class.\n  Because of this, validation happens *after the flow resumes*, so you should handle it explicitly in your flow.\n  Continue reading for an example best practice.\n</Warning>\n\nThe following is an example `RunInput` class that uses a custom `model_validator`:\n\n```python  theme={null}\nfrom typing import Literal\n\nimport pydantic\n\nfrom prefect.input import RunInput\n\n\nclass ShirtOrder(RunInput):\n    size: Literal[\"small\", \"medium\", \"large\", \"xlarge\"]\n    color: Literal[\"red\", \"green\", \"black\"]\n\n    @pydantic.model_validator(mode=\"after\")\n    def validate_age(self):\n        if self.color == \"green\" and self.size == \"small\":\n            raise ValueError(\n                \"Green is only in-stock for medium, large, and XL sizes.\"\n            )\n\n        return self\n```\n\nIn the example, we use Pydantic's `model_validator` decorator to define custom validation for our `ShirtOrder` class.\nYou can use it in a flow like this:\n\n```python  theme={null}\nfrom typing import Literal\n\nimport pydantic\n\nfrom prefect import flow, pause_flow_run\nfrom prefect.input import RunInput\n\n\nclass ShirtOrder(RunInput):\n    size: Literal[\"small\", \"medium\", \"large\", \"xlarge\"]\n    color: Literal[\"red\", \"green\", \"black\"]\n\n    @pydantic.model_validator(mode=\"after\")\n    def validate_age(self):\n        if self.color == \"green\" and self.size == \"small\":\n            raise ValueError(\n                \"Green is only in-stock for medium, large, and XL sizes.\"\n            )\n\n        return self\n\n\n@flow\ndef get_shirt_order():\n    shirt_order = pause_flow_run(wait_for_input=ShirtOrder)\n```\n\nIf a user chooses any size and color combination other than `small` and `green`, the flow run resumes successfully.\nHowever, if the user chooses size `small` and color `green`, the flow run will resume, and `pause_flow_run` raises a\n`ValidationError` exception. This causes the flow run to fail and log the error.\n\nTo avoid a flow run failure, use a `while` loop and pause again if the `ValidationError` exception is raised:\n\n```python  theme={null}\nfrom typing import Literal\n\nimport pydantic\nfrom prefect import flow\nfrom prefect.flow_runs import pause_flow_run\nfrom prefect.logging import get_run_logger\nfrom prefect.input import RunInput\n\n\nclass ShirtOrder(RunInput):\n    size: Literal[\"small\", \"medium\", \"large\", \"xlarge\"]\n    color: Literal[\"red\", \"green\", \"black\"]\n\n    @pydantic.model_validator(mode=\"after\")\n    def validate_age(self):\n        if self.color == \"green\" and self.size == \"small\":\n            raise ValueError(\n                \"Green is only in-stock for medium, large, and XL sizes.\"\n            )\n\n        return self\n\n\n@flow\ndef get_shirt_order():\n    logger = get_run_logger()\n    shirt_order = None\n\n    while shirt_order is None:\n        try:\n            shirt_order = pause_flow_run(wait_for_input=ShirtOrder)\n        except pydantic.ValidationError as exc:\n            logger.error(f\"Invalid size and color combination: {exc}\")\n\n    logger.info(\n        f\"Shirt order: {shirt_order.size}, {shirt_order.color}\"\n    )\n```\n\nThis code causes the flow run to continually pause until the user enters a valid age.\n\nAs an additional step, you can use an [automation](/v3/automate/events/automations-triggers) to alert the user to the error.\n\n## Send and receive input at runtime\n\nUse the `send_input` and `receive_input` functions to send input to a flow or receive input from a flow at runtime.\nYou don't need to pause or suspend the flow to send or receive input.\n\n<Note>\n  **Reasons to send or receive input without pausing or suspending**\n\n  You might want to send or receive input without pausing or suspending in scenarios where the flow run is designed to handle\n  real-time data. For example, in a live monitoring system, you might need to update certain parameters based on the incoming\n  data without interrupting the flow. Another example is having a long-running flow that continually responds to runtime input with\n  low latency. For example, if you're building a chatbot, you could have a flow that starts a GPT Assistant and manages a conversation thread.\n</Note>\n\nThe most important parameter to the `send_input` and `receive_input` functions is `run_type`, which should be one of the following:\n\n* A built-in type such as `int` or `str`\n* A `pydantic.BaseModel` class\n* A `prefect.input.RunInput` class\n\n<Tip>\n  **When to use a `BaseModel` or `RunInput` instead of a built-in type**\n\n  Most built-in types and collections of built-in types should work with `send_input` and `receive_input`, but there is a caveat with\n  nested collection types, such as lists of tuples. For example, `List[Tuple[str, float]])`. In this case, validation may happen after\n  your flow receives the data, so calling `receive_input` may raise a `ValidationError`. You can plan to catch this exception, and\n  consider placing the field in an explicit `BaseModel` or `RunInput` so your flow only receives exact type matches.\n\n  See examples below of `receive_input`, `send_input`, and the two functions working together.\n</Tip>\n\n### Receiving input\n\nThe following flow uses `receive_input` to continually receive names and print a personalized greeting for each name it receives:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.input.run_input import receive_input\n\n\n@flow\nasync def greeter_flow():\n    async for name_input in receive_input(str, timeout=None):\n        # Prints \"Hello, andrew!\" if another flow sent \"andrew\"\n        print(f\"Hello, {name_input}!\")\n```\n\nWhen you pass a type such as `str` into `receive_input`, Prefect creates a `RunInput` class to manage your\ninput automatically. When a flow sends input of this type, Prefect uses the `RunInput` class to validate the input.\nIf the validation succeeds, your flow receives the input in the type you specified. In this example, if the flow received a\nvalid string as input, the variable `name_input` contains the string value.\n\nIf, instead, you pass a `BaseModel`, Prefect upgrades your `BaseModel` to a `RunInput` class, and the variable your flow sees\n(in this case, `name_input`), is a `RunInput` instance that behaves like a `BaseModel`. If you pass in a `RunInput` class,\nno upgrade is needed and you'll get a `RunInput` instance.\n\nA simpler approach is to pass types such as `str` into `receive_input` . If you need access to the generated\n`RunInput` that contains the received value, pass `with_metadata=True` to `receive_input`:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.input.run_input import receive_input\n\n\n@flow\nasync def greeter_flow():\n    async for name_input in receive_input(\n        str,\n        timeout=None,\n        with_metadata=True\n    ):\n        # Input will always be in the field \"value\" on this object.\n        print(f\"Hello, {name_input.value}!\")\n\n```\n\n<Tip>\n  **When to use `with_metadata=True`**\n\n  The primary uses of accessing the `RunInput` object for a receive input are to respond to the sender with the `RunInput.respond()`\n  function, or to access the unique key for an input.\n</Tip>\n\nNotice that the printing of `name_input.value`. When Prefect generates a `RunInput` for you from a built-in type,\nthe `RunInput` class has a single field, `value`, that uses a type annotation matching the type you specified.\nSo if you call `receive_input` like this: `receive_input(str, with_metadata=True)`, it's equivalent to manually\ncreating the following `RunInput` class and `receive_input` call:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.input.run_input import RunInput\n\nclass GreeterInput(RunInput):\n    value: str\n\n@flow\nasync def greeter_flow():\n    async for name_input in receive_input(GreeterInput, timeout=None):\n        print(f\"Hello, {name_input.value}!\")\n```\n\n<Warning>\n  **The type used in `receive_input` and `send_input` must match**\n\n  For a flow to receive input, the sender must use the same type that the receiver is receiving.\n  This means that if the receiver is receiving `GreeterInput`, the sender must send `GreeterInput`. If the receiver is\n  receiving `GreeterInput` and the sender sends the `str` input that Prefect automatically upgrades to a `RunInput` class,\n  the types won't match; which means the receiving flow run won't receive the input. However, the input will wait for if the flow ever\n  calls `receive_input(str)`.\n</Warning>\n\n### Keep track of inputs you've already seen\n\nBy default, each time you call `receive_input`, you get an iterator that iterates over all known inputs to a specific flow run,\nstarting with the first received. The iterator keeps track of your current position as you iterate over it, or you can call `next()`\nto explicitly get the next input. If you're using the iterator in a loop, you should assign it to a variable:\n\n```python  theme={null}\nfrom prefect import flow, get_client\nfrom prefect.deployments import run_deployment\nfrom prefect.input.run_input import receive_input, send_input\n\nEXIT_SIGNAL = \"__EXIT__\"\n\n\n@flow\nasync def sender():\n    greeter_flow_run = await run_deployment(\n        \"greeter/send-receive\", timeout=0, as_subflow=False\n    )\n    client = get_client()\n\n    # Assigning the `receive_input` iterator to a variable\n    # outside of the the `while True` loop allows us to continue\n    # iterating over inputs in subsequent passes through the\n    # while loop without losing our position.\n    receiver = receive_input(\n        str,\n        with_metadata=True,\n        timeout=None,\n        poll_interval=0.1\n    )\n\n    while True:\n        name = input(\"What is your name? \")\n        if not name:\n            continue\n\n        if name == \"q\" or name == \"quit\":\n            await send_input(\n                EXIT_SIGNAL,\n                flow_run_id=greeter_flow_run.id\n            )\n            print(\"Goodbye!\")\n            break\n\n        await send_input(name, flow_run_id=greeter_flow_run.id)\n\n        # Saving the iterator outside of the while loop and\n        # calling next() on each iteration of the loop ensures\n        # that we're always getting the newest greeting. If we\n        # had instead called `receive_input` here, we would\n        # always get the _first_ greeting this flow received,\n        # print it, and then ask for a new name.\n        greeting = await receiver.next()\n        print(greeting)\n```\n\nAn iterator helps keep track of the inputs your flow has already received. If you want your flow to suspend and then resume later,\nsave the keys of the inputs you've seen so the flow can read them back out when it resumes.\nConsider using a [Variable](/v3/concepts/variables/).\n\nThe following flow receives input for 30 seconds then suspends itself, which exits the flow and tears down infrastructure:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.logging import get_run_logger\nfrom prefect.flow_runs import suspend_flow_run\nfrom prefect.variables import Variable\nfrom prefect.context import get_run_context\nfrom prefect.input.run_input import receive_input\n\n\nEXIT_SIGNAL = \"__EXIT__\"\n\n\n@flow\nasync def greeter():\n    logger = get_run_logger()\n    run_context = get_run_context()\n    assert run_context.flow_run, \"Could not see my flow run ID\"\n\n    variable_name = f\"{run_context.flow_run.id}-seen-ids\"\n\n    try:\n        seen_keys = await Variable.get(variable_name)\n    except (ValueError, TypeError):\n        seen_keys = []\n\n    try:\n        async for name_input in receive_input(\n            str,\n            with_metadata=True,\n            poll_interval=0.1,\n            timeout=30,\n            exclude_keys=seen_keys\n        ):\n            if name_input.value == EXIT_SIGNAL:\n                print(\"Goodbye!\")\n                return\n            await name_input.respond(f\"Hello, {name_input.value}!\")\n\n            seen_keys.append(name_input.metadata.key)\n            await Variable.set(\n                variable_name,\n                seen_keys,\n                overwrite=True\n            )\n    except TimeoutError:\n        logger.info(\"Suspending greeter after 30 seconds of idle time\")\n        await suspend_flow_run(timeout=10000)\n```\n\nAs this flow processes name input, it adds the *key* of the flow run input to the list of seen keys.\nWhen the flow later suspends and then resumes, it reads the keys it has already seen from the variable and\npasses them as the `exlude_keys` parameter to `receive_input`.\n\n### Respond to the input's sender\n\nWhen your flow receives input from another flow, Prefect knows the sending flow run ID, so the receiving flow can\nrespond by calling the `respond` method on the `RunInput` instance the flow received. There are a couple of requirements:\n\n* Pass in a `BaseModel` or `RunInput`, or use `with_metadata=True`.\n* The flow you are responding to must receive the same type of input you send to see it.\n\nThe `respond` method is equivalent to calling `send_input(..., flow_run_id=sending_flow_run.id)`. But with `respond`,\nyour flow doesn't need to know the sending flow run's ID.\n\nNext, make the `greeter_flow` respond to name inputs instead of printing them:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.input.run_input import receive_input\n\n\n@flow\nasync def greeter():\n    async for name_input in receive_input(\n        str,\n        with_metadata=True,\n        timeout=None\n    ):\n        await name_input.respond(f\"Hello, {name_input.value}!\")\n```\n\nHowever, this flow runs forever unless there's a signal that it should exit.\nHere's how to make it to look for a special string:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.input.run_input import receive_input\n\n\n\nEXIT_SIGNAL = \"__EXIT__\"\n\n\n@flow\nasync def greeter():\n    async for name_input in receive_input(\n        str,\n        with_metadata=True,\n        poll_interval=0.1,\n        timeout=None\n    ):\n        if name_input.value == EXIT_SIGNAL:\n            print(\"Goodbye!\")\n            return\n        await name_input.respond(f\"Hello, {name_input.value}!\")\n```\n\nWith a `greeter` flow in place, create the flow that sends `greeter` names.\n\n### Send input\n\nSend input to a flow with the `send_input` function. This works similarly to `receive_input` and, like that function,\naccepts the same `run_input` argument. This can be a built-in type such as `str`, or else a `BaseModel` or `RunInput` subclass.\n\n<Note>\n  **When to send input to a flow run**\n\n  Send input to a flow run as soon as you have the flow run's ID. The flow does not have to be receiving input for you to send input.\n  If you send a flow input before it is receiving, it will see your input when it calls `receive_input`\n  (as long as the types in the `send_input` and `receive_input` calls match).\n</Note>\n\nNext, create a `sender` flow that starts a `greeter` flow run and then enters a loop—continuously\ngetting input from the terminal and sending it to the greeter flow:\n\n```python  theme={null}\nfrom prefect import flow\nfrom prefect.deployments import run_deployment\n\n@flow\nasync def sender():\n    greeter_flow_run = await run_deployment(\n        \"greeter/send-receive\", timeout=0, as_subflow=False\n    )\n    receiver = receive_input(str, timeout=None, poll_interval=0.1)\n    client = get_client()\n\n    while True:\n        flow_run = await client.read_flow_run(greeter_flow_run.id)\n\n        if not flow_run.state or not flow_run.state.is_running():\n            continue\n\n        name = input(\"What is your name? \")\n        if not name:\n            continue\n\n        if name == \"q\" or name == \"quit\":\n            await send_input(\n                EXIT_SIGNAL,\n                flow_run_id=greeter_flow_run.id\n            )\n            print(\"Goodbye!\")\n            break\n\n        await send_input(name, flow_run_id=greeter_flow_run.id)\n        greeting = await receiver.next()\n        print(greeting)\n```\n\nFirst, `run_deployment` starts a `greeter` flow run. This requires a deployed flow running in a process.\nThat process begins running `greeter` while `sender` continues to execute. Calling `run_deployment(..., timeout=0)`\nensures that `sender` won't wait for the `greeter` flow run to complete, because it's running a loop and only exits when sending `EXIT_SIGNAL`.\n\nNext, the iterator returned by `receive_input` as `receiver` is captured. This flow works by entering a loop. On each iteration of the loop,\nthe flow asks for terminal input, sends that to the `greeter` flow, and then runs `receiver.next()` to wait until it receives the response from `greeter`.\n\nNext, the terminal user who ran this flow is allowed to exit by entering the string `q` or `quit`.\nWhen that happens, the `greeter` flow is sent an exit signal to shut down, too.\n\nFinally, the new name is sent to `greeter`. `greeter` sends back a greeting as a string.\nWhen you receive the greeting, print it and continue the loop that gets terminal input.\n\n### A complete example\n\nFor a complete example of using `send_input` and `receive_input`, here is what the `greeter` and `sender` flows look like together:\n\n```python  theme={null}\nimport asyncio\nimport sys\nfrom prefect import flow, get_client\nfrom prefect.variables import Variable\nfrom prefect.context import get_run_context\nfrom prefect.deployments import run_deployment\nfrom prefect.input.run_input import receive_input, send_input\n\n\nEXIT_SIGNAL = \"__EXIT__\"\n\n\n@flow\nasync def greeter():\n    run_context = get_run_context()\n    assert run_context.flow_run, \"Could not see my flow run ID\"\n\n    variable_name = f\"{run_context.flow_run.id}-seen-ids\"\n\n    try:\n        seen_keys = await Variable.get(variable_name)\n    except (ValueError, TypeError):\n        seen_keys = []\n\n    async for name_input in receive_input(\n        str,\n        with_metadata=True,\n        poll_interval=0.1,\n        timeout=None\n    ):\n        if name_input.value == EXIT_SIGNAL:\n            print(\"Goodbye!\")\n            return\n        await name_input.respond(f\"Hello, {name_input.value}!\")\n\n        seen_keys.append(name_input.metadata.key)\n        await Variable.set(\n            variable_name,\n            seen_keys,\n            overwrite=True\n        )\n\n\n@flow\nasync def sender():\n    greeter_flow_run = await run_deployment(\n        \"greeter/send-receive\", timeout=0, as_subflow=False\n    )\n    receiver = receive_input(str, timeout=None, poll_interval=0.1)\n    client = get_client()\n\n    while True:\n        flow_run = await client.read_flow_run(greeter_flow_run.id)\n\n        if not flow_run.state or not flow_run.state.is_running():\n            continue\n\n        name = input(\"What is your name? \")\n        if not name:\n            continue\n\n        if name == \"q\" or name == \"quit\":\n            await send_input(\n                EXIT_SIGNAL,\n                flow_run_id=greeter_flow_run.id\n            )\n            print(\"Goodbye!\")\n            break\n\n        await send_input(name, flow_run_id=greeter_flow_run.id)\n        greeting = await receiver.next()\n        print(greeting)\n\n\nif __name__ == \"__main__\":\n    if sys.argv[1] == \"greeter\":\n        asyncio.run(greeter.serve(name=\"send-receive\"))\n    elif sys.argv[1] == \"sender\":\n        asyncio.run(sender())\n```\n\nTo run the example, you need a Python environment with Prefect installed, pointed at either a Prefect Cloud account or a self-hosted Prefect server instance.\n\nWith your environment set up, start a flow runner in one terminal with the following command:\n\n```bash  theme={null}\npython my_file_name greeter\n```\n\nFor example, with Prefect Cloud, you should see output like this:\n\n```bash  theme={null}\n______________________________________________________________________\n| Your flow 'greeter' is being served and polling for scheduled runs |\n|                                                                    |\n| To trigger a run for this flow, use the following command:         |\n|                                                                    |\n|         $ prefect deployment run 'greeter/send-receive'            |\n|                                                                    |\n| You can also run your flow via the Prefect UI:                     |\n| https://app.prefect.cloud/account/...(a URL for your account)      |\n|                                                                    |\n______________________________________________________________________\n```\n\nThen start the greeter process in another terminal:\n\n```bash  theme={null}\npython my_file_name sender\n```\n\nYou should see output like this:\n\n```bash  theme={null}\n11:38:41.800 | INFO    | prefect.engine - Created flow run 'gregarious-owl' for flow 'sender'\n11:38:41.802 | INFO    | Flow run 'gregarious-owl' - View at https://app.prefect.cloud/account/...\nWhat is your name?\n```\n\nType a name and press the enter key to see a greeting to see sending and receiving in action:\n\n```bash  theme={null}\nWhat is your name? andrew\nHello, andrew!\n```",
  "content_length": 27988
}