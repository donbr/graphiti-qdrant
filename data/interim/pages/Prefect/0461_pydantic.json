{
  "title": "pydantic",
  "source_url": "https://docs-3.prefect.io/v3/api-ref/python/prefect-utilities-pydantic",
  "content": "# `prefect.utilities.pydantic`\n\n## Functions\n\n### `add_cloudpickle_reduction` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L66\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nadd_cloudpickle_reduction(__model_cls: Optional[type[M]] = None, **kwargs: Any) -> Union[type[M], Callable[[type[M]], type[M]]]\n```\n\nAdds a `__reducer__` to the given class that ensures it is cloudpickle compatible.\n\nWorkaround for issues with cloudpickle when using cythonized pydantic which\nthrows exceptions when attempting to pickle the class which has \"compiled\"\nvalidator methods dynamically attached to it.\n\nWe cannot define this utility in the model class itself because the class is the\ntype that contains unserializable methods.\n\nAny model using some features of Pydantic (e.g. `Path` validation) with a Cython\ncompiled Pydantic installation may encounter pickling issues.\n\nSee related issue at [https://github.com/cloudpipe/cloudpickle/issues/408](https://github.com/cloudpipe/cloudpickle/issues/408)\n\n### `get_class_fields_only` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L95\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nget_class_fields_only(model: type[BaseModel]) -> set[str]\n```\n\nGets all the field names defined on the model class but not any parent classes.\nAny fields that are on the parent but redefined on the subclass are included.\n\n### `add_type_dispatch` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L112\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nadd_type_dispatch(model_cls: type[M]) -> type[M]\n```\n\nExtend a Pydantic model to add a 'type' field that is used as a discriminator field\nto dynamically determine the subtype that when deserializing models.\n\nThis allows automatic resolution to subtypes of the decorated model.\n\nIf a type field already exists, it should be a string literal field that has a\nconstant value for each subclass. The default value of this field will be used as\nthe dispatch key.\n\nIf a type field does not exist, one will be added. In this case, the value of the\nfield will be set to the value of the `__dispatch_key__`. The base class should\ndefine a `__dispatch_key__` class method that is used to determine the unique key\nfor each subclass. Alternatively, each subclass can define the `__dispatch_key__`\nas a string literal.\n\nThe base class must not define a 'type' field. If it is not desirable to add a field\nto the model and the dispatch key can be tracked separately, the lower level\nutilities in `prefect.utilities.dispatch` should be used directly.\n\n### `custom_pydantic_encoder` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L263\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\ncustom_pydantic_encoder(type_encoders: dict[Any, Callable[[type[Any]], Any]], obj: Any) -> Any\n```\n\n### `parse_obj_as` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L281\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nparse_obj_as(type_: type[T], data: Any, mode: Literal['python', 'json', 'strings'] = 'python') -> T\n```\n\nParse a given data structure as a Pydantic model via `TypeAdapter`.\n\nRead more about `TypeAdapter` [here](https://docs.pydantic.dev/latest/concepts/type_adapter/).\n\n**Args:**\n\n* `type_`: The type to parse the data as.\n* `data`: The data to be parsed.\n* `mode`: The mode to use for parsing, either `python`, `json`, or `strings`.\n  Defaults to `python`, where `data` should be a Python object (e.g. `dict`).\n\n**Returns:**\n\n* The parsed `data` as the given `type_`.\n\n### `handle_secret_render` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L343\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nhandle_secret_render(value: object, context: dict[str, Any]) -> object\n```\n\n## Classes\n\n### `PartialModel` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L200\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\nA utility for creating a Pydantic model in several steps.\n\nFields may be set at initialization, via attribute assignment, or at finalization\nwhen the concrete model is returned.\n\nPydantic validation does not occur until finalization.\n\nEach field can only be set once and a `ValueError` will be raised on assignment if\na field already has a value.\n\n**Methods:**\n\n#### `finalize` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L234\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nfinalize(self, **kwargs: Any) -> M\n```\n\n#### `raise_if_already_set` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L240\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nraise_if_already_set(self, name: str) -> None\n```\n\n#### `raise_if_not_in_model` <sup><a href=\"https://github.com/PrefectHQ/prefect/blob/main/src/prefect/utilities/pydantic.py#L244\" target=\"_blank\"><Icon icon=\"github\" style=\"width: 14px; height: 14px;\" /></a></sup>\n\n```python  theme={null}\nraise_if_not_in_model(self, name: str) -> None\n```",
  "content_length": 5704
}