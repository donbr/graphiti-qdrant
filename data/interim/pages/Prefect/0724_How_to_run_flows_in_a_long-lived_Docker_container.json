{
  "title": "How to run flows in a long-lived Docker container",
  "source_url": "https://docs-3.prefect.io/v3/how-to-guides/deployment_infra/serve-flows-docker",
  "content": "Learn how to serve a flow in a long-lived Docker container\n\nThe `.serve` method allows you to easily elevate a flow to a deployment, listening for scheduled work to execute [as a local process](/v3/how-to-guides/deployment_infra/run-flows-in-local-processes).\n\nHowever, this *\"local\"* process does not need to be on your local machine. In this example we show how to run a flow in Docker container on your local machine, but you could use a Docker container on any machine that has [Docker installed](https://docs.docker.com/engine/install/).\n\n## Overview\n\nIn this example, you will set up:\n\n* a simple flow that retrieves the number of stars for some GitHub repositories\n* a `Dockerfile` that packages up your flow code and dependencies into a container image\n\n## Writing the flow\n\nSay we have a flow that retrieves the number of stars for a GitHub repository:\n\n```python serve_retrieve_github_stars.py {19-23} theme={null}\nimport httpx\nfrom prefect import flow, task\n\n\n@task(log_prints=True)\ndef get_stars_for_repo(repo: str) -> int:\n    response = httpx.Client().get(f\"https://api.github.com/repos/{repo}\")\n    stargazer_count = response.json()[\"stargazers_count\"]\n    print(f\"{repo} has {stargazer_count} stars\")\n    return stargazer_count\n\n\n@flow\ndef retrieve_github_stars(repos: list[str]) -> list[int]:\n    return get_stars_for_repo.map(repos).wait()\n\n\nif __name__ == \"__main__\":\n    retrieve_github_stars.serve(\n        parameters={\n            \"repos\": [\"python/cpython\", \"prefectHQ/prefect\"],\n        }\n    )\n```\n\nWe can serve this flow on our local machine using:\n\n```bash  theme={null}\npython serve_retrieve_github_stars.py\n```\n\n... but how can we package this up so we can run it on other machines?\n\n## Writing the Dockerfile\n\nAssuming we have our Python requirements defined in a file:\n\n```txt requirements.txt theme={null}\nprefect\n```\n\nand this directory structure:\n\n```\n├── Dockerfile\n├── requirements.txt\n└── serve_retrieve_github_stars.py\n```\n\nWe can package up our flow into a Docker container using a `Dockerfile`.\n\n<CodeGroup>\n  ```dockerfile Using pip theme={null}\n  # Use an official Python runtime as the base image\n  FROM python:3.12-slim\n\n  # Set the working directory in the container\n  WORKDIR /app\n\n  # Copy the requirements file into the container\n  COPY requirements.txt .\n\n  # Install the required packages\n  RUN pip install --no-cache-dir -r requirements.txt\n\n  # Copy the rest of the application code\n  COPY serve_retrieve_github_stars.py .\n\n  # Set the command to run your application\n  CMD [\"python\", \"serve_retrieve_github_stars.py\"]\n  ```\n\n  ```dockerfile Using uv theme={null}\n  # Use the official Python image with uv pre-installed\n  FROM ghcr.io/astral-sh/uv:python3.12-bookworm-slim\n\n  # Set the working directory\n  WORKDIR /app\n\n  # Set environment variables\n  ENV UV_SYSTEM_PYTHON=1\n  ENV PATH=\"/root/.local/bin:$PATH\"\n\n  # Copy only the requirements file first to leverage Docker cache\n  COPY requirements.txt .\n\n  # Install dependencies\n  RUN --mount=type=cache,target=/root/.cache/uv \\\n      uv pip install -r requirements.txt\n\n  # Copy the rest of the application code\n  COPY serve_retrieve_github_stars.py .\n\n  # Set the entrypoint\n  ENTRYPOINT [\"python\", \"serve_retrieve_github_stars.py\"]\n  ```\n</CodeGroup>\n\n<Note>\n  Using `pip`, the image is built in about 20 seconds, and using `uv`, the image is built in about 3 seconds.\n\n  You can learn more about using `uv` in the [Astral documentation](https://docs.astral.sh/uv/guides/integration/docker/).\n</Note>\n\n## Build and run the container\n\nNow that we have a flow and a Dockerfile, we can build the image from the Dockerfile and run a container from this image.\n\n### Build (and push) the image\n\nWe can build the image with the `docker build` command and the `-t` flag to specify a name for the image.\n\n```bash  theme={null}\ndocker build -t my-flow-image .\n```\n\nAt this point, you may also want to push the image to a container registry such as [Docker Hub](https://hub.docker.com/) or [GitHub Container Registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry). Please refer to each registry's respective documentation for details on authentication and registry naming conventions.\n\n### Run the container\n\nYou'll likely want to inject some environment variables into your container, so let's define a `.env` file:\n\n```bash .env theme={null}\nPREFECT_API_URL=<YOUR-API-URL>\nPREFECT_API_KEY=<YOUR-API-KEY-IF-USING-PREFECT-CLOUD>\n```\n\nThen, run the container in [detached mode](https://docs.docker.com/engine/reference/commandline/run/#detached-d) (in other words, in the background):\n\n```bash  theme={null}\ndocker run -d --env-file .env my-flow-image\n```\n\n#### Verify the container is running\n\n```bash  theme={null}\ndocker ps | grep my-flow-image\n```\n\nYou should see your container in the list of running containers, note the `CONTAINER ID` as we'll need it to view logs.\n\n#### View logs\n\n```bash  theme={null}\ndocker logs <CONTAINER-ID>\n```\n\nYou should see logs from your newly served process, with the link to your deployment in the UI.\n\n### Stop the container\n\n```bash  theme={null}\ndocker stop <CONTAINER-ID>\n```\n\n## Health checks for production deployments\n\nWhen deploying to production environments like Google Cloud Run, AWS ECS, or Kubernetes, you may need to configure health checks to ensure your container is running properly. The `.serve()` method supports an optional webserver that exposes a health endpoint.\n\n### Enabling the health check webserver\n\nYou can enable the health check webserver in two ways:\n\n1. **Pass `webserver=True` to `.serve()`:**\n\n```python  theme={null}\nif __name__ == \"__main__\":\n    retrieve_github_stars.serve(\n        parameters={\n            \"repos\": [\"python/cpython\", \"prefectHQ/prefect\"],\n        },\n        webserver=True  # Enable health check webserver\n    )\n```\n\n2. **Set the environment variable:**\n\n```bash  theme={null}\nPREFECT_RUNNER_SERVER_ENABLE=true\n```\n\nWhen enabled, the webserver exposes a health endpoint at `http://localhost:8080/health` by default.\n\n### Configuring the health check port\n\nYou can customize the host and port using environment variables:\n\n```bash  theme={null}\nPREFECT_RUNNER_SERVER_HOST=0.0.0.0  # Allow external connections\nPREFECT_RUNNER_SERVER_PORT=8080      # Port for health checks\n```\n\n### Docker with health checks\n\nAdd a health check to your Dockerfile:\n\n```dockerfile  theme={null}\n# ... your existing Dockerfile content ...\n\n# Health check configuration\nHEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\\n  CMD python -c \"import urllib.request as u; u.urlopen('http://localhost:8080/health', timeout=1)\"\n\n# Set the command to run your application with webserver enabled\nCMD [\"python\", \"serve_retrieve_github_stars.py\"]\n```\n\nOr if you prefer to use environment variables:\n\n```dockerfile  theme={null}\n# ... your existing Dockerfile content ...\n\n# Enable the health check webserver\nENV PREFECT_RUNNER_SERVER_ENABLE=true\nENV PREFECT_RUNNER_SERVER_HOST=0.0.0.0\nENV PREFECT_RUNNER_SERVER_PORT=8080\n\n# Health check configuration\nHEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\\n  CMD python -c \"import urllib.request as u; u.urlopen('http://localhost:8080/health', timeout=1)\"\n\nCMD [\"python\", \"serve_retrieve_github_stars.py\"]\n```\n\n### Platform-specific configurations\n\n<Tabs>\n  <Tab title=\"Google Cloud Run\">\n    Cloud Run requires containers to listen on a port. Configure your container to expose the health check port:\n\n    ```yaml  theme={null}\n    # In your Cloud Run configuration\n    livenessProbe:\n      httpGet:\n        path: /health\n        port: 8080\n      initialDelaySeconds: 60\n      periodSeconds: 30\n    ```\n\n    Make sure to set the container port to 8080 in Cloud Run settings.\n  </Tab>\n\n  <Tab title=\"AWS ECS/Fargate\">\n    Configure health checks in your task definition:\n\n    ```json  theme={null}\n    {\n      \"healthCheck\": {\n        \"command\": [\"CMD-SHELL\", \"python -c \\\"import urllib.request as u; u.urlopen('http://localhost:8080/health', timeout=1)\\\"\"],\n        \"interval\": 30,\n        \"timeout\": 10,\n        \"retries\": 3,\n        \"startPeriod\": 60\n      }\n    }\n    ```\n  </Tab>\n\n  <Tab title=\"Kubernetes\">\n    Add liveness and readiness probes to your deployment:\n\n    ```yaml  theme={null}\n    livenessProbe:\n      httpGet:\n        path: /health\n        port: 8080\n      initialDelaySeconds: 60\n      periodSeconds: 30\n      timeoutSeconds: 10\n      failureThreshold: 3\n\n    readinessProbe:\n      httpGet:\n        path: /health\n        port: 8080\n      initialDelaySeconds: 10\n      periodSeconds: 5\n    ```\n  </Tab>\n</Tabs>\n\nThe health endpoint returns:\n\n* **200 OK** with `{\"message\": \"OK\"}` when the runner is healthy and polling for work\n* **503 Service Unavailable** when the runner hasn't polled recently (indicating it may be unresponsive)\n\n## Next steps\n\nCongratulations! You have packaged and served a flow on a long-lived Docker container.\n\nYou may now easily deploy this container to other infrastructures, such as:\n\n* [Modal](https://modal.com/)\n* [Google Cloud Run](https://cloud.google.com/run)\n* [AWS Fargate / ECS](https://aws.amazon.com/fargate/)\n* Managed Kubernetes (For example: GKE, EKS, or AKS)\n\nor anywhere else you can run a Docker container!",
  "content_length": 9288
}